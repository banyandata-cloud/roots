/* eslint-disable eqeqeq */
/* eslint-disable no-nested-ternary */
import {
	FloatingFocusManager,
	autoUpdate,
	flip,
	offset,
	shift,
	size,
	useClick,
	useDismiss,
	useFloating,
	useInteractions,
	useListNavigation,
	useRole,
} from '@floating-ui/react-dom-interactions';
import { motion } from 'framer-motion';
import React, {
	forwardRef,
	useEffect,
	useImperativeHandle,
	useLayoutEffect,
	useMemo,
	useRef,
	useState,
} from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { classes } from '../../../utils';
import Button from '../../buttons/button/Button';
import { ErrorBoundaryWrapper } from '../../errorBoundary';
import { CaretIcon, InfoIcon } from '../../icons';
import { SelectAllIcon } from '../../icons/SelectAll';
import Popper from '../../popper/Popper';
import { Tooltip } from '../../tooltip';
import styles from './Dropdownv2.module.css';

interface DropdownProps {
	className?: string;
	popperClassName?: string;
	value?: string | string[];
	onChange: (event: React.ChangeEvent<HTMLInputElement>, value: string) => void;
	leftComponent?: React.ElementType;
	onBlur?: React.FocusEventHandler<HTMLInputElement>;
	children: React.ReactNode;
	highlightOnSelect?: boolean;
	label?: string;
	placeholder?: string;
	multi?: boolean;
	disabled?: boolean;
	error?: string;
	id?: string;
	name?: string;
	feedback?: { type: string };
	formatter?: (totalSelected: number) => string;
	custom?: boolean;
	required?: boolean;
	multiSelectActionTitle?: string;
	valueAsCount?: boolean;
	caretAsUpDown?: boolean;
}

const Dropdown = forwardRef<HTMLInputElement, DropdownProps>((props, inputRef) => {
	const {
		className = '',
		popperClassName = '',
		value,
		onChange,
		leftComponent: LeftComponent,
		onBlur,
		children,
		highlightOnSelect,
		label,
		placeholder = 'Select an option',
		multi,
		disabled,
		error,
		id,
		name,
		feedback,
		formatter = (totalSelected) => {
			return `${totalSelected} options applied`;
		},
		custom,
		required,
		multiSelectActionTitle,
		valueAsCount,
		caretAsUpDown,
	} = props;

	const [open, setOpen] = useState(false);
	const [activeIndex, setActiveIndex] = useState<number | null>(null);
	const [selectedIndex, setSelectedIndex] = useState(0);
	const listItemsRef = useRef<(HTMLDivElement | null)[]>([]);
	const multiOptionsRef = useRef(null);

	const isControlled = value !== undefined;

	// for uncontrolled input
	const [uncontrolledValue, setUncontrolledValue] = useState<string | string[]>(value ?? []);
	const [appliedMultiUncontrolledValue, setAppliedMultiUncontrolledValue] = useState<string[] | null>(null);

	const { x, y, reference, floating, strategy, context } = useFloating({
		open,
		onOpenChange: setOpen,
		whileElementsMounted: autoUpdate,
		middleware: [
			offset(5),
			flip({
				padding: 8,
			}),
			shift({
				padding: 8,
			}),
			size({
				apply({ rects, availableHeight, elements }) {
					Object.assign(elements.floating.style, {
						width: `${rects.reference.width}px`,
						minWidth: 'fit-content',
						maxHeight: `${availableHeight}px`,
					});
				},
				padding: 8,
			}),
		],
	});

	const { getReferenceProps, getFloatingProps, getItemProps } = useInteractions([
		useClick(context, {
			enabled: !disabled && !error,
		}),
		useRole(context, {
			role: 'listbox',
		}),
		useListNavigation(context, {
			listRef: listItemsRef,
			activeIndex,
			selectedIndex,
			onNavigate: setActiveIndex,
		}),
		useDismiss(context),
	]);

	const onSelect = (child: React.ReactElement, selected: boolean) => {
		return (event: React.MouseEvent) => {
			if (event.currentTarget.getAttribute('data-elem') !== 'dropdown-item') {
				return;
			}
			const { value: itemValue } = child.props;
			const itemValueString = itemValue?.toString?.();
			const index = event.currentTarget.getAttribute('data-index');

			// to support form libraries which require name and value on the event
			const nativeEvent = event.nativeEvent || event;
			const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);

			Object.defineProperty(clonedEvent, 'target', {
				writable: true,
				value: {
					value: itemValueString,
					name,
				},
			});

			setSelectedIndex(parseInt(index ?? '0', 10));

			if (multi) {
				if (selected) {
					setUncontrolledValue((prev) =>
						(prev as string[]).filter((val) => val !== itemValueString)
					);
				} else {
					setUncontrolledValue([...(uncontrolledValue as string[]), itemValueString]);
				}
				setActiveIndex(parseInt(index ?? '0', 10));
			} else {
				if (isControlled) {
					onChange(clonedEvent, itemValueString ?? '');
				} else {
					setUncontrolledValue(itemValueString ?? '');
				}
				setActiveIndex(null);
				setOpen(false);
			}
		};
	};

	const onNavigate = (child: React.ReactElement, selected: boolean) => {
		return (event: React.KeyboardEvent) => {
			const selectKey = [' ', 'Spacebar', 'Enter'].includes(event.key);
			if (selectKey) {
				event.stopPropagation();
				onSelect(child, selected)(event);
			}
		};
	};

	useImperativeHandle(
		inputRef,
		() => ({
			value: () => {
				const inputValue = (inputRef.current?.value ?? '').split(', ') ?? [];
				if (multi) {
					return inputValue;
				}
				return inputValue?.[0] ?? null;
			},
		}),
		[]
	);

	const childrenArray = React.Children.toArray(children);

	const selectedOptions = useMemo(() => {
		let inputValue = uncontrolledValue;
		if (isControlled && !multi) {
			inputValue = value;
		}
		const options: { title: string; value: string }[] = [];
		if (inputValue != null && inputValue !== '') {
			childrenArray?.forEach((child: React.ReactElement) => {
				if (
					(multi &&
						(inputValue?.indexOf?.(child?.props?.value?.toString?.()) ?? -1) !== -1) ||
					(!multi && inputValue?.toString() === child?.props?.value?.toString?.())
				) {
					options.push({
						title: child?.props?.title,
						value: child?.props?.value?.toString?.(),
					});
				}
			});
		}
		return options;
	}, [value, uncontrolledValue, multi]);

	const items = childrenArray.map((child: React.ReactElement, index: number) => {
		let selected = false;

		if (
			selectedOptions.findIndex((option) => {
				return option.value === child?.props?.value?.toString?.();
			}) !== -1
		) {
			selected = true;
		}

		return React.cloneElement(child, {
			...getItemProps({
				key: child?.props?.value,
				onKeyDown: onNavigate(child, selected),
				onClick: onSelect(child, selected),
				onMouseEnter: () => {
					setActiveIndex(index);
				},
				dataAttrs: {
					'data-index': index,
				},
				selected,
				tabIndex: activeIndex === index ? 0 : -1,
				ref: (node) => {
					listItemsRef.current[index] = node;
				},
			}),
		});
	});

	const [pointer, setPointer] = useState(false);

	if (!open && pointer) {
		setPointer(false);
	}

	useLayoutEffect(() => {
		if (open && activeIndex != null && !pointer) {
			requestAnimationFrame(() => {
				listItemsRef.current[activeIndex]?.scrollIntoView({
					block: 'nearest',
				});
			});
		}
	}, [open, activeIndex, pointer]);

	useEffect(() => {
		if (multi && isControlled) {
			setUncontrolledValue(value);
		}
	}, [open, multi, value]);

	const onSelectAll = (event: React.MouseEvent, selected: boolean) => {
		const nativeEvent = event.nativeEvent || event;
		const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);

		let itemValue = [];

		if (selected) {
			itemValue = childrenArray.map((child: React.ReactElement) => {
				return child?.props?.value?.toString?.();
			});
		}

		Object.defineProperty(clonedEvent, 'target', {
			writable: true,
			value: {
				value: itemValue,
				name,
			},
		});

		setUncontrolledValue(itemValue);

		setActiveIndex(0);
	};

	const onApply = (event: React.MouseEvent) => {
		const nativeEvent = event.nativeEvent || event;
		const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
		const val = multi ? uncontrolledValue : uncontrolledValue[0];

		Object.defineProperty(clonedEvent, 'target', {
			writable: true,
			value: {
				value: val,
				name,
			},
		});

		onChange(clonedEvent, val);
		setOpen(false);
	};

	const handleFocus = (event: React.FocusEvent<HTMLInputElement>) => {
		setOpen(true);
		if (onBlur) {
			onBlur(event);
		}
	};

	const inputValue = multi
		? valueAsCount
			? `${uncontrolledValue.length} selected`
			: formatter?.(uncontrolledValue?.length ?? 0)
		: uncontrolledValue?.[0] ?? placeholder;

	const isAnySelected = multi ? uncontrolledValue?.length > 0 : Boolean(uncontrolledValue);

	const showTooltip = !isAnySelected && open;

	return (
		<ErrorBoundary FallbackComponent={ErrorBoundaryWrapper}>
			<div
				className={classes(
					styles['input-container'],
					className,
					disabled ? styles['disabled'] : '',
					open ? styles['opened'] : ''
				)}
			>
				<label htmlFor={id}>{label}</label>
				<div className={styles['input-wrapper']} ref={reference}>
					{LeftComponent && <LeftComponent className={styles['left-component']} />}
					<input
						{...getReferenceProps()}
						id={id}
						value={inputValue}
						disabled={disabled}
						placeholder={placeholder}
						className={classes(styles['input'], error ? styles['error'] : '')}
						onFocus={handleFocus}
						readOnly
						name={name}
						required={required}
					/>
					{multi && multiOptionsRef.current && (
						<span
							className={classes(styles['multi-label'], multiSelectActionTitle ? styles['multi'] : '')}
						>
							{formatter?.(uncontrolledValue?.length ?? 0)}
						</span>
					)}
					<Popper
						floating={floating}
						strategy={strategy}
						style={{ top: y ?? 0, left: x ?? 0 }}
						className={classes(styles['dropdown'], popperClassName)}
					>
						<FloatingFocusManager context={context}>
							<div
								className={classes(styles['dropdown-wrapper'], popperClassName)}
								ref={floating}
								{...getFloatingProps()}
							>
								{!multi && (
									<>
										{childrenArray?.map((child: React.ReactElement, index: number) => {
											return React.cloneElement(child, {
												...getItemProps({
													key: child?.props?.value,
													onClick: onSelect(child, false),
													selected: activeIndex === index,
													tabIndex: activeIndex === index ? 0 : -1,
													ref: (node) => {
														listItemsRef.current[index] = node;
													},
												}),
											});
										})}
									</>
								)}

								{multi && (
									<>
										{childrenArray?.map((child: React.ReactElement) => {
											return React.cloneElement(child, {
												...getItemProps({
													onClick: onSelect(child, false),
												}),
											});
										})}
									</>
								)}
								{showTooltip && (
									<Tooltip message={`No option selected`} open={showTooltip} />
								)}
							</div>
						</FloatingFocusManager>
					</Popper>
				</div>
			</div>
		</ErrorBoundary>
	);
});

export default Dropdown;
