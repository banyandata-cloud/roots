'use strict';

var React = require('react');
var jsxRuntime = require('react/jsx-runtime');
var ReactDOM = require('react-dom');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);
var ReactDOM__namespace = /*#__PURE__*/_interopNamespaceDefault(ReactDOM);

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
}
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
  var f = n.default;
	if (typeof f == "function") {
		var a = function () {
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var propTypes$1 = {exports: {}};

var reactIs = {exports: {}};

var reactIs_production_min = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min;

function requireReactIs_production_min () {
	if (hasRequiredReactIs_production_min) return reactIs_production_min;
	hasRequiredReactIs_production_min = 1;
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min.AsyncMode=l;reactIs_production_min.ConcurrentMode=m;reactIs_production_min.ContextConsumer=k;reactIs_production_min.ContextProvider=h;reactIs_production_min.Element=c;reactIs_production_min.ForwardRef=n;reactIs_production_min.Fragment=e;reactIs_production_min.Lazy=t;reactIs_production_min.Memo=r;reactIs_production_min.Portal=d;
	reactIs_production_min.Profiler=g;reactIs_production_min.StrictMode=f;reactIs_production_min.Suspense=p;reactIs_production_min.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min.isConcurrentMode=A;reactIs_production_min.isContextConsumer=function(a){return z(a)===k};reactIs_production_min.isContextProvider=function(a){return z(a)===h};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min.isForwardRef=function(a){return z(a)===n};reactIs_production_min.isFragment=function(a){return z(a)===e};reactIs_production_min.isLazy=function(a){return z(a)===t};
	reactIs_production_min.isMemo=function(a){return z(a)===r};reactIs_production_min.isPortal=function(a){return z(a)===d};reactIs_production_min.isProfiler=function(a){return z(a)===g};reactIs_production_min.isStrictMode=function(a){return z(a)===f};reactIs_production_min.isSuspense=function(a){return z(a)===p};
	reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min.typeOf=z;
	return reactIs_production_min;
}

var reactIs_development = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development;

function requireReactIs_development () {
	if (hasRequiredReactIs_development) return reactIs_development;
	hasRequiredReactIs_development = 1;



	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	// (unstable) APIs that have been removed. Can we remove the symbols?

	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	} // AsyncMode is deprecated along with isAsyncMode

	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }

	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	reactIs_development.AsyncMode = AsyncMode;
	reactIs_development.ConcurrentMode = ConcurrentMode;
	reactIs_development.ContextConsumer = ContextConsumer;
	reactIs_development.ContextProvider = ContextProvider;
	reactIs_development.Element = Element;
	reactIs_development.ForwardRef = ForwardRef;
	reactIs_development.Fragment = Fragment;
	reactIs_development.Lazy = Lazy;
	reactIs_development.Memo = Memo;
	reactIs_development.Portal = Portal;
	reactIs_development.Profiler = Profiler;
	reactIs_development.StrictMode = StrictMode;
	reactIs_development.Suspense = Suspense;
	reactIs_development.isAsyncMode = isAsyncMode;
	reactIs_development.isConcurrentMode = isConcurrentMode;
	reactIs_development.isContextConsumer = isContextConsumer;
	reactIs_development.isContextProvider = isContextProvider;
	reactIs_development.isElement = isElement;
	reactIs_development.isForwardRef = isForwardRef;
	reactIs_development.isFragment = isFragment;
	reactIs_development.isLazy = isLazy;
	reactIs_development.isMemo = isMemo;
	reactIs_development.isPortal = isPortal;
	reactIs_development.isProfiler = isProfiler;
	reactIs_development.isStrictMode = isStrictMode;
	reactIs_development.isSuspense = isSuspense;
	reactIs_development.isValidElementType = isValidElementType;
	reactIs_development.typeOf = typeOf;
	  })();
	}
	return reactIs_development;
}

var hasRequiredReactIs;

function requireReactIs () {
	if (hasRequiredReactIs) return reactIs.exports;
	hasRequiredReactIs = 1;
	(function (module) {

		if (process.env.NODE_ENV === 'production') {
		  module.exports = requireReactIs_production_min();
		} else {
		  module.exports = requireReactIs_development();
		}
} (reactIs));
	return reactIs.exports;
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

var objectAssign;
var hasRequiredObjectAssign;

function requireObjectAssign () {
	if (hasRequiredObjectAssign) return objectAssign;
	hasRequiredObjectAssign = 1;
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return objectAssign;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;

function requireReactPropTypesSecret () {
	if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
	hasRequiredReactPropTypesSecret = 1;

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	ReactPropTypesSecret_1 = ReactPropTypesSecret;
	return ReactPropTypesSecret_1;
}

var has$1;
var hasRequiredHas;

function requireHas () {
	if (hasRequiredHas) return has$1;
	hasRequiredHas = 1;
	has$1 = Function.call.bind(Object.prototype.hasOwnProperty);
	return has$1;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var checkPropTypes_1;
var hasRequiredCheckPropTypes;

function requireCheckPropTypes () {
	if (hasRequiredCheckPropTypes) return checkPropTypes_1;
	hasRequiredCheckPropTypes = 1;

	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  var ReactPropTypesSecret = requireReactPropTypesSecret();
	  var loggedTypeFailures = {};
	  var has = requireHas();

	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) { /**/ }
	  };
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (process.env.NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            var err = Error(
	              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
	              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
	              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
	            );
	            err.name = 'Invariant Violation';
	            throw err;
	          }
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error && !(error instanceof Error)) {
	          printWarning(
	            (componentName || 'React class') + ': type specification of ' +
	            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
	            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
	            'You may have forgotten to pass an argument to the type checker ' +
	            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
	            'shape all require an argument).'
	          );
	        }
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          printWarning(
	            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
	          );
	        }
	      }
	    }
	  }
	}

	/**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */
	checkPropTypes.resetWarningCache = function() {
	  if (process.env.NODE_ENV !== 'production') {
	    loggedTypeFailures = {};
	  }
	};

	checkPropTypes_1 = checkPropTypes;
	return checkPropTypes_1;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;

function requireFactoryWithTypeCheckers () {
	if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
	hasRequiredFactoryWithTypeCheckers = 1;

	var ReactIs = requireReactIs();
	var assign = requireObjectAssign();

	var ReactPropTypesSecret = requireReactPropTypesSecret();
	var has = requireHas();
	var checkPropTypes = requireCheckPropTypes();

	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	function emptyFunctionThatReturnsNull() {
	  return null;
	}

	factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bigint: createPrimitiveTypeChecker('bigint'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    elementType: createElementTypeTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message, data) {
	    this.message = message;
	    this.data = data && typeof data === 'object' ? data: {};
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    if (process.env.NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          var err = new Error(
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	          err.name = 'Invariant Violation';
	          throw err;
	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            printWarning(
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError(
	          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
	          {expectedType: expectedType}
	        );
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!ReactIs.isValidElementType(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (arguments.length > 1) {
	          printWarning(
	            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
	            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
	          );
	        } else {
	          printWarning('Invalid argument supplied to oneOf, expected an array.');
	        }
	      }
	      return emptyFunctionThatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
	        var type = getPreciseType(value);
	        if (type === 'symbol') {
	          return String(value);
	        }
	        return value;
	      });
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (has(propValue, key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunctionThatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        printWarning(
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
	        );
	        return emptyFunctionThatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var expectedTypes = [];
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
	        if (checkerResult == null) {
	          return null;
	        }
	        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
	          expectedTypes.push(checkerResult.data.expectedType);
	        }
	      }
	      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function invalidValidatorError(componentName, location, propFullName, key, type) {
	    return new PropTypeError(
	      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
	      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
	    );
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from props.
	      var allKeys = assign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (has(shapeTypes, key) && typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // falsy value can't be a Symbol
	    if (!propValue) {
	      return false;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithTypeCheckers;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;

function requireFactoryWithThrowingShims () {
	if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
	hasRequiredFactoryWithThrowingShims = 1;

	var ReactPropTypesSecret = requireReactPropTypesSecret();

	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;

	factoryWithThrowingShims = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error(
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	    err.name = 'Invariant Violation';
	    throw err;
	  }	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bigint: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,

	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };

	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithThrowingShims;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var ReactIs = requireReactIs();

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  propTypes$1.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  propTypes$1.exports = requireFactoryWithThrowingShims()();
}

function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

function _typeof$2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$2(obj); }
/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || _typeof$2(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} - the new date with the days added
 * @throws {TypeError} - 2 arguments required
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */

function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 days, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  date.setDate(date.getDate() + amount);
  return date;
}

/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * const result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 */

function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 months, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  var dayOfMonth = date.getDate(); // The JS Date object supports date math by accepting out-of-bounds values for
  // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
  // want except that dates will wrap around the end of a month, meaning that
  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
  // we'll default to the end of the desired month by adding 1 to the desired
  // month and using a date of 0 to back up one day to the end of the desired
  // month.

  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();

  if (dayOfMonth >= daysInMonth) {
    // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
  } else {
    // Otherwise, we now know that setting the original day-of-month value won't
    // cause an overflow, so set the desired day-of-month. Note that we can't
    // just set the date of `endOfDesiredMonth` because that object may have had
    // its time changed in the unusual case where where a DST transition was on
    // the last day of the month and its local time was in the hour skipped or
    // repeated next to a DST transition.  So we use `date` instead which is
    // guaranteed to still have the original time.
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

var defaultOptions$1 = {};
function getDefaultOptions() {
  return defaultOptions$1;
}

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */

function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

var MILLISECONDS_IN_DAY$1 = 86400000;
/**
 * @name differenceInCalendarDays
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates. This means that the times are removed
 * from the dates and then the difference in days is calculated.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar days
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 * // How many calendar days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInCalendarDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 1
 */

function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight); // Round the number of days to the nearest integer
  // because the number of milliseconds in a day is not constant
  // (e.g. it's different in the day of the daylight saving time clock shift)

  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
}

/**
 * @name compareAsc
 * @category Common Helpers
 * @summary Compare the two dates and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return 1 if the first date is after the second,
 * -1 if the first date is before the second or 0 if dates are equal.
 *
 * @param {Date|Number} dateLeft - the first date to compare
 * @param {Date|Number} dateRight - the second date to compare
 * @returns {Number} the result of the comparison
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989:
 * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
 * //=> -1
 *
 * @example
 * // Sort the array of dates:
 * const result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareAsc)
 * //=> [
 * //   Wed Feb 11 1987 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Sun Jul 02 1995 00:00:00
 * // ]
 */

function compareAsc(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();

  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1; // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}

/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */
/**
 * Milliseconds in 1 hour
 *
 * @name millisecondsInHour
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInHour = 3600000;

/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day (and year and month)?
 *
 * @description
 * Are the given dates in the same day (and year and month)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same day (and year and month)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 *
 * @example
 * // Are 4 September and 4 October in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
 * //=> false
 *
 * @example
 * // Are 4 September, 2014 and 4 September, 2015 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
 * //=> false
 */

function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}

function _typeof$1(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }
/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */

function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof$1(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  requiredArgs(1, arguments);

  if (!isDate(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }

  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

/**
 * @name differenceInCalendarMonths
 * @category Month Helpers
 * @summary Get the number of calendar months between the given dates.
 *
 * @description
 * Get the number of calendar months between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar months
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInCalendarMonths(
 *   new Date(2014, 8, 1),
 *   new Date(2014, 0, 31)
 * )
 * //=> 8
 */

function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}

// for accurate equality comparisons of UTC timestamps that end up
// having the same representation in local time, e.g. one hour before
// DST ends vs. the instant that DST ends.

function compareLocalAsc(dateLeft, dateRight) {
  var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();

  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1; // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}
/**
 * @name differenceInDays
 * @category Day Helpers
 * @summary Get the number of full days between the given dates.
 *
 * @description
 * Get the number of full day periods between two dates. Fractional days are
 * truncated towards zero.
 *
 * One "full day" is the distance between a local time in one day to the same
 * local time on the next or previous day. A full day can sometimes be less than
 * or more than 24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 24-hour periods, use this instead:
 * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.
 *
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full days according to the local timezone
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 365
 * // How many full days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 0
 * // How many full days are between
 * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 92 days, even in
 * // time zones where DST starts and the
 * // period has only 92*24-1 hours.
 * const result = differenceInDays(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 1)
 * )
//=> 92
 */


function differenceInDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareLocalAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
  dateLeft.setDate(dateLeft.getDate() - sign * difference); // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
  // If so, result must be decreased by 1 in absolute value

  var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign);
  var result = sign * (difference - isLastDayNotFull); // Prevent negative zero

  return result === 0 ? 0 : result;
}

/**
 * @name differenceInMilliseconds
 * @category Millisecond Helpers
 * @summary Get the number of milliseconds between the given dates.
 *
 * @description
 * Get the number of milliseconds between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of milliseconds
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many milliseconds are between
 * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
 * const result = differenceInMilliseconds(
 *   new Date(2014, 6, 2, 12, 30, 21, 700),
 *   new Date(2014, 6, 2, 12, 30, 20, 600)
 * )
 * //=> 1100
 */

function differenceInMilliseconds(dateLeft, dateRight) {
  requiredArgs(2, arguments);
  return toDate(dateLeft).getTime() - toDate(dateRight).getTime();
}

var roundingMap = {
  ceil: Math.ceil,
  round: Math.round,
  floor: Math.floor,
  trunc: function trunc(value) {
    return value < 0 ? Math.ceil(value) : Math.floor(value);
  } // Math.trunc is not supported by IE

};
var defaultRoundingMethod = 'trunc';
function getRoundingMethod(method) {
  return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
}

/**
 * @name differenceInHours
 * @category Hour Helpers
 * @summary Get the number of hours between the given dates.
 *
 * @description
 * Get the number of hours between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
 * @returns {Number} the number of hours
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many hours are between 2 July 2014 06:50:00 and 2 July 2014 19:00:00?
 * const result = differenceInHours(
 *   new Date(2014, 6, 2, 19, 0),
 *   new Date(2014, 6, 2, 6, 50)
 * )
 * //=> 12
 */

function differenceInHours(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}

/**
 * @name endOfDay
 * @category Day Helpers
 * @summary Return the end of a day for the given date.
 *
 * @description
 * Return the end of a day for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a day for 2 September 2014 11:55:00:
 * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 23:59:59.999
 */

function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name endOfMonth
 * @category Month Helpers
 * @summary Return the end of a month for the given date.
 *
 * @description
 * Return the end of a month for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a month for 2 September 2014 11:55:00:
 * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */

function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name isLastDayOfMonth
 * @category Month Helpers
 * @summary Is the given date the last day of a month?
 *
 * @description
 * Is the given date the last day of a month?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is the last day of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 28 February 2014 the last day of a month?
 * const result = isLastDayOfMonth(new Date(2014, 1, 28))
 * //=> true
 */

function isLastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return endOfDay(date).getTime() === endOfMonth(date).getTime();
}

/**
 * @name differenceInMonths
 * @category Month Helpers
 * @summary Get the number of full months between the given dates.
 *
 * @description
 * Get the number of full months between the given dates using trunc as a default rounding method.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full months
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
 * //=> 7
 */

function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
  var result; // Check for the difference of less than month

  if (difference < 1) {
    result = 0;
  } else {
    if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
      // This will check if the date is end of Feb and assign a higher end of month date
      // to compare it with Jan
      dateLeft.setDate(30);
    }

    dateLeft.setMonth(dateLeft.getMonth() - sign * difference); // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
    // If so, result must be decreased by 1 in absolute value

    var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign; // Check for cases of one full calendar month

    if (isLastDayOfMonth(toDate(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
      isLastMonthNotFull = false;
    }

    result = sign * (difference - Number(isLastMonthNotFull));
  } // Prevent negative zero


  return result === 0 ? 0 : result;
}

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

var MILLISECONDS_IN_DAY = 86400000;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

var MILLISECONDS_IN_WEEK$1 = 604800000;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}

function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}

var MILLISECONDS_IN_WEEK = 604800000;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return sign + output;
}

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters$2 = {
  // Year
  y: function y(date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();

      case 'aaa':
        return dayPeriodEnumValue;

      case 'aaaaa':
        return dayPeriodEnumValue[0];

      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var formatters$3 = formatters$2;

var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
};

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */
var formatters = {
  // Era
  G: function G(date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;

    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B

      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ

      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function y(date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }

    return formatters$3.y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize, options) {
    var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    } // Ordinal number


    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    } // Padding


    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date); // Padding

    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function Q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'QQ':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...

      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'qq':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...

      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function M(date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      case 'M':
      case 'MM':
        return formatters$3.M(date, token);
      // 1st, 2nd, ..., 12th

      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D

      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December

      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function L(date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12

      case 'LL':
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th

      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D

      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December

      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize, options) {
    var week = getUTCWeek(date, options);

    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }

    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize) {
    var isoWeek = getUTCISOWeek(date);

    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }

    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function d(date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }

    return formatters$3.d(date, token);
  },
  // Day of year
  D: function D(date, token, localize) {
    var dayOfYear = getUTCDayOfYear(date);

    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }

    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize) {
    var dayOfWeek = date.getUTCDay();

    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'ee':
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th

      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'cc':
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th

      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T

      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu

      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday

      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02

      case 'ii':
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd

      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue

      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function a(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }

    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function h(date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return formatters$3.h(date, token);
  },
  // Hour [0-23]
  H: function H(date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }

    return formatters$3.H(date, token);
  },
  // Hour [0-11]
  K: function K(date, token, localize) {
    var hours = date.getUTCHours() % 12;

    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;

    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function m(date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }

    return formatters$3.m(date, token);
  },
  // Second
  s: function s(date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }

    return formatters$3.s(date, token);
  },
  // Fraction of second
  S: function S(date, token) {
    return formatters$3.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return 'Z';
    }

    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`

      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`

      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`

      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`

      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};

function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;

  if (minutes === 0) {
    return sign + String(hours);
  }

  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }

  return formatTimezone(offset, dirtyDelimiter);
}

function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

var formatters$1 = formatters;

var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
};

var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
};

var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
};

var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$1 = longFormatters;

var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance = function formatDistance(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

var formatDistance$1 = formatDistance;

function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
var formatLong$1 = formatLong;

var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

var formatRelative$1 = formatRelative;

function buildLocalizeFn(args) {
  return function (dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
var localize$1 = localize;

function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}

function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function valueCallback(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
var match$1 = match;

/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var locale = {
  code: 'en-US',
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
var defaultLocale = locale;

// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format$2(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions = getDefaultOptions();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var originalDate = toDate(dirtyDate);

  if (!isValid(originalDate)) {
    throw new RangeError('Invalid time value');
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }

    return substring;
  }).join('').match(formattingTokensRegExp).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }

    var firstCharacter = substring[0];

    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }

    var formatter = formatters$1[firstCharacter];

    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }

      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }

      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }

    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }

    return substring;
  }).join('');
  return result;
}

function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);

  if (!matched) {
    return input;
  }

  return matched[1].replace(doubleQuoteRegExp, "'");
}

/**
 * @name fromUnixTime
 * @category Timestamp Helpers
 * @summary Create a date from a Unix timestamp.
 *
 * @description
 * Create a date from a Unix timestamp (in seconds). Decimal values will be discarded.
 *
 * @param {Number} unixTime - the given Unix timestamp (in seconds)
 * @returns {Date} the date
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Create the date 29 February 2012 11:45:05:
 * const result = fromUnixTime(1330515905)
 * //=> Wed Feb 29 2012 11:45:05
 */

function fromUnixTime(dirtyUnixTime) {
  requiredArgs(1, arguments);
  var unixTime = toInteger(dirtyUnixTime);
  return toDate(unixTime * 1000);
}

/**
 * @name getTime
 * @category Timestamp Helpers
 * @summary Get the milliseconds timestamp of the given date.
 *
 * @description
 * Get the milliseconds timestamp of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the timestamp
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the timestamp of 29 February 2012 11:45:05.123:
 * const result = getTime(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 1330515905123
 */

function getTime$1(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  return timestamp;
}

/**
 * @name getUnixTime
 * @category Timestamp Helpers
 * @summary Get the seconds timestamp of the given date.
 *
 * @description
 * Get the seconds timestamp of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the timestamp
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the timestamp of 29 February 2012 11:45:05 CET:
 * const result = getUnixTime(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 1330512305
 */

function getUnixTime(dirtyDate) {
  requiredArgs(1, arguments);
  return Math.floor(getTime$1(dirtyDate) / 1000);
}

/**
 * @name isAfter
 * @category Common Helpers
 * @summary Is the first date after the second one?
 *
 * @description
 * Is the first date after the second one?
 *
 * @param {Date|Number} date - the date that should be after the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is after the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 after 11 February 1987?
 * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> true
 */

function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}

/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * @param {Date|Number} date - the date that should be before the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is before the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */

function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

/**
 * @name subDays
 * @category Day Helpers
 * @summary Subtract the specified number of days from the given date.
 *
 * @description
 * Subtract the specified number of days from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the days subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 10 days from 1 September 2014:
 * const result = subDays(new Date(2014, 8, 1), 10)
 * //=> Fri Aug 22 2014 00:00:00
 */

function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}

/**
 * @name subMonths
 * @category Month Helpers
 * @summary Subtract the specified number of months from the given date.
 *
 * @description
 * Subtract the specified number of months from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 5 months from 1 February 2015:
 * const result = subMonths(new Date(2015, 1, 1), 5)
 * //=> Mon Sep 01 2014 00:00:00
 */

function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
/**
 * @name sub
 * @category Common Helpers
 * @summary Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @description
 * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Duration} duration - the object with years, months, weeks, days, hours, minutes and seconds to be subtracted
 *
 * | Key     | Description                        |
 * |---------|------------------------------------|
 * | years   | Amount of years to be subtracted   |
 * | months  | Amount of months to be subtracted  |
 * | weeks   | Amount of weeks to be subtracted   |
 * | days    | Amount of days to be subtracted    |
 * | hours   | Amount of hours to be subtracted   |
 * | minutes | Amount of minutes to be subtracted |
 * | seconds | Amount of seconds to be subtracted |
 *
 * All values default to 0
 *
 * @returns {Date} the new date with the seconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract the following duration from 15 June 2017 15:29:20
 * const result = sub(new Date(2017, 5, 15, 15, 29, 20), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> Mon Sep 1 2014 10:19:50
 */

function sub$2(date, duration) {
  requiredArgs(2, arguments);
  if (!duration || _typeof(duration) !== 'object') return new Date(NaN);
  var years = duration.years ? toInteger(duration.years) : 0;
  var months = duration.months ? toInteger(duration.months) : 0;
  var weeks = duration.weeks ? toInteger(duration.weeks) : 0;
  var days = duration.days ? toInteger(duration.days) : 0;
  var hours = duration.hours ? toInteger(duration.hours) : 0;
  var minutes = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds = duration.seconds ? toInteger(duration.seconds) : 0; // Subtract years and months

  var dateWithoutMonths = subMonths(date, months + years * 12); // Subtract weeks and days

  var dateWithoutDays = subDays(dateWithoutMonths, days + weeks * 7); // Subtract hours, minutes and seconds

  var minutestoSub = minutes + hours * 60;
  var secondstoSub = seconds + minutestoSub * 60;
  var mstoSub = secondstoSub * 1000;
  var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
  return finalDate;
}

// BASE URLS
var auth = process.env.REACT_APP_AUTH_BASE_URL;
var encs = process.env.REACT_APP_ENCS_BASE_URL;
var scos = process.env.REACT_APP_SCOS_BASE_URL;
var aws = process.env.REACT_APP_AWS_BASE_URL;
var gcp = process.env.REACT_APP_GCP_BASE_URL;
var oci = process.env.REACT_APP_OCI_BASE_URL;
var pgsql = process.env.REACT_APP_PGSQL_BASE_URL;
var mysql = process.env.REACT_APP_MYSQL_BASE_URL;
var oracle = process.env.REACT_APP_ORACLE_BASE_URL;
var lmosGcp = process.env.REACT_APP_AUDIT_LOG_GCP_BASE_URL;
var lmosAws = process.env.REACT_APP_AUDIT_LOG_AWS_BASE_URL;
var BASE_URLS = {
  auth: auth,
  encs: encs,
  scos: scos,
  aws: aws,
  gcp: gcp,
  oci: oci,
  'lmos-aws': lmosAws,
  'lmos-gcp': lmosGcp,
  pgsql: pgsql,
  mysql: mysql,
  oracle: oracle
};
var MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var FULL_MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
var DAYS = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];

var sumArrayOfObjects = function sumArrayOfObjects(objects) {
  return objects.reduce(function (acc, cur) {
    var keysOfCurrentObject = Object.keys(cur);
    keysOfCurrentObject.forEach(function (key) {
      if (Object.prototype.hasOwnProperty.call(cur, key)) {
        acc[key] = (acc[key] || 0) + cur[key];
      }
    });
    return acc;
  }, {});
};
var getSpacedDisplayName = function getSpacedDisplayName(string) {
  return string === null || string === void 0 ? void 0 : string.replace(/-/g, ' ').replace(/\b\w/g, function (s) {
    return s.toUpperCase();
  });
};
var doubleDigitted = function doubleDigitted(number) {
  var _number$toString$slic;
  return number === null || number === void 0 ? void 0 : (_number$toString$slic = number.toString().slice(-2)) === null || _number$toString$slic === void 0 ? void 0 : _number$toString$slic.padStart(2, '0');
};
var getJSDateFromEpoch = function getJSDateFromEpoch(epoch) {
  var date = new Date(0);
  date.setUTCSeconds(epoch);
  return date;
};
var getDateFromEpoch = function getDateFromEpoch(epoch) {
  var date = new Date(0);
  date.setUTCSeconds(epoch);
  var paddedDate = date.getDate().toString().padStart(2, '0');
  var month = MONTHS[date.getMonth()];
  var year = date.getFullYear();
  return "".concat(month, " ").concat(paddedDate, ", ").concat(year);
};
var getTimeFromEpoch = function getTimeFromEpoch(epoch) {
  var date = new Date(0);
  date.setUTCSeconds(epoch);
  var hours = doubleDigitted(date.getHours());
  var minutes = doubleDigitted(date.getMinutes());
  var seconds = doubleDigitted(date.getSeconds());
  return "".concat(hours, ":").concat(minutes, ":").concat(seconds);
};

// The above two functions will be depracted soon.

/**
 * To get the formatted time and date
 *
 * @param {string} epoch The epoch value : timestamp .
 * @param {string} type type of format to return either "date" or "time"
 * @param {string} format fomrat of date(optional) and time[default = 12 hrs]
 * @returns {string} Returns the formatted date or time.
 */
var epochToFormattedDate = function epochToFormattedDate(epoch, type, format) {
  var date = new Date(0);
  date.setUTCSeconds(epoch);
  if (type === 'time') {
    var hours = doubleDigitted(date.getHours());
    var minutes = doubleDigitted(date.getMinutes());
    var seconds = doubleDigitted(date.getSeconds());
    var hours12 = (date.getHours() + 11) % 12 + 1;
    var meridian = date.getHours() >= 12 ? 'PM' : 'AM';
    var timeFormat = {
      24: "".concat(hours, ":").concat(minutes, ":").concat(seconds, " Hrs"),
      12: "".concat(hours12, ":").concat(minutes, ":").concat(seconds, " ").concat(meridian)
    };
    return timeFormat[format !== null && format !== void 0 ? format : 12];
  }
  if (type === 'date') {
    if (format) {
      return format$2(date, format);
    }
    var paddedDate = date.getDate().toString().padStart(2, '0');
    var month = MONTHS[date.getMonth()];
    var year = date.getFullYear();
    return "".concat(month, " ").concat(paddedDate, ", ").concat(year);
  }
  return null;
};
var uniqueArray = function uniqueArray(array) {
  return _toConsumableArray$1(new Set(array));
};
var uniqueArrayOfObjects = function uniqueArrayOfObjects() {
  var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return array.filter(function (value, index, self) {
    return index === self.findIndex(function (t) {
      return t[key] === value[key];
    });
  });
};
var getInitialsOfName = function getInitialsOfName() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var names = name.split(' ');
  var initials = names[0].substring(0, 1).toUpperCase();
  if (names.length > 1) {
    initials += names[names.length - 1].substring(0, 1).toUpperCase();
  }
  return initials;
};
var safeJSONParse = function safeJSONParse(object) {
  try {
    return JSON.parse(object);
  } catch (error) {
    return null;
  }
};
function cloneDeep(object) {
  return safeJSONParse(JSON.stringify(object));
}
function classes() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args.join(' ');
}
function inputHelper(event) {
  var _event$target = event.target,
    dataset = _event$target.dataset,
    type = _event$target.type;
  var fieldName = event.target.name;
  var fieldValue = ['checkbox', 'radio'].includes(type) ? event.target.checked : event.target.value;
  return {
    fieldName: fieldName,
    fieldValue: fieldValue,
    dataset: dataset
  };
}
var getCurrentSearchParams = function getCurrentSearchParams(searchParams) {
  var currentSearchParams = {};
  searchParams === null || searchParams === void 0 ? void 0 : searchParams.forEach(function (value, key) {
    currentSearchParams[key] = value;
  });
  return currentSearchParams;
};
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts 'string' to a property path array
 * @param string} string The string to convert
 * @returns {Array} Returns the property path array
 */
var stringToPath = function stringToPath(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
};

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place..
 *
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
var get$1 = function get(object, path) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  var pathArr = null;
  var srcObject = object;
  if (Array.isArray(path)) {
    pathArr = _toConsumableArray$1(path);
  } else if (typeof path === 'string') {
    pathArr = stringToPath(path);
  } else {
    return defaultValue;
  }
  var index = 0;
  var _pathArr = pathArr,
    length = _pathArr.length;
  while (object != null && index < length) {
    var _srcObject, _key$toString;
    var key = pathArr[index++];
    srcObject = (_srcObject = srcObject) === null || _srcObject === void 0 ? void 0 : _srcObject[key === null || key === void 0 ? void 0 : (_key$toString = key.toString) === null || _key$toString === void 0 ? void 0 : _key$toString.call(key)];
    if (srcObject == null) {
      break;
    }
  }
  return index && index === length && srcObject !== undefined ? srcObject : defaultValue;
};
var getDayInfo = function getDayInfo(date) {
  var month = FULL_MONTHS[date.getMonth()];
  var monthAsNumber = date.getMonth();
  var year = date.getFullYear();
  var dateAsNumber = date.getDate();
  var day = DAYS[date.getDay()];
  var dayAsNumber = date.getDay();
  var hoursIn12 = date.getHours();
  var hours = (date.getHours() + 11) % 12 + 1;
  var minutes = date.getMinutes();
  var seconds = date.getSeconds();
  var meridian = hours >= 12 ? 'PM' : 'AM';
  return {
    month: month,
    monthAsNumber: monthAsNumber,
    year: year,
    dateAsNumber: dateAsNumber,
    day: day,
    dayAsNumber: dayAsNumber,
    hoursIn12: hoursIn12,
    hours: hours,
    minutes: minutes,
    seconds: seconds,
    meridian: meridian
  };
};
var getDatesInStringFormat = function getDatesInStringFormat(_ref) {
  var startingDate = _ref.startingDate,
    endingDate = _ref.endingDate;
  return ["".concat(startingDate.getDate(), " ").concat(MONTHS[startingDate.getMonth()].substring(0, 3), " ").concat(startingDate.getFullYear()), "".concat(endingDate.getDate(), " ").concat(MONTHS[endingDate.getMonth()].substring(0, 3), " ").concat(endingDate.getFullYear())];
};
var getDatesInAMonth = function getDatesInAMonth(_ref2) {
  var month = _ref2.month,
    year = _ref2.year;
  var date = new Date(Date.UTC(year, month, 1));
  var dates = [];
  var days = [];
  var dateObj = [];
  while (date.getUTCMonth() === month) {
    var dateNumber = new Date(date).getDate();
    var dayNumber = new Date(date).getDay();
    dates.push(dateNumber);
    days.push(dayNumber);
    dateObj.push(new Date(date));
    date.setUTCDate(date.getUTCDate() + 1);
  }
  return {
    dateObj: dateObj,
    dates: dates,
    days: days
  };
};
var getCSSVariableValue = function getCSSVariableValue(variable) {
  return getComputedStyle(document.documentElement).getPropertyValue(variable);
};

var e$1=[],t=[];function n(n,r){if(n&&"undefined"!=typeof document){var a,s=!0===r.prepend?"prepend":"append",d=!0===r.singleTag,i="string"==typeof r.container?document.querySelector(r.container):document.getElementsByTagName("head")[0];if(d){var u=e$1.indexOf(i);-1===u&&(u=e$1.push(i)-1,t[u]={}),a=t[u]&&t[u][s]?t[u][s]:t[u][s]=c();}else a=c();65279===n.charCodeAt(0)&&(n=n.substring(1)),a.styleSheet?a.styleSheet.cssText+=n:a.appendChild(document.createTextNode(n));}function c(){var e=document.createElement("style");if(e.setAttribute("type","text/css"),r.attributes)for(var t=Object.keys(r.attributes),n=0;n<t.length;n++)e.setAttribute(t[n],r.attributes[t[n]]);var a="prepend"===s?"afterbegin":"beforeend";return i.insertAdjacentElement(a,e),e}}

var css$18 = ".BaseCell_module_root__81e07d2d {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0.5rem;\n  gap: 0.5rem;\n  flex: none;\n  height: 3rem;\n  background: var(--white);\n  max-width: 100%;\n  max-height: 100%;\n}\n.BaseCell_module_root__81e07d2d > [data-elem*=component] {\n  display: inline-block;\n  max-height: 100%;\n}\n.BaseCell_module_root__81e07d2d.BaseCell_module_sm__81e07d2d {\n  width: 9.063rem;\n}\n.BaseCell_module_root__81e07d2d.BaseCell_module_md__81e07d2d {\n  width: 15.625rem;\n}\n.BaseCell_module_root__81e07d2d.BaseCell_module_lg__81e07d2d {\n  width: 21.875rem;\n}\n.BaseCell_module_root__81e07d2d.BaseCell_module_auto__81e07d2d {\n  width: auto;\n}\n.BaseCell_module_root__81e07d2d.BaseCell_module_borderRadiusDefault__81e07d2d {\n  border-radius: 0.25rem;\n}\n.BaseCell_module_root__81e07d2d.BaseCell_module_borderRadiusRound__81e07d2d {\n  border-radius: 50%;\n}\n.BaseCell_module_root__81e07d2d.BaseCell_module_borderRadiusEllipse__81e07d2d {\n  border-radius: 1.563rem;\n}\n.BaseCell_module_root__81e07d2d.BaseCell_module_flexible__81e07d2d {\n  flex-grow: 1;\n  flex-shrink: 1;\n  min-width: 3rem;\n}\n.BaseCell_module_root__81e07d2d.BaseCell_module_flexible__81e07d2d.BaseCell_module_sm__81e07d2d {\n  min-width: 9.063rem;\n}\n.BaseCell_module_root__81e07d2d.BaseCell_module_flexible__81e07d2d.BaseCell_module_md__81e07d2d {\n  min-width: 15.625rem;\n}\n.BaseCell_module_root__81e07d2d.BaseCell_module_flexible__81e07d2d.BaseCell_module_lg__81e07d2d {\n  min-width: 21.875rem;\n}";
var modules_3af9b74c = {"root":"BaseCell_module_root__81e07d2d","sm":"BaseCell_module_sm__81e07d2d","md":"BaseCell_module_md__81e07d2d","lg":"BaseCell_module_lg__81e07d2d","auto":"BaseCell_module_auto__81e07d2d","border-radius-default":"BaseCell_module_borderRadiusDefault__81e07d2d","border-radius-round":"BaseCell_module_borderRadiusRound__81e07d2d","border-radius-ellipse":"BaseCell_module_borderRadiusEllipse__81e07d2d","flexible":"BaseCell_module_flexible__81e07d2d"};
n(css$18,{});

var BaseCell = /*#__PURE__*/React.forwardRef(function BaseCell(props, ref) {
  var className = props.className,
    size = props.size,
    flexible = props.flexible,
    rounded = props.rounded,
    component1 = props.component1,
    component2 = props.component2,
    component3 = props.component3,
    RootDOM = props.RootDOM,
    attrs = props.attrs,
    radius = props.radius;
  var Component = /*#__PURE__*/React.createElement(RootDOM, _objectSpread2({
    'data-elem': 'base-cell',
    ref: ref,
    className: classes(className, modules_3af9b74c.root, modules_3af9b74c[size], modules_3af9b74c["border-radius-".concat(radius)], flexible ? modules_3af9b74c.flexible : '', rounded ? modules_3af9b74c.rounded : '')
  }, attrs), /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [component1 && /*#__PURE__*/jsxRuntime.jsx("span", {
      "data-elem": "component1",
      children: component1
    }), component2 && /*#__PURE__*/jsxRuntime.jsx("span", {
      "data-elem": "component2",
      children: component2
    }), component3 && /*#__PURE__*/jsxRuntime.jsx("span", {
      "data-elem": "component3",
      children: component3
    })]
  }));
  if ( /*#__PURE__*/React.isValidElement(Component)) {
    return Component;
  }
  return null;
});
BaseCell.propTypes = {
  className: propTypes$1.exports.string,
  component1: propTypes$1.exports.element,
  component2: propTypes$1.exports.element,
  component3: propTypes$1.exports.element,
  size: propTypes$1.exports.oneOf(['sm', 'md', 'lg', 'auto']),
  flexible: propTypes$1.exports.bool,
  radius: propTypes$1.exports.oneOf(['none', 'default', 'round', 'ellipse']),
  RootDOM: propTypes$1.exports.oneOf(['div', 'span', 'button', 'td']),
  attrs: propTypes$1.exports.object
};
BaseCell.defaultProps = {
  className: '',
  component1: null,
  component2: null,
  component3: null,
  size: 'sm',
  flexible: false,
  radius: 'none',
  RootDOM: 'div',
  attrs: {}
};

var propTypes = {
  className: propTypes$1.exports.string,
  component1: propTypes$1.exports.element,
  component2: propTypes$1.exports.element,
  component3: propTypes$1.exports.element,
  size: propTypes$1.exports.oneOf(['sm', 'md', 'lg', 'auto']),
  flexible: propTypes$1.exports.bool,
  radius: propTypes$1.exports.oneOf(['none', 'default', 'round', 'ellipse']),
  RootDOM: propTypes$1.exports.oneOf(['div', 'span', 'button']),
  attrs: propTypes$1.exports.object
};
var defaultProps = {
  className: '',
  component1: null,
  component2: null,
  component3: null,
  size: 'sm',
  flexible: false,
  radius: 'none',
  RootDOM: 'div',
  attrs: {}
};

var css$17 = "button.BaseButton_module_root__39a3f3ec[data-elem=base-cell] {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  display: inline-flex;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  border: none;\n  background: none;\n  padding: 0.5rem 0.75rem;\n}\nbutton.BaseButton_module_root__39a3f3ec[data-elem=base-cell]:focus {\n  outline: 1px solid var(--highlight);\n}\nbutton.BaseButton_module_root__39a3f3ec[data-elem=base-cell]:active {\n  outline: none;\n}\nbutton.BaseButton_module_root__39a3f3ec[data-elem=base-cell]:disabled {\n  cursor: not-allowed;\n}\nbutton.BaseButton_module_root__39a3f3ec[data-elem=base-cell].BaseButton_module_contained__39a3f3ec {\n  background: var(--black);\n  color: var(--white);\n}\nbutton.BaseButton_module_root__39a3f3ec[data-elem=base-cell].BaseButton_module_outlined__39a3f3ec {\n  color: var(--black);\n  border: 1px solid var(--black);\n}\nbutton.BaseButton_module_root__39a3f3ec[data-elem=base-cell].BaseButton_module_text__39a3f3ec {\n  color: var(--black);\n}\nbutton.BaseButton_module_root__39a3f3ec[data-elem=base-cell] [data-elem*=component] {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n}\nbutton.BaseButton_module_root__39a3f3ec[data-elem=base-cell] [data-elem=component2] {\n  min-width: 0;\n}\nbutton.BaseButton_module_root__39a3f3ec[data-elem=base-cell] [data-elem=title] {\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n}";
var modules_ab72627b = {"root":"BaseButton_module_root__39a3f3ec","contained":"BaseButton_module_contained__39a3f3ec","outlined":"BaseButton_module_outlined__39a3f3ec","text":"BaseButton_module_text__39a3f3ec"};
n(css$17,{});

var BaseButton = /*#__PURE__*/React.forwardRef(function BaseButton(props, ref) {
  var className = props.className,
    component1 = props.component1,
    title = props.title,
    component3 = props.component3,
    size = props.size,
    flexible = props.flexible,
    radius = props.radius,
    disabled = props.disabled,
    type = props.type,
    _onClick = props.onClick,
    blurOnClick = props.blurOnClick,
    variant = props.variant;
  var Title = title && /*#__PURE__*/jsxRuntime.jsx("span", {
    "data-elem": "title",
    children: title
  });
  return /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
    className: classes(className, modules_ab72627b.root, modules_ab72627b[variant]),
    ref: ref,
    component1: component1,
    component2: Title,
    component3: component3,
    flexible: flexible,
    radius: radius,
    size: size,
    attrs: {
      disabled: disabled,
      type: type,
      onClick: function onClick(event) {
        if (blurOnClick) {
          var _event$currentTarget;
          event === null || event === void 0 ? void 0 : (_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : _event$currentTarget.blur();
        }
        _onClick(event);
      }
    },
    RootDOM: "button"
  });
});
BaseButton.propTypes = _objectSpread2(_objectSpread2({}, BaseCell.propTypes), {}, {
  title: propTypes$1.exports.string,
  disabled: propTypes$1.exports.bool,
  type: propTypes$1.exports.oneOf(['button', 'submit', 'reset']),
  onClick: propTypes$1.exports.func,
  blurOnClick: propTypes$1.exports.bool,
  variant: propTypes$1.exports.oneOf(['contained', 'outlined', 'text'])
});
BaseButton.defaultProps = _objectSpread2(_objectSpread2({}, BaseCell.defaultProps), {}, {
  title: null,
  disabled: false,
  type: 'submit',
  onClick: function onClick() {},
  blurOnClick: true,
  variant: 'contained'
});

var css$16 = ".Button_module_root__0be1a26c[data-elem=base-cell] {\n  cursor: pointer;\n}\n.Button_module_root__0be1a26c[data-elem=base-cell] [data-elem=component2] [data-elem=title] {\n  font-weight: 500;\n  font-size: 0.875rem;\n}\n.Button_module_root__0be1a26c[data-elem=base-cell].Button_module_primary__0be1a26c.Button_module_contained__0be1a26c {\n  background-color: var(--highlight);\n  color: var(--white);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell].Button_module_primary__0be1a26c.Button_module_outlined__0be1a26c {\n  background-color: transparent;\n  border-color: var(--highlight);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell].Button_module_primary__0be1a26c.Button_module_outlined__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell].Button_module_primary__0be1a26c.Button_module_text__0be1a26c {\n  color: var(--highlight);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell].Button_module_success__0be1a26c.Button_module_contained__0be1a26c {\n  background-color: var(--success);\n  color: var(--white);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell].Button_module_success__0be1a26c.Button_module_outlined__0be1a26c {\n  background-color: transparent;\n  border-color: var(--success);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell].Button_module_success__0be1a26c.Button_module_outlined__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell].Button_module_success__0be1a26c.Button_module_text__0be1a26c {\n  color: var(--success);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell].Button_module_danger__0be1a26c.Button_module_contained__0be1a26c {\n  background-color: var(--error);\n  color: var(--white);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell].Button_module_danger__0be1a26c.Button_module_outlined__0be1a26c {\n  background-color: transparent;\n  border-color: var(--error);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell].Button_module_danger__0be1a26c.Button_module_outlined__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell].Button_module_danger__0be1a26c.Button_module_text__0be1a26c {\n  color: var(--error);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell].Button_module_warning__0be1a26c.Button_module_contained__0be1a26c {\n  background-color: var(--warning);\n  color: var(--white);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell].Button_module_warning__0be1a26c.Button_module_outlined__0be1a26c {\n  background-color: transparent;\n  border-color: var(--warning);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell].Button_module_warning__0be1a26c.Button_module_outlined__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell].Button_module_warning__0be1a26c.Button_module_text__0be1a26c {\n  color: var(--warning);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_primary__0be1a26c.Button_module_contained__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_success__0be1a26c.Button_module_contained__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_danger__0be1a26c.Button_module_contained__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_warning__0be1a26c.Button_module_contained__0be1a26c {\n  background-color: var(--grey4);\n  color: var(--grey);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_primary__0be1a26c.Button_module_outlined__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_success__0be1a26c.Button_module_outlined__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_danger__0be1a26c.Button_module_outlined__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_warning__0be1a26c.Button_module_outlined__0be1a26c {\n  background-color: transparent;\n  border-color: var(--grey);\n}\n.Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_primary__0be1a26c.Button_module_outlined__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_primary__0be1a26c.Button_module_text__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_success__0be1a26c.Button_module_outlined__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_success__0be1a26c.Button_module_text__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_danger__0be1a26c.Button_module_outlined__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_danger__0be1a26c.Button_module_text__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_warning__0be1a26c.Button_module_outlined__0be1a26c, .Button_module_root__0be1a26c[data-elem=base-cell]:disabled.Button_module_warning__0be1a26c.Button_module_text__0be1a26c {\n  color: var(--grey);\n}";
var modules_b0070f27 = {"root":"Button_module_root__0be1a26c","primary":"Button_module_primary__0be1a26c","contained":"Button_module_contained__0be1a26c","outlined":"Button_module_outlined__0be1a26c","text":"Button_module_text__0be1a26c","success":"Button_module_success__0be1a26c","danger":"Button_module_danger__0be1a26c","warning":"Button_module_warning__0be1a26c"};
n(css$16,{});

var Button = /*#__PURE__*/React.forwardRef(function Button(props, ref) {
  var className = props.className,
    type = props.type,
    LeftComponent = props.leftComponent,
    title = props.title,
    RightComponent = props.rightComponent,
    size = props.size,
    flexible = props.flexible,
    radius = props.radius,
    disabled = props.disabled,
    onClick = props.onClick,
    blurOnClick = props.blurOnClick,
    variant = props.variant,
    color = props.color;
  return /*#__PURE__*/jsxRuntime.jsx(BaseButton, {
    ref: ref,
    type: type,
    component1: LeftComponent && /*#__PURE__*/jsxRuntime.jsx(LeftComponent, {}),
    title: title,
    component3: RightComponent && /*#__PURE__*/jsxRuntime.jsx(RightComponent, {}),
    size: size,
    flexible: flexible,
    radius: radius,
    disabled: disabled,
    onClick: onClick,
    blurOnClick: blurOnClick,
    variant: variant,
    className: classes(modules_b0070f27.root, modules_b0070f27["radius-".concat(radius)], modules_b0070f27[variant], modules_b0070f27[color], className)
  });
});
Button.propTypes = _objectSpread2(_objectSpread2({}, BaseButton.propTypes), {}, {
  color: propTypes$1.exports.oneOf(['primary', 'success', 'danger', 'warning']),
  leftComponent: propTypes$1.exports.node,
  rightComponent: propTypes$1.exports.node
});
Button.defaultProps = _objectSpread2(_objectSpread2({}, BaseButton.defaultProps), {}, {
  color: 'primary',
  leftComponent: null,
  rightComponent: null,
  radius: 'default'
});

var css$15 = ".Chip_module_root__0aa07630[data-elem=base-cell] {\n  position: relative;\n}\n.Chip_module_root__0aa07630[data-elem=base-cell] [data-elem=component2] [data-elem=title] {\n  font-weight: 500;\n  font-size: 0.875rem;\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_sm__0aa07630 {\n  height: 2rem;\n  padding: 0.188rem 0.5rem;\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_md__0aa07630 {\n  height: 2.25rem;\n  padding: 0.563rem 1rem;\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_status__0aa07630.Chip_module_success__0aa07630 {\n  background-color: var(--success-bg);\n  color: var(--success);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_status__0aa07630.Chip_module_info__0aa07630 {\n  background-color: var(--info-bg);\n  color: var(--info);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_status__0aa07630.Chip_module_danger__0aa07630 {\n  background-color: var(--error-bg);\n  color: var(--error);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_status__0aa07630.Chip_module_warning__0aa07630 {\n  background-color: var(--warning-bg);\n  color: var(--warning);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_status__0aa07630.Chip_module_default__0aa07630 {\n  background-color: var(--grey5);\n  color: var(--grey);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_status__0aa07630:hover {\n  box-shadow: -2px -2px 4px rgba(166, 166, 166, 0.25), 2px 2px 4px rgba(166, 166, 166, 0.24);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_input__0aa07630 {\n  border-width: 1px;\n  border-style: solid;\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_input__0aa07630.Chip_module_success__0aa07630 {\n  background-color: var(--success-bg);\n  color: var(--success);\n  border-color: var(--success-outline);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_input__0aa07630.Chip_module_success__0aa07630:hover {\n  background-color: var(--success-outline);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_input__0aa07630.Chip_module_info__0aa07630 {\n  background-color: var(--info-bg);\n  color: var(--info);\n  border-color: var(--info-outline);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_input__0aa07630.Chip_module_info__0aa07630:hover {\n  background-color: var(--info-outline);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_input__0aa07630.Chip_module_danger__0aa07630 {\n  background-color: var(--error-bg);\n  color: var(--error);\n  border-color: var(--error-outline);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_input__0aa07630.Chip_module_danger__0aa07630:hover {\n  background-color: var(--error-outline);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_input__0aa07630.Chip_module_warning__0aa07630 {\n  background-color: var(--warning-bg);\n  color: var(--warning);\n  border-color: var(--warning-outline);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_input__0aa07630.Chip_module_warning__0aa07630:hover {\n  background-color: var(--warning-outline);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_input__0aa07630.Chip_module_default__0aa07630 {\n  background-color: var(--grey8);\n  color: var(--grey);\n  border-color: var(--grey6);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell].Chip_module_input__0aa07630.Chip_module_default__0aa07630:hover {\n  background-color: var(--grey6);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell]:disabled.Chip_module_status__0aa07630, .Chip_module_root__0aa07630[data-elem=base-cell]:disabled.Chip_module_input__0aa07630 {\n  filter: grayscale(1);\n  border-color: var(--grey4);\n  background-color: var(--grey5);\n  color: var(--grey2);\n}\n.Chip_module_root__0aa07630[data-elem=base-cell]:disabled.Chip_module_status__0aa07630 [data-elem=component1],\n.Chip_module_root__0aa07630[data-elem=base-cell]:disabled.Chip_module_status__0aa07630 [data-elem=component3], .Chip_module_root__0aa07630[data-elem=base-cell]:disabled.Chip_module_input__0aa07630 [data-elem=component1],\n.Chip_module_root__0aa07630[data-elem=base-cell]:disabled.Chip_module_input__0aa07630 [data-elem=component3] {\n  opacity: 0.5;\n}\n.Chip_module_root__0aa07630[data-elem=base-cell]:disabled.Chip_module_status__0aa07630:hover, .Chip_module_root__0aa07630[data-elem=base-cell]:disabled.Chip_module_input__0aa07630:hover {\n  box-shadow: none;\n  background-color: var(--grey5);\n}";
var modules_31aa5fd7 = {"root":"Chip_module_root__0aa07630","sm":"Chip_module_sm__0aa07630","md":"Chip_module_md__0aa07630","status":"Chip_module_status__0aa07630","success":"Chip_module_success__0aa07630","info":"Chip_module_info__0aa07630","danger":"Chip_module_danger__0aa07630","warning":"Chip_module_warning__0aa07630","default":"Chip_module_default__0aa07630","input":"Chip_module_input__0aa07630"};
n(css$15,{});

var Chip = /*#__PURE__*/React.forwardRef(function Chip(props, ref) {
  var className = props.className,
    type = props.type,
    LeftComponent = props.leftComponent,
    title = props.title,
    RightComponent = props.rightComponent,
    size = props.size,
    flexible = props.flexible,
    radius = props.radius,
    disabled = props.disabled,
    onClick = props.onClick,
    variant = props.variant,
    color = props.color;
  return /*#__PURE__*/jsxRuntime.jsx(BaseButton, {
    ref: ref,
    type: type,
    component1: LeftComponent && /*#__PURE__*/jsxRuntime.jsx(LeftComponent, {}),
    title: title,
    component3: RightComponent && /*#__PURE__*/jsxRuntime.jsx(RightComponent, {}),
    size: 'auto',
    flexible: flexible,
    radius: radius,
    disabled: disabled,
    onClick: onClick,
    variant: 'contained',
    className: classes(modules_31aa5fd7.root, modules_31aa5fd7["radius-".concat(radius)], modules_31aa5fd7[variant], modules_31aa5fd7[color], modules_31aa5fd7[size], className)
  });
});
Chip.propTypes = _objectSpread2(_objectSpread2({}, BaseButton.propTypes), {}, {
  size: propTypes$1.exports.oneOf(['sm', 'md']),
  variant: propTypes$1.exports.oneOf(['status', 'input']),
  color: propTypes$1.exports.oneOf(['success', 'info', 'warning', 'danger', 'default']),
  leftComponent: propTypes$1.exports.func,
  rightComponent: propTypes$1.exports.func
});
Chip.defaultProps = _objectSpread2(_objectSpread2({}, BaseButton.defaultProps), {}, {
  size: 'sm',
  variant: 'status',
  color: 'success',
  leftComponent: null,
  rightComponent: null,
  radius: 'default'
});

var AlertIcon = {
  Info: function Info(props) {
    var className = props.className;
    return /*#__PURE__*/jsxRuntime.jsx("svg", {
      className: className,
      viewBox: "0 0 20 20",
      fill: "#0F62FE",
      xmlns: "http://www.w3.org/2000/svg",
      children: /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M10 1.25C8.26942 1.25 6.57769 1.76318 5.13876 2.72464C3.69983 3.6861 2.57832 5.05267 1.91606 6.65152C1.25379 8.25037 1.08051 10.0097 1.41813 11.707C1.75575 13.4044 2.58911 14.9635 3.81282 16.1872C5.03653 17.4109 6.59563 18.2442 8.29296 18.5819C9.9903 18.9195 11.7496 18.7462 13.3485 18.0839C14.9473 17.4217 16.3139 16.3002 17.2754 14.8612C18.2368 13.4223 18.75 11.7306 18.75 10C18.75 7.67936 17.8281 5.45376 16.1872 3.81282C14.5462 2.17187 12.3206 1.25 10 1.25ZM10 5C10.1854 5 10.3667 5.05498 10.5209 5.158C10.675 5.26101 10.7952 5.40743 10.8661 5.57873C10.9371 5.75004 10.9557 5.93854 10.9195 6.1204C10.8833 6.30225 10.794 6.4693 10.6629 6.60041C10.5318 6.73152 10.3648 6.82081 10.1829 6.85699C10.001 6.89316 9.81254 6.87459 9.64124 6.80364C9.46993 6.73268 9.32351 6.61252 9.2205 6.45835C9.11749 6.30418 9.0625 6.12292 9.0625 5.9375C9.0625 5.68886 9.16128 5.4504 9.33709 5.27459C9.51291 5.09877 9.75136 5 10 5ZM12.5 15.0781H7.5V13.6719H9.29688V10.0781H8.125V8.67188H10.7031V13.6719H12.5V15.0781Z"
      })
    });
  },
  Warning: function Warning(props) {
    var className = props.className;
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      viewBox: "0 0 20 20",
      fill: "#CBA006",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        x: "1.25",
        y: "1.25",
        width: "17.5",
        height: "17.5",
        rx: "8.75",
        fill: "white"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M10 1.25C5.1875 1.25 1.25 5.1875 1.25 10C1.25 14.8125 5.1875 18.75 10 18.75C14.8125 18.75 18.75 14.8125 18.75 10C18.75 5.1875 14.8125 1.25 10 1.25ZM9.3125 5H10.6875V11.875H9.3125V5V5ZM10 15.625C9.5 15.625 9.0625 15.1875 9.0625 14.6875C9.0625 14.1875 9.5 13.75 10 13.75C10.5 13.75 10.9375 14.1875 10.9375 14.6875C10.9375 15.1875 10.5 15.625 10 15.625Z"
      })]
    });
  },
  Success: function Success(props) {
    var className = props.className;
    return /*#__PURE__*/jsxRuntime.jsx("svg", {
      className: className,
      viewBox: "0 0 20 20",
      fill: "#24A148",
      xmlns: "http://www.w3.org/2000/svg",
      children: /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M10 1.25C8.26942 1.25 6.57769 1.76318 5.13876 2.72464C3.69983 3.6861 2.57832 5.05267 1.91606 6.65152C1.25379 8.25037 1.08051 10.0097 1.41813 11.707C1.75575 13.4044 2.58911 14.9635 3.81282 16.1872C5.03653 17.4109 6.59563 18.2442 8.29296 18.5819C9.9903 18.9195 11.7496 18.7462 13.3485 18.0839C14.9473 17.4217 16.3139 16.3002 17.2754 14.8612C18.2368 13.4223 18.75 11.7306 18.75 10C18.75 7.67936 17.8281 5.45376 16.1872 3.81282C14.5462 2.17187 12.3206 1.25 10 1.25ZM8.75 13.4937L5.625 10.3687L6.61875 9.375L8.75 11.5063L13.3813 6.875L14.3788 7.86625L8.75 13.4937Z"
      })
    });
  },
  Danger: function Danger(props) {
    var className = props.className;
    return /*#__PURE__*/jsxRuntime.jsx("svg", {
      className: className,
      viewBox: "0 0 20 20",
      fill: "#DA1E28",
      xmlns: "http://www.w3.org/2000/svg",
      children: /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M10.0002 1.24992C8.84911 1.24279 7.70808 1.46424 6.64326 1.90144C5.57844 2.33864 4.61101 2.98289 3.79707 3.79683C2.98314 4.61077 2.33889 5.5782 1.90168 6.64302C1.46448 7.70784 1.24303 8.84886 1.25017 9.99992C1.24303 11.151 1.46448 12.292 1.90168 13.3568C2.33889 14.4216 2.98314 15.3891 3.79707 16.203C4.61101 17.017 5.57844 17.6612 6.64326 18.0984C7.70808 18.5356 8.84911 18.7571 10.0002 18.7499C11.1512 18.7571 12.2923 18.5356 13.3571 18.0984C14.4219 17.6612 15.3893 17.017 16.2033 16.203C17.0172 15.3891 17.6615 14.4216 18.0987 13.3568C18.5359 12.292 18.7573 11.151 18.7502 9.99992C18.7573 8.84886 18.5359 7.70784 18.0987 6.64302C17.6615 5.5782 17.0172 4.61077 16.2033 3.79683C15.3893 2.98289 14.4219 2.33864 13.3571 1.90144C12.2923 1.46424 11.1512 1.24279 10.0002 1.24992ZM13.4033 14.3749L5.62517 6.59742L6.59767 5.62492L14.3752 13.403L13.4033 14.3749Z"
      })
    });
  }
};
AlertIcon.Info.defaultProps = {
  className: ''
};
AlertIcon.Warning.defaultProps = {
  className: ''
};
AlertIcon.Success.defaultProps = {
  className: ''
};
AlertIcon.Danger.defaultProps = {
  className: ''
};

var Caret = function Caret(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    viewBox: "0 0 16 17",
    fill: "#161616",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M8 11.5L3 6.50005L3.7 5.80005L8 10.1L12.3 5.80005L13 6.50005L8 11.5Z"
    })
  });
};
Caret.defaultProps = {
  className: ''
};

var Cross$1 = function Cross(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    viewBox: "0 0 24 25",
    fill: "black",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M13.4099 12.5002L19.7099 6.21019C19.8982 6.02188 20.004 5.76649 20.004 5.50019C20.004 5.23388 19.8982 4.97849 19.7099 4.79019C19.5216 4.60188 19.2662 4.49609 18.9999 4.49609C18.7336 4.49609 18.4782 4.60188 18.2899 4.79019L11.9999 11.0902L5.70994 4.79019C5.52164 4.60188 5.26624 4.49609 4.99994 4.49609C4.73364 4.49609 4.47824 4.60188 4.28994 4.79019C4.10164 4.97849 3.99585 5.23388 3.99585 5.50019C3.99585 5.76649 4.10164 6.02188 4.28994 6.21019L10.5899 12.5002L4.28994 18.7902C4.19621 18.8831 4.12182 18.9937 4.07105 19.1156C4.02028 19.2375 3.99414 19.3682 3.99414 19.5002C3.99414 19.6322 4.02028 19.7629 4.07105 19.8848C4.12182 20.0066 4.19621 20.1172 4.28994 20.2102C4.3829 20.3039 4.4935 20.3783 4.61536 20.4291C4.73722 20.4798 4.86793 20.506 4.99994 20.506C5.13195 20.506 5.26266 20.4798 5.38452 20.4291C5.50638 20.3783 5.61698 20.3039 5.70994 20.2102L11.9999 13.9102L18.2899 20.2102C18.3829 20.3039 18.4935 20.3783 18.6154 20.4291C18.7372 20.4798 18.8679 20.506 18.9999 20.506C19.132 20.506 19.2627 20.4798 19.3845 20.4291C19.5064 20.3783 19.617 20.3039 19.7099 20.2102C19.8037 20.1172 19.8781 20.0066 19.9288 19.8848C19.9796 19.7629 20.0057 19.6322 20.0057 19.5002C20.0057 19.3682 19.9796 19.2375 19.9288 19.1156C19.8781 18.9937 19.8037 18.8831 19.7099 18.7902L13.4099 12.5002Z"
    })
  });
};
Cross$1.defaultProps = {
  className: ''
};

var Tick = function Tick(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    viewBox: "0 0 13 12",
    fill: "#0F62FE",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsx("g", {
      clipPath: "url(#clip0_638_154)",
      children: /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M11.6911 1.6875H10.7549C10.6237 1.6875 10.4991 1.74777 10.4188 1.85089L4.89691 8.84598L2.24914 5.49107C2.20908 5.44022 2.15803 5.3991 2.09981 5.3708C2.04159 5.3425 1.97771 5.32776 1.91298 5.32768H0.976817C0.887085 5.32768 0.837531 5.4308 0.892442 5.50045L4.56075 10.1478C4.73217 10.3647 5.06164 10.3647 5.23441 10.1478L11.7755 1.85893C11.8304 1.79063 11.7808 1.6875 11.6911 1.6875Z"
      })
    }), /*#__PURE__*/jsxRuntime.jsx("defs", {
      children: /*#__PURE__*/jsxRuntime.jsx("clipPath", {
        id: "clip0_638_154",
        children: /*#__PURE__*/jsxRuntime.jsx("rect", {
          width: "12",
          height: "12",
          fill: "white",
          transform: "translate(0.333344)"
        })
      })
    })]
  });
};
Tick.defaultProps = {
  className: ''
};

var BreadcrumbSeperator = function BreadcrumbSeperator(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    "data-elem": "breadcrumb-seperator-icon",
    viewBox: "0 0 24 24",
    stroke: "black",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M14.4809 3.88548L9.51916 20.1145",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })
  });
};
BreadcrumbSeperator.defaultProps = {
  className: ''
};

var Calender$1 = function Calender(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    width: "20",
    height: "23",
    viewBox: "0 0 20 23",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M10 18.4966C10.1978 18.4966 10.3911 18.4379 10.5556 18.3281C10.72 18.2182 10.8482 18.062 10.9239 17.8793C10.9996 17.6965 11.0194 17.4955 10.9808 17.3015C10.9422 17.1075 10.847 16.9293 10.7071 16.7895C10.5673 16.6496 10.3891 16.5544 10.1951 16.5158C10.0011 16.4772 9.80004 16.497 9.61732 16.5727C9.43459 16.6484 9.27841 16.7766 9.16853 16.941C9.05865 17.1055 9 17.2988 9 17.4966C9 17.7618 9.10536 18.0162 9.29289 18.2037C9.48043 18.3912 9.73478 18.4966 10 18.4966ZM15 18.4966C15.1978 18.4966 15.3911 18.4379 15.5556 18.3281C15.72 18.2182 15.8482 18.062 15.9239 17.8793C15.9996 17.6965 16.0194 17.4955 15.9808 17.3015C15.9422 17.1075 15.847 16.9293 15.7071 16.7895C15.5673 16.6496 15.3891 16.5544 15.1951 16.5158C15.0011 16.4772 14.8 16.497 14.6173 16.5727C14.4346 16.6484 14.2784 16.7766 14.1685 16.941C14.0586 17.1055 14 17.2988 14 17.4966C14 17.7618 14.1054 18.0162 14.2929 18.2037C14.4804 18.3912 14.7348 18.4966 15 18.4966ZM15 14.4966C15.1978 14.4966 15.3911 14.4379 15.5556 14.3281C15.72 14.2182 15.8482 14.062 15.9239 13.8793C15.9996 13.6965 16.0194 13.4955 15.9808 13.3015C15.9422 13.1075 15.847 12.9293 15.7071 12.7895C15.5673 12.6496 15.3891 12.5544 15.1951 12.5158C15.0011 12.4772 14.8 12.497 14.6173 12.5727C14.4346 12.6484 14.2784 12.7766 14.1685 12.941C14.0586 13.1055 14 13.2988 14 13.4966C14 13.7618 14.1054 14.0162 14.2929 14.2037C14.4804 14.3912 14.7348 14.4966 15 14.4966ZM10 14.4966C10.1978 14.4966 10.3911 14.4379 10.5556 14.3281C10.72 14.2182 10.8482 14.062 10.9239 13.8793C10.9996 13.6965 11.0194 13.4955 10.9808 13.3015C10.9422 13.1075 10.847 12.9293 10.7071 12.7895C10.5673 12.6496 10.3891 12.5544 10.1951 12.5158C10.0011 12.4772 9.80004 12.497 9.61732 12.5727C9.43459 12.6484 9.27841 12.7766 9.16853 12.941C9.05865 13.1055 9 13.2988 9 13.4966C9 13.7618 9.10536 14.0162 9.29289 14.2037C9.48043 14.3912 9.73478 14.4966 10 14.4966ZM17 2.49658H16V1.49658C16 1.23137 15.8946 0.977012 15.7071 0.789475C15.5196 0.601939 15.2652 0.496582 15 0.496582C14.7348 0.496582 14.4804 0.601939 14.2929 0.789475C14.1054 0.977012 14 1.23137 14 1.49658V2.49658H6V1.49658C6 1.23137 5.89464 0.977012 5.70711 0.789475C5.51957 0.601939 5.26522 0.496582 5 0.496582C4.73478 0.496582 4.48043 0.601939 4.29289 0.789475C4.10536 0.977012 4 1.23137 4 1.49658V2.49658H3C2.20435 2.49658 1.44129 2.81265 0.87868 3.37526C0.316071 3.93787 0 4.70093 0 5.49658V19.4966C0 20.2922 0.316071 21.0553 0.87868 21.6179C1.44129 22.1805 2.20435 22.4966 3 22.4966H17C17.7956 22.4966 18.5587 22.1805 19.1213 21.6179C19.6839 21.0553 20 20.2922 20 19.4966V5.49658C20 4.70093 19.6839 3.93787 19.1213 3.37526C18.5587 2.81265 17.7956 2.49658 17 2.49658ZM18 19.4966C18 19.7618 17.8946 20.0162 17.7071 20.2037C17.5196 20.3912 17.2652 20.4966 17 20.4966H3C2.73478 20.4966 2.48043 20.3912 2.29289 20.2037C2.10536 20.0162 2 19.7618 2 19.4966V10.4966H18V19.4966ZM18 8.49658H2V5.49658C2 5.23137 2.10536 4.97701 2.29289 4.78948C2.48043 4.60194 2.73478 4.49658 3 4.49658H4V5.49658C4 5.7618 4.10536 6.01615 4.29289 6.20369C4.48043 6.39122 4.73478 6.49658 5 6.49658C5.26522 6.49658 5.51957 6.39122 5.70711 6.20369C5.89464 6.01615 6 5.7618 6 5.49658V4.49658H14V5.49658C14 5.7618 14.1054 6.01615 14.2929 6.20369C14.4804 6.39122 14.7348 6.49658 15 6.49658C15.2652 6.49658 15.5196 6.39122 15.7071 6.20369C15.8946 6.01615 16 5.7618 16 5.49658V4.49658H17C17.2652 4.49658 17.5196 4.60194 17.7071 4.78948C17.8946 4.97701 18 5.23137 18 5.49658V8.49658ZM5 14.4966C5.19778 14.4966 5.39112 14.4379 5.55557 14.3281C5.72002 14.2182 5.84819 14.062 5.92388 13.8793C5.99957 13.6965 6.01937 13.4955 5.98079 13.3015C5.9422 13.1075 5.84696 12.9293 5.70711 12.7895C5.56725 12.6496 5.38907 12.5544 5.19509 12.5158C5.00111 12.4772 4.80004 12.497 4.61732 12.5727C4.43459 12.6484 4.27841 12.7766 4.16853 12.941C4.05865 13.1055 4 13.2988 4 13.4966C4 13.7618 4.10536 14.0162 4.29289 14.2037C4.48043 14.3912 4.73478 14.4966 5 14.4966ZM5 18.4966C5.19778 18.4966 5.39112 18.4379 5.55557 18.3281C5.72002 18.2182 5.84819 18.062 5.92388 17.8793C5.99957 17.6965 6.01937 17.4955 5.98079 17.3015C5.9422 17.1075 5.84696 16.9293 5.70711 16.7895C5.56725 16.6496 5.38907 16.5544 5.19509 16.5158C5.00111 16.4772 4.80004 16.497 4.61732 16.5727C4.43459 16.6484 4.27841 16.7766 4.16853 16.941C4.05865 17.1055 4 17.2988 4 17.4966C4 17.7618 4.10536 18.0162 4.29289 18.2037C4.48043 18.3912 4.73478 18.4966 5 18.4966Z",
      fill: "#333333"
    })
  });
};
Calender$1.defaultProps = {
  className: ''
};

var Copy = function Copy(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    fill: "black",
    className: className,
    viewBox: "0 0 16 17",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M2 9.5H1V2.5C1 1.94772 1.44772 1.5 2 1.5H9V2.5H2V9.5ZM14 5.5V14.5H5V5.5H14ZM5 4.5H14C14.5523 4.5 15 4.94772 15 5.5V14.5C15 15.0523 14.5523 15.5 14 15.5H5C4.44772 15.5 4 15.0523 4 14.5V5.5C4 4.94772 4.44772 4.5 5 4.5Z"
    })
  });
};
Copy.defaultProps = {
  className: ''
};

var Download = function Download(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    viewBox: "0 0 24 25",
    fill: "#737373",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M8.29 13.79C8.19627 13.883 8.12188 13.9936 8.07111 14.1154C8.02034 14.2373 7.9942 14.368 7.9942 14.5C7.9942 14.632 8.02034 14.7627 8.07111 14.8846C8.12188 15.0064 8.19627 15.117 8.29 15.21L11.29 18.21C11.383 18.3037 11.4936 18.3781 11.6154 18.4289C11.7373 18.4797 11.868 18.5058 12 18.5058C12.132 18.5058 12.2627 18.4797 12.3846 18.4289C12.5064 18.3781 12.617 18.3037 12.71 18.21L15.71 15.21C15.8983 15.0217 16.0041 14.7663 16.0041 14.5C16.0041 14.2337 15.8983 13.9783 15.71 13.79C15.5217 13.6017 15.2663 13.4959 15 13.4959C14.7337 13.4959 14.4783 13.6017 14.29 13.79L13 15.09V3.5C13 3.23478 12.8946 2.98043 12.7071 2.79289C12.5196 2.60536 12.2652 2.5 12 2.5C11.7348 2.5 11.4804 2.60536 11.2929 2.79289C11.1054 2.98043 11 3.23478 11 3.5V15.09L9.71 13.79C9.61704 13.6963 9.50644 13.6219 9.38458 13.5711C9.26272 13.5203 9.13201 13.4942 9 13.4942C8.86799 13.4942 8.73728 13.5203 8.61542 13.5711C8.49356 13.6219 8.38296 13.6963 8.29 13.79ZM18 9.5H16C15.7348 9.5 15.4804 9.60536 15.2929 9.79289C15.1054 9.98043 15 10.2348 15 10.5C15 10.7652 15.1054 11.0196 15.2929 11.2071C15.4804 11.3946 15.7348 11.5 16 11.5H18C18.2652 11.5 18.5196 11.6054 18.7071 11.7929C18.8946 11.9804 19 12.2348 19 12.5V19.5C19 19.7652 18.8946 20.0196 18.7071 20.2071C18.5196 20.3946 18.2652 20.5 18 20.5H6C5.73478 20.5 5.48043 20.3946 5.29289 20.2071C5.10536 20.0196 5 19.7652 5 19.5V12.5C5 12.2348 5.10536 11.9804 5.29289 11.7929C5.48043 11.6054 5.73478 11.5 6 11.5H8C8.26522 11.5 8.51957 11.3946 8.70711 11.2071C8.89464 11.0196 9 10.7652 9 10.5C9 10.2348 8.89464 9.98043 8.70711 9.79289C8.51957 9.60536 8.26522 9.5 8 9.5H6C5.20435 9.5 4.44129 9.81607 3.87868 10.3787C3.31607 10.9413 3 11.7044 3 12.5V19.5C3 20.2956 3.31607 21.0587 3.87868 21.6213C4.44129 22.1839 5.20435 22.5 6 22.5H18C18.7956 22.5 19.5587 22.1839 20.1213 21.6213C20.6839 21.0587 21 20.2956 21 19.5V12.5C21 11.7044 20.6839 10.9413 20.1213 10.3787C19.5587 9.81607 18.7956 9.5 18 9.5Z"
    })
  });
};
Download.defaultProps = {
  className: ''
};

var CheckboxIcon = {
  Checked: function Checked(props) {
    var className = props.className;
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        x: "0.5",
        y: "0.5",
        width: "19",
        height: "19",
        rx: "5.5",
        fill: "white"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M14.6668 6.5L8.25016 12.9167L5.3335 10",
        stroke: "#0F62FE",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }), /*#__PURE__*/jsxRuntime.jsx("rect", {
        x: "0.5",
        y: "0.5",
        width: "19",
        height: "19",
        rx: "5.5",
        stroke: "#0F62FE"
      })]
    });
  },
  UnChecked: function UnChecked(props) {
    var className = props.className;
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        x: "0.5",
        y: "0.5",
        width: "19",
        height: "19",
        rx: "5.5",
        fill: "white"
      }), /*#__PURE__*/jsxRuntime.jsx("rect", {
        x: "0.5",
        y: "0.5",
        width: "19",
        height: "19",
        rx: "5.5",
        stroke: "#888888"
      })]
    });
  }
};
CheckboxIcon.Checked.defaultProps = {
  className: ''
};
CheckboxIcon.UnChecked.defaultProps = {
  className: ''
};

var RadioIcon = {
  Checked: function Checked(props) {
    var className = props.className;
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        x: "0.5",
        y: "0.5",
        width: "19",
        height: "19",
        rx: "9.5",
        fill: "#EDF5FF"
      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
        cx: "10",
        cy: "10",
        r: "4",
        fill: "#0F62FE"
      }), /*#__PURE__*/jsxRuntime.jsx("rect", {
        x: "0.5",
        y: "0.5",
        width: "19",
        height: "19",
        rx: "9.5",
        stroke: "#0F62FE"
      })]
    });
  },
  UnChecked: function UnChecked(props) {
    var className = props.className;
    return /*#__PURE__*/jsxRuntime.jsx("svg", {
      className: className,
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: /*#__PURE__*/jsxRuntime.jsx("rect", {
        x: "0.5",
        y: "0.5",
        width: "19",
        height: "19",
        rx: "9.5",
        stroke: "#888888"
      })
    });
  }
};
RadioIcon.Checked.defaultProps = {
  className: ''
};
RadioIcon.UnChecked.defaultProps = {
  className: ''
};

var Server = function Server(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "#333333",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M9.99998 11.3333C9.86812 11.3333 9.73923 11.3724 9.6296 11.4457C9.51997 11.5189 9.43452 11.623 9.38406 11.7449C9.3336 11.8667 9.3204 12.0007 9.34612 12.13C9.37185 12.2594 9.43534 12.3781 9.52857 12.4714C9.62181 12.5646 9.7406 12.6281 9.86992 12.6538C9.99924 12.6796 10.1333 12.6664 10.2551 12.6159C10.3769 12.5654 10.481 12.48 10.5543 12.3704C10.6275 12.2607 10.6666 12.1318 10.6666 12C10.6666 11.8232 10.5964 11.6536 10.4714 11.5286C10.3464 11.4036 10.1768 11.3333 9.99998 11.3333ZM5.99998 11.3333H3.99998C3.82317 11.3333 3.6536 11.4036 3.52858 11.5286C3.40355 11.6536 3.33331 11.8232 3.33331 12C3.33331 12.1768 3.40355 12.3464 3.52858 12.4714C3.6536 12.5964 3.82317 12.6666 3.99998 12.6666H5.99998C6.17679 12.6666 6.34636 12.5964 6.47138 12.4714C6.59641 12.3464 6.66665 12.1768 6.66665 12C6.66665 11.8232 6.59641 11.6536 6.47138 11.5286C6.34636 11.4036 6.17679 11.3333 5.99998 11.3333ZM12 11.3333C11.8681 11.3333 11.7392 11.3724 11.6296 11.4457C11.52 11.5189 11.4345 11.623 11.3841 11.7449C11.3336 11.8667 11.3204 12.0007 11.3461 12.13C11.3718 12.2594 11.4353 12.3781 11.5286 12.4714C11.6218 12.5646 11.7406 12.6281 11.8699 12.6538C11.9992 12.6796 12.1333 12.6664 12.2551 12.6159C12.3769 12.5654 12.481 12.48 12.5543 12.3704C12.6275 12.2607 12.6666 12.1318 12.6666 12C12.6666 11.8232 12.5964 11.6536 12.4714 11.5286C12.3464 11.4036 12.1768 11.3333 12 11.3333ZM9.99998 7.33331C9.86812 7.33331 9.73923 7.37241 9.6296 7.44567C9.51997 7.51892 9.43452 7.62304 9.38406 7.74486C9.3336 7.86667 9.3204 8.00072 9.34612 8.13004C9.37185 8.25936 9.43534 8.37815 9.52857 8.47138C9.62181 8.56462 9.7406 8.62811 9.86992 8.65384C9.99924 8.67956 10.1333 8.66636 10.2551 8.6159C10.3769 8.56544 10.481 8.47999 10.5543 8.37036C10.6275 8.26073 10.6666 8.13183 10.6666 7.99998C10.6666 7.82317 10.5964 7.6536 10.4714 7.52857C10.3464 7.40355 10.1768 7.33331 9.99998 7.33331ZM5.99998 7.33331H3.99998C3.82317 7.33331 3.6536 7.40355 3.52858 7.52857C3.40355 7.6536 3.33331 7.82317 3.33331 7.99998C3.33331 8.17679 3.40355 8.34636 3.52858 8.47138C3.6536 8.59641 3.82317 8.66665 3.99998 8.66665H5.99998C6.17679 8.66665 6.34636 8.59641 6.47138 8.47138C6.59641 8.34636 6.66665 8.17679 6.66665 7.99998C6.66665 7.82317 6.59641 7.6536 6.47138 7.52857C6.34636 7.40355 6.17679 7.33331 5.99998 7.33331ZM12 3.33331C11.8681 3.33331 11.7392 3.37241 11.6296 3.44567C11.52 3.51892 11.4345 3.62304 11.3841 3.74486C11.3336 3.86667 11.3204 4.00072 11.3461 4.13004C11.3718 4.25936 11.4353 4.37815 11.5286 4.47138C11.6218 4.56462 11.7406 4.62811 11.8699 4.65384C11.9992 4.67956 12.1333 4.66636 12.2551 4.6159C12.3769 4.56544 12.481 4.47999 12.5543 4.37036C12.6275 4.26073 12.6666 4.13183 12.6666 3.99998C12.6666 3.82317 12.5964 3.6536 12.4714 3.52858C12.3464 3.40355 12.1768 3.33331 12 3.33331ZM12 7.33331C11.8681 7.33331 11.7392 7.37241 11.6296 7.44567C11.52 7.51892 11.4345 7.62304 11.3841 7.74486C11.3336 7.86667 11.3204 8.00072 11.3461 8.13004C11.3718 8.25936 11.4353 8.37815 11.5286 8.47138C11.6218 8.56462 11.7406 8.62811 11.8699 8.65384C11.9992 8.67956 12.1333 8.66636 12.2551 8.6159C12.3769 8.56544 12.481 8.47999 12.5543 8.37036C12.6275 8.26073 12.6666 8.13183 12.6666 7.99998C12.6666 7.82317 12.5964 7.6536 12.4714 7.52857C12.3464 7.40355 12.1768 7.33331 12 7.33331ZM14.6666 3.33331C14.6666 2.80288 14.4559 2.29417 14.0809 1.9191C13.7058 1.54403 13.1971 1.33331 12.6666 1.33331H3.33331C2.80288 1.33331 2.29417 1.54403 1.9191 1.9191C1.54403 2.29417 1.33331 2.80288 1.33331 3.33331V4.66665C1.33625 5.16002 1.52145 5.63489 1.85331 5.99998C1.52145 6.36507 1.33625 6.83994 1.33331 7.33331V8.66665C1.33625 9.16002 1.52145 9.63489 1.85331 9.99998C1.52145 10.3651 1.33625 10.8399 1.33331 11.3333V12.6666C1.33331 13.1971 1.54403 13.7058 1.9191 14.0809C2.29417 14.4559 2.80288 14.6666 3.33331 14.6666H12.6666C13.1971 14.6666 13.7058 14.4559 14.0809 14.0809C14.4559 13.7058 14.6666 13.1971 14.6666 12.6666V11.3333C14.6637 10.8399 14.4785 10.3651 14.1466 9.99998C14.4785 9.63489 14.6637 9.16002 14.6666 8.66665V7.33331C14.6637 6.83994 14.4785 6.36507 14.1466 5.99998C14.4785 5.63489 14.6637 5.16002 14.6666 4.66665V3.33331ZM13.3333 12.6666C13.3333 12.8435 13.2631 13.013 13.1381 13.1381C13.013 13.2631 12.8435 13.3333 12.6666 13.3333H3.33331C3.1565 13.3333 2.98693 13.2631 2.86191 13.1381C2.73688 13.013 2.66665 12.8435 2.66665 12.6666V11.3333C2.66665 11.1565 2.73688 10.9869 2.86191 10.8619C2.98693 10.7369 3.1565 10.6666 3.33331 10.6666H12.6666C12.8435 10.6666 13.013 10.7369 13.1381 10.8619C13.2631 10.9869 13.3333 11.1565 13.3333 11.3333V12.6666ZM13.3333 8.66665C13.3333 8.84346 13.2631 9.01303 13.1381 9.13805C13.013 9.26307 12.8435 9.33331 12.6666 9.33331H3.33331C3.1565 9.33331 2.98693 9.26307 2.86191 9.13805C2.73688 9.01303 2.66665 8.84346 2.66665 8.66665V7.33331C2.66665 7.1565 2.73688 6.98693 2.86191 6.86191C2.98693 6.73688 3.1565 6.66665 3.33331 6.66665H12.6666C12.8435 6.66665 13.013 6.73688 13.1381 6.86191C13.2631 6.98693 13.3333 7.1565 13.3333 7.33331V8.66665ZM13.3333 4.66665C13.3333 4.84346 13.2631 5.01303 13.1381 5.13805C13.013 5.26307 12.8435 5.33331 12.6666 5.33331H3.33331C3.1565 5.33331 2.98693 5.26307 2.86191 5.13805C2.73688 5.01303 2.66665 4.84346 2.66665 4.66665V3.33331C2.66665 3.1565 2.73688 2.98693 2.86191 2.86191C2.98693 2.73688 3.1565 2.66665 3.33331 2.66665H12.6666C12.8435 2.66665 13.013 2.73688 13.1381 2.86191C13.2631 2.98693 13.3333 3.1565 13.3333 3.33331V4.66665ZM9.99998 3.33331C9.86812 3.33331 9.73923 3.37241 9.6296 3.44567C9.51997 3.51892 9.43452 3.62304 9.38406 3.74486C9.3336 3.86667 9.3204 4.00072 9.34612 4.13004C9.37185 4.25936 9.43534 4.37815 9.52857 4.47138C9.62181 4.56462 9.7406 4.62811 9.86992 4.65384C9.99924 4.67956 10.1333 4.66636 10.2551 4.6159C10.3769 4.56544 10.481 4.47999 10.5543 4.37036C10.6275 4.26073 10.6666 4.13183 10.6666 3.99998C10.6666 3.82317 10.5964 3.6536 10.4714 3.52858C10.3464 3.40355 10.1768 3.33331 9.99998 3.33331ZM5.99998 3.33331H3.99998C3.82317 3.33331 3.6536 3.40355 3.52858 3.52858C3.40355 3.6536 3.33331 3.82317 3.33331 3.99998C3.33331 4.17679 3.40355 4.34636 3.52858 4.47138C3.6536 4.59641 3.82317 4.66665 3.99998 4.66665H5.99998C6.17679 4.66665 6.34636 4.59641 6.47138 4.47138C6.59641 4.34636 6.66665 4.17679 6.66665 3.99998C6.66665 3.82317 6.59641 3.6536 6.47138 3.52858C6.34636 3.40355 6.17679 3.33331 5.99998 3.33331Z"
    })
  });
};
Server.defaultProps = {
  className: ''
};

var css$14 = ".Arrow_module_right__19f08663 {\n  transform: rotate(0deg);\n}\n\n.Arrow_module_left__19f08663 {\n  transform: rotate(180deg);\n}\n\n.Arrow_module_bottom__19f08663 {\n  transform: rotate(90deg);\n}\n\n.Arrow_module_top__19f08663 {\n  transform: rotate(270deg);\n}";
var modules_e313d483 = {"right":"Arrow_module_right__19f08663","left":"Arrow_module_left__19f08663","bottom":"Arrow_module_bottom__19f08663","top":"Arrow_module_top__19f08663"};
n(css$14,{});

var Arrow$1 = function Arrow(props) {
  var className = props.className,
    position = props.position;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: classes(className, modules_e313d483[position]),
    viewBox: "0 0 25 24",
    fill: "#333333",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M18.8348 11.62C18.7872 11.4973 18.7158 11.3851 18.6248 11.29L13.6248 6.29C13.5316 6.19676 13.4209 6.1228 13.299 6.07234C13.1772 6.02188 13.0467 5.99591 12.9148 5.99591C12.6485 5.99591 12.3931 6.1017 12.2048 6.29C12.1116 6.38324 12.0376 6.49393 11.9871 6.61575C11.9367 6.73758 11.9107 6.86814 11.9107 7C11.9107 7.2663 12.0165 7.5217 12.2048 7.71L15.5048 11H7.91479C7.64958 11 7.39522 11.1054 7.20769 11.2929C7.02015 11.4804 6.91479 11.7348 6.91479 12C6.91479 12.2652 7.02015 12.5196 7.20769 12.7071C7.39522 12.8946 7.64958 13 7.91479 13H15.5048L12.2048 16.29C12.1111 16.383 12.0367 16.4936 11.9859 16.6154C11.9351 16.7373 11.909 16.868 11.909 17C11.909 17.132 11.9351 17.2627 11.9859 17.3846C12.0367 17.5064 12.1111 17.617 12.2048 17.71C12.2978 17.8037 12.4084 17.8781 12.5302 17.9289C12.6521 17.9797 12.7828 18.0058 12.9148 18.0058C13.0468 18.0058 13.1775 17.9797 13.2994 17.9289C13.4212 17.8781 13.5318 17.8037 13.6248 17.71L18.6248 12.71C18.7158 12.6149 18.7872 12.5028 18.8348 12.38C18.9348 12.1365 18.9348 11.8635 18.8348 11.62Z"
    })
  });
};
Arrow$1.defaultProps = {
  className: '',
  position: 'right'
};

var css$13 = ".Chevron_module_left__8b1808eb {\n  transform: rotate(0deg);\n}\n\n.Chevron_module_bottom__8b1808eb {\n  transform: rotate(90deg);\n}\n\n.Chevron_module_right__8b1808eb {\n  transform: rotate(180deg);\n}\n\n.Chevron_module_top__8b1808eb {\n  transform: rotate(270deg);\n}";
var modules_bf5b0b74 = {"left":"Chevron_module_left__8b1808eb","bottom":"Chevron_module_bottom__8b1808eb","right":"Chevron_module_right__8b1808eb","top":"Chevron_module_top__8b1808eb"};
n(css$13,{});

var Chevron = function Chevron(props) {
  var className = props.className,
    position = props.position;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: classes(className, modules_bf5b0b74[position]),
    viewBox: "0 0 22 22",
    fill: "none",
    stroke: "white",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M14.3649 16.766L8.78855 11.1896C8.68381 11.0849 8.68381 10.9151 8.78855 10.8104L14.3649 5.23399",
      strokeWidth: "0.893962",
      strokeLinecap: "round"
    })
  });
};
Chevron.defaultProps = {
  className: '',
  position: 'left'
};

var Delete = function Delete(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    viewBox: "0 0 18 20",
    fill: "#CD0000",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M7.16667 15.5C7.40978 15.5 7.64294 15.4034 7.81485 15.2315C7.98676 15.0596 8.08333 14.8264 8.08333 14.5833V9.08333C8.08333 8.84021 7.98676 8.60706 7.81485 8.43515C7.64294 8.26324 7.40978 8.16666 7.16667 8.16666C6.92355 8.16666 6.69039 8.26324 6.51849 8.43515C6.34658 8.60706 6.25 8.84021 6.25 9.08333V14.5833C6.25 14.8264 6.34658 15.0596 6.51849 15.2315C6.69039 15.4034 6.92355 15.5 7.16667 15.5ZM16.3333 4.49999H12.6667V3.58333C12.6667 2.85398 12.3769 2.15451 11.8612 1.63878C11.3455 1.12306 10.646 0.833328 9.91667 0.833328H8.08333C7.35399 0.833328 6.65451 1.12306 6.13879 1.63878C5.62306 2.15451 5.33333 2.85398 5.33333 3.58333V4.49999H1.66667C1.42355 4.49999 1.19039 4.59657 1.01849 4.76848C0.846577 4.94039 0.75 5.17355 0.75 5.41666C0.75 5.65978 0.846577 5.89293 1.01849 6.06484C1.19039 6.23675 1.42355 6.33333 1.66667 6.33333H2.58333V16.4167C2.58333 17.146 2.87306 17.8455 3.38879 18.3612C3.90451 18.8769 4.60399 19.1667 5.33333 19.1667H12.6667C13.396 19.1667 14.0955 18.8769 14.6112 18.3612C15.1269 17.8455 15.4167 17.146 15.4167 16.4167V6.33333H16.3333C16.5764 6.33333 16.8096 6.23675 16.9815 6.06484C17.1534 5.89293 17.25 5.65978 17.25 5.41666C17.25 5.17355 17.1534 4.94039 16.9815 4.76848C16.8096 4.59657 16.5764 4.49999 16.3333 4.49999ZM7.16667 3.58333C7.16667 3.34021 7.26324 3.10706 7.43515 2.93515C7.60706 2.76324 7.84022 2.66666 8.08333 2.66666H9.91667C10.1598 2.66666 10.3929 2.76324 10.5648 2.93515C10.7368 3.10706 10.8333 3.34021 10.8333 3.58333V4.49999H7.16667V3.58333ZM13.5833 16.4167C13.5833 16.6598 13.4868 16.8929 13.3148 17.0648C13.1429 17.2368 12.9098 17.3333 12.6667 17.3333H5.33333C5.09022 17.3333 4.85706 17.2368 4.68515 17.0648C4.51324 16.8929 4.41667 16.6598 4.41667 16.4167V6.33333H13.5833V16.4167ZM10.8333 15.5C11.0764 15.5 11.3096 15.4034 11.4815 15.2315C11.6534 15.0596 11.75 14.8264 11.75 14.5833V9.08333C11.75 8.84021 11.6534 8.60706 11.4815 8.43515C11.3096 8.26324 11.0764 8.16666 10.8333 8.16666C10.5902 8.16666 10.3571 8.26324 10.1852 8.43515C10.0132 8.60706 9.91667 8.84021 9.91667 9.08333V14.5833C9.91667 14.8264 10.0132 15.0596 10.1852 15.2315C10.3571 15.4034 10.5902 15.5 10.8333 15.5Z"
    })
  });
};
Delete.defaultProps = {
  className: ''
};

var Plus = function Plus(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    viewBox: "0 0 20 21",
    fill: "white",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M10 0.248047C8.02219 0.248047 6.08879 0.834537 4.4443 1.93335C2.79981 3.03216 1.51809 4.59395 0.761209 6.42121C0.00433284 8.24847 -0.193701 10.2591 0.192152 12.1989C0.578004 14.1388 1.53041 15.9206 2.92894 17.3191C4.32746 18.7176 6.10929 19.67 8.0491 20.0559C9.98891 20.4418 11.9996 20.2437 13.8268 19.4868C15.6541 18.73 17.2159 17.4482 18.3147 15.8037C19.4135 14.1593 20 12.2259 20 10.248C20 8.93483 19.7413 7.63447 19.2388 6.42121C18.7363 5.20796 17.9997 4.10556 17.0711 3.17698C16.1425 2.24839 15.0401 1.5118 13.8268 1.00925C12.6136 0.506705 11.3132 0.248047 10 0.248047V0.248047ZM10 18.248C8.41775 18.248 6.87104 17.7789 5.55544 16.8998C4.23985 16.0208 3.21447 14.7713 2.60897 13.3095C2.00347 11.8477 1.84504 10.2392 2.15372 8.68732C2.4624 7.13548 3.22433 5.71001 4.34315 4.59119C5.46197 3.47237 6.88743 2.71045 8.43928 2.40176C9.99113 2.09308 11.5997 2.25151 13.0615 2.85701C14.5233 3.46251 15.7727 4.48789 16.6518 5.80348C17.5308 7.11908 18 8.6658 18 10.248C18 12.3698 17.1572 14.4046 15.6569 15.9049C14.1566 17.4052 12.1217 18.248 10 18.248V18.248ZM14 9.24805H11V6.24805C11 5.98283 10.8946 5.72848 10.7071 5.54094C10.5196 5.3534 10.2652 5.24805 10 5.24805C9.73479 5.24805 9.48043 5.3534 9.2929 5.54094C9.10536 5.72848 9 5.98283 9 6.24805V9.24805H6C5.73479 9.24805 5.48043 9.3534 5.2929 9.54094C5.10536 9.72848 5 9.98283 5 10.248C5 10.5133 5.10536 10.7676 5.2929 10.9552C5.48043 11.1427 5.73479 11.248 6 11.248H9V14.248C9 14.5133 9.10536 14.7676 9.2929 14.9552C9.48043 15.1427 9.73479 15.248 10 15.248C10.2652 15.248 10.5196 15.1427 10.7071 14.9552C10.8946 14.7676 11 14.5133 11 14.248V11.248H14C14.2652 11.248 14.5196 11.1427 14.7071 10.9552C14.8946 10.7676 15 10.5133 15 10.248C15 9.98283 14.8946 9.72848 14.7071 9.54094C14.5196 9.3534 14.2652 9.24805 14 9.24805Z"
    })
  });
};
Plus.defaultProps = {
  className: ''
};

var Edit = function Edit(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    viewBox: "0 0 16 17",
    fill: "none",
    stroke: "#101010",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsxs("g", {
      clipPath: "url(#clip0_7396_6511)",
      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M3.33341 11.4333L2.66675 14.0999L5.33341 13.4333L13.0001 5.7666C13.5524 5.21432 13.5524 4.31889 13.0001 3.7666C12.4478 3.21432 11.5524 3.21432 11.0001 3.7666L3.33341 11.4333Z",
        strokeWidth: "1.33333",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M10 4.7666L12 6.7666",
        strokeWidth: "1.33333",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M8.66675 14.0999H14.0001",
        strokeWidth: "1.33333",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      })]
    }), /*#__PURE__*/jsxRuntime.jsx("defs", {
      children: /*#__PURE__*/jsxRuntime.jsx("clipPath", {
        id: "clip0_7396_6511",
        children: /*#__PURE__*/jsxRuntime.jsx("rect", {
          width: "16",
          height: "16",
          fill: "white",
          transform: "translate(0 0.766602)"
        })
      })
    })]
  });
};
Edit.defaultProps = {
  className: ''
};

var View$2 = function View(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    viewBox: "0 0 16 17",
    fill: "black",
    stroke: "#101010",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M14.1542 8.69774L14.1551 8.69995C14.1643 8.72098 14.169 8.74368 14.169 8.76662C14.169 8.78956 14.1643 8.81226 14.1551 8.83329L14.1542 8.8355C12.8627 11.8341 10.4797 13.6 8.00004 13.6C5.52041 13.6 3.13743 11.8341 1.84593 8.8355L1.84593 8.8355L1.84497 8.83329C1.83579 8.81226 1.83105 8.78956 1.83105 8.76662C1.83105 8.74368 1.83579 8.72098 1.84497 8.69995L1.84497 8.69996L1.84593 8.69774C3.13743 5.69916 5.52041 3.93329 8.00004 3.93329C10.4797 3.93329 12.8627 5.69916 14.1542 8.69774ZM2.28022 8.55531L2.18169 8.76662L2.28022 8.97793C3.48618 11.5641 5.63114 13.2666 8.00004 13.2666C10.3689 13.2666 12.5139 11.5641 13.7199 8.97793L13.8184 8.76662L13.7199 8.55531C12.5139 5.96912 10.3689 4.26662 8.00004 4.26662C5.63114 4.26662 3.48618 5.96912 2.28022 8.55531ZM6.79631 6.9651C7.15262 6.72703 7.57152 6.59996 8.00004 6.59996C8.57468 6.59996 9.12578 6.82823 9.53211 7.23456C9.93844 7.64089 10.1667 8.19199 10.1667 8.76662C10.1667 9.19515 10.0396 9.61405 9.80156 9.97036C9.56349 10.3267 9.2251 10.6044 8.82919 10.7684C8.43329 10.9324 7.99764 10.9753 7.57735 10.8917C7.15706 10.8081 6.77099 10.6017 6.46798 10.2987C6.16497 9.99567 5.95861 9.60961 5.87501 9.18932C5.79141 8.76903 5.83432 8.33338 5.99831 7.93747C6.16229 7.54157 6.44 7.20318 6.79631 6.9651ZM6.9815 10.291C7.28299 10.4924 7.63745 10.6 8.00004 10.6C8.48628 10.6 8.95259 10.4068 9.29641 10.063C9.64022 9.71917 9.83338 9.25285 9.83338 8.76662C9.83338 8.40402 9.72585 8.04957 9.52441 7.74808C9.32296 7.44659 9.03663 7.2116 8.70163 7.07284C8.36663 6.93408 7.99801 6.89778 7.64238 6.96851C7.28675 7.03926 6.96008 7.21386 6.70368 7.47026C6.44729 7.72666 6.27268 8.05332 6.20194 8.40896C6.1312 8.76459 6.1675 9.13321 6.30627 9.46821C6.44503 9.80321 6.68001 10.0895 6.9815 10.291Z"
    })
  });
};
View$2.defaultProps = {
  className: ''
};

var Filter = function Filter(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    viewBox: "0 0 24 24",
    fill: "#0F62FE",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M19 2H5C4.20435 2 3.44129 2.31607 2.87868 2.87868C2.31607 3.44129 2 4.20435 2 5V6.17C1.99986 6.58294 2.08497 6.99147 2.25 7.37V7.43C2.39128 7.75097 2.59139 8.04266 2.84 8.29L9 14.41V21C8.99966 21.1699 9.04264 21.3372 9.12487 21.4859C9.20711 21.6346 9.32589 21.7599 9.47 21.85C9.62914 21.9486 9.81277 22.0006 10 22C10.1565 21.9991 10.3107 21.9614 10.45 21.89L14.45 19.89C14.6149 19.8069 14.7536 19.6798 14.8507 19.5227C14.9478 19.3656 14.9994 19.1847 15 19V14.41L21.12 8.29C21.3686 8.04266 21.5687 7.75097 21.71 7.43V7.37C21.8888 6.99443 21.9876 6.58578 22 6.17V5C22 4.20435 21.6839 3.44129 21.1213 2.87868C20.5587 2.31607 19.7956 2 19 2ZM13.29 13.29C13.1973 13.3834 13.124 13.4943 13.0742 13.6161C13.0245 13.7379 12.9992 13.8684 13 14V18.38L11 19.38V14C11.0008 13.8684 10.9755 13.7379 10.9258 13.6161C10.876 13.4943 10.8027 13.3834 10.71 13.29L5.41 8H18.59L13.29 13.29ZM20 6H4V5C4 4.73478 4.10536 4.48043 4.29289 4.29289C4.48043 4.10536 4.73478 4 5 4H19C19.2652 4 19.5196 4.10536 19.7071 4.29289C19.8946 4.48043 20 4.73478 20 5V6Z"
    })
  });
};
Filter.defaultProps = {
  className: ''
};

var MagnifyingGlass = function MagnifyingGlass(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    viewBox: "0 0 19 18",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M8.85626 14.0625C12.1182 14.0625 14.7625 11.4182 14.7625 8.15625C14.7625 4.89432 12.1182 2.25 8.85626 2.25C5.59433 2.25 2.95001 4.89432 2.95001 8.15625C2.95001 11.4182 5.59433 14.0625 8.85626 14.0625Z",
      stroke: "#888888",
      strokeWidth: "1.29375",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M13.0328 12.3328L16.45 15.75",
      stroke: "#888888",
      strokeWidth: "1.29375",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })]
  });
};
MagnifyingGlass.defaultProps = {
  className: ''
};

var Columns$1 = function Columns(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    width: "14",
    height: "15",
    viewBox: "0 0 14 15",
    fill: "#2A2A2A",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M12.25 1.17167H1.75002C1.59531 1.17167 1.44694 1.23313 1.33754 1.34252C1.22815 1.45192 1.16669 1.60029 1.16669 1.755V12.255C1.16669 12.4097 1.22815 12.5581 1.33754 12.6675C1.44694 12.7769 1.59531 12.8383 1.75002 12.8383H12.25C12.4047 12.8383 12.5531 12.7769 12.6625 12.6675C12.7719 12.5581 12.8334 12.4097 12.8334 12.255V1.755C12.8334 1.60029 12.7719 1.45192 12.6625 1.34252C12.5531 1.23313 12.4047 1.17167 12.25 1.17167ZM6.41669 11.6717H2.33335V2.33833H6.41669V11.6717ZM11.6667 11.6717H7.58335V2.33833H11.6667V11.6717Z"
    })
  });
};
Columns$1.defaultProps = {
  className: ''
};

var Refresh = function Refresh(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    viewBox: "0 0 27 26",
    fill: "#333333",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M22.0565 16.7416H17.2276C16.9449 16.7416 16.6737 16.8539 16.4738 17.0538C16.2739 17.2537 16.1616 17.5249 16.1616 17.8076C16.1616 18.0903 16.2739 18.3614 16.4738 18.5614C16.6737 18.7613 16.9449 18.8736 17.2276 18.8736H19.7859C18.6101 20.1024 17.0937 20.9515 15.4316 21.3119C13.7695 21.6723 12.0375 21.5275 10.4584 20.896C8.87917 20.2646 7.52486 19.1754 6.56944 17.7683C5.61403 16.3613 5.10114 14.7007 5.09669 13C5.09669 12.7173 4.98438 12.4462 4.78447 12.2462C4.58456 12.0463 4.31342 11.934 4.03071 11.934C3.74799 11.934 3.47685 12.0463 3.27694 12.2462C3.07703 12.4462 2.96472 12.7173 2.96472 13C2.97036 15.0817 3.58536 17.1161 4.73383 18.8523C5.8823 20.5885 7.51399 21.9504 9.42751 22.77C11.341 23.5896 13.4527 23.831 15.5018 23.4644C17.5509 23.0978 19.4479 22.1393 20.9585 20.7071V22.5939C20.9585 22.8766 21.0708 23.1477 21.2708 23.3476C21.4707 23.5475 21.7418 23.6598 22.0245 23.6598C22.3072 23.6598 22.5784 23.5475 22.7783 23.3476C22.9782 23.1477 23.0905 22.8766 23.0905 22.5939V17.7969C23.0879 17.5215 22.9787 17.2578 22.786 17.0611C22.5932 16.8643 22.3318 16.7499 22.0565 16.7416ZM16.8225 13C16.8225 12.3675 16.635 11.7492 16.2836 11.2233C15.9322 10.6974 15.4327 10.2875 14.8484 10.0455C14.264 9.80344 13.621 9.74011 13.0007 9.8635C12.3803 9.98689 11.8105 10.2915 11.3633 10.7387C10.916 11.186 10.6115 11.7558 10.4881 12.3761C10.3647 12.9965 10.428 13.6395 10.67 14.2238C10.9121 14.8082 11.322 15.3076 11.8479 15.659C12.3738 16.0104 12.9921 16.198 13.6246 16.198C14.4727 16.198 15.2861 15.861 15.8859 15.2613C16.4856 14.6616 16.8225 13.8482 16.8225 13ZM12.5586 13C12.5586 12.7892 12.6211 12.5831 12.7382 12.4078C12.8554 12.2325 13.0218 12.0958 13.2166 12.0152C13.4114 11.9345 13.6257 11.9134 13.8325 11.9545C14.0393 11.9956 14.2292 12.0972 14.3783 12.2462C14.5274 12.3953 14.6289 12.5853 14.6701 12.792C14.7112 12.9988 14.6901 13.2132 14.6094 13.4079C14.5287 13.6027 14.3921 13.7692 14.2168 13.8863C14.0415 14.0035 13.8354 14.066 13.6246 14.066C13.3418 14.066 13.0707 13.9537 12.8708 13.7538C12.6709 13.5539 12.5586 13.2827 12.5586 13ZM13.6246 2.34016C10.8918 2.34796 8.26638 3.40499 6.29059 5.29294V3.40615C6.29059 3.12343 6.17828 2.85229 5.97837 2.65238C5.77846 2.45247 5.50732 2.34016 5.22461 2.34016C4.94189 2.34016 4.67075 2.45247 4.47084 2.65238C4.27093 2.85229 4.15862 3.12343 4.15862 3.40615V8.20308C4.15862 8.48579 4.27093 8.75693 4.47084 8.95684C4.67075 9.15675 4.94189 9.26906 5.22461 9.26906H10.0215C10.3043 9.26906 10.5754 9.15675 10.7753 8.95684C10.9752 8.75693 11.0875 8.48579 11.0875 8.20308C11.0875 7.92036 10.9752 7.64922 10.7753 7.44931C10.5754 7.2494 10.3043 7.13709 10.0215 7.13709H7.46317C8.63838 5.90894 10.1538 5.06002 11.8149 4.6993C13.4761 4.33858 15.2071 4.48252 16.7859 5.11264C18.3646 5.74276 19.719 6.83031 20.6752 8.2357C21.6315 9.64108 22.1459 11.3002 22.1524 13C22.1524 13.2827 22.2647 13.5539 22.4647 13.7538C22.6646 13.9537 22.9357 14.066 23.2184 14.066C23.5011 14.066 23.7723 13.9537 23.9722 13.7538C24.1721 13.5539 24.2844 13.2827 24.2844 13C24.2844 11.6001 24.0087 10.214 23.473 8.92066C22.9373 7.62735 22.1521 6.45222 21.1622 5.46236C20.1723 4.4725 18.9972 3.6873 17.7039 3.1516C16.4106 2.61589 15.0244 2.34016 13.6246 2.34016Z"
    })
  });
};
Refresh.defaultProps = {
  className: ''
};

var Nut = function Nut(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    viewBox: "0 0 26 26",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M22.4023 17.727V8.27303C22.4015 8.1307 22.3632 7.99108 22.2913 7.86826C22.2193 7.74544 22.1163 7.64376 21.9925 7.57348L13.5979 2.82652C13.4794 2.7581 13.345 2.72208 13.2082 2.72208C13.0713 2.72208 12.9369 2.7581 12.8184 2.82652L4.42378 7.57348C4.30001 7.64376 4.19696 7.74544 4.12502 7.86826C4.05308 7.99108 4.0148 8.1307 4.01404 8.27303V17.727C4.0148 17.8693 4.05308 18.0089 4.12502 18.1317C4.19696 18.2546 4.30001 18.3562 4.42378 18.4265L12.8184 23.1735C12.9369 23.2419 13.0713 23.2779 13.2082 23.2779C13.345 23.2779 13.4794 23.2419 13.5979 23.1735L21.9925 18.4265C22.1163 18.3562 22.2193 18.2546 22.2913 18.1317C22.3632 18.0089 22.4015 17.8693 22.4023 17.727V17.727Z",
      stroke: "#333333",
      strokeWidth: "1.91877",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M13.2082 16.5977C15.1951 16.5977 16.8059 14.987 16.8059 13C16.8059 11.013 15.1951 9.40231 13.2082 9.40231C11.2212 9.40231 9.61047 11.013 9.61047 13C9.61047 14.987 11.2212 16.5977 13.2082 16.5977Z",
      stroke: "#333333",
      strokeWidth: "1.91877",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })]
  });
};
Nut.defaultProps = {
  className: ''
};

var HalfShade = function HalfShade(_ref) {
  var className = _ref.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    width: "21",
    height: "21",
    viewBox: "0 0 21 21",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M19.8301 5.81656C19.0191 4.30102 17.8352 3.01725 16.3901 2.08656C15.0823 1.24524 13.5963 0.720506 12.0502 0.554044C10.5041 0.387583 8.9405 0.583984 7.4836 1.12764C6.0267 1.6713 4.71667 2.54724 3.65758 3.68586C2.59849 4.82447 1.81954 6.19439 1.3826 7.68678C0.945669 9.17916 0.862799 10.7529 1.14058 12.2829C1.41835 13.8129 2.04912 15.2571 2.98277 16.5006C3.91641 17.7442 5.12721 18.7529 6.51895 19.4465C7.91069 20.1402 9.44503 20.4997 11.0001 20.4966H11.2901C12.9891 20.4464 14.6473 19.964 16.1082 19.0949C17.569 18.2258 18.7841 16.9986 19.6388 15.5294C20.4936 14.0601 20.9597 12.3972 20.9931 10.6977C21.0266 8.99828 20.6263 7.31833 19.8301 5.81656ZM10.0001 18.4266C8.0782 18.1706 6.31468 17.2255 5.03741 15.7669C3.76014 14.3082 3.05604 12.4354 3.05604 10.4966C3.05604 8.55774 3.76014 6.68489 5.03741 5.22626C6.31468 3.76763 8.0782 2.82248 10.0001 2.56656V18.4266ZM12.0001 2.56656C12.8646 2.67715 13.7055 2.92706 14.4901 3.30656L12.0001 7.61656V2.56656ZM12.0001 11.5666L16.1701 4.39656C16.7849 4.92451 17.3174 5.54131 17.7501 6.22656L12.0001 16.1866V11.5666ZM13.1501 18.1466L18.7401 8.49656C18.9091 9.14991 18.9964 9.82171 19.0001 10.4966C18.9988 12.2426 18.4264 13.9402 17.3702 15.3305C16.3139 16.7208 14.8318 17.7273 13.1501 18.1966V18.1466Z",
      fill: "#333333"
    })
  });
};
HalfShade.defaultProps = {
  className: ''
};

var AngleDouble = function AngleDouble(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    viewBox: "0 0 19 19",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M9.30329 6.7771C9.23506 6.70831 9.15389 6.6537 9.06445 6.61644C8.97501 6.57918 8.87908 6.56 8.78219 6.56C8.6853 6.56 8.58937 6.57918 8.49994 6.61644C8.4105 6.6537 8.32932 6.70831 8.26109 6.7771L6.05926 8.97893C5.99047 9.04716 5.93587 9.12833 5.89861 9.21777C5.86135 9.30721 5.84216 9.40314 5.84216 9.50003C5.84216 9.59692 5.86135 9.69285 5.89861 9.78229C5.93587 9.87172 5.99047 9.9529 6.05926 10.0211L8.26109 12.223C8.32932 12.2917 8.4105 12.3464 8.49994 12.3836C8.58937 12.4209 8.6853 12.4401 8.78219 12.4401C8.87908 12.4401 8.97501 12.4209 9.06445 12.3836C9.15389 12.3464 9.23506 12.2917 9.30329 12.223C9.37208 12.1547 9.42669 12.0736 9.46395 11.9841C9.50121 11.8947 9.52039 11.7987 9.52039 11.7019C9.52039 11.605 9.50121 11.509 9.46395 11.4196C9.42669 11.3302 9.37208 11.249 9.30329 11.1808L7.61522 9.50003L9.30329 7.8193C9.37208 7.75107 9.42669 7.66989 9.46395 7.58045C9.50121 7.49102 9.52039 7.39509 9.52039 7.2982C9.52039 7.20131 9.50121 7.10538 9.46395 7.01594C9.42669 6.9265 9.37208 6.84533 9.30329 6.7771ZM11.6519 9.50003L13.3693 7.8193C13.5075 7.68109 13.5852 7.49365 13.5852 7.2982C13.5852 7.10275 13.5075 6.9153 13.3693 6.7771C13.2311 6.63889 13.0437 6.56125 12.8482 6.56125C12.6528 6.56125 12.4653 6.63889 12.3271 6.7771L10.1253 8.97893C10.0565 9.04716 10.0019 9.12833 9.96466 9.21777C9.92739 9.30721 9.90821 9.40314 9.90821 9.50003C9.90821 9.59692 9.92739 9.69285 9.96466 9.78229C10.0019 9.87172 10.0565 9.9529 10.1253 10.0211L12.3271 12.223C12.3954 12.2917 12.4765 12.3464 12.566 12.3836C12.6554 12.4209 12.7514 12.4401 12.8482 12.4401C12.9451 12.4401 13.0411 12.4209 13.1305 12.3836C13.2199 12.3464 13.3011 12.2917 13.3693 12.223C13.4381 12.1547 13.4927 12.0736 13.53 11.9841C13.5673 11.8947 13.5864 11.7987 13.5864 11.7019C13.5864 11.605 13.5673 11.509 13.53 11.4196C13.4927 11.3302 13.4381 11.249 13.3693 11.1808L11.6519 9.50003Z",
      fill: "#110DEF"
    })
  });
};
AngleDouble.defaultProps = {
  className: ''
};

var ExpandArrowAlt = function ExpandArrowAlt(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    viewBox: "0 0 21 21",
    fill: "#888888",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M8.07488 11.575L3.66654 15.9917V14.6667C3.66654 14.4457 3.57875 14.2337 3.42247 14.0774C3.26619 13.9212 3.05423 13.8334 2.83321 13.8334C2.6122 13.8334 2.40024 13.9212 2.24396 14.0774C2.08768 14.2337 1.99988 14.4457 1.99988 14.6667V18C2.00119 18.1089 2.02384 18.2165 2.06654 18.3167C2.15111 18.5203 2.31292 18.6821 2.51654 18.7667C2.61673 18.8094 2.72431 18.832 2.83321 18.8334H6.16654C6.38756 18.8334 6.59952 18.7456 6.7558 18.5893C6.91208 18.433 6.99988 18.221 6.99988 18C6.99988 17.779 6.91208 17.567 6.7558 17.4108C6.59952 17.2545 6.38756 17.1667 6.16654 17.1667H4.84154L9.25821 12.7584C9.41513 12.6014 9.50329 12.3886 9.50329 12.1667C9.50329 11.9448 9.41513 11.7319 9.25821 11.575C9.10129 11.4181 8.88846 11.3299 8.66654 11.3299C8.44463 11.3299 8.2318 11.4181 8.07488 11.575ZM4.84154 3.83335H6.16654C6.38756 3.83335 6.59952 3.74556 6.7558 3.58928C6.91208 3.433 6.99988 3.22103 6.99988 3.00002C6.99988 2.77901 6.91208 2.56704 6.7558 2.41076C6.59952 2.25448 6.38756 2.16669 6.16654 2.16669H2.83321C2.72431 2.168 2.61673 2.19065 2.51654 2.23335C2.31292 2.31792 2.15111 2.47973 2.06654 2.68335C2.02384 2.78354 2.00119 2.89112 1.99988 3.00002V6.33335C1.99988 6.55437 2.08768 6.76633 2.24396 6.92261C2.40024 7.07889 2.6122 7.16669 2.83321 7.16669C3.05423 7.16669 3.26619 7.07889 3.42247 6.92261C3.57875 6.76633 3.66654 6.55437 3.66654 6.33335V5.00835L8.07488 9.42502C8.15235 9.50313 8.24451 9.56512 8.34606 9.60743C8.44761 9.64974 8.55654 9.67152 8.66654 9.67152C8.77655 9.67152 8.88548 9.64974 8.98703 9.60743C9.08857 9.56512 9.18074 9.50313 9.25821 9.42502C9.33632 9.34755 9.39831 9.25538 9.44062 9.15383C9.48293 9.05229 9.50471 8.94336 9.50471 8.83335C9.50471 8.72334 9.48293 8.61442 9.44062 8.51287C9.39831 8.41132 9.33632 8.31916 9.25821 8.24169L4.84154 3.83335ZM17.8332 13.8334C17.6122 13.8334 17.4002 13.9212 17.244 14.0774C17.0877 14.2337 16.9999 14.4457 16.9999 14.6667V15.9917L12.5915 11.575C12.4346 11.4181 12.2218 11.3299 11.9999 11.3299C11.778 11.3299 11.5651 11.4181 11.4082 11.575C11.2513 11.7319 11.1631 11.9448 11.1631 12.1667C11.1631 12.3886 11.2513 12.6014 11.4082 12.7584L15.8249 17.1667H14.4999C14.2789 17.1667 14.0669 17.2545 13.9106 17.4108C13.7543 17.567 13.6665 17.779 13.6665 18C13.6665 18.221 13.7543 18.433 13.9106 18.5893C14.0669 18.7456 14.2789 18.8334 14.4999 18.8334H17.8332C17.9421 18.832 18.0497 18.8094 18.1499 18.7667C18.3535 18.6821 18.5153 18.5203 18.5999 18.3167C18.6426 18.2165 18.6652 18.1089 18.6665 18V14.6667C18.6665 14.4457 18.5787 14.2337 18.4225 14.0774C18.2662 13.9212 18.0542 13.8334 17.8332 13.8334ZM18.5999 2.68335C18.5153 2.47973 18.3535 2.31792 18.1499 2.23335C18.0497 2.19065 17.9421 2.168 17.8332 2.16669H14.4999C14.2789 2.16669 14.0669 2.25448 13.9106 2.41076C13.7543 2.56704 13.6665 2.77901 13.6665 3.00002C13.6665 3.22103 13.7543 3.433 13.9106 3.58928C14.0669 3.74556 14.2789 3.83335 14.4999 3.83335H15.8249L11.4082 8.24169C11.3301 8.31916 11.2681 8.41132 11.2258 8.51287C11.1835 8.61442 11.1617 8.72334 11.1617 8.83335C11.1617 8.94336 11.1835 9.05229 11.2258 9.15383C11.2681 9.25538 11.3301 9.34755 11.4082 9.42502C11.4857 9.50313 11.5778 9.56512 11.6794 9.60743C11.7809 9.64974 11.8899 9.67152 11.9999 9.67152C12.1099 9.67152 12.2188 9.64974 12.3204 9.60743C12.4219 9.56512 12.5141 9.50313 12.5915 9.42502L16.9999 5.00835V6.33335C16.9999 6.55437 17.0877 6.76633 17.244 6.92261C17.4002 7.07889 17.6122 7.16669 17.8332 7.16669C18.0542 7.16669 18.2662 7.07889 18.4225 6.92261C18.5787 6.76633 18.6665 6.55437 18.6665 6.33335V3.00002C18.6652 2.89112 18.6426 2.78354 18.5999 2.68335Z"
    })
  });
};

var Reset = function Reset(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    width: "25",
    height: "25",
    viewBox: "0 0 25 25",
    fill: "#333333",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M5.37 5.26658C7.22349 3.4955 9.68639 2.50389 12.25 2.49658C14.2278 2.49658 16.1612 3.08307 17.8057 4.18189C19.4502 5.2807 20.7319 6.84249 21.4888 8.66975C22.2457 10.497 22.4437 12.5077 22.0579 14.4475C21.672 16.3873 20.7196 18.1691 19.3211 19.5676C17.9225 20.9662 16.1407 21.9186 14.2009 22.3044C12.2611 22.6903 10.2504 22.4923 8.42317 21.7354C6.5959 20.9785 5.03412 19.6968 3.9353 18.0523C2.83649 16.4078 2.25 14.4744 2.25 12.4966C2.25 12.2314 2.35536 11.977 2.54289 11.7895C2.73043 11.6019 2.98478 11.4966 3.25 11.4966C3.51522 11.4966 3.76957 11.6019 3.95711 11.7895C4.14464 11.977 4.25 12.2314 4.25 12.4966C4.24279 14.3563 4.88372 16.1604 6.06259 17.5988C7.24147 19.0371 8.88463 20.0198 10.7096 20.3779C12.5345 20.736 14.4272 20.4471 16.0622 19.5609C17.6972 18.6747 18.9723 17.2465 19.6684 15.522C20.3645 13.7974 20.438 11.8843 19.8763 10.1114C19.3146 8.33849 18.1528 6.8167 16.5907 5.80763C15.0285 4.79856 13.1636 4.36527 11.3165 4.58225C9.46951 4.79924 7.75578 5.65294 6.47 6.99658H8.87C9.13522 6.99658 9.38957 7.10194 9.57711 7.28948C9.76464 7.47701 9.87 7.73137 9.87 7.99658C9.87 8.2618 9.76464 8.51615 9.57711 8.70369C9.38957 8.89122 9.13522 8.99658 8.87 8.99658H4.37C4.10478 8.99658 3.85043 8.89122 3.66289 8.70369C3.47536 8.51615 3.37 8.2618 3.37 7.99658V3.49658C3.37 3.23137 3.47536 2.97701 3.66289 2.78948C3.85043 2.60194 4.10478 2.49658 4.37 2.49658C4.63522 2.49658 4.88957 2.60194 5.07711 2.78948C5.26464 2.97701 5.37 3.23137 5.37 3.49658V5.26658Z"
    })
  });
};
Reset.propTypes = {
  className: propTypes$1.exports.string
};
Reset.defaultProps = {
  className: ''
};

var Settings = function Settings(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    width: "14",
    height: "15",
    viewBox: "0 0 14 15",
    fill: "#2A2A2A",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M11.6084 7.38999C11.5148 7.28354 11.4633 7.14669 11.4633 7.00499C11.4633 6.8633 11.5148 6.72645 11.6084 6.61999L12.355 5.77999C12.4373 5.68822 12.4884 5.57274 12.501 5.45012C12.5135 5.32751 12.487 5.20406 12.425 5.09749L11.2584 3.07916C11.197 2.97272 11.1037 2.88834 10.9916 2.83806C10.8795 2.78778 10.7545 2.77417 10.6342 2.79916L9.53752 3.02083C9.39798 3.04966 9.25271 3.02642 9.12912 2.95549C9.00554 2.88457 8.91219 2.77086 8.86669 2.63583L8.51085 1.56833C8.47172 1.45247 8.39716 1.35183 8.29772 1.28065C8.19828 1.20947 8.07898 1.17135 7.95669 1.17166H5.62335C5.49615 1.16502 5.37027 1.2002 5.26493 1.27183C5.1596 1.34345 5.08061 1.44759 5.04002 1.56833L4.71335 2.63583C4.66786 2.77086 4.5745 2.88457 4.45092 2.95549C4.32734 3.02642 4.18206 3.04966 4.04252 3.02083L2.91669 2.79916C2.80268 2.78305 2.68645 2.80104 2.58264 2.85087C2.47883 2.90069 2.3921 2.98013 2.33335 3.07916L1.16669 5.09749C1.1032 5.20287 1.07465 5.32563 1.08513 5.44821C1.0956 5.57079 1.14457 5.68692 1.22502 5.77999L1.96585 6.61999C2.05937 6.72645 2.11095 6.8633 2.11095 7.00499C2.11095 7.14669 2.05937 7.28354 1.96585 7.38999L1.22502 8.22999C1.14457 8.32307 1.0956 8.4392 1.08513 8.56178C1.07465 8.68436 1.1032 8.80712 1.16669 8.91249L2.33335 10.9308C2.39466 11.0373 2.48801 11.1216 2.60008 11.1719C2.71216 11.2222 2.83725 11.2358 2.95752 11.2108L4.05419 10.9892C4.19373 10.9603 4.339 10.9836 4.46259 11.0545C4.58617 11.1254 4.67952 11.2391 4.72502 11.3742L5.08085 12.4417C5.12144 12.5624 5.20044 12.6665 5.30577 12.7382C5.4111 12.8098 5.53698 12.845 5.66419 12.8383H7.99752C8.11981 12.8386 8.23911 12.8005 8.33855 12.7293C8.438 12.6582 8.51255 12.5575 8.55169 12.4417L8.90752 11.3742C8.95302 11.2391 9.04637 11.1254 9.16996 11.0545C9.29354 10.9836 9.43881 10.9603 9.57835 10.9892L10.675 11.2108C10.7953 11.2358 10.9204 11.2222 11.0325 11.1719C11.1445 11.1216 11.2379 11.0373 11.2992 10.9308L12.4659 8.91249C12.5278 8.80593 12.5544 8.68248 12.5418 8.55986C12.5292 8.43725 12.4781 8.32177 12.3959 8.22999L11.6084 7.38999ZM10.7392 8.17166L11.2059 8.69666L10.4592 9.99166L9.77085 9.85166C9.35073 9.76578 8.91369 9.83715 8.5427 10.0522C8.17172 10.2673 7.89261 10.6111 7.75835 11.0183L7.53669 11.6717H6.04335L5.83335 11.0067C5.6991 10.5994 5.41999 10.2556 5.04901 10.0405C4.67802 9.82548 4.24098 9.75412 3.82085 9.83999L3.13252 9.97999L2.37419 8.69083L2.84085 8.16583C3.12783 7.84498 3.28648 7.42962 3.28648 6.99916C3.28648 6.5687 3.12783 6.15334 2.84085 5.83249L2.37419 5.30749L3.12085 4.02416L3.80919 4.16416C4.22932 4.25004 4.66635 4.17867 5.03734 3.96361C5.40833 3.74855 5.68744 3.40475 5.82169 2.99749L6.04335 2.33833H7.53669L7.75835 3.00333C7.89261 3.41059 8.17172 3.75438 8.5427 3.96944C8.91369 4.18451 9.35073 4.25587 9.77085 4.16999L10.4592 4.02999L11.2059 5.32499L10.7392 5.84999C10.4554 6.1701 10.2988 6.58306 10.2988 7.01083C10.2988 7.4386 10.4554 7.85155 10.7392 8.17166ZM6.79002 4.67166C6.32853 4.67166 5.87741 4.80851 5.49369 5.0649C5.10998 5.32129 4.81091 5.68571 4.6343 6.11207C4.4577 6.53843 4.41149 7.00758 4.50152 7.46021C4.59155 7.91283 4.81378 8.32859 5.14011 8.65491C5.46643 8.98123 5.88219 9.20346 6.33481 9.29349C6.78743 9.38353 7.25659 9.33732 7.68295 9.16071C8.10931 8.98411 8.47373 8.68504 8.73012 8.30132C8.98651 7.91761 9.12335 7.46648 9.12335 7.00499C9.12335 6.38616 8.87752 5.79266 8.43994 5.35508C8.00235 4.91749 7.40886 4.67166 6.79002 4.67166ZM6.79002 8.17166C6.55928 8.17166 6.33371 8.10324 6.14186 7.97504C5.95 7.84685 5.80046 7.66464 5.71216 7.45146C5.62386 7.23828 5.60076 7.0037 5.64577 6.77739C5.69079 6.55108 5.8019 6.3432 5.96506 6.18004C6.12822 6.01688 6.3361 5.90576 6.56242 5.86074C6.78873 5.81573 7.0233 5.83883 7.23649 5.92713C7.44967 6.01544 7.63187 6.16497 7.76007 6.35683C7.88826 6.54869 7.95669 6.77425 7.95669 7.00499C7.95669 7.31441 7.83377 7.61116 7.61498 7.82995C7.39619 8.04874 7.09944 8.17166 6.79002 8.17166Z"
    })
  });
};

var Trash = function Trash(props) {
  var className = props.className;
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    width: "14",
    height: "15",
    viewBox: "0 0 14 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsx("g", {
      clipPath: "url(#clip0_3863_19293)",
      children: /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M1.75 3.50499H2.91667M2.91667 3.50499H12.25M2.91667 3.50499V11.6717C2.91667 11.9811 3.03958 12.2778 3.25838 12.4966C3.47717 12.7154 3.77391 12.8383 4.08333 12.8383H9.91667C10.2261 12.8383 10.5228 12.7154 10.7416 12.4966C10.9604 12.2778 11.0833 11.9811 11.0833 11.6717V3.50499H2.91667ZM4.66667 3.50499V2.33833C4.66667 2.02891 4.78958 1.73216 5.00838 1.51337C5.22717 1.29458 5.52391 1.17166 5.83333 1.17166H8.16667C8.47609 1.17166 8.77283 1.29458 8.99162 1.51337C9.21042 1.73216 9.33333 2.02891 9.33333 2.33833V3.50499M5.83333 6.42166V9.92166M8.16667 6.42166V9.92166",
        stroke: "#FF626A",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      })
    }), /*#__PURE__*/jsxRuntime.jsx("defs", {
      children: /*#__PURE__*/jsxRuntime.jsx("clipPath", {
        id: "clip0_3863_19293",
        children: /*#__PURE__*/jsxRuntime.jsx("rect", {
          width: "14",
          height: "14",
          fill: "white",
          transform: "translate(0 0.00500488)"
        })
      })
    })]
  });
};

var SearchIcon = function SearchIcon(_ref) {
  var className = _ref.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 17 16",
    fill: "#9B9BA3",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M14.4784 13.5267L12.0051 11.0733C12.9651 9.87629 13.4301 8.35688 13.3043 6.82755C13.1785 5.29821 12.4715 3.8752 11.3287 2.85111C10.186 1.82702 8.69427 1.27969 7.16035 1.32166C5.62642 1.36363 4.16688 1.99172 3.08182 3.07677C1.99677 4.16183 1.36868 5.62137 1.32671 7.15529C1.28474 8.68922 1.83207 10.1809 2.85616 11.3237C3.88025 12.4665 5.30326 13.1734 6.8326 13.2992C8.36193 13.425 9.88134 12.9601 11.0784 12L13.5317 14.4533C13.5937 14.5158 13.6674 14.5654 13.7487 14.5993C13.8299 14.6331 13.9171 14.6505 14.0051 14.6505C14.0931 14.6505 14.1802 14.6331 14.2614 14.5993C14.3427 14.5654 14.4164 14.5158 14.4784 14.4533C14.5986 14.329 14.6657 14.1629 14.6657 13.99C14.6657 13.8171 14.5986 13.651 14.4784 13.5267ZM7.3384 12C6.41542 12 5.51316 11.7263 4.74574 11.2135C3.97831 10.7008 3.38017 9.97192 3.02696 9.1192C2.67375 8.26648 2.58133 7.32817 2.7614 6.42292C2.94146 5.51768 3.38592 4.68616 4.03857 4.03351C4.69121 3.38087 5.52273 2.93641 6.42798 2.75635C7.33322 2.57628 8.27153 2.6687 9.12425 3.02191C9.97698 3.37512 10.7058 3.97326 11.2186 4.74068C11.7314 5.50811 12.0051 6.41037 12.0051 7.33335C12.0051 8.57102 11.5134 9.75801 10.6382 10.6332C9.76306 11.5083 8.57607 12 7.3384 12Z"
    })
  });
};

var Close = function Close(_ref) {
  var className = _ref.className;
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 14 15",
    fill: "#333333",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M11.0834 3.74416L10.2609 2.92166L7.00002 6.18249L3.73919 2.92166L2.91669 3.74416L6.17752 7.00499L2.91669 10.2658L3.73919 11.0883L7.00002 7.82749L10.2609 11.0883L11.0834 10.2658L7.82252 7.00499L11.0834 3.74416Z"
    })
  });
};

var css$12 = ".Sort_module_root__5112e35d.Sort_module_orderAz__5112e35d {\n  transform: none;\n}\n.Sort_module_root__5112e35d.Sort_module_orderZa__5112e35d {\n  transform: rotate(180deg);\n}";
var modules_501919d9 = {"root":"Sort_module_root__5112e35d","order-az":"Sort_module_orderAz__5112e35d","order-za":"Sort_module_orderZa__5112e35d"};
n(css$12,{});

var Sort = function Sort(_ref) {
  var className = _ref.className,
    position = _ref.position;
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: classes(modules_501919d9.root, className, modules_501919d9["order-".concat(position)]),
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 16 16",
    fill: "#737373",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M4 5.33333C4 4.96514 4.29848 4.66666 4.66667 4.66666H11.3333C11.7015 4.66666 12 4.96514 12 5.33333C12 5.70152 11.7015 6 11.3333 6H4.66667C4.29848 6 4 5.70152 4 5.33333Z"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M5.33333 8C5.33333 7.63181 5.63181 7.33333 6 7.33333H10C10.3682 7.33333 10.6667 7.63181 10.6667 8C10.6667 8.36819 10.3682 8.66666 10 8.66666H6C5.63181 8.66666 5.33333 8.36819 5.33333 8Z"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M7.33333 10C6.96514 10 6.66667 10.2985 6.66667 10.6667C6.66667 11.0349 6.96514 11.3333 7.33333 11.3333H8.66667C9.03486 11.3333 9.33333 11.0349 9.33333 10.6667C9.33333 10.2985 9.03486 10 8.66667 10H7.33333Z"
    })]
  });
};
Sort.defaultProps = {
  position: 'az'
};

var Azure = function Azure(_ref) {
  var className = _ref.className,
    _ref$circular = _ref.circular,
    circular = _ref$circular === void 0 ? false : _ref$circular;
  if (circular) {
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      width: "1.5rem",
      height: "1.5rem",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        width: "24",
        height: "24",
        rx: "12",
        fill: "#D6EDFF"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M12.6955 6L8.27266 9.84464L4.5 16.6353H7.90223L12.6955 6ZM13.2837 6.89941L11.3964 12.2324L15.0148 16.7906L7.99414 18H19.5L13.2837 6.89941Z",
        fill: "#0072C6"
      })]
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsx("g", {
      clipPath: "url(#clip0_848_49288)",
      children: /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M12.7603 5.49121L7.92669 9.66196L3.80371 17.0286H7.52186L12.7603 5.49121ZM13.4031 6.46691L11.3405 12.2523L15.2949 17.1971L7.62231 18.5091H20.1966L13.4031 6.46691Z",
        fill: "#0072C6"
      })
    }), /*#__PURE__*/jsxRuntime.jsx("defs", {
      children: /*#__PURE__*/jsxRuntime.jsx("clipPath", {
        id: "clip0_848_49288",
        children: /*#__PURE__*/jsxRuntime.jsx("rect", {
          width: "16.3929",
          height: "13.0179",
          fill: "white",
          transform: "translate(3.80371 5.49097)"
        })
      })
    })]
  });
};
var DigitalOcean = function DigitalOcean(_ref2) {
  var className = _ref2.className,
    _ref2$circular = _ref2.circular,
    circular = _ref2$circular === void 0 ? false : _ref2$circular;
  if (circular) {
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      width: "1.5rem",
      height: "1.5rem",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        width: "24",
        height: "24",
        rx: "12",
        fill: "#D9ECFF"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M12.0007 18.8384V16.1864C14.685 16.1864 16.7687 13.4025 15.738 10.448C15.3598 9.36238 14.5219 8.48612 13.4763 8.09064C10.6511 7.02052 7.98905 9.19178 7.98905 11.9989H5.46045C5.46045 7.52456 9.59816 4.03503 14.0844 5.50063C16.042 6.14426 17.6066 7.77271 18.2147 9.8199C19.6162 14.5114 16.2793 18.8384 12.0007 18.8384Z",
        fill: "#0080FF"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M12.0081 16.2017H9.47949V13.5574H12.0081V16.2017Z",
        fill: "#0080FF"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M9.47933 18.2256H7.54395V16.2017H9.47933V18.2256Z",
        fill: "#0080FF"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M7.54386 16.2017H5.91992V14.5034H7.54386V16.2017Z",
        fill: "#0080FF"
      })]
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 28 28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M13.7367 21.9525V18.7558C17.1203 18.7558 19.7468 15.4003 18.4475 11.8391C17.9709 10.5305 16.9146 9.4743 15.5967 8.99761C12.0355 7.70773 8.67999 10.3249 8.67999 13.7085H5.49268C5.49268 8.31528 10.7083 4.10915 16.3632 5.87572C18.8308 6.65152 20.803 8.61438 21.5694 11.082C23.336 16.7369 19.1299 21.9525 13.7367 21.9525Z",
      fill: "#0080FF"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M13.7459 18.7742H10.5586V15.5869H13.7459V18.7742Z",
      fill: "#0080FF"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M10.5587 21.2137H8.11914V18.7742H10.5587V21.2137Z",
      fill: "#0080FF"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M8.11925 18.7745H6.07227V16.7275H8.11925V18.7745Z",
      fill: "#0080FF"
    })]
  });
};
var Oracle$1 = function Oracle(_ref3) {
  var className = _ref3.className,
    _ref3$circular = _ref3.circular,
    circular = _ref3$circular === void 0 ? false : _ref3$circular;
  if (circular) {
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      width: "1.5rem",
      height: "1.5rem",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        width: "24",
        height: "24",
        rx: "12",
        fill: "#FFDAD5"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M9.04459 17C6.24204 17 4 14.7778 4 12C4 9.22222 6.24204 7 9.04459 7H14.9554C17.758 7 20 9.22222 20 12C20 14.7778 17.758 17 14.9554 17H9.04459ZM14.8025 15.2323C16.6369 15.2323 18.0637 13.7677 18.0637 12C18.0637 10.1818 16.586 8.76768 14.8025 8.76768H9.19745C7.36306 8.76768 5.93631 10.2323 5.93631 12C5.93631 13.7677 7.41401 15.2323 9.19745 15.2323H14.8025Z",
        fill: "#C74634"
      })]
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 28 28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsx("g", {
      clipPath: "url(#clip0_848_49303)",
      children: /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M10.3239 19.9035C7.00921 19.9035 4.35742 17.2517 4.35742 13.937C4.35742 10.6222 7.00921 7.97046 10.3239 7.97046H17.315C20.6297 7.97046 23.2815 10.6222 23.2815 13.937C23.2815 17.2517 20.6297 19.9035 17.315 19.9035H10.3239ZM17.1342 17.7941C19.3039 17.7941 20.9914 16.0463 20.9914 13.937C20.9914 11.7673 19.2436 10.0798 17.1342 10.0798H10.5047C8.3351 10.0798 6.6476 11.8276 6.6476 13.937C6.6476 16.0463 8.39537 17.7941 10.5047 17.7941H17.1342Z",
        fill: "#C74634"
      })
    }), /*#__PURE__*/jsxRuntime.jsx("defs", {
      children: /*#__PURE__*/jsxRuntime.jsx("clipPath", {
        id: "clip0_848_49303",
        children: /*#__PURE__*/jsxRuntime.jsx("rect", {
          width: "19.2857",
          height: "15.067",
          fill: "white",
          transform: "translate(4.35742 6.7146)"
        })
      })
    })]
  });
};
var AWS = function AWS(_ref4) {
  var className = _ref4.className,
    _ref4$circular = _ref4.circular,
    circular = _ref4$circular === void 0 ? false : _ref4$circular;
  if (circular) {
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      width: "1.5rem",
      height: "1.5rem",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        width: "24",
        height: "24",
        rx: "12",
        fill: "#FFEFD8"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M8.50897 10.3584C8.50484 10.559 8.52457 10.7592 8.56749 10.9524C8.61478 11.1177 8.67171 11.2784 8.73783 11.4331C8.76151 11.4789 8.77442 11.5321 8.77509 11.5867C8.77509 11.6534 8.74315 11.7202 8.67398 11.7869L8.33875 12.0672C8.2983 12.1037 8.25021 12.1246 8.20041 12.1273C8.1398 12.122 8.0829 12.0887 8.04077 12.0338C7.96905 11.9372 7.90488 11.8321 7.84914 11.7201C7.79594 11.6067 7.74268 11.4798 7.68419 11.3264C7.26912 11.9403 6.74762 12.2472 6.11967 12.2472C5.67253 12.2472 5.31615 12.087 5.05541 11.7665C4.79467 11.4461 4.66162 11.0192 4.66162 10.4852C4.66162 9.91795 4.82125 9.45743 5.14587 9.11038C5.47049 8.76332 5.90148 8.58977 6.44958 8.58977C6.63835 8.59171 6.8268 8.60955 7.01365 8.64318C7.21055 8.67657 7.41277 8.72994 7.6256 8.79003V8.3028C7.6256 7.7954 7.54043 7.44186 7.37551 7.23493C7.20517 7.02804 6.91787 6.92793 6.50811 6.92793C6.31446 6.92792 6.12151 6.95705 5.93339 7.01469C5.73777 7.07314 5.54572 7.14897 5.35868 7.24161C5.29816 7.27557 5.23595 7.30455 5.17243 7.32836C5.14487 7.33976 5.11623 7.34649 5.08726 7.34839C5.01277 7.34839 4.9755 7.28167 4.9755 7.1415V6.81447C4.9755 6.70765 4.98615 6.62754 5.01277 6.58088C5.05292 6.52004 5.104 6.47201 5.16181 6.44071C5.37525 6.30826 5.60027 6.20747 5.83231 6.14039C6.10347 6.05313 6.38252 6.0105 6.66245 6.01358C7.29581 6.01358 7.75865 6.19376 8.05665 6.55417C8.34933 6.91458 8.49832 7.46185 8.49832 8.19602V10.3584H8.50897ZM6.34851 11.3729C6.53519 11.3703 6.72029 11.3298 6.89661 11.2528C7.09192 11.168 7.26618 11.0207 7.40212 10.8255C7.4879 10.7025 7.54982 10.5562 7.58305 10.3982C7.61961 10.2081 7.63747 10.0131 7.63625 9.81754V9.53751C7.4749 9.48825 7.31149 9.45037 7.14676 9.42405C6.98083 9.39769 6.81374 9.38437 6.64648 9.38418C6.28995 9.38418 6.02921 9.47094 5.85361 9.65124C5.678 9.83154 5.59286 10.085 5.59286 10.4188C5.59286 10.7324 5.65674 10.966 5.78976 11.1262C5.91751 11.2931 6.10373 11.3732 6.34851 11.3732V11.3729ZM10.6216 12.0937C10.5258 12.0937 10.4619 12.0737 10.4193 12.027C10.3767 11.9869 10.3395 11.8935 10.3076 11.7667L9.05701 6.60758C9.03276 6.52122 9.0167 6.43159 9.00913 6.34053C9.00913 6.23371 9.05171 6.17366 9.13688 6.17366H9.65837C9.75948 6.17366 9.82871 6.19369 9.86591 6.24038C9.90849 6.28044 9.9404 6.37391 9.97237 6.50068L10.8664 10.9189L11.6965 6.5008C11.7231 6.36727 11.755 6.28056 11.7976 6.2405C11.8402 6.20044 11.9146 6.17377 12.0105 6.17377H12.4363C12.5375 6.17377 12.6067 6.1938 12.6493 6.2405C12.6919 6.28056 12.7291 6.37402 12.7504 6.5008L13.5912 10.9725L14.5115 6.5008C14.5434 6.36727 14.5806 6.28056 14.6179 6.2405C14.6605 6.20044 14.7297 6.17377 14.8255 6.17377H15.3204C15.4055 6.17377 15.4534 6.22718 15.4534 6.34064C15.4522 6.37655 15.4486 6.41228 15.4428 6.44746C15.4344 6.5044 15.4219 6.56025 15.4055 6.61434L14.123 11.7734C14.0911 11.9069 14.0539 11.9937 14.0113 12.0337C13.9511 12.082 13.8804 12.1054 13.8091 12.1005H13.3514C13.2503 12.1005 13.1811 12.0804 13.1385 12.0337C13.0959 11.987 13.0587 11.9002 13.0374 11.7667L12.2126 7.46185L11.3931 11.76C11.3665 11.8935 11.3346 11.9803 11.292 12.0271C11.2494 12.0739 11.1749 12.0938 11.0791 12.0938L10.6216 12.0937ZM17.4595 12.2739C17.1835 12.2743 16.9085 12.2339 16.64 12.1538C16.3739 12.0736 16.1664 11.9869 16.0281 11.8867C15.9429 11.8267 15.8844 11.7599 15.8631 11.6998C15.8424 11.6409 15.8315 11.5772 15.8312 11.5128V11.1727C15.8312 11.0325 15.8737 10.9658 15.9536 10.9658C15.9861 10.9659 16.0185 10.9727 16.0493 10.9858C16.0813 10.9992 16.1292 11.0259 16.1824 11.0525C16.3704 11.1562 16.5666 11.2345 16.7678 11.2861C16.9762 11.3392 17.1883 11.3661 17.401 11.3663C17.7362 11.3663 17.997 11.2929 18.1779 11.146C18.2646 11.0804 18.3359 10.9872 18.3845 10.8758C18.4331 10.7645 18.4574 10.6389 18.4547 10.512C18.4566 10.4261 18.4449 10.3405 18.4202 10.2603C18.3956 10.1802 18.3585 10.1069 18.3111 10.0448C18.2153 9.91799 18.0343 9.80445 17.7736 9.69763L17.0019 9.39735C16.6134 9.24387 16.326 9.01695 16.1505 8.71655C15.9791 8.43956 15.8856 8.09934 15.8844 7.74878C15.8801 7.49036 15.9296 7.235 16.0281 7.00793C16.1231 6.79322 16.2538 6.60659 16.4113 6.46066C16.5772 6.30318 16.7648 6.18548 16.9647 6.11349C17.1826 6.03485 17.4084 5.99669 17.6351 6.00022C17.7543 5.99914 17.8734 6.00806 17.9916 6.02693C18.114 6.04696 18.2258 6.07366 18.3375 6.10033C18.444 6.13371 18.545 6.16706 18.6408 6.20715C18.7185 6.23728 18.7934 6.27755 18.8643 6.32729C18.927 6.36692 18.9816 6.424 19.024 6.49416C19.0586 6.55911 19.0754 6.63642 19.0719 6.7144V7.02808C19.0719 7.16824 19.0293 7.24172 18.9495 7.24172C18.9069 7.24172 18.8377 7.21502 18.7472 7.16161C18.4439 6.98807 18.1033 6.9013 17.7255 6.9013C17.4222 6.9013 17.1828 6.96135 17.0178 7.08824C16.8528 7.21513 16.7677 7.40871 16.7677 7.68225C16.7662 7.77087 16.7797 7.85888 16.8072 7.94054C16.8347 8.02219 16.8757 8.09565 16.9273 8.15612C17.0338 8.28293 17.2307 8.40974 17.5127 8.5232L18.2683 8.82337C18.6516 8.97689 18.9282 9.19045 19.0931 9.46407C19.2556 9.73255 19.3417 10.0615 19.3379 10.3985C19.3407 10.6665 19.2933 10.9317 19.1996 11.1726C19.1052 11.4011 18.9727 11.6014 18.8111 11.76C18.6354 11.9315 18.4348 12.0585 18.2204 12.1339C17.9739 12.2289 17.7173 12.2762 17.4595 12.274L17.4595 12.2739Z",
        fill: "#252F3E"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M18.4651 15.5173C16.7144 17.1391 14.1708 18.0001 11.9837 18.0001C8.91858 18.0002 6.15678 16.5786 4.07088 14.216C3.90592 14.029 4.05491 13.7755 4.25181 13.9222C6.50805 15.5641 9.29113 16.5584 12.17 16.5584C14.1123 16.5584 16.2461 16.051 18.2097 15.01C18.5024 14.8431 18.7525 15.2504 18.4652 15.5174L18.4651 15.5173Z",
        fill: "#FF9900"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M19.1941 14.4764C18.9706 14.116 17.7148 14.3029 17.1454 14.3896C16.975 14.4163 16.9485 14.2294 17.1028 14.0893C18.1032 13.2083 19.7475 13.4619 19.9391 13.7556C20.1307 14.0559 19.8859 16.1182 18.9493 17.106C18.8057 17.2596 18.6673 17.1794 18.7311 16.9792C18.944 16.3185 19.4176 14.8301 19.1941 14.4764Z",
        fill: "#FF9900"
      })]
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 28 28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M9.7913 12.4941C9.78633 12.6869 9.8101 12.8793 9.86185 13.065C9.91884 13.2238 9.98747 13.3782 10.0672 13.527C10.0957 13.571 10.1113 13.6221 10.1121 13.6745C10.1121 13.7386 10.0736 13.8028 9.99021 13.8669L9.58612 14.1363C9.53737 14.1715 9.4794 14.1915 9.41937 14.1941C9.34631 14.189 9.27773 14.157 9.22695 14.1043C9.1405 14.0114 9.06315 13.9104 8.99597 13.8028C8.93184 13.6938 8.86764 13.5718 8.79713 13.4243C8.29683 14.0144 7.66822 14.3094 6.91131 14.3094C6.37233 14.3094 5.94277 14.1554 5.62847 13.8474C5.31418 13.5394 5.15381 13.1291 5.15381 12.616C5.15381 12.0708 5.34623 11.6282 5.73751 11.2947C6.1288 10.9611 6.64831 10.7943 7.30897 10.7943C7.53651 10.7962 7.76366 10.8133 7.98889 10.8457C8.22622 10.8778 8.46997 10.929 8.72651 10.9868V10.5185C8.72651 10.0309 8.62385 9.69113 8.42506 9.49226C8.21973 9.29342 7.87343 9.19722 7.37952 9.19722C7.1461 9.19721 6.91352 9.2252 6.68677 9.28059C6.45098 9.33677 6.21948 9.40965 5.99402 9.49867C5.92108 9.53131 5.84609 9.55916 5.76952 9.58205C5.73631 9.593 5.70179 9.59947 5.66686 9.6013C5.57707 9.6013 5.53215 9.53717 5.53215 9.40247V9.08817C5.53215 8.98551 5.54499 8.90852 5.57707 8.86368C5.62547 8.80521 5.68704 8.75904 5.75673 8.72897C6.014 8.60168 6.28523 8.50481 6.56493 8.44034C6.89177 8.35648 7.22814 8.31551 7.56556 8.31847C8.32899 8.31847 8.88689 8.49164 9.24609 8.83801C9.59888 9.18438 9.77847 9.71034 9.77847 10.4159V12.4941H9.7913ZM7.18714 13.4691C7.41216 13.4666 7.63528 13.4276 7.8478 13.3536C8.08323 13.2722 8.29328 13.1306 8.45714 12.943C8.56053 12.8247 8.63517 12.6842 8.67522 12.5323C8.71929 12.3496 8.74083 12.1622 8.73935 11.9743V11.7052C8.54487 11.6578 8.34789 11.6214 8.14934 11.5961C7.94932 11.5708 7.74792 11.558 7.54631 11.5578C7.11656 11.5578 6.80226 11.6412 6.5906 11.8145C6.37893 11.9877 6.27631 12.2314 6.27631 12.5521C6.27631 12.8535 6.3533 13.078 6.51364 13.232C6.66763 13.3924 6.89209 13.4693 7.18714 13.4693V13.4691ZM12.3378 14.1618C12.2223 14.1618 12.1453 14.1426 12.094 14.0977C12.0427 14.0592 11.9978 13.9694 11.9593 13.8475L10.4519 8.88934C10.4227 8.80634 10.4033 8.7202 10.3942 8.63269C10.3942 8.53002 10.4455 8.47231 10.5482 8.47231H11.1768C11.2986 8.47231 11.3821 8.49156 11.4269 8.53644C11.4783 8.57494 11.5167 8.66477 11.5553 8.78661L12.6328 13.0328L13.6334 8.78672C13.6655 8.65839 13.704 8.57505 13.7553 8.53655C13.8066 8.49805 13.8964 8.47242 14.012 8.47242H14.5253C14.6471 8.47242 14.7306 8.49167 14.7819 8.53655C14.8332 8.57505 14.8781 8.66488 14.9038 8.78672L15.9172 13.0842L17.0265 8.78672C17.065 8.65839 17.1099 8.57505 17.1549 8.53655C17.2062 8.49805 17.2896 8.47242 17.405 8.47242H18.0016C18.1042 8.47242 18.1619 8.52376 18.1619 8.6328C18.1604 8.66731 18.1562 8.70164 18.1491 8.73546C18.1391 8.79017 18.124 8.84385 18.1042 8.89583L16.5584 13.854C16.5199 13.9823 16.475 14.0657 16.4237 14.1042C16.3512 14.1506 16.2659 14.173 16.1799 14.1683H15.6283C15.5064 14.1683 15.4229 14.1491 15.3716 14.1042C15.3203 14.0593 15.2754 13.9759 15.2497 13.8475L14.2556 9.71034L13.2678 13.8411C13.2357 13.9694 13.1972 14.0528 13.1459 14.0978C13.0946 14.1428 13.0048 14.1619 12.8892 14.1619L12.3378 14.1618ZM20.58 14.335C20.2474 14.3353 19.9158 14.2966 19.5922 14.2195C19.2715 14.1425 19.0214 14.0592 18.8546 13.9629C18.752 13.9052 18.6815 13.841 18.6558 13.7832C18.6308 13.7266 18.6177 13.6655 18.6173 13.6036V13.2767C18.6173 13.142 18.6686 13.0778 18.7648 13.0778C18.8041 13.078 18.8431 13.0845 18.8803 13.0971C18.9188 13.1099 18.9765 13.1356 19.0407 13.1612C19.2672 13.2609 19.5037 13.3361 19.7462 13.3857C19.9975 13.4367 20.2532 13.4625 20.5095 13.4627C20.9136 13.4627 21.2279 13.3922 21.446 13.251C21.5505 13.188 21.6364 13.0984 21.695 12.9914C21.7536 12.8843 21.7828 12.7637 21.7797 12.6417C21.7819 12.5591 21.7678 12.4769 21.7381 12.3999C21.7083 12.3228 21.6636 12.2524 21.6065 12.1927C21.4911 12.0708 21.2729 11.9617 20.9587 11.8591L20.0284 11.5705C19.5602 11.423 19.2138 11.2049 19.0022 10.9162C18.7957 10.65 18.6829 10.323 18.6815 9.9861C18.6762 9.73774 18.7359 9.49232 18.8546 9.2741C18.9692 9.06774 19.1267 8.88839 19.3166 8.74814C19.5165 8.5968 19.7427 8.48368 19.9837 8.41449C20.2463 8.33892 20.5185 8.30224 20.7917 8.30564C20.9354 8.30459 21.0789 8.31317 21.2215 8.3313C21.369 8.35055 21.5038 8.37622 21.6384 8.40184C21.7667 8.43393 21.8885 8.46597 22.004 8.50451C22.0976 8.53346 22.1879 8.57216 22.2734 8.61996C22.3489 8.65805 22.4148 8.71291 22.4658 8.78034C22.5075 8.84275 22.5278 8.91705 22.5235 8.992V9.29346C22.5235 9.42817 22.4722 9.49878 22.376 9.49878C22.3247 9.49878 22.2413 9.47312 22.1322 9.42179C21.7666 9.25501 21.3561 9.17162 20.9007 9.17162C20.5351 9.17162 20.2465 9.22933 20.0476 9.35128C19.8488 9.47323 19.7462 9.65927 19.7462 9.92215C19.7444 10.0073 19.7606 10.0919 19.7938 10.1704C19.827 10.2489 19.8763 10.3195 19.9386 10.3776C20.0669 10.4994 20.3042 10.6213 20.6442 10.7304L21.555 11.0188C22.017 11.1664 22.3504 11.3716 22.5492 11.6346C22.745 11.8926 22.8488 12.2087 22.8442 12.5326C22.8476 12.7902 22.7904 13.045 22.6775 13.2766C22.5637 13.4962 22.404 13.6887 22.2092 13.8411C21.9975 14.0059 21.7556 14.128 21.4972 14.2004C21.2001 14.2918 20.8908 14.3372 20.58 14.3351L20.58 14.335Z",
      fill: "#252F3E"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M21.7928 17.452C19.6825 19.0107 16.6165 19.8381 13.9803 19.8381C10.2857 19.8382 6.95667 18.472 4.44237 16.2014C4.24354 16.0217 4.42312 15.778 4.66045 15.9191C7.38007 17.497 10.7347 18.4526 14.2048 18.4526C16.546 18.4526 19.1181 17.965 21.485 16.9645C21.8377 16.8041 22.1392 17.1955 21.7929 17.4521L21.7928 17.452Z",
      fill: "#FF9900"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M22.6719 16.4516C22.4025 16.1052 20.8887 16.2848 20.2024 16.3682C19.9971 16.3938 19.9651 16.2142 20.1511 16.0796C21.3569 15.2329 23.3389 15.4766 23.5698 15.7588C23.8008 16.0475 23.5057 18.0295 22.3768 18.9788C22.2036 19.1263 22.0368 19.0493 22.1138 18.8569C22.3704 18.2219 22.9413 16.7915 22.6719 16.4516Z",
      fill: "#FF9900"
    })]
  });
};
var GCP = function GCP(_ref5) {
  var className = _ref5.className,
    _ref5$circular = _ref5.circular,
    circular = _ref5$circular === void 0 ? false : _ref5$circular;
  if (circular) {
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      width: "1.5rem",
      height: "1.5rem",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        width: "24",
        height: "24",
        rx: "12",
        fill: "#CAFFD8"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M14.3104 9.31285L15.5273 8.01524L15.6082 7.46916C13.3908 5.31898 9.86583 5.56301 7.86639 7.97781C7.3076 8.66208 6.90183 9.47272 6.67969 10.3486L7.11534 10.2828L9.54925 9.85563L9.73683 9.65085C10.2574 9.03715 10.9779 8.65823 11.7515 8.59135C12.525 8.52446 13.2934 8.77465 13.8999 9.29089L14.3104 9.31285Z",
        fill: "#EA4335"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M17.2611 10.3099C16.9814 9.21152 16.407 8.22406 15.6084 7.46875L13.9003 9.29003C14.2562 9.60011 14.5415 9.99231 14.7345 10.4371C14.9276 10.8818 15.0234 11.3675 15.0148 11.8575V12.1806C15.4157 12.1806 15.8002 12.3504 16.0836 12.6527C16.3671 12.9549 16.5264 13.3649 16.5264 13.7923C16.5264 14.2198 16.3671 14.6297 16.0836 14.932C15.8002 15.2342 15.4157 15.404 15.0148 15.404H11.9706L11.6719 15.7501V17.6945L11.9706 17.9998H15.0149C15.8629 18.0094 16.6912 17.7272 17.3769 17.1951C18.0626 16.663 18.5691 15.9093 18.8213 15.046C19.0735 14.1826 19.058 13.2556 18.7769 12.4025C18.4959 11.5493 17.9643 10.8155 17.2612 10.3099",
        fill: "#4285F4"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M8.93042 17.9995H11.9714V15.4044H8.93042C8.71526 15.4043 8.50266 15.3547 8.30709 15.259L7.8757 15.3999L6.65016 16.6974L6.54346 17.1389C7.22953 17.6962 8.06794 17.9985 8.93042 17.9995Z",
        fill: "#34A853"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M8.93042 9.58206C8.10662 9.5874 7.30496 9.86693 6.63738 10.3816C5.9698 10.8963 5.46965 11.6204 5.20676 12.4529C4.94387 13.2853 4.93137 14.1845 5.17101 15.0249C5.41066 15.8653 5.89047 16.6049 6.54345 17.1404L8.30719 15.2599C8.08307 15.1519 7.88687 14.9876 7.7354 14.781C7.58394 14.5745 7.48175 14.3318 7.43759 14.0738C7.39343 13.8159 7.40862 13.5504 7.48187 13.3001C7.55511 13.0497 7.68422 12.8221 7.85812 12.6367C8.03201 12.4513 8.2455 12.3136 8.48027 12.2355C8.71503 12.1574 8.96406 12.1412 9.20599 12.1883C9.44791 12.2354 9.67551 12.3444 9.86926 12.5059C10.063 12.6674 10.2171 12.8766 10.3184 13.1155L12.0821 11.235C11.7119 10.7189 11.2348 10.3012 10.688 10.0145C10.1413 9.72775 9.53973 9.57975 8.93042 9.58206Z",
        fill: "#FBBC05"
      })]
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 28 28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M17.1825 10.2428L18.8588 8.56628L18.9702 7.86076C15.9158 5.08279 11.0599 5.39807 8.30563 8.51792C7.53587 9.40199 6.97691 10.4493 6.6709 11.5809L7.27102 11.4959L10.6238 10.944L10.8822 10.6794C11.5994 9.88656 12.5919 9.39701 13.6575 9.3106C14.7231 9.22419 15.7815 9.54741 16.6171 10.2144L17.1825 10.2428Z",
      fill: "#EA4335"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M21.2473 11.5308C20.8619 10.1117 20.0707 8.83595 18.9706 7.86011L16.6176 10.2132C17.1079 10.6138 17.5009 11.1205 17.7668 11.6951C18.0327 12.2697 18.1647 12.8972 18.1528 13.5303V13.9477C18.7051 13.9477 19.2347 14.1671 19.6252 14.5576C20.0157 14.9481 20.2351 15.4777 20.2351 16.03C20.2351 16.5822 20.0157 17.1119 19.6252 17.5024C19.2347 17.8929 18.7051 18.1123 18.1528 18.1123H13.9594L13.5479 18.5594V21.0715L13.9594 21.466H18.153C19.3212 21.4783 20.4622 21.1137 21.4068 20.4263C22.3514 19.7388 23.0491 18.7651 23.3965 17.6497C23.744 16.5343 23.7225 15.3366 23.3353 14.2343C22.9482 13.1321 22.216 12.184 21.2474 11.5308",
      fill: "#4285F4"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M9.77106 21.4657H13.9601V18.1129H9.77106C9.47467 18.1127 9.1818 18.0486 8.91238 17.925L8.31813 18.107L6.62989 19.7834L6.48291 20.3538C7.42801 21.0738 8.58295 21.4643 9.77106 21.4657Z",
      fill: "#34A853"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M9.77125 10.5904C8.63644 10.5973 7.53211 10.9584 6.6125 11.6234C5.69288 12.2883 5.00389 13.2239 4.64175 14.2994C4.27961 15.3749 4.26239 16.5366 4.59251 17.6224C4.92263 18.7081 5.5836 19.6637 6.48311 20.3556L8.91273 17.926C8.604 17.7865 8.33371 17.5742 8.12507 17.3073C7.91642 17.0404 7.77564 16.7269 7.71481 16.3936C7.65398 16.0604 7.67491 15.7173 7.77581 15.3939C7.87671 15.0705 8.05457 14.7764 8.29411 14.5369C8.53366 14.2973 8.82775 14.1195 9.15115 14.0186C9.47454 13.9177 9.81759 13.8967 10.1509 13.9576C10.4841 14.0184 10.7977 14.1592 11.0645 14.3678C11.3314 14.5765 11.5437 14.8468 11.6832 15.1555L14.1128 12.7259C13.6029 12.0592 12.9456 11.5195 12.1924 11.1491C11.4393 10.7786 10.6106 10.5874 9.77125 10.5904Z",
      fill: "#FBBC05"
    })]
  });
};
var Clouds = {
  Azure: Azure,
  DigitalOcean: DigitalOcean,
  Oracle: Oracle$1,
  AWS: AWS,
  GCP: GCP
};

var Oracle = function Oracle(_ref) {
  var className = _ref.className,
    _ref$circular = _ref.circular,
    circular = _ref$circular === void 0 ? false : _ref$circular;
  if (circular) {
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      width: "1.5rem",
      height: "1.5rem",
      viewBox: "0 0 32 28",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        x: "4",
        y: "2",
        width: "24",
        height: "24",
        rx: "12",
        fill: "#FFD2CC"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M13.0446 19.091C10.242 19.091 8 16.8284 8 14.0001C8 11.1718 10.242 8.90918 13.0446 8.90918H18.9554C21.758 8.90918 24 11.1718 24 14.0001C24 16.8284 21.758 19.091 18.9554 19.091H13.0446ZM18.8025 17.2912C20.6369 17.2912 22.0637 15.7999 22.0637 14.0001C22.0637 12.1488 20.586 10.709 18.8025 10.709H13.1975C11.3631 10.709 9.93631 12.2003 9.93631 14.0001C9.93631 15.7999 11.414 17.2912 13.1975 17.2912H18.8025Z",
        fill: "#C74634"
      })]
    });
  }
  return /*#__PURE__*/jsxRuntime.jsx("svg", {
    className: className,
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M7.93631 18.8726C4.0828 18.8726 1 15.7898 1 11.9363C1 8.0828 4.0828 5 7.93631 5H16.0637C19.9172 5 23 8.0828 23 11.9363C23 15.7898 19.9172 18.8726 16.0637 18.8726H7.93631ZM15.8535 16.4204C18.3758 16.4204 20.3376 14.3885 20.3376 11.9363C20.3376 9.41401 18.3057 7.45223 15.8535 7.45223H8.1465C5.6242 7.45223 3.66242 9.48408 3.66242 11.9363C3.66242 14.3885 5.69427 16.4204 8.1465 16.4204H15.8535Z",
      fill: "#C74634"
    })
  });
};
var MySql = function MySql(_ref2) {
  var className = _ref2.className,
    _ref2$circular = _ref2.circular,
    circular = _ref2$circular === void 0 ? false : _ref2$circular;
  if (circular) {
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      width: "1.5rem",
      height: "1.5rem",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        width: "24",
        height: "24",
        rx: "12",
        fill: "#CAFDFD"
      }), /*#__PURE__*/jsxRuntime.jsxs("g", {
        clipPath: "url(#clip0_849_49428)",
        children: [/*#__PURE__*/jsxRuntime.jsx("path", {
          d: "M17.4784 15.5262C16.77 15.5083 16.2211 15.5803 15.7606 15.7781C15.6278 15.832 15.4153 15.8321 15.3976 16.003C15.4684 16.075 15.4773 16.1919 15.5393 16.2908C15.6456 16.4707 15.8314 16.7136 15.9997 16.8395C16.1856 16.9834 16.3716 17.1273 16.5663 17.2532C16.9117 17.4691 17.3013 17.595 17.6378 17.8109C17.8326 17.9368 18.0273 18.0988 18.2221 18.2337C18.3195 18.3055 18.3815 18.4226 18.5055 18.4675V18.4406C18.4435 18.3596 18.4257 18.2427 18.3638 18.1527C18.2754 18.0628 18.1867 17.9818 18.0981 17.8918C17.8414 17.5411 17.5227 17.2353 17.1773 16.9834C16.894 16.7855 16.2741 16.5157 16.1591 16.1829C16.1591 16.1829 16.1502 16.1739 16.1414 16.1649C16.3361 16.1469 16.5663 16.075 16.7523 16.021C17.0534 15.94 17.3278 15.958 17.6378 15.8771C17.7794 15.8411 17.9211 15.7961 18.0627 15.7511V15.6702C17.9034 15.5083 17.7883 15.2924 17.6201 15.1395C17.1685 14.7437 16.6726 14.3569 16.1591 14.0332C15.8846 13.8532 15.5304 13.7363 15.2382 13.5834C15.132 13.5294 14.9549 13.5025 14.8929 13.4125C14.7335 13.2146 14.6449 12.9538 14.5298 12.7199C14.2731 12.2252 14.0251 11.6765 13.8038 11.1549C13.6445 10.8041 13.5471 10.4532 13.3522 10.1295C12.4402 8.60037 11.4485 7.67392 9.92562 6.76541C9.59797 6.57655 9.20839 6.49559 8.79224 6.39669C8.57096 6.38764 8.34952 6.3697 8.12819 6.36066C7.9865 6.29769 7.84482 6.12682 7.72084 6.04586C7.21624 5.72201 5.91455 5.0205 5.54268 5.94696C5.30358 6.53157 5.89689 7.10719 6.10046 7.4041C6.25111 7.61095 6.44582 7.84479 6.55209 8.07868C6.61407 8.2315 6.63173 8.39353 6.69372 8.5554C6.83546 8.95105 6.96819 9.39189 7.1542 9.76072C7.25161 9.94957 7.35782 10.1474 7.4818 10.3183C7.55264 10.4172 7.67656 10.4623 7.70318 10.6241C7.57926 10.8041 7.57035 11.0739 7.49946 11.2988C7.18072 12.3152 7.30474 13.5744 7.75626 14.321C7.8979 14.5458 8.2344 15.0406 8.68597 14.8517C9.08446 14.6898 8.99591 14.1771 9.11093 13.7274C9.1376 13.6193 9.11989 13.5474 9.17297 13.4755V13.4935C9.29694 13.7453 9.42087 13.9882 9.53599 14.2401C9.8105 14.6807 10.2886 15.1395 10.687 15.4454C10.8996 15.6072 11.0678 15.8861 11.3335 15.985V15.958H11.3157C11.2626 15.877 11.1829 15.8411 11.1121 15.7781C10.9527 15.6162 10.7756 15.4183 10.6517 15.2384C10.2798 14.7347 9.95214 14.177 9.65996 13.6014C9.51833 13.3226 9.3943 13.0167 9.27923 12.7379C9.22605 12.6299 9.22605 12.4681 9.13755 12.4141C9.00472 12.612 8.80995 12.7829 8.71254 13.0257C8.54439 13.4125 8.52663 13.8892 8.46464 14.3839C8.42922 14.393 8.44688 14.3839 8.42917 14.402C8.1459 14.3299 8.04849 14.0332 7.94217 13.7813C7.67651 13.1427 7.63224 12.1173 7.86253 11.3797C7.92451 11.1908 8.19018 10.5972 8.08391 10.4173C8.03078 10.2464 7.85362 10.1474 7.75626 10.0125C7.64119 9.84163 7.51717 9.62583 7.43752 9.43687C7.22499 8.93316 7.11873 8.37548 6.88854 7.87178C6.78228 7.63789 6.59641 7.39511 6.44582 7.17921C6.27762 6.93638 6.09166 6.76541 5.95883 6.4776C5.9146 6.3787 5.85256 6.21678 5.92341 6.10883C5.94112 6.03686 5.97649 6.00993 6.04738 5.99194C6.1625 5.89293 6.49015 6.01887 6.60517 6.07284C6.93282 6.20768 7.20728 6.33372 7.4818 6.52258C7.60572 6.61253 7.73855 6.78345 7.8979 6.82843H8.08386C8.36723 6.89135 8.68592 6.84642 8.95158 6.92733C9.42092 7.08021 9.84587 7.3051 10.2267 7.54798C11.3866 8.29452 12.3428 9.35591 12.9892 10.6241C13.0955 10.8309 13.1397 11.02 13.2371 11.2358C13.4231 11.6765 13.6533 12.1263 13.8392 12.558C14.0251 12.9807 14.2022 13.4125 14.4679 13.7633C14.6007 13.9521 15.1319 14.0511 15.371 14.1501C15.5481 14.231 15.8226 14.303 15.982 14.4019C16.283 14.5907 16.584 14.8067 16.8674 15.0135C17.0091 15.1215 17.4518 15.3464 17.4784 15.5262Z",
          fill: "#00546B"
        }), /*#__PURE__*/jsxRuntime.jsx("path", {
          d: "M8.44646 7.70972C8.29597 7.70972 8.18976 7.72781 8.0835 7.75475V7.77274H8.10121C8.1721 7.91667 8.29597 8.01562 8.38448 8.14151C8.45537 8.28539 8.51731 8.42937 8.5882 8.5733C8.59701 8.56426 8.60586 8.55531 8.60586 8.55531C8.72989 8.4653 8.79182 8.32142 8.79182 8.10553C8.73869 8.04261 8.72984 7.97964 8.68556 7.91667C8.63248 7.82666 8.51731 7.78173 8.44646 7.70972Z",
          fill: "#00546B"
        })]
      }), /*#__PURE__*/jsxRuntime.jsx("defs", {
        children: /*#__PURE__*/jsxRuntime.jsx("clipPath", {
          id: "clip0_849_49428",
          children: /*#__PURE__*/jsxRuntime.jsx("rect", {
            width: "13.0286",
            height: "13.0286",
            fill: "white",
            transform: "translate(5.48584 5.4856)"
          })
        })
      })]
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsxs("g", {
      clipPath: "url(#clip0_849_49327)",
      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M20.4096 17.4133C19.3222 17.3857 18.4795 17.4962 17.7727 17.7999C17.5688 17.8827 17.2425 17.8828 17.2153 18.1451C17.3241 18.2556 17.3377 18.4351 17.4328 18.587C17.5961 18.8631 17.8814 19.2359 18.1396 19.4293C18.425 19.6502 18.7106 19.871 19.0095 20.0644C19.5396 20.3958 20.1378 20.589 20.6543 20.9205C20.9534 21.1136 21.2522 21.3624 21.5513 21.5694C21.7008 21.6797 21.7959 21.8594 21.9863 21.9284V21.887C21.891 21.7627 21.8639 21.5832 21.7688 21.4451C21.633 21.307 21.4969 21.1828 21.361 21.0447C20.9668 20.5063 20.4775 20.0368 19.9475 19.6502C19.5125 19.3464 18.561 18.9322 18.3843 18.4212C18.3843 18.4212 18.3707 18.4075 18.3571 18.3937C18.6561 18.3661 19.0095 18.2556 19.295 18.1728C19.7571 18.0484 20.1785 18.0761 20.6543 17.9518C20.8717 17.8966 21.0892 17.8275 21.3066 17.7585V17.6343C21.0621 17.3857 20.8853 17.0544 20.6271 16.8196C19.9339 16.2119 19.1726 15.6183 18.3843 15.1212C17.9629 14.8451 17.4192 14.6655 16.9707 14.4309C16.8077 14.3479 16.5357 14.3066 16.4407 14.1685C16.1959 13.8648 16.06 13.4644 15.8833 13.1053C15.4893 12.3458 15.1085 11.5036 14.7687 10.7029C14.5242 10.1643 14.3746 9.62575 14.0756 9.12878C12.6756 6.78146 11.1532 5.35927 8.81542 3.96463C8.31245 3.67471 7.71441 3.55043 7.07558 3.39861C6.73589 3.38472 6.39597 3.35718 6.0562 3.34329C5.8387 3.24663 5.6212 2.98433 5.43089 2.86005C4.65628 2.36292 2.65808 1.28604 2.08722 2.70823C1.72019 3.60567 2.63097 4.4893 2.94347 4.94508C3.17472 5.26261 3.47362 5.62157 3.63675 5.98061C3.73191 6.2152 3.75901 6.46393 3.85417 6.71241C4.07175 7.31978 4.2755 7.99651 4.56105 8.56268C4.71058 8.8526 4.87362 9.15632 5.06394 9.41869C5.17269 9.57052 5.36292 9.63964 5.40378 9.88813C5.21355 10.1643 5.19987 10.5786 5.09105 10.9237C4.60175 12.484 4.79214 14.4171 5.48526 15.5631C5.70269 15.9081 6.21925 16.6678 6.91245 16.3777C7.52417 16.1292 7.38823 15.3422 7.5648 14.6518C7.60573 14.4859 7.57855 14.3756 7.66003 14.2652V14.2929C7.85034 14.6794 8.04058 15.0523 8.2173 15.4389C8.6387 16.1153 9.37261 16.8196 9.98425 17.2891C10.3106 17.5375 10.5688 17.9656 10.9766 18.1175V18.076H10.9493C10.8678 17.9517 10.7454 17.8966 10.6367 17.7998C10.3921 17.5514 10.1202 17.2476 9.92995 16.9714C9.35917 16.1981 8.85612 15.3421 8.40761 14.4584C8.19019 14.0305 7.9998 13.561 7.82316 13.133C7.74151 12.9671 7.74152 12.7187 7.60566 12.6359C7.40175 12.9396 7.10277 13.202 6.95323 13.5748C6.69511 14.1685 6.66784 14.9003 6.57269 15.6596C6.51831 15.6736 6.54542 15.6596 6.51823 15.6874C6.08339 15.5768 5.93386 15.1212 5.77066 14.7346C5.36284 13.7543 5.29487 12.1802 5.64839 11.048C5.74355 10.758 6.15136 9.84678 5.98823 9.57059C5.90667 9.30822 5.63472 9.15632 5.48526 8.94926C5.30862 8.68689 5.11823 8.35563 4.99597 8.06555C4.66972 7.29232 4.50659 6.43623 4.15323 5.663C3.99011 5.30396 3.7048 4.93127 3.47362 4.59985C3.21542 4.22708 2.92995 3.96463 2.72605 3.52281C2.65816 3.37099 2.56292 3.12243 2.67167 2.95672C2.69886 2.84624 2.75315 2.80489 2.86198 2.77728C3.0387 2.6253 3.54167 2.81862 3.71823 2.90148C4.2212 3.10846 4.64253 3.30194 5.06394 3.59186C5.25417 3.72995 5.45808 3.99232 5.70269 4.06137H5.98816C6.42316 4.15795 6.91237 4.08899 7.32019 4.21319C8.04066 4.44787 8.693 4.7931 9.27753 5.16594C11.0582 6.31195 12.526 7.94127 13.5183 9.88813C13.6814 10.2056 13.7493 10.4957 13.8989 10.827C14.1844 11.5036 14.5378 12.194 14.8231 12.8568C15.1085 13.5057 15.3803 14.1685 15.7882 14.7071C15.9921 14.9969 16.8075 15.1489 17.1746 15.3008C17.4464 15.425 17.8678 15.5355 18.1125 15.6873C18.5746 15.9772 19.0367 16.3088 19.4717 16.6262C19.6892 16.7919 20.3687 17.1371 20.4096 17.4133Z",
        fill: "#00546B"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M6.54547 5.41406C6.31445 5.41406 6.15141 5.44184 5.98828 5.48319V5.51081H6.01547C6.1243 5.73175 6.31445 5.88365 6.45031 6.0769C6.55914 6.29777 6.65422 6.5188 6.76305 6.73974C6.77656 6.72585 6.79016 6.71212 6.79016 6.71212C6.98055 6.57395 7.07563 6.35309 7.07563 6.02167C6.99406 5.92508 6.98047 5.82842 6.9125 5.73175C6.83102 5.59358 6.65422 5.52462 6.54547 5.41406Z",
        fill: "#00546B"
      })]
    }), /*#__PURE__*/jsxRuntime.jsx("defs", {
      children: /*#__PURE__*/jsxRuntime.jsx("clipPath", {
        id: "clip0_849_49327",
        children: /*#__PURE__*/jsxRuntime.jsx("rect", {
          width: "20",
          height: "20",
          fill: "white",
          transform: "translate(2 2)"
        })
      })
    })]
  });
};
var PgSql = function PgSql(_ref3) {
  var className = _ref3.className,
    _ref3$circular = _ref3.circular,
    circular = _ref3$circular === void 0 ? false : _ref3$circular;
  if (circular) {
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      width: "1.5rem",
      height: "1.5rem",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        width: "24",
        height: "24",
        rx: "12",
        fill: "#D0E2FF"
      }), /*#__PURE__*/jsxRuntime.jsxs("g", {
        clipPath: "url(#clip0_849_49430)",
        children: [/*#__PURE__*/jsxRuntime.jsx("path", {
          d: "M17.761 13.1469C17.6913 12.9424 17.5089 12.8 17.273 12.7658C17.1618 12.7497 17.0344 12.7566 16.8837 12.7867C16.6209 12.8393 16.426 12.8593 16.2838 12.8632C16.8207 11.9842 17.2573 10.9818 17.5087 10.0382C17.9152 8.51243 17.698 7.81735 17.4441 7.50295C16.7725 6.67078 15.7925 6.22373 14.6102 6.21005C13.9796 6.20257 13.4259 6.32331 13.1371 6.41013C12.8682 6.36412 12.579 6.33844 12.2756 6.33369C11.7069 6.32489 11.2044 6.4451 10.7751 6.69215C10.5374 6.61422 10.1559 6.50434 9.71531 6.43423C8.67913 6.26929 7.844 6.39781 7.23314 6.81623C6.49345 7.32284 6.15055 8.20304 6.21397 9.43239C6.23411 9.8227 6.45929 11.0103 6.81385 12.1365C7.01762 12.7839 7.23491 13.3214 7.45968 13.7344C7.77845 14.3201 8.11953 14.665 8.50244 14.7888C8.71705 14.8581 9.10699 14.9067 9.51712 14.5755C9.5691 14.6366 9.63846 14.6972 9.7305 14.7536C9.8474 14.825 9.99034 14.8834 10.1331 14.9181C10.6476 15.0427 11.1295 15.0116 11.5406 14.8368C11.5431 14.9077 11.5451 14.9754 11.5467 15.0339C11.5494 15.1288 11.5521 15.2218 11.5557 15.3088C11.5801 15.897 11.6214 16.3544 11.7437 16.6745C11.7504 16.6921 11.7594 16.7189 11.7689 16.7473C11.8299 16.9285 11.932 17.2317 12.1915 17.4692C12.4603 17.7152 12.7854 17.7906 13.0832 17.7906C13.2325 17.7906 13.375 17.7716 13.5 17.7456C13.9454 17.6531 14.4514 17.512 14.8174 17.0068C15.1634 16.5291 15.3316 15.8097 15.362 14.6761C15.366 14.644 15.3696 14.6134 15.3731 14.5842L15.3804 14.5243L15.4619 14.5313L15.4829 14.5326C15.9366 14.5527 16.4914 14.4594 16.8321 14.3059C17.1013 14.1848 17.9641 13.7432 17.761 13.1469Z",
          fill: "black"
        }), /*#__PURE__*/jsxRuntime.jsx("path", {
          d: "M16.9853 13.263C15.6362 13.5328 15.5434 13.09 15.5434 13.09C16.9678 11.0406 17.5633 8.43927 17.0495 7.80261C15.6476 6.0659 13.2209 6.88726 13.1804 6.90855L13.1674 6.91083C12.9008 6.85717 12.6026 6.82524 12.2673 6.81992C11.6569 6.81024 11.1938 6.97509 10.8424 7.23346C10.8424 7.23346 6.51346 5.50427 6.71482 9.4082C6.75764 10.2387 7.94252 15.6923 9.35576 14.0451C9.87231 13.4427 10.3714 12.9334 10.3714 12.9334C10.6193 13.0931 10.9161 13.1745 11.2272 13.1453L11.2513 13.1254C11.2438 13.2002 11.2473 13.2733 11.261 13.3599C10.8969 13.7543 11.0039 13.8236 10.2761 13.9688C9.53966 14.116 9.97229 14.378 10.2548 14.4465C10.5972 14.5295 11.3894 14.6471 11.9247 13.9205L11.9034 14.0035C12.046 14.1143 12.1462 14.724 12.1294 15.2769C12.1126 15.8297 12.1014 16.2092 12.2138 16.5057C12.3262 16.8021 12.4382 17.4691 13.395 17.2704C14.1944 17.1042 14.6087 16.6738 14.6664 15.9557C14.7073 15.4452 14.7999 15.5207 14.8057 15.0643L14.8799 14.8482C14.9655 14.1562 14.8935 13.933 15.386 14.0368L15.5058 14.047C15.8682 14.063 16.3427 13.9904 16.6212 13.865C17.2208 13.5952 17.5765 13.1446 16.9852 13.263H16.9853Z",
          fill: "#336791"
        }), /*#__PURE__*/jsxRuntime.jsx("path", {
          d: "M11.0961 9.77897C10.9745 9.76256 10.8644 9.77774 10.8087 9.81864C10.7774 9.84165 10.7677 9.8683 10.7651 9.88664C10.7581 9.93524 10.7932 9.98899 10.8148 10.0167C10.8758 10.0952 10.965 10.1491 11.0533 10.161C11.0661 10.1627 11.0788 10.1635 11.0915 10.1635C11.2387 10.1635 11.3726 10.0524 11.3844 9.97034C11.3991 9.8676 11.2453 9.79911 11.0961 9.77901V9.77897ZM15.1236 9.78222C15.112 9.70169 14.9642 9.67873 14.8239 9.69764C14.6838 9.71656 14.548 9.77787 14.5594 9.85858C14.5684 9.92134 14.6853 10.0285 14.8237 10.0285C14.8354 10.0285 14.8472 10.0277 14.8591 10.0261C14.9514 10.0137 15.0192 9.95684 15.0514 9.92407C15.1004 9.87411 15.1288 9.81842 15.1236 9.78222Z",
          fill: "#D0E2FF"
        }), /*#__PURE__*/jsxRuntime.jsx("path", {
          d: "M17.4347 13.2321C17.3832 13.0812 17.2176 13.0327 16.9426 13.0878C16.1258 13.2512 15.8333 13.138 15.7373 13.0695C16.3721 12.1317 16.8944 10.9982 17.1761 9.94057C17.3096 9.4396 17.3833 8.97434 17.3893 8.59511C17.396 8.17889 17.3229 7.87302 17.1721 7.68618C16.5641 6.93296 15.6719 6.52892 14.5918 6.51784C13.8492 6.50974 13.2218 6.69399 13.1002 6.7458C12.8441 6.68405 12.5649 6.64614 12.2609 6.6413C11.7035 6.63255 11.2217 6.76195 10.8227 7.02572C10.6495 6.96317 10.2016 6.81411 9.65397 6.72856C8.70715 6.58078 7.95476 6.69276 7.41785 7.06157C6.77719 7.50167 6.48142 8.28836 6.53872 9.39975C6.55799 9.77365 6.77773 10.9239 7.12449 12.0255C7.58093 13.4754 8.07711 14.2962 8.59914 14.465C8.66025 14.4848 8.7307 14.4986 8.8084 14.4986C8.99884 14.4986 9.23232 14.4154 9.47524 14.1322C9.77153 13.7876 10.078 13.4513 10.3943 13.1238C10.5996 13.2306 10.825 13.2903 11.0556 13.2962C11.056 13.3021 11.0566 13.3079 11.0572 13.3137C11.0175 13.3596 10.9786 13.4062 10.9406 13.4534C10.7808 13.65 10.7476 13.691 10.2333 13.7936C10.087 13.8229 9.69847 13.9006 9.69275 14.1647C9.68658 14.4532 10.1521 14.5744 10.2051 14.5872C10.3899 14.6321 10.5679 14.6542 10.7377 14.6542C11.1507 14.6542 11.5141 14.5226 11.8045 14.268C11.7955 15.2966 11.8398 16.3101 11.9672 16.6189C12.0715 16.8718 12.3263 17.4896 13.1314 17.4896C13.2495 17.4896 13.3795 17.4762 13.5225 17.4465C14.3627 17.2719 14.7275 16.9118 14.8687 16.1181C14.9442 15.6938 15.0738 14.6808 15.1348 14.1375C15.2634 14.1764 15.429 14.1942 15.6081 14.1942C15.9815 14.1942 16.4124 14.1172 16.6826 13.9956C16.9862 13.8589 17.534 13.5235 17.4347 13.2321ZM15.4339 9.56029C15.4311 9.7207 15.4083 9.86633 15.3842 10.0183C15.3582 10.1818 15.3314 10.3509 15.3246 10.556C15.3179 10.7557 15.3437 10.9633 15.3685 11.1641C15.4188 11.5696 15.4704 11.9871 15.2707 12.3991C15.2375 12.3421 15.208 12.2832 15.1823 12.2228C15.1574 12.1644 15.1035 12.0708 15.0289 11.9411C14.7386 11.4363 14.0589 10.2543 14.4069 9.77198C14.5105 9.62842 14.7736 9.48081 15.4339 9.56029ZM14.6335 6.84266C15.6013 6.86337 16.3668 7.21441 16.9088 7.88595C17.3245 8.40105 16.8668 10.7448 15.5416 12.7668C15.5282 12.7504 15.5148 12.734 15.5014 12.7177L15.4846 12.6973C15.827 12.149 15.7601 11.6065 15.7005 11.1255C15.676 10.9281 15.6528 10.7416 15.6587 10.5665C15.6648 10.3809 15.6901 10.2216 15.7146 10.0677C15.7447 9.87798 15.7753 9.68168 15.7669 9.45028C15.7732 9.42601 15.7757 9.39733 15.7724 9.36328C15.7509 9.14139 15.4896 8.47727 14.957 7.87619C14.6657 7.54741 14.2409 7.17949 13.6608 6.93133C13.9103 6.88119 14.2515 6.83443 14.6335 6.84266ZM9.21817 13.9249C8.95052 14.237 8.76572 14.1771 8.70493 14.1575C8.30891 14.0294 7.84939 13.2179 7.44425 11.9309C7.09369 10.8173 6.88883 9.69752 6.87259 9.38352C6.82142 8.39045 7.06969 7.69836 7.61055 7.32644C8.49077 6.72122 9.93794 7.08347 10.5194 7.26719C10.5111 7.27519 10.5024 7.28267 10.4941 7.29081C9.53988 8.2252 9.56252 9.82164 9.56487 9.91924C9.56478 9.95689 9.56805 10.0102 9.57249 10.0835C9.58892 10.352 9.61949 10.8518 9.53784 11.4177C9.46199 11.9436 9.6292 12.4584 9.9965 12.83C10.0342 12.8681 10.0738 12.9043 10.1152 12.9386C9.95173 13.1083 9.5964 13.4838 9.21817 13.9249ZM10.2379 12.6057C9.94184 12.3062 9.80738 11.8896 9.86894 11.4626C9.95513 10.8648 9.92333 10.3441 9.90623 10.0643C9.90383 10.0252 9.90169 9.99089 9.90047 9.96384C10.0399 9.84398 10.6859 9.50839 11.1466 9.61074C11.3568 9.6574 11.4849 9.79622 11.5382 10.035C11.8138 11.271 11.5746 11.7862 11.3825 12.2002C11.3429 12.2855 11.3054 12.3662 11.2735 12.4495L11.2487 12.514C11.1861 12.677 11.1277 12.8286 11.0916 12.9725C10.7768 12.9716 10.4707 12.8413 10.2379 12.6057V12.6057ZM10.2862 14.2727C10.1943 14.2505 10.1116 14.2118 10.0631 14.1797C10.1036 14.1613 10.1757 14.1361 10.3008 14.1111C10.9058 13.9904 10.9992 13.9051 11.2032 13.654C11.25 13.5963 11.303 13.5311 11.3765 13.4515L11.3766 13.4515C11.4859 13.3327 11.536 13.3528 11.6267 13.3893C11.7002 13.4188 11.7719 13.5082 11.8009 13.6065C11.8146 13.653 11.8301 13.7411 11.7796 13.8097C11.3534 14.3884 10.7322 14.381 10.2862 14.2727ZM13.4525 17.1296C12.7123 17.2833 12.4503 16.9172 12.2776 16.4986C12.1661 16.2283 12.1113 15.0097 12.1502 13.6639C12.1507 13.646 12.1481 13.6288 12.143 13.6125C12.1384 13.5803 12.1315 13.5486 12.1223 13.5174C12.0645 13.3216 11.9237 13.1578 11.7547 13.0899C11.6875 13.0629 11.5643 13.0134 11.4163 13.0501C11.4478 12.924 11.5026 12.7815 11.562 12.6273L11.5869 12.5624C11.6149 12.4893 11.6501 12.4135 11.6873 12.3333C11.8884 11.9001 12.1638 11.3068 11.8649 9.96648C11.753 9.46445 11.3791 9.21928 10.8123 9.27624C10.4725 9.31033 10.1617 9.44325 10.0066 9.51947C9.97328 9.53583 9.94279 9.55167 9.9143 9.56706C9.95758 9.06125 10.1211 8.11595 10.7327 7.51785C11.1177 7.14135 11.6306 6.95539 12.2554 6.96542C13.4865 6.98495 14.276 7.59755 14.7216 8.10807C15.1055 8.54796 15.3134 8.99109 15.3964 9.2301C14.7724 9.16857 14.3481 9.28798 14.133 9.58619C13.665 10.2349 14.389 11.4939 14.737 12.0989C14.8008 12.2098 14.8559 12.3057 14.8732 12.3464C14.9865 12.6127 15.1332 12.7905 15.2403 12.9202C15.2732 12.96 15.305 12.9986 15.3292 13.0322C15.1402 13.0851 14.8008 13.2071 14.8317 13.8172C14.8068 14.1233 14.6294 15.5566 14.5392 16.063C14.4202 16.732 14.1663 16.9812 13.4525 17.1296V17.1296ZM16.5419 13.7016C16.3486 13.7886 16.0252 13.8538 15.718 13.8678C15.3787 13.8832 15.206 13.831 15.1653 13.7988C15.1463 13.4186 15.2922 13.3789 15.4467 13.3369C15.4709 13.3303 15.4946 13.3238 15.5175 13.3161C15.5317 13.3273 15.5472 13.3384 15.5643 13.3493C15.837 13.5238 16.3234 13.5427 17.0102 13.4052L17.0177 13.4038C16.9251 13.4877 16.7666 13.6004 16.5419 13.7016Z",
          fill: "#D0E2FF"
        })]
      }), /*#__PURE__*/jsxRuntime.jsx("defs", {
        children: /*#__PURE__*/jsxRuntime.jsx("clipPath", {
          id: "clip0_849_49430",
          children: /*#__PURE__*/jsxRuntime.jsx("rect", {
            width: "11.6129",
            height: "11.6129",
            fill: "white",
            transform: "translate(6.19336 6.1936)"
          })
        })
      })]
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsxs("g", {
      clipPath: "url(#clip0_849_49322)",
      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M21.7645 13.9443C21.6465 13.5977 21.3373 13.3564 20.9375 13.2984C20.749 13.2711 20.5331 13.2828 20.2776 13.3338C19.8322 13.4229 19.5018 13.4568 19.2607 13.4634C20.1708 11.9735 20.9109 10.2745 21.3369 8.67514C22.0258 6.08904 21.6577 4.91091 21.2275 4.37802C20.089 2.96752 18.428 2.20978 16.4241 2.1866C15.3552 2.17392 14.4167 2.37857 13.9272 2.52573C13.4714 2.44775 12.9813 2.40421 12.4671 2.39616C11.5031 2.38125 10.6514 2.585 9.92367 3.00375C9.52078 2.87165 8.87415 2.68542 8.1274 2.56658C6.37112 2.28702 4.9556 2.50485 3.92022 3.21406C2.66648 4.07274 2.08528 5.56465 2.19277 7.64835C2.2269 8.30992 2.60858 10.3228 3.20954 12.2317C3.55492 13.329 3.92322 14.2402 4.3042 14.9402C4.8445 15.9328 5.42262 16.5174 6.07164 16.7273C6.4354 16.8448 7.09633 16.9271 7.79148 16.3658C7.87959 16.4692 7.99716 16.572 8.15316 16.6675C8.3513 16.7887 8.59358 16.8877 8.83555 16.9464C9.70754 17.1577 10.5243 17.1049 11.2212 16.8086C11.2255 16.9288 11.2288 17.0436 11.2315 17.1427C11.2362 17.3035 11.2408 17.4612 11.2468 17.6087C11.2881 18.6057 11.3581 19.381 11.5654 19.9234C11.5768 19.9532 11.5921 19.9987 11.6082 20.0469C11.7116 20.3539 11.8846 20.8679 12.3245 21.2704C12.7801 21.6874 13.3311 21.8152 13.8358 21.8152C14.089 21.8152 14.3305 21.783 14.5423 21.739C15.2973 21.5821 16.1549 21.3431 16.7752 20.4866C17.3617 19.677 17.6468 18.4576 17.6984 16.5362C17.7051 16.4818 17.7112 16.4299 17.7172 16.3805L17.7295 16.279L17.8676 16.2908L17.9032 16.2931C18.6723 16.3271 19.6126 16.1689 20.1901 15.9088C20.6465 15.7035 22.1088 14.9549 21.7645 13.9443Z",
        fill: "black"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M20.4499 14.141C18.1633 14.5984 18.006 13.8477 18.006 13.8477C20.4203 10.3741 21.4296 5.96497 20.5587 4.88584C18.1826 1.94219 14.0694 3.33436 14.0007 3.37044L13.9787 3.37431C13.5269 3.28336 13.0213 3.22924 12.4531 3.22022C11.4184 3.20382 10.6336 3.48323 10.038 3.92115C10.038 3.92115 2.70051 0.990245 3.04182 7.60725C3.1144 9.01493 5.12273 18.2586 7.51812 15.4666C8.39365 14.4456 9.23965 13.5824 9.23965 13.5824C9.65977 13.853 10.1628 13.9911 10.6901 13.9415L10.7311 13.9078C10.7183 14.0345 10.7241 14.1585 10.7474 14.3053C10.1303 14.9738 10.3117 15.0911 9.07811 15.3374C7.82982 15.5868 8.56311 16.0309 9.0419 16.147C9.62233 16.2877 10.9651 16.487 11.8724 15.2555L11.8363 15.3961C12.078 15.5838 12.2478 16.6174 12.2193 17.5545C12.1909 18.4914 12.1719 19.1347 12.3623 19.6372C12.5529 20.1397 12.7428 21.2702 14.3645 20.9333C15.7195 20.6518 16.4217 19.9221 16.5195 18.705C16.5887 17.8398 16.7457 17.9677 16.7555 17.1941L16.8814 16.8279C17.0265 15.655 16.9044 15.2765 17.7392 15.4526L17.9422 15.4699C18.5565 15.4969 19.3608 15.374 19.8328 15.1613C20.8491 14.704 21.4519 13.9404 20.4498 14.141H20.4499Z",
        fill: "#336791"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M10.4683 8.23557C10.2623 8.20777 10.0757 8.23349 9.98126 8.30282C9.92821 8.34181 9.91175 8.38699 9.90729 8.41808C9.89545 8.50045 9.95497 8.59156 9.99156 8.63852C10.0951 8.77152 10.2462 8.86292 10.3958 8.88305C10.4175 8.88603 10.4391 8.88737 10.4606 8.88737C10.7101 8.88737 10.937 8.69898 10.957 8.55995C10.982 8.38579 10.7212 8.26972 10.4683 8.23565V8.23557ZM17.2948 8.24109C17.2751 8.10459 17.0246 8.06567 16.7869 8.09773C16.5495 8.12979 16.3193 8.23371 16.3385 8.37051C16.3539 8.4769 16.552 8.6585 16.7865 8.6585C16.8063 8.6585 16.8263 8.65724 16.8465 8.65448C17.003 8.63345 17.1179 8.53706 17.1725 8.48152C17.2555 8.39683 17.3037 8.30245 17.2948 8.24109Z",
        fill: "white"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M21.2115 14.0886C21.1243 13.8329 20.8437 13.7507 20.3774 13.844C18.993 14.1211 18.4973 13.9292 18.3345 13.813C19.4105 12.2235 20.2958 10.3022 20.7733 8.50962C20.9995 7.66048 21.1245 6.87188 21.1347 6.2291C21.146 5.52362 21.022 5.00519 20.7665 4.6885C19.736 3.41181 18.2236 2.72699 16.3929 2.7082C15.1343 2.69448 14.0709 3.00678 13.8648 3.0946C13.4307 2.98993 12.9574 2.92567 12.4422 2.91747C11.4974 2.90263 10.6807 3.12196 10.0045 3.56904C9.71083 3.46303 8.95178 3.21038 8.02351 3.06538C6.41869 2.81488 5.14342 3.00469 4.23337 3.6298C3.14747 4.37576 2.64616 5.70918 2.74327 7.59294C2.77595 8.22669 3.1484 10.1764 3.73613 12.0435C4.50978 14.501 5.35079 15.8922 6.23562 16.1784C6.33919 16.2119 6.4586 16.2353 6.59031 16.2353C6.91309 16.2353 7.30883 16.0942 7.72057 15.6143C8.22277 15.0301 8.74227 14.4602 9.27841 13.9051C9.62625 14.0861 10.0084 14.1872 10.3992 14.1973C10.4 14.2073 10.401 14.2172 10.4019 14.227C10.3346 14.3048 10.2687 14.3837 10.2043 14.4637C9.9335 14.797 9.87714 14.8664 9.00545 15.0404C8.75749 15.0901 8.09894 15.2217 8.08925 15.6693C8.07879 16.1583 8.86775 16.3637 8.95763 16.3855C9.27087 16.4615 9.57266 16.499 9.86045 16.499C10.5604 16.499 11.1763 16.276 11.6686 15.8444C11.6534 17.5878 11.7284 19.3058 11.9443 19.8292C12.1211 20.2577 12.5531 21.305 13.9175 21.3049C14.1178 21.3049 14.3381 21.2823 14.5806 21.2319C16.0046 20.9359 16.623 20.3257 16.8622 18.9802C16.9902 18.2612 17.2099 16.5442 17.3133 15.6232C17.5313 15.6892 17.812 15.7194 18.1155 15.7193C18.7485 15.7193 19.4788 15.5889 19.9368 15.3828C20.4514 15.1511 21.3799 14.5825 21.2115 14.0886ZM17.8203 7.86505C17.8156 8.13694 17.777 8.38377 17.7361 8.64142C17.692 8.91853 17.6465 9.20503 17.635 9.55281C17.6237 9.89127 17.6673 10.2432 17.7095 10.5835C17.7947 11.2708 17.8821 11.9785 17.5437 12.6767C17.4875 12.5802 17.4374 12.4803 17.3938 12.3778C17.3517 12.279 17.2604 12.1202 17.1339 11.9004C16.6419 11.0449 15.4897 9.04139 16.0795 8.22386C16.2552 7.98053 16.7011 7.73033 17.8203 7.86505ZM16.4636 3.25876C18.104 3.29387 19.4015 3.88887 20.3202 5.02711C21.0248 5.90018 20.2489 9.87278 18.0028 13.3C17.9802 13.2721 17.9575 13.2444 17.9347 13.2167L17.9062 13.1823C18.4866 12.2528 18.3732 11.3332 18.2721 10.5179C18.2306 10.1834 18.1914 9.86734 18.2014 9.57048C18.2117 9.25587 18.2546 8.986 18.2961 8.72507C18.3471 8.40353 18.399 8.07081 18.3847 7.6786C18.3954 7.63744 18.3997 7.58884 18.3941 7.53113C18.3576 7.15502 17.9147 6.02938 17.012 5.01056C16.5182 4.45329 15.7982 3.82967 14.815 3.40906C15.2379 3.32407 15.8162 3.24482 16.4636 3.25876ZM7.28484 15.263C6.8312 15.7918 6.51796 15.6904 6.41493 15.6572C5.74369 15.4401 4.96481 14.0645 4.27812 11.8831C3.68393 9.99564 3.3367 8.09765 3.30917 7.56543C3.22244 5.88221 3.64325 4.70915 4.55999 4.07875C6.05194 3.05293 8.50483 3.66693 9.49047 3.97833C9.47632 3.9919 9.46156 4.00457 9.44756 4.01836C7.83014 5.60212 7.8685 8.30803 7.8725 8.47346C7.87235 8.53727 7.87788 8.62763 7.88542 8.75191C7.91325 9.20704 7.96508 10.0541 7.82668 11.0133C7.69812 11.9047 7.98153 12.7772 8.60409 13.4071C8.66799 13.4716 8.73514 13.533 8.80531 13.5911C8.52821 13.8789 7.92594 14.5152 7.28484 15.263ZM9.01322 13.027C8.51144 12.5193 8.28355 11.8131 8.38788 11.0894C8.53397 10.0761 8.48007 9.19355 8.45109 8.7194C8.44701 8.65305 8.4434 8.5949 8.44132 8.54905C8.6776 8.3459 9.77257 7.77708 10.5534 7.95056C10.9097 8.02966 11.1269 8.26494 11.2171 8.6696C11.6843 10.7647 11.279 11.6379 10.9533 12.3397C10.8861 12.4842 10.8227 12.6209 10.7686 12.7622L10.7266 12.8715C10.6203 13.1478 10.5215 13.4047 10.4602 13.6486C9.92673 13.6472 9.40781 13.4262 9.01322 13.0269V13.027ZM9.09511 15.8524C8.93933 15.8147 8.79924 15.7492 8.71704 15.6948C8.78571 15.6635 8.90788 15.6209 9.11979 15.5785C10.1452 15.3739 10.3036 15.2294 10.6495 14.8037C10.7288 14.706 10.8186 14.5954 10.9431 14.4606L10.9433 14.4604C11.1287 14.2591 11.2135 14.2933 11.3672 14.3552C11.4919 14.4051 11.6133 14.5566 11.6625 14.7233C11.6858 14.802 11.7119 14.9514 11.6263 15.0677C10.9039 16.0485 9.85115 16.0359 9.09511 15.8524ZM14.4618 20.6947C13.2073 20.9553 12.7631 20.3347 12.4704 19.6252C12.2815 19.1671 12.1886 17.1016 12.2545 14.8206C12.2554 14.7902 12.2509 14.7609 12.2423 14.7334C12.2346 14.6789 12.2229 14.625 12.2072 14.5722C12.1093 14.2403 11.8705 13.9627 11.5841 13.8475C11.4703 13.8018 11.2615 13.718 11.0105 13.7802C11.0641 13.5664 11.1569 13.3249 11.2575 13.0635L11.2997 12.9535C11.3472 12.8296 11.4069 12.7011 11.47 12.5651C11.8108 11.8309 12.2776 10.8253 11.771 8.55353C11.5812 7.7026 10.9475 7.28705 9.98686 7.3836C9.41096 7.44137 8.88405 7.66667 8.62124 7.79586C8.56473 7.8236 8.51306 7.85044 8.46477 7.87653C8.53812 7.01919 8.81523 5.41694 9.85184 4.40319C10.5045 3.76504 11.3738 3.44984 12.4328 3.46683C14.5196 3.49993 15.8578 4.53828 16.613 5.4036C17.2637 6.14918 17.6161 6.90028 17.7567 7.30539C16.6991 7.2011 15.9799 7.4035 15.6152 7.90896C14.822 9.00844 16.0492 11.1424 16.639 12.168C16.7472 12.3559 16.8405 12.5184 16.8699 12.5874C17.062 13.0387 17.3106 13.3401 17.4922 13.56C17.5478 13.6274 17.6018 13.6928 17.6429 13.7499C17.3226 13.8394 16.7472 14.0463 16.7996 15.0804C16.7573 15.5993 16.4566 18.0286 16.3039 18.8869C16.1022 20.0208 15.6718 20.4432 14.4618 20.6948V20.6947ZM19.6983 14.8845C19.3707 15.0319 18.8226 15.1424 18.3019 15.1662C17.7268 15.1923 17.434 15.1037 17.3651 15.0492C17.3328 14.4048 17.5801 14.3375 17.8419 14.2662C17.8831 14.255 17.9232 14.2441 17.962 14.231C17.986 14.25 18.0124 14.2688 18.0413 14.2873C18.5036 14.5831 19.328 14.6151 20.4921 14.3821L20.5048 14.3796C20.3478 14.5219 20.0792 14.7129 19.6983 14.8845Z",
        fill: "white"
      })]
    }), /*#__PURE__*/jsxRuntime.jsx("defs", {
      children: /*#__PURE__*/jsxRuntime.jsx("clipPath", {
        id: "clip0_849_49322",
        children: /*#__PURE__*/jsxRuntime.jsx("rect", {
          width: "19.6835",
          height: "19.6835",
          fill: "white",
          transform: "translate(2.1582 2.1582)"
        })
      })
    })]
  });
};
var MSSql = function MSSql(_ref4) {
  var className = _ref4.className,
    _ref4$circular = _ref4.circular,
    circular = _ref4$circular === void 0 ? false : _ref4$circular;
  if (circular) {
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      width: "1.5rem",
      height: "1.5rem",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
        width: "24",
        height: "24",
        rx: "12",
        fill: "#FFF1F1"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M12.8269 9.89575L11.4466 10.3836L10.2457 10.9572L9.9098 11.0532C9.82424 11.1413 9.73453 11.2306 9.6375 11.3209C9.53108 11.4203 9.43197 11.5106 9.3558 11.5761C9.2713 11.6484 9.1461 11.7839 9.08246 11.8697C8.98752 11.9984 8.9124 12.1351 8.88006 12.2401C8.82267 12.4298 8.85086 12.6218 8.96144 12.7991C9.10333 13.0249 9.38607 13.2553 9.71574 13.4123C9.88372 13.4924 10.1665 13.5952 10.3793 13.6528C10.7329 13.7499 11.4174 13.8549 11.794 13.8707C11.8701 13.8741 11.9724 13.8741 11.9766 13.8707C11.9849 13.8651 12.0433 13.7443 12.1112 13.5941C12.3428 13.0825 12.5097 12.6026 12.6005 12.1927C12.6547 11.9442 12.6975 11.6134 12.7256 11.2215C12.733 11.112 12.7361 10.745 12.7298 10.6208C12.7204 10.4175 12.7037 10.2526 12.6777 10.0911C12.6735 10.0674 12.6724 10.046 12.6745 10.0448C12.6787 10.0415 12.6912 10.0369 12.8613 9.98386L12.8268 9.89579V9.89576H12.8269V9.89575ZM12.5118 10.0956C12.5243 10.0956 12.5577 10.4423 12.566 10.6614C12.5681 10.7077 12.5671 10.7382 12.565 10.7382C12.5567 10.7382 12.3887 10.6309 12.2687 10.5496C12.1644 10.4785 11.9662 10.3362 11.9349 10.3091C11.9244 10.3012 11.9254 10.3001 12.011 10.2684C12.156 10.2153 12.5003 10.0956 12.5118 10.0956ZM11.8086 10.3463C11.818 10.3463 11.842 10.361 11.8994 10.3994C12.1143 10.5451 12.4064 10.7213 12.5316 10.78C12.5702 10.798 12.5744 10.7913 12.4857 10.8568C12.2958 10.9968 12.059 11.1346 11.7689 11.2735C11.7178 11.2983 11.6751 11.3175 11.674 11.3175C11.6719 11.3175 11.6782 11.2893 11.6865 11.2554C11.7564 10.9742 11.7961 10.6896 11.7982 10.4615C11.7992 10.3486 11.7992 10.3486 11.8086 10.3452C11.8065 10.3463 11.8075 10.3463 11.8086 10.3463ZM11.6636 10.4062C11.6698 10.413 11.6657 10.6659 11.6573 10.7348C11.6385 10.8997 11.6093 11.0532 11.5614 11.226C11.5499 11.2678 11.5394 11.3028 11.5374 11.3051C11.5332 11.3107 11.3902 11.1594 11.3433 11.1007C11.2619 10.999 11.1983 10.8974 11.1513 10.798C11.1273 10.7472 11.0898 10.6479 11.0929 10.6445C11.1096 10.632 11.6594 10.4017 11.6636 10.4062ZM10.9813 10.6964C10.9823 10.6964 10.9833 10.6964 10.9844 10.6975C10.9865 10.6998 10.9938 10.7179 11.0001 10.7382C11.0334 10.8364 11.1085 10.981 11.1732 11.0736C11.2442 11.1752 11.337 11.2836 11.4142 11.3548C11.4393 11.3773 11.4622 11.3988 11.4653 11.4022C11.4716 11.409 11.4737 11.4078 11.3036 11.4778C11.1065 11.5591 10.8915 11.6404 10.6453 11.7263C10.5865 11.7468 10.5277 11.7675 10.469 11.7884C10.4596 11.7918 10.4628 11.7861 10.4899 11.7398C10.6119 11.5332 10.7976 11.1278 10.902 10.8409C10.9197 10.7913 10.9374 10.7416 10.9406 10.7303C10.9448 10.7145 10.95 10.7088 10.9635 10.7009C10.9708 10.6987 10.9781 10.6964 10.9813 10.6964ZM10.7726 10.7901C10.7757 10.7924 10.7225 10.9132 10.6704 11.0239C10.5692 11.2373 10.4586 11.4474 10.3104 11.7026C10.2854 11.7466 10.2614 11.7873 10.2583 11.7918C10.2531 11.7997 10.251 11.7974 10.2343 11.7624C10.1988 11.6868 10.1696 11.5896 10.1539 11.5004C10.1383 11.4123 10.1414 11.2588 10.1592 11.1639C10.1727 11.0939 10.1717 11.095 10.203 11.0781C10.3365 11.0047 10.7684 10.7856 10.7726 10.7901ZM12.5723 10.8692V10.9166C12.5723 11.1684 12.5473 11.514 12.5107 11.7658C12.5045 11.8099 12.4992 11.846 12.4982 11.8471C12.4982 11.8471 12.468 11.8381 12.4325 11.8268C12.276 11.7737 12.1059 11.6958 11.9526 11.6043C11.8514 11.5445 11.7043 11.4462 11.7084 11.4417C11.7095 11.4406 11.7533 11.4157 11.8044 11.3864C12.0089 11.2712 12.205 11.147 12.3751 11.0239C12.4388 10.9776 12.5347 10.9031 12.5556 10.8827L12.5723 10.8692ZM9.98491 11.2034C9.98909 11.2034 9.98804 11.2125 9.98178 11.2531C9.97761 11.2825 9.9724 11.3367 9.97032 11.3739C9.96196 11.5388 9.98701 11.6608 10.0621 11.8279C10.083 11.8742 10.0997 11.9126 10.0986 11.9137C10.0913 11.9205 9.40068 12.1396 9.18366 12.2039C9.11898 12.2231 9.06265 12.2401 9.05846 12.2412C9.05117 12.2435 9.05012 12.2423 9.05325 12.2231C9.07724 12.0571 9.19409 11.8403 9.35684 11.6574C9.46535 11.5354 9.55195 11.4643 9.7001 11.3728C9.80651 11.3073 9.97031 11.2091 9.98283 11.2046C9.98284 11.2034 9.98387 11.2034 9.98491 11.2034ZM11.6125 11.5185C11.6135 11.5174 11.6385 11.5321 11.6688 11.5512C11.8921 11.6913 12.203 11.8211 12.4679 11.8878L12.492 11.8934L12.4586 11.9137C12.3198 11.9973 11.8639 12.2028 11.3975 12.3914C11.3297 12.4185 11.263 12.4456 11.2504 12.4512C11.2379 12.4569 11.2264 12.4603 11.2264 12.4592C11.2264 12.458 11.2452 12.4185 11.2692 12.3699C11.3996 12.1057 11.5311 11.7839 11.5978 11.5603C11.6062 11.5388 11.6114 11.5196 11.6125 11.5185ZM11.4466 11.5772C11.4476 11.5784 11.4393 11.6021 11.4288 11.6292C11.3381 11.8674 11.2191 12.1272 11.0668 12.4185C11.0282 12.4931 10.9959 12.5529 10.9948 12.5529C10.9938 12.5529 10.9625 12.5326 10.9249 12.5077C10.7037 12.3609 10.5076 12.1802 10.3793 12.0052L10.3605 11.9804L10.4554 11.9521C10.7956 11.8516 11.0845 11.7432 11.3715 11.61C11.4121 11.5919 11.4455 11.5772 11.4466 11.5772ZM12.4774 11.9668C12.4774 11.9668 12.4784 11.9679 12.4774 11.9668C12.4784 11.9928 12.4252 12.2254 12.3814 12.3937C12.3449 12.5348 12.3135 12.6455 12.2562 12.8408C12.2311 12.9267 12.2092 12.9978 12.2082 12.9978C12.2071 12.9978 12.2009 12.9967 12.1946 12.9944C11.8848 12.9334 11.6072 12.8487 11.3464 12.7358C11.2734 12.7042 11.1691 12.6534 11.1628 12.6477C11.1607 12.6455 11.2233 12.6139 11.3026 12.5766C11.7773 12.3519 12.2697 12.0967 12.4388 11.9871C12.4586 11.9736 12.4742 11.9668 12.4774 11.9668ZM10.0976 12.0549C10.0997 12.0571 9.96719 12.2638 9.78147 12.545C9.71679 12.6432 9.64168 12.7584 9.61351 12.8013C9.58534 12.8442 9.54257 12.912 9.51857 12.9526L9.47473 13.026L9.42778 12.9831C9.37248 12.9334 9.27651 12.8273 9.23374 12.7686C9.14401 12.6478 9.08351 12.5202 9.05951 12.4038C9.04803 12.3496 9.04803 12.3225 9.05845 12.3192C9.0741 12.3146 9.35266 12.2435 9.6135 12.178C9.75852 12.1419 9.92648 12.0989 9.98699 12.0831C10.0475 12.0673 10.0966 12.0549 10.0976 12.0549ZM10.2311 12.1102L10.2645 12.1509C10.4148 12.3327 10.5681 12.4671 10.7538 12.5845C10.7872 12.6048 10.8123 12.6229 10.8102 12.6241C10.8029 12.6297 10.1654 12.8747 9.87015 12.9854C9.70428 13.0486 9.56759 13.0994 9.56657 13.0994C9.56553 13.0994 9.55613 13.0927 9.54568 13.0848L9.52691 13.0701L9.55716 13.0227C9.65523 12.8691 9.77836 12.7008 10.0465 12.3508L10.2311 12.1102ZM11.0637 12.755C11.0647 12.7539 11.1106 12.772 11.167 12.7946C11.3026 12.8499 11.41 12.8849 11.554 12.9244C11.7314 12.973 11.988 13.0204 12.1393 13.034C12.1623 13.0362 12.1748 13.0385 12.1706 13.0419C12.1633 13.0464 12.01 13.1017 11.8973 13.1401C11.7178 13.2011 11.1701 13.3761 10.7236 13.515C10.6412 13.541 10.5702 13.5624 10.566 13.5636C10.5556 13.5658 10.5212 13.5557 10.5212 13.5511C10.5212 13.5489 10.5462 13.5139 10.5765 13.4755C10.7267 13.2813 10.8759 13.0644 11.0001 12.8589C11.0345 12.8024 11.0637 12.7562 11.0637 12.755ZM10.8801 12.7607C10.8811 12.7618 10.807 12.8905 10.6777 13.1119C10.6224 13.2056 10.5608 13.3117 10.5389 13.349C10.518 13.3851 10.4867 13.4416 10.469 13.4732L10.4387 13.5308L10.4231 13.5263C10.3855 13.515 10.1216 13.4145 10.0517 13.384C9.96508 13.3467 9.87536 13.3016 9.80858 13.2632C9.72513 13.2146 9.62081 13.1423 9.62915 13.1401C9.63123 13.139 9.77417 13.0972 9.9463 13.0464C10.4033 12.912 10.6568 12.8341 10.8227 12.7776C10.8529 12.7674 10.879 12.7595 10.8801 12.7607ZM12.179 13.0904H12.18C12.1842 13.1017 12.0152 13.6099 11.9536 13.7702C11.9401 13.8063 11.9349 13.8154 11.9275 13.8142C11.9098 13.8131 11.6646 13.7759 11.5154 13.7521C11.2557 13.7092 10.8196 13.6268 10.71 13.5997L10.685 13.5941L10.8404 13.5556C11.1743 13.4743 11.3349 13.4303 11.4977 13.3761C11.7032 13.3083 11.9067 13.2236 12.1122 13.1198C12.1445 13.104 12.1717 13.0915 12.179 13.0904Z",
        fill: "url(#paint0_linear_849_49429)"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M11.4035 6.4129C11.3805 6.40953 11.0102 6.55407 10.7713 6.65908C10.4489 6.80138 10.1985 6.9369 10.0441 7.05432C9.9867 7.09838 9.9147 7.17628 9.90324 7.20677C9.89907 7.21806 9.89697 7.23161 9.89697 7.24516L10.0368 7.38858L10.3696 7.50376L11.1615 7.65734L12.067 7.8256L12.0764 7.74091C12.0733 7.74091 12.0712 7.73979 12.0681 7.73979L11.9491 7.71945L11.9252 7.67316C11.802 7.43827 11.6664 7.14692 11.5871 6.95043C11.5256 6.79798 11.4671 6.62183 11.4348 6.49535C11.4171 6.41856 11.415 6.41405 11.4035 6.41292V6.41289H11.4035V6.4129ZM11.3868 6.47051H11.3879C11.3889 6.47162 11.3931 6.50326 11.3972 6.54051C11.415 6.69862 11.4473 6.85105 11.4984 7.01593C11.537 7.14015 11.537 7.13338 11.4922 7.11869C11.3858 7.08708 10.909 6.99787 10.5636 6.94592C10.5084 6.93801 10.4614 6.93011 10.4614 6.92899C10.4572 6.92447 10.7107 6.78105 10.8224 6.7246C10.9653 6.65344 11.3576 6.47615 11.3868 6.47051ZM10.381 6.97641L10.4218 6.99107C10.6429 7.07239 11.199 7.18758 11.5057 7.21468C11.5402 7.21807 11.5694 7.22146 11.5704 7.22146C11.5714 7.22259 11.5422 7.23953 11.5047 7.25872C11.3565 7.33889 11.1938 7.43714 11.0811 7.51281C11.0477 7.53538 11.0175 7.55346 11.0133 7.55346C11.0091 7.55346 10.9872 7.54894 10.9643 7.54555L10.9225 7.53877L10.8182 7.42809C10.6346 7.235 10.4906 7.08595 10.4353 7.02947L10.381 6.97641ZM10.3393 7.01141L10.4864 7.21016C10.5668 7.3197 10.6481 7.42697 10.6659 7.45068C10.6836 7.47441 10.6982 7.49361 10.6972 7.49474C10.693 7.49812 10.4844 7.45407 10.3738 7.42698C10.26 7.39874 10.2131 7.38519 10.1432 7.36149L10.0858 7.34115V7.32533C10.0868 7.24967 10.1755 7.13675 10.3258 7.02158L10.3393 7.01141ZM11.5892 7.28243C11.5934 7.28243 11.5986 7.29259 11.6111 7.32308C11.6466 7.40777 11.7572 7.63589 11.7843 7.67992C11.7927 7.69462 11.8072 7.69574 11.6601 7.66977C11.3065 7.60764 11.1927 7.58734 11.1927 7.58508C11.1927 7.58396 11.2032 7.57605 11.2167 7.56813C11.3263 7.50265 11.4369 7.41908 11.535 7.32987C11.559 7.30841 11.5809 7.28808 11.585 7.28469C11.5861 7.28243 11.5882 7.28131 11.5892 7.28243Z",
        fill: "url(#paint1_linear_849_49429)"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M9.91066 7.19092C9.91066 7.19092 9.88772 7.23046 9.90963 7.28918C9.9232 7.32531 9.96284 7.36934 10.0077 7.41452C10.0077 7.41452 10.472 7.90461 10.5283 7.97463C10.7849 8.29533 10.8966 8.61152 10.907 9.04742C10.9133 9.32747 10.8642 9.57365 10.7422 9.85935C10.5252 10.372 10.0671 10.9378 9.36084 11.5657L9.46414 11.5284C9.53091 11.4742 9.62168 11.4166 9.83451 11.2901C10.3259 10.9988 10.8788 10.7311 11.557 10.4556C12.5335 10.0581 14.1392 9.59283 15.0531 9.44152L15.148 9.4257L15.1334 9.40086C15.05 9.26083 14.9926 9.17389 14.9237 9.08129C14.7234 8.81252 14.4803 8.59459 14.183 8.4139C13.774 8.16661 13.245 7.97351 12.5752 7.83009C12.449 7.80297 12.1715 7.75104 11.9461 7.71377C11.4683 7.63361 11.1595 7.57827 10.8194 7.51503C10.6973 7.49244 10.5147 7.45857 10.3937 7.43034C10.3311 7.41565 10.2111 7.38516 10.1172 7.35016C10.0421 7.31853 9.93361 7.28691 9.91066 7.19092ZM10.1798 7.47324C10.1809 7.47213 10.1976 7.47888 10.2195 7.48679C10.2591 7.50146 10.3103 7.5184 10.3708 7.53648C10.4166 7.55011 10.4625 7.56329 10.5085 7.576C10.5711 7.59293 10.6232 7.60874 10.6243 7.60874C10.6316 7.61665 10.737 7.98138 10.7724 8.12141C10.786 8.1745 10.7964 8.21966 10.7954 8.21966C10.7943 8.2208 10.7829 8.20159 10.7693 8.17562C10.6472 7.94299 10.4542 7.70698 10.231 7.51726C10.2018 7.4947 10.1798 7.47437 10.1798 7.47324ZM10.6931 7.62682C10.6984 7.62682 10.7213 7.63021 10.7495 7.63698C10.9268 7.67989 11.2451 7.74539 11.4485 7.78266C11.4829 7.7883 11.5101 7.79509 11.5101 7.79733C11.5101 7.7996 11.4975 7.80749 11.4819 7.81653C11.4475 7.83572 11.3087 7.92493 11.2628 7.95881C11.147 8.04237 11.0427 8.13271 10.9675 8.21402C10.9373 8.24677 10.9112 8.27387 10.9112 8.27387C10.9112 8.27387 10.9049 8.25468 10.8997 8.23095C10.8622 8.07398 10.7839 7.84135 10.713 7.67762C10.7015 7.65166 10.6921 7.62794 10.6921 7.62569C10.6921 7.62794 10.6921 7.62682 10.6931 7.62682ZM11.5966 7.81314C11.6029 7.81539 11.6133 7.85379 11.6342 7.93848C11.6728 8.10223 11.6905 8.28517 11.6843 8.45569C11.6822 8.50311 11.6801 8.54715 11.678 8.55281L11.6749 8.56409L11.6206 8.5449C11.509 8.50651 11.3275 8.4489 11.172 8.40148C11.0833 8.37551 11.0114 8.35179 11.0114 8.34954C11.0114 8.34275 11.1407 8.20273 11.196 8.14966C11.3014 8.04914 11.5872 7.80975 11.5966 7.81314ZM11.6686 7.82442C11.6718 7.82105 12.1006 7.90121 12.2957 7.94187C12.4407 7.97236 12.6514 8.01979 12.6639 8.02545C12.6702 8.0277 12.6483 8.04124 12.5784 8.07512C12.3029 8.20951 12.0985 8.33032 11.895 8.47714C11.8418 8.51553 11.797 8.54715 11.7959 8.54715C11.7949 8.54715 11.7938 8.51441 11.7938 8.47488C11.7938 8.26033 11.7542 8.04351 11.6811 7.86057C11.6738 7.8425 11.6676 7.82557 11.6686 7.82442ZM12.7776 8.06158C12.7808 8.06496 12.7672 8.15644 12.7547 8.21064C12.7171 8.3789 12.6159 8.62848 12.4918 8.86335C12.4699 8.90513 12.4501 8.93901 12.448 8.94014C12.4459 8.94126 12.4177 8.92432 12.3854 8.90399C12.2644 8.8272 12.1266 8.75493 11.9764 8.68717C11.9347 8.66798 11.8982 8.65216 11.8971 8.64992C11.8898 8.64314 12.2257 8.40261 12.4031 8.28742C12.544 8.19483 12.7735 8.05705 12.7776 8.06158ZM12.8569 8.07512C12.8663 8.07512 13.0562 8.13159 13.1553 8.16321C13.4005 8.24227 13.6822 8.35405 13.8658 8.44439L13.9419 8.48167L13.8888 8.49521C13.4402 8.607 13.0562 8.73575 12.6858 8.89836C12.6556 8.91191 12.6284 8.9232 12.6264 8.9232C12.6243 8.9232 12.6347 8.89723 12.6483 8.8656C12.7599 8.60927 12.8319 8.34163 12.8496 8.11351C12.8507 8.09205 12.8538 8.07512 12.8569 8.07512ZM10.9665 8.5449C10.9696 8.5415 11.1146 8.57878 11.1929 8.60247C11.3118 8.63862 11.5643 8.73008 11.5643 8.73686C11.5643 8.73799 11.5361 8.76396 11.5028 8.79559C11.3661 8.91868 11.2346 9.04853 11.0771 9.2134C11.0301 9.26198 10.9905 9.3015 10.9884 9.3015C10.9863 9.3015 10.9853 9.29471 10.9863 9.28568C11.0103 9.09596 11.0051 8.85205 10.9717 8.60474C10.9686 8.57311 10.9654 8.54602 10.9665 8.5449ZM14.014 8.54829C14.016 8.55054 13.9472 8.66798 13.9034 8.7346C13.8408 8.83171 13.7489 8.96047 13.5413 9.24278C13.4318 9.39183 13.3087 9.5601 13.268 9.61656C13.2263 9.67301 13.1918 9.72043 13.1908 9.72043C13.1897 9.72043 13.1762 9.70012 13.1616 9.67528C13.0447 9.48556 12.9049 9.31956 12.739 9.1705C12.7077 9.14226 12.6733 9.11177 12.6618 9.10274C12.6504 9.09371 12.641 9.08467 12.641 9.08355C12.641 9.08017 12.8183 8.99771 12.9529 8.93901C13.1887 8.83511 13.51 8.7109 13.751 8.63071C13.8773 8.58781 14.0119 8.54602 14.014 8.54829ZM14.0943 8.57086C14.0985 8.56974 14.1235 8.58329 14.1538 8.60247C14.4073 8.75944 14.6556 8.96158 14.8517 9.16937C14.907 9.2281 15.0437 9.38168 15.0416 9.3828C15.0416 9.3828 14.9936 9.38732 14.9373 9.39183C14.498 9.42798 13.9357 9.52846 13.3953 9.66961C13.3588 9.67864 13.3264 9.68655 13.3243 9.68655C13.3223 9.68655 13.3629 9.64251 13.4141 9.58945C13.7312 9.25858 13.8763 9.04967 14.0473 8.67701C14.0713 8.62169 14.0922 8.57426 14.0943 8.57086C14.0932 8.57086 14.0932 8.57086 14.0943 8.57086ZM11.7709 8.82835C11.7855 8.83172 11.9211 8.90063 12.0233 8.95595C12.1172 9.00674 12.2581 9.08807 12.2654 9.09483C12.2664 9.09596 12.2163 9.12419 12.1548 9.15695C11.9587 9.26309 11.7907 9.36359 11.6154 9.47877C11.5653 9.51153 11.5236 9.53864 11.5226 9.53864C11.5184 9.53864 11.5194 9.5341 11.5476 9.47877C11.6415 9.29359 11.7166 9.07226 11.7594 8.85656C11.7636 8.83963 11.7677 8.82835 11.7709 8.82835ZM11.6352 8.85544C11.6384 8.85883 11.6029 8.99772 11.581 9.07338C11.5382 9.2168 11.4662 9.39635 11.3963 9.53186C11.3796 9.56346 11.3546 9.60977 11.341 9.63574L11.3149 9.6809L11.2565 9.61994C11.1887 9.54879 11.1334 9.50475 11.0625 9.46522C11.0343 9.44942 11.0124 9.43586 11.0124 9.43361C11.0124 9.42458 11.1908 9.24955 11.3275 9.12307C11.4255 9.0316 11.6321 8.85205 11.6352 8.85544ZM12.4647 9.22471L12.5158 9.26083C12.6326 9.34328 12.7703 9.45281 12.8757 9.54879C12.9352 9.60186 13.0499 9.71367 13.0729 9.74077L13.0854 9.75546L13.0009 9.78143C12.5231 9.92483 12.1538 10.0524 11.7229 10.2241C11.6749 10.2433 11.6342 10.2591 11.6311 10.2591C11.6248 10.2591 11.6196 10.2647 11.7271 10.1574C12.0025 9.88307 12.2466 9.58041 12.4281 9.28567L12.4647 9.22471ZM12.2466 9.28343C12.2487 9.28568 12.1058 9.50362 12.0202 9.62671C11.918 9.77352 11.7364 10.0197 11.6112 10.18C11.5591 10.2467 11.5142 10.302 11.5121 10.3031C11.509 10.3043 11.508 10.2873 11.508 10.2613C11.508 10.1247 11.4756 9.97902 11.4193 9.85482C11.3953 9.80287 11.3911 9.79045 11.3963 9.78481C11.4162 9.7656 11.7198 9.57815 11.9117 9.46636C12.0411 9.39183 12.2435 9.28117 12.2466 9.28343ZM10.9279 9.6335C10.931 9.6335 10.955 9.64704 10.9821 9.66286C11.0489 9.70237 11.1084 9.74641 11.1616 9.79385C11.1637 9.7961 11.1365 9.81983 11.1011 9.84804C11.002 9.92483 10.8517 10.0479 10.7641 10.1236C10.6723 10.2026 10.6692 10.2049 10.6796 10.188C10.7484 10.0739 10.7829 10.0095 10.8194 9.9271C10.8517 9.85371 10.8841 9.76675 10.907 9.69109C10.9154 9.65834 10.9258 9.6335 10.9279 9.6335ZM11.2795 9.93161C11.2847 9.93049 11.291 9.94064 11.3191 9.98582C11.3786 10.0818 11.4245 10.2105 11.436 10.3144L11.4381 10.337L11.2951 10.3969C11.0395 10.5041 10.8037 10.6103 10.6441 10.6893C10.5992 10.7119 10.521 10.7526 10.4699 10.7797C10.4188 10.8079 10.377 10.8294 10.377 10.8282C10.377 10.8271 10.4094 10.8011 10.449 10.7695C10.761 10.5245 11.0312 10.2557 11.2336 9.98695C11.2555 9.95871 11.2753 9.93274 11.2774 9.93161L11.2795 9.93161ZM11.1178 9.97453C11.1219 9.97904 11.003 10.1247 10.9216 10.2139C10.7203 10.4364 10.521 10.6103 10.2737 10.7797C10.2424 10.8011 10.2143 10.8203 10.2111 10.8226C10.2038 10.8271 10.2132 10.8158 10.3217 10.6882C10.3906 10.608 10.4428 10.5403 10.5022 10.4567C10.5419 10.4014 10.5492 10.3935 10.6066 10.3494C10.7599 10.2297 11.1136 9.97 11.1178 9.97453Z",
        fill: "url(#paint2_radial_849_49429)"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M7.99745 14.8872C7.9782 14.8872 7.95895 14.8892 7.93987 14.8892C7.55114 14.9116 7.28896 15.0968 7.13567 15.4584C7.00456 15.7854 7.01888 16.2129 7.13714 16.542C7.27466 16.8635 7.49689 17.0332 7.86781 17.0973C7.94629 17.1112 7.99892 17.1578 8.15092 17.3499L8.33795 17.5871H8.67716L8.4516 17.341C8.32692 17.206 8.22608 17.0885 8.22608 17.0782C8.22608 17.0679 8.27377 17.0453 8.3315 17.0262C8.52183 16.9639 8.67989 16.8047 8.79045 16.5608C8.87993 16.3649 8.89277 16.3044 8.9056 16.0607C8.93916 15.3353 8.58582 14.8818 7.99743 14.887L7.99745 14.8872ZM8.29484 16.7841C8.12982 16.8706 7.8902 16.8879 7.73379 16.8258C7.57206 16.7615 7.41548 16.5797 7.34505 16.3739C7.26677 16.1488 7.27795 15.7337 7.36743 15.5467C7.51136 15.249 7.7017 15.1121 7.97984 15.1121C8.39239 15.1121 8.62708 15.3856 8.65771 15.8996C8.68192 16.3286 8.54916 16.6505 8.29502 16.7839L8.29484 16.7841ZM14.1545 15.5068C14.0123 15.5068 13.9033 15.5691 13.83 15.692L13.7724 15.7892V15.5364H13.5262V17.0526H13.7723V16.568C13.7723 16.1248 13.7774 16.073 13.8346 15.9517C13.9134 15.7854 14.0491 15.7025 14.1802 15.7422L14.2682 15.77V15.5072H14.1545V15.5068ZM12.7079 15.4929C12.6596 15.4929 12.6085 15.4999 12.5575 15.512C12.228 15.6052 12.0423 15.9466 12.0536 16.2979C12.0536 16.592 12.1064 16.739 12.2376 16.8933C12.5062 17.1318 12.7491 17.1508 13.077 17.0229C13.1329 16.9971 13.1938 16.9673 13.1938 16.9673V16.7287L13.077 16.7942C12.8116 16.9193 12.6118 16.9193 12.4517 16.772C12.3496 16.6595 12.3047 16.5245 12.2839 16.3705H13.2768V16.1661C13.2768 15.7493 13.0451 15.4862 12.7077 15.4929H12.7079ZM12.3063 16.1578C12.3063 16.1578 12.343 15.8978 12.479 15.7958C12.5445 15.7457 12.6197 15.7215 12.6932 15.7215C12.7669 15.7215 12.8404 15.7473 12.9011 15.7976C13.0258 15.9013 13.0467 16.1558 13.0467 16.1558H12.3063V16.1578H12.3063ZM6.36978 15.8843C6.10283 15.7092 5.98438 15.583 5.99886 15.4342C6.04029 15.0224 6.51043 15.0793 6.77078 15.2351L6.77263 14.9581C6.77263 14.9581 6.62869 14.8906 6.42241 14.887C6.10594 14.8819 5.90131 14.9942 5.80543 15.2228C5.6646 15.5602 5.7893 15.8146 6.24 16.0984C6.49302 16.2578 6.60486 16.3961 6.60486 16.5469C6.60486 16.8585 6.25777 16.9673 5.89968 16.7718C5.82598 16.7321 5.76363 16.699 5.76034 16.699C5.74749 16.7873 5.75411 16.9986 5.75411 16.9986C5.75411 16.9986 5.86413 17.0487 6.02914 17.0832C6.43837 17.1715 6.81078 16.9637 6.84598 16.6263C6.87661 16.3096 6.77079 16.1435 6.3698 15.8841L6.36978 15.8843ZM16.3339 15.4893C16.2859 15.4893 16.2349 15.4965 16.1817 15.5086C15.8526 15.6019 15.6672 15.9432 15.6799 16.2945C15.6799 16.5882 15.7325 16.7339 15.8636 16.8879C16.1322 17.1267 16.3752 17.1459 16.7047 17.0177C16.7604 16.9919 16.8211 16.9626 16.8211 16.9626V16.7236L16.7045 16.7895C16.4386 16.9141 16.2387 16.9141 16.0792 16.7669C15.9766 16.6545 15.932 16.5212 15.9113 16.3654H16.9025V16.1609C16.9025 15.7462 16.6707 15.4828 16.3334 15.4898L16.3339 15.4893ZM15.9324 16.1542C15.9324 16.1542 15.9694 15.8946 16.1053 15.7906C16.1705 15.7404 16.2457 15.7162 16.3192 15.7162C16.3926 15.7162 16.4665 15.742 16.5272 15.7924C16.6519 15.8962 16.6728 16.1524 16.6728 16.1524H15.9326L15.9324 16.1542ZM11.4189 15.8877C11.1519 15.713 11.0338 15.5864 11.0481 15.4375C11.0895 15.0255 11.5597 15.0827 11.82 15.2385L11.8219 14.9614C11.8219 14.9614 11.678 14.894 11.4717 14.8908C11.1552 14.8856 10.9506 14.9979 10.8545 15.2266C10.7139 15.5639 10.8402 15.8184 11.2894 16.1022C11.5421 16.2614 11.6539 16.3979 11.6539 16.5487C11.6539 16.8603 11.307 16.9709 10.9489 16.7736C10.8756 16.7339 10.8133 16.7011 10.8096 16.7011C10.7967 16.7894 10.8034 17.0008 10.8034 17.0008C10.8034 17.0008 10.9121 17.049 11.0766 17.0853C11.4862 17.1739 11.8587 16.9663 11.8938 16.6289C11.9242 16.3137 11.8186 16.1476 11.4189 15.888V15.8877H11.4189ZM17.7808 15.5032C17.6385 15.5032 17.5283 15.5657 17.4562 15.6886L17.3987 15.7854V15.533H17.1524V17.0489H17.3985V16.5642C17.3985 16.1212 17.4034 16.0692 17.4608 15.9482C17.5397 15.7821 17.6753 15.6989 17.8064 15.7388L17.8944 15.7666V15.5032H17.7808V15.5032ZM9.46063 15.8789V14.9132H9.21237V17.0522H10.2564V16.7996H9.46064V15.8789H9.46063ZM15.2019 16.18L14.9972 16.7563L14.8005 16.1768L14.6006 15.5346H14.3465C14.5112 16.0399 14.6903 16.5539 14.8709 17.0522C14.9492 17.0542 15.0277 17.0522 15.106 17.0522L15.3823 16.3012L15.6637 15.5348H15.4208C15.4208 15.5348 15.3135 15.8392 15.2017 16.1802L15.2019 16.18ZM10.0327 14.3303C10.0727 14.3303 10.106 14.3164 10.1335 14.2867C10.1607 14.2573 10.175 14.2227 10.175 14.1795C10.175 14.1362 10.1607 14.1001 10.1335 14.0723C10.106 14.0445 10.0743 14.0306 10.0345 14.0306C9.9942 14.0306 9.96081 14.0445 9.93367 14.0739C9.90618 14.1033 9.89371 14.1394 9.89371 14.1811C9.89371 14.2247 9.90655 14.2608 9.93367 14.2883C9.95935 14.316 9.99273 14.3299 10.0327 14.3299V14.3303ZM9.94469 14.0842C9.96852 14.0584 9.99749 14.0465 10.0345 14.0465C10.0694 14.0465 10.0983 14.0584 10.1226 14.0842C10.1464 14.11 10.1592 14.1414 10.1592 14.1795C10.1592 14.2176 10.1464 14.2505 10.1226 14.2763C10.0984 14.3021 10.0694 14.3144 10.0345 14.3144C9.99914 14.3144 9.97035 14.3025 9.94653 14.2763C9.92269 14.2505 9.90986 14.2176 9.90986 14.1795C9.90986 14.1414 9.92086 14.11 9.94469 14.0842ZM10.0039 14.1934H10.02C10.0314 14.1934 10.0426 14.2053 10.0521 14.2279L10.0714 14.2747H10.1016L10.0778 14.2227C10.0681 14.2019 10.0586 14.1898 10.0474 14.1864C10.0615 14.1828 10.0727 14.1777 10.0807 14.1673C10.0888 14.1584 10.0917 14.1463 10.0917 14.1326C10.0917 14.1167 10.0872 14.1049 10.0774 14.0961C10.0664 14.0862 10.0488 14.0808 10.0261 14.0808H9.97514V14.2747H10.0008V14.1934L10.0039 14.1934ZM10.0039 14.1033H10.0263C10.0424 14.1033 10.0538 14.1068 10.06 14.112C10.0661 14.1172 10.0677 14.1239 10.0677 14.1362C10.0677 14.1586 10.0549 14.1692 10.0311 14.1692H10.0036V14.1033H10.0039ZM5.90295 14.1761C5.90295 14.1086 5.90113 14.0584 5.89965 14.0289H5.90113C5.90753 14.0638 5.91542 14.0898 5.92184 14.107L6.16019 14.6834H6.20017L6.43852 14.1019C6.44496 14.086 6.45138 14.0622 6.45926 14.029H6.46108C6.45632 14.0866 6.45467 14.1366 6.45467 14.1765V14.6852H6.53625V13.929H6.43394L6.21484 14.4549C6.20677 14.4758 6.19558 14.507 6.18128 14.5482H6.17797C6.17321 14.5278 6.16202 14.4966 6.14607 14.4585L5.9319 13.9272H5.82318V14.6834H5.90166V14.1765L5.90295 14.1761ZM6.71504 14.1775H6.78546V14.6485H6.71504V14.1775ZM6.75024 14.0048C6.76492 14.0048 6.77739 13.9995 6.78691 13.989C6.79664 13.9786 6.80306 13.9651 6.80306 13.9493C6.80306 13.9338 6.79829 13.9199 6.78711 13.9096C6.77721 13.8991 6.76455 13.8937 6.75007 13.8937C6.73578 13.8937 6.72294 13.8991 6.71339 13.9096C6.7037 13.9199 6.69726 13.9338 6.69726 13.9493C6.69726 13.9665 6.70222 13.9786 6.71339 13.989C6.72441 13.9995 6.73577 14.0048 6.75007 14.0048H6.75024ZM7.28749 14.6588V14.5758C7.24898 14.607 7.20754 14.6225 7.16464 14.6225C7.11331 14.6225 7.07167 14.6034 7.04123 14.5669C7.01099 14.5308 6.99486 14.4806 6.99486 14.4181C6.99486 14.3526 7.01099 14.3005 7.04435 14.2609C7.07644 14.2228 7.11807 14.2037 7.16905 14.2037C7.21067 14.2037 7.25062 14.2176 7.2875 14.2454V14.1571C7.25395 14.138 7.21563 14.1293 7.17235 14.1293C7.09239 14.1293 7.03007 14.1571 6.9835 14.2107C6.93728 14.2643 6.91345 14.3371 6.91345 14.425C6.91345 14.5032 6.93416 14.5689 6.97727 14.6191C7.02218 14.6707 7.07959 14.6969 7.14999 14.6969C7.20443 14.6953 7.24898 14.683 7.28749 14.6588ZM7.48899 14.4077C7.48899 14.3456 7.50182 14.2954 7.52566 14.2608C7.54804 14.2297 7.57516 14.214 7.60725 14.214C7.63439 14.214 7.65364 14.2194 7.66775 14.2315V14.1414C7.65676 14.1362 7.6408 14.1344 7.62009 14.1344C7.5913 14.1344 7.56564 14.1449 7.54309 14.1642C7.51925 14.1846 7.50018 14.2158 7.489 14.2555H7.48717V14.1449H7.40741V14.6848H7.48735V14.4077H7.48899ZM7.94793 14.6955C8.02312 14.6955 8.08362 14.6693 8.12854 14.6173C8.17326 14.5657 8.19564 14.4962 8.19564 14.4097C8.19564 14.3214 8.17512 14.2539 8.1333 14.2037C8.09187 14.1535 8.03429 14.1292 7.9591 14.1292C7.88392 14.1292 7.82341 14.1535 7.7785 14.2003C7.73046 14.2519 7.70516 14.3248 7.70516 14.4182C7.70516 14.4996 7.72569 14.5671 7.76898 14.6173C7.8137 14.6693 7.87293 14.6953 7.94793 14.6953V14.6955ZM7.83425 14.2557C7.86469 14.221 7.90467 14.2037 7.95416 14.2037C8.00552 14.2037 8.04402 14.221 8.07262 14.2557C8.1014 14.292 8.11572 14.3438 8.11572 14.4131C8.11572 14.479 8.10287 14.5308 8.07573 14.5655C8.04861 14.6018 8.00863 14.6211 7.95581 14.6211C7.90448 14.6211 7.86469 14.6018 7.83425 14.5655C7.80401 14.529 7.78951 14.479 7.78951 14.4131C7.7864 14.3476 7.80236 14.294 7.83425 14.2557ZM8.54568 14.6485C8.57611 14.6191 8.59226 14.583 8.59226 14.5377C8.59226 14.498 8.57941 14.4651 8.55559 14.4391C8.53614 14.4182 8.50609 14.3994 8.46263 14.3803C8.42411 14.3629 8.40028 14.3474 8.38744 14.3353C8.37461 14.3214 8.36672 14.3041 8.36672 14.2797C8.36672 14.2573 8.3748 14.24 8.39057 14.2261C8.40671 14.2122 8.42724 14.2055 8.45475 14.2055C8.49784 14.2055 8.53468 14.2178 8.56841 14.2438V14.1573C8.53615 14.1398 8.50113 14.1315 8.46115 14.1315C8.40982 14.1315 8.36654 14.1468 8.33462 14.1763C8.30107 14.2057 8.28513 14.2438 8.28513 14.2886C8.28513 14.3283 8.29612 14.3613 8.31701 14.3855C8.33462 14.4061 8.36471 14.4272 8.40649 14.446C8.44648 14.4651 8.47361 14.4823 8.48809 14.4962C8.50239 14.5101 8.5088 14.5274 8.5088 14.5478C8.5088 14.5982 8.47691 14.6243 8.41456 14.6243C8.36652 14.6243 8.32345 14.6072 8.28492 14.5727V14.6659C8.31976 14.6886 8.36157 14.6989 8.40777 14.6989C8.467 14.6955 8.51338 14.6798 8.54529 14.6487L8.54568 14.6485ZM8.92633 14.1293C8.85114 14.1293 8.79064 14.1535 8.74572 14.2003C8.69805 14.2519 8.67238 14.3248 8.67238 14.4183C8.67238 14.4996 8.69311 14.5671 8.73619 14.6173C8.78111 14.6693 8.84015 14.6953 8.91533 14.6953C8.99233 14.6953 9.05102 14.6691 9.09594 14.6171C9.14086 14.5655 9.16322 14.496 9.16322 14.4095C9.16322 14.3212 9.14232 14.2537 9.10087 14.2035C9.05762 14.1533 9.00003 14.1291 8.92669 14.1291L8.92633 14.1293ZM9.08144 14.4131C9.08144 14.479 9.06861 14.5308 9.04148 14.5655C9.01433 14.6018 8.97436 14.6211 8.92155 14.6211C8.87019 14.6211 8.83042 14.6018 8.79997 14.5655C8.76972 14.529 8.75524 14.479 8.75524 14.4131C8.75524 14.3436 8.7712 14.29 8.80329 14.2539C8.83353 14.2194 8.87352 14.2019 8.9232 14.2019C8.9727 14.2019 9.0125 14.2194 9.04127 14.2539C9.06695 14.292 9.08126 14.3438 9.08126 14.4131H9.08144ZM9.29745 14.6832H9.37721V14.2158H9.494V14.1432H9.3772V14.0598C9.3772 13.984 9.40432 13.9459 9.46044 13.9459C9.47933 13.9459 9.49858 13.9511 9.51289 13.9598V13.8818C9.49858 13.8749 9.47933 13.8733 9.45529 13.8733C9.41221 13.8733 9.37701 13.8872 9.34822 13.9166C9.31466 13.9511 9.29688 13.9959 9.29688 14.0567V14.1452H9.21252V14.2178H9.29688V14.6834L9.29745 14.6832ZM9.62509 14.5359C9.62509 14.6415 9.6682 14.6953 9.7562 14.6953C9.78811 14.6953 9.81212 14.6897 9.83137 14.6774V14.6032C9.81671 14.6151 9.79929 14.6207 9.78004 14.6207C9.75292 14.6207 9.73384 14.6137 9.72265 14.598C9.71128 14.5826 9.70487 14.5564 9.70487 14.5202V14.2156H9.83137V14.143H9.70487V13.9838C9.67736 13.9941 9.65041 14.0029 9.62491 14.0116V14.143H9.53874V14.2156H9.62491V14.5357L9.62509 14.5359ZM18.2062 15.531C18.179 15.5032 18.1469 15.4893 18.1072 15.4893C18.0668 15.4893 18.0334 15.5032 18.0063 15.533C17.9792 15.5622 17.9663 15.5985 17.9663 15.6402C17.9663 15.6834 17.9792 15.7196 18.0061 15.7473C18.0333 15.7751 18.0666 15.789 18.107 15.789C18.1467 15.789 18.1803 15.7751 18.2078 15.7457C18.2348 15.716 18.2491 15.6816 18.2491 15.6386C18.2476 15.5949 18.2331 15.5588 18.206 15.531L18.2062 15.531ZM18.1933 15.7354C18.1695 15.7612 18.1405 15.7731 18.1053 15.7731C18.0705 15.7731 18.0415 15.7612 18.0173 15.7354C17.9935 15.7092 17.9806 15.6765 17.9806 15.6382C17.9806 15.6005 17.9916 15.5691 18.0158 15.5429C18.0397 15.5171 18.0685 15.5052 18.1053 15.5052C18.1402 15.5052 18.1691 15.5171 18.1933 15.5429C18.2172 15.5691 18.23 15.6005 18.23 15.6382C18.23 15.6783 18.219 15.7092 18.1933 15.7354ZM18.1214 15.6471C18.1357 15.6435 18.1471 15.6366 18.155 15.6281C18.1631 15.6191 18.166 15.607 18.166 15.5932C18.166 15.5777 18.1614 15.5654 18.1517 15.5568C18.1407 15.5469 18.1229 15.5415 18.1004 15.5415H18.0494V15.7352H18.0751V15.6539H18.091C18.1021 15.6539 18.1131 15.6658 18.1229 15.6884L18.142 15.735H18.1725L18.1486 15.683C18.1404 15.6604 18.1308 15.6501 18.1211 15.6467L18.1214 15.6471ZM18.1038 15.6297H18.0763V15.5642H18.0989C18.1149 15.5642 18.126 15.5673 18.1325 15.5727C18.1389 15.5779 18.1403 15.5846 18.1403 15.5969C18.1403 15.6193 18.1275 15.6297 18.1037 15.6297L18.1038 15.6297ZM13.643 14.1207H13.6654V13.9268H13.7246V13.9026H13.5838V13.9268H13.643V14.1207H13.643ZM13.7787 13.9751C13.7787 13.9562 13.7787 13.9407 13.7774 13.932C13.7789 13.9423 13.7822 13.9493 13.7836 13.9544L13.8524 14.1207H13.8634L13.9323 13.9528C13.9342 13.9477 13.9356 13.9409 13.9387 13.932C13.9373 13.9493 13.9373 13.9631 13.9373 13.9737V14.1206H13.9611V13.9026H13.9323L13.87 14.0531C13.8685 14.0584 13.8636 14.0689 13.8604 14.0809H13.8586C13.8573 14.0739 13.854 14.067 13.8494 14.0551L13.7871 13.9026H13.7548V14.121H13.7774V13.9753L13.7787 13.9751Z",
        fill: "#231F1F"
      }), /*#__PURE__*/jsxRuntime.jsxs("defs", {
        children: [/*#__PURE__*/jsxRuntime.jsxs("linearGradient", {
          id: "paint0_linear_849_49429",
          x1: "9.88952",
          y1: "13.1353",
          x2: "10.4083",
          y2: "12.8521",
          gradientUnits: "userSpaceOnUse",
          children: [/*#__PURE__*/jsxRuntime.jsx("stop", {
            stopColor: "#909CA9"
          }), /*#__PURE__*/jsxRuntime.jsx("stop", {
            offset: "1",
            stopColor: "#EDEDEE"
          })]
        }), /*#__PURE__*/jsxRuntime.jsxs("linearGradient", {
          id: "paint1_linear_849_49429",
          x1: "9.90063",
          y1: "7.11704",
          x2: "10.3022",
          y2: "7.11704",
          gradientUnits: "userSpaceOnUse",
          children: [/*#__PURE__*/jsxRuntime.jsx("stop", {
            stopColor: "#939FAB"
          }), /*#__PURE__*/jsxRuntime.jsx("stop", {
            offset: "1",
            stopColor: "#DCDEE1"
          })]
        }), /*#__PURE__*/jsxRuntime.jsxs("radialGradient", {
          id: "paint2_radial_849_49429",
          cx: "0",
          cy: "0",
          r: "1",
          gradientUnits: "userSpaceOnUse",
          gradientTransform: "translate(11.9272 9.11059) rotate(-170.765) scale(0.518749 1.11902)",
          children: [/*#__PURE__*/jsxRuntime.jsx("stop", {
            stopColor: "#EE352C"
          }), /*#__PURE__*/jsxRuntime.jsx("stop", {
            offset: "1",
            stopColor: "#A91D22"
          })]
        })]
      })]
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsxs("g", {
      clipPath: "url(#clip0_849_49341)",
      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M15.58 8.77588L13.531 9.44493L11.7485 10.2317L11.2498 10.3633C11.1228 10.4841 10.9896 10.6065 10.8456 10.7304C10.6876 10.8666 10.5405 10.9906 10.4274 11.0804C10.302 11.1795 10.1162 11.3653 10.0217 11.483C9.88076 11.6595 9.76926 11.8469 9.72125 11.991C9.63606 12.2512 9.6779 12.5144 9.84205 12.7576C10.0527 13.0673 10.4724 13.3833 10.9618 13.5985C11.2111 13.7085 11.6308 13.8494 11.9467 13.9284C12.4717 14.0616 13.4877 14.2056 14.0467 14.2273C14.1598 14.232 14.3116 14.232 14.3177 14.2273C14.3301 14.2195 14.4169 14.0539 14.5176 13.8479C14.8614 13.1463 15.1091 12.4881 15.2439 11.926C15.3244 11.5853 15.3879 11.1315 15.4297 10.5941C15.4406 10.4439 15.4452 9.94055 15.4359 9.77018C15.4219 9.49142 15.3972 9.26532 15.3585 9.04385C15.3523 9.01132 15.3507 8.98189 15.3538 8.98035C15.36 8.97571 15.3786 8.96952 15.631 8.89671L15.5799 8.77593V8.77589H15.58V8.77588ZM15.1123 9.05002C15.1308 9.05002 15.1804 9.52545 15.1928 9.82592C15.1959 9.88941 15.1943 9.93123 15.1912 9.93123C15.1788 9.93123 14.9295 9.78412 14.7514 9.67261C14.5965 9.57504 14.3023 9.37989 14.2558 9.34273C14.2403 9.3319 14.2419 9.33035 14.3689 9.28697C14.5841 9.21417 15.0952 9.05002 15.1123 9.05002ZM14.0684 9.39383C14.0824 9.39383 14.118 9.41394 14.2032 9.46661C14.5222 9.66639 14.9558 9.908 15.1417 9.98854C15.199 10.0133 15.2051 10.004 15.0735 10.0939C14.7917 10.2859 14.4401 10.4748 14.0096 10.6653C13.9337 10.6994 13.8702 10.7257 13.8687 10.7257C13.8656 10.7257 13.8748 10.687 13.8872 10.6405C13.991 10.2549 14.0498 9.86462 14.0529 9.55178C14.0545 9.39691 14.0545 9.39691 14.0684 9.39228C14.0653 9.39383 14.0669 9.39383 14.0684 9.39383ZM13.8532 9.47591C13.8624 9.48518 13.8563 9.83211 13.8439 9.92657C13.816 10.1527 13.7726 10.3633 13.7014 10.6003C13.6844 10.6575 13.6689 10.7056 13.6658 10.7087C13.6596 10.7164 13.4474 10.5089 13.3777 10.4283C13.2569 10.289 13.1625 10.1496 13.0928 10.0133C13.0571 9.9436 13.0014 9.80733 13.006 9.80268C13.0308 9.78564 13.847 9.46972 13.8532 9.47591ZM12.8403 9.87391C12.8419 9.87391 12.8434 9.87391 12.845 9.87546C12.8481 9.87856 12.8589 9.90334 12.8682 9.93121C12.9177 10.066 13.0292 10.2642 13.1253 10.3912C13.2306 10.5306 13.3684 10.6792 13.483 10.7768C13.5202 10.8078 13.5542 10.8372 13.5589 10.8418C13.5682 10.8511 13.5713 10.8496 13.3188 10.9456C13.0262 11.0571 12.7071 11.1686 12.3416 11.2863C12.2543 11.3145 12.1671 11.3429 12.0799 11.3715C12.066 11.3761 12.0706 11.3684 12.1109 11.3049C12.2921 11.0215 12.5677 10.4655 12.7226 10.0721C12.7489 10.004 12.7753 9.93587 12.7799 9.92038C12.7861 9.89868 12.7939 9.89095 12.814 9.8801C12.8248 9.87703 12.8357 9.87391 12.8403 9.87391ZM12.5306 10.0025C12.5352 10.0056 12.4563 10.1713 12.3788 10.323C12.2286 10.6157 12.0644 10.9038 11.8445 11.2538C11.8074 11.3142 11.7717 11.37 11.7671 11.3762C11.7594 11.387 11.7562 11.3839 11.7315 11.3359C11.6788 11.2321 11.6354 11.0989 11.6122 10.9766C11.589 10.8558 11.5936 10.6452 11.62 10.5151C11.6401 10.4191 11.6385 10.4206 11.685 10.3974C11.8832 10.2967 12.5244 9.99626 12.5306 10.0025ZM15.2021 10.1109V10.1759C15.2021 10.5213 15.1649 10.9952 15.1107 11.3405C15.1014 11.4009 15.0936 11.4505 15.0921 11.4521C15.0921 11.4521 15.0472 11.4397 14.9945 11.4242C14.7623 11.3514 14.5098 11.2445 14.2821 11.1191C14.1319 11.037 13.9136 10.9022 13.9198 10.896C13.9213 10.8945 13.9863 10.8604 14.0622 10.8202C14.3658 10.6622 14.6569 10.4919 14.9094 10.323C15.0038 10.2595 15.1463 10.1573 15.1773 10.1295L15.2021 10.1109ZM11.3613 10.5693C11.3675 10.5693 11.366 10.5817 11.3567 10.6374C11.3505 10.6777 11.3427 10.752 11.3397 10.8031C11.3272 11.0292 11.3644 11.1965 11.4759 11.4257C11.5069 11.4892 11.5317 11.5418 11.5301 11.5434C11.5193 11.5527 10.4941 11.8532 10.1719 11.9414C10.0759 11.9677 9.99229 11.991 9.98607 11.9925C9.97525 11.9956 9.97369 11.9941 9.97833 11.9677C10.0139 11.7401 10.1874 11.4427 10.429 11.1918C10.5901 11.0246 10.7186 10.927 10.9385 10.8016C11.0965 10.7117 11.3396 10.577 11.3582 10.5708C11.3582 10.5693 11.3598 10.5693 11.3613 10.5693ZM13.7773 11.0014C13.7788 10.9998 13.816 11.02 13.8609 11.0463C14.1923 11.2383 14.6538 11.4164 15.0472 11.5078L15.0828 11.5155L15.0332 11.5434C14.8273 11.658 14.1505 11.9398 13.4583 12.1985C13.3576 12.2356 13.2585 12.2728 13.2399 12.2806C13.2213 12.2883 13.2042 12.293 13.2042 12.2914C13.2042 12.2898 13.2321 12.2356 13.2677 12.1691C13.4613 11.8067 13.6565 11.3653 13.7556 11.0587C13.768 11.0292 13.7757 11.0029 13.7773 11.0014ZM13.531 11.0819C13.5326 11.0835 13.5202 11.116 13.5047 11.1531C13.37 11.4799 13.1934 11.8361 12.9673 12.2357C12.91 12.3379 12.862 12.42 12.8604 12.42C12.8589 12.42 12.8124 12.3921 12.7567 12.358C12.4283 12.1567 12.1372 11.9089 11.9467 11.6689L11.9188 11.6348L12.0598 11.5961C12.5646 11.4582 12.9936 11.3096 13.4195 11.1268C13.4799 11.102 13.5295 11.0819 13.531 11.0819ZM15.0611 11.6162C15.0611 11.6162 15.0627 11.6177 15.0611 11.6162C15.0627 11.6518 14.9837 11.9709 14.9187 12.2016C14.8645 12.3952 14.818 12.547 14.7328 12.8149C14.6956 12.9326 14.6631 13.0301 14.6616 13.0301C14.66 13.0301 14.6507 13.0286 14.6415 13.0255C14.1815 12.9419 13.7695 12.8257 13.3824 12.6708C13.2739 12.6275 13.1191 12.5578 13.1098 12.55C13.1067 12.5469 13.1996 12.5036 13.3173 12.4525C14.022 12.1443 14.753 11.7943 15.0038 11.6441C15.0333 11.6255 15.0565 11.6162 15.0611 11.6162ZM11.5286 11.737C11.5317 11.7401 11.335 12.0235 11.0593 12.4091C10.9633 12.5439 10.8518 12.7018 10.81 12.7607C10.7682 12.8195 10.7047 12.9124 10.6691 12.9682L10.604 13.0689L10.5343 13.01C10.4522 12.9419 10.3098 12.7963 10.2463 12.7158C10.1131 12.5501 10.0233 12.3751 9.98763 12.2156C9.97059 12.1412 9.97059 12.104 9.98606 12.0994C10.0093 12.0932 10.4228 11.9956 10.81 11.9058C11.0253 11.8563 11.2746 11.7974 11.3644 11.7757C11.4542 11.754 11.527 11.737 11.5286 11.737ZM11.7268 11.8129L11.7763 11.8686C11.9994 12.118 12.227 12.3023 12.5027 12.4633C12.5523 12.4912 12.5894 12.516 12.5863 12.5176C12.5755 12.5253 11.6292 12.8613 11.191 13.0131C10.9447 13.0998 10.7418 13.1695 10.7403 13.1695C10.7388 13.1695 10.7248 13.1602 10.7093 13.1494L10.6814 13.1293L10.7264 13.0642C10.8719 12.8536 11.0547 12.6229 11.4527 12.1428L11.7268 11.8129ZM12.9627 12.6972C12.9642 12.6956 13.0323 12.7204 13.116 12.7514C13.3173 12.8273 13.4768 12.8753 13.6906 12.9295C13.9538 12.9961 14.3348 13.0611 14.5594 13.0797C14.5935 13.0828 14.612 13.0859 14.6058 13.0906C14.595 13.0968 14.3673 13.1726 14.2001 13.2253C13.9337 13.3089 13.1206 13.549 12.4578 13.7395C12.3355 13.7751 12.2301 13.8045 12.2239 13.806C12.2085 13.8092 12.1573 13.7952 12.1573 13.789C12.1573 13.7859 12.1945 13.7379 12.2394 13.6853C12.4624 13.4189 12.6839 13.1215 12.8682 12.8397C12.9193 12.7622 12.9627 12.6987 12.9627 12.6972ZM12.6901 12.7049C12.6916 12.7065 12.5817 12.883 12.3897 13.1866C12.3076 13.3151 12.2162 13.4607 12.1837 13.5118C12.1527 13.5613 12.1062 13.6388 12.0799 13.6821L12.035 13.7611L12.0118 13.7549C11.956 13.7394 11.5642 13.6016 11.4604 13.5598C11.3319 13.5087 11.1987 13.4467 11.0996 13.3941C10.9757 13.3275 10.8208 13.2284 10.8332 13.2253C10.8363 13.2237 11.0485 13.1664 11.304 13.0967C11.9823 12.9124 12.3587 12.8056 12.6049 12.7282C12.6498 12.7142 12.6885 12.7034 12.6901 12.7049ZM14.6182 13.1571H14.6198C14.626 13.1726 14.3751 13.8695 14.2837 14.0894C14.2636 14.139 14.2558 14.1514 14.245 14.1498C14.2187 14.1483 13.8547 14.0972 13.6332 14.0647C13.2476 14.0058 12.6003 13.8927 12.4377 13.8556L12.4005 13.8479L12.6312 13.7952C13.1268 13.6837 13.3653 13.6233 13.6069 13.5489C13.912 13.456 14.214 13.3399 14.5191 13.1974C14.5671 13.1757 14.6074 13.1587 14.6182 13.1571Z",
        fill: "url(#paint0_linear_849_49341)"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M13.4673 3.99935C13.4332 3.99473 12.8834 4.19296 12.5288 4.33697C12.0502 4.53212 11.6785 4.71798 11.4493 4.87901C11.3642 4.93943 11.2573 5.04628 11.2403 5.08808C11.2341 5.10357 11.231 5.12216 11.231 5.14074L11.4385 5.33743L11.9325 5.49539L13.108 5.70602L14.4522 5.93678L14.4662 5.82063C14.4615 5.82063 14.4584 5.81908 14.4538 5.81908L14.2772 5.79119L14.2416 5.72771C14.0589 5.40557 13.8575 5.006 13.7399 4.73653C13.6485 4.52745 13.5618 4.28588 13.5137 4.11242C13.4874 4.00711 13.4843 4.00092 13.4673 3.99938V3.99934H13.4673V3.99935ZM13.4425 4.07835H13.4441C13.4456 4.07988 13.4518 4.12328 13.458 4.17435C13.4843 4.3912 13.5323 4.60024 13.6082 4.82636C13.6655 4.99672 13.6655 4.98744 13.5989 4.96729C13.4409 4.92394 12.7332 4.80159 12.2206 4.73035C12.1385 4.71951 12.0688 4.70867 12.0688 4.70713C12.0626 4.70094 12.4389 4.50424 12.6046 4.42682C12.8168 4.32923 13.3991 4.08609 13.4425 4.07835ZM11.9495 4.77216L12.01 4.79227C12.3383 4.90379 13.1637 5.06177 13.619 5.09893C13.6701 5.10358 13.7135 5.10824 13.715 5.10824C13.7166 5.10978 13.6732 5.13301 13.6175 5.15933C13.3976 5.26929 13.156 5.40403 12.9887 5.50779C12.9392 5.53875 12.8942 5.56355 12.8881 5.56355C12.8819 5.56355 12.8493 5.55735 12.8153 5.5527L12.7533 5.5434L12.5985 5.39162C12.3259 5.12681 12.1122 4.92238 12.0301 4.84493L11.9495 4.77216ZM11.8876 4.82016L12.106 5.09274C12.2252 5.24296 12.346 5.39008 12.3724 5.42259C12.3987 5.45513 12.4204 5.48147 12.4188 5.48301C12.4126 5.48766 12.1029 5.42725 11.9387 5.39009C11.7699 5.35137 11.7002 5.33278 11.5965 5.30027L11.5113 5.27239V5.25069C11.5128 5.14692 11.6445 4.99206 11.8675 4.83411L11.8876 4.82016ZM13.7429 5.19185C13.7491 5.19185 13.7569 5.20578 13.7754 5.2476C13.8281 5.36374 13.9923 5.67659 14.0325 5.73698C14.0449 5.75714 14.0666 5.75868 13.8482 5.72306C13.3233 5.63786 13.1544 5.61001 13.1544 5.60691C13.1544 5.60537 13.1699 5.59452 13.19 5.58367C13.3527 5.49387 13.5168 5.37925 13.6624 5.2569C13.698 5.22747 13.7306 5.1996 13.7367 5.19494C13.7383 5.19185 13.7414 5.19031 13.7429 5.19185Z",
        fill: "url(#paint1_linear_849_49341)"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M11.2512 5.06616C11.2512 5.06616 11.2172 5.12039 11.2497 5.20092C11.2698 5.25047 11.3287 5.31085 11.3953 5.37282C11.3953 5.37282 12.0844 6.04494 12.1681 6.14097C12.549 6.58079 12.7147 7.01443 12.7302 7.61223C12.7395 7.9963 12.6667 8.33391 12.4855 8.72574C12.1634 9.42885 11.4835 10.2047 10.4351 11.0658L10.5884 11.0147C10.6875 10.9404 10.8223 10.8614 11.1382 10.6879C11.8676 10.2884 12.6884 9.92132 13.6951 9.54344C15.1446 8.99829 17.5281 8.36022 18.8847 8.15272L19.0257 8.13102L19.004 8.09695C18.8801 7.9049 18.7949 7.78567 18.6927 7.65868C18.3953 7.29008 18.0345 6.9912 17.5931 6.7434C16.986 6.40425 16.2008 6.13943 15.2066 5.94274C15.0192 5.90556 14.6072 5.83433 14.2727 5.78322C13.5634 5.67329 13.105 5.59739 12.6001 5.51066C12.419 5.47967 12.1479 5.43323 11.9683 5.39452C11.8753 5.37436 11.6973 5.33256 11.5579 5.28455C11.4464 5.24117 11.2853 5.1978 11.2512 5.06616ZM11.6508 5.45335C11.6523 5.45182 11.6771 5.46109 11.7097 5.47193C11.7685 5.49204 11.8444 5.51528 11.9342 5.54008C12.0022 5.55877 12.0703 5.57684 12.1387 5.59428C12.2316 5.61749 12.309 5.63918 12.3105 5.63918C12.3214 5.65003 12.4778 6.15022 12.5305 6.34227C12.5506 6.41507 12.5661 6.47701 12.5645 6.47701C12.563 6.47858 12.5459 6.45223 12.5258 6.41662C12.3446 6.09758 12.0581 5.77391 11.7267 5.51372C11.6833 5.48277 11.6508 5.45489 11.6508 5.45335ZM12.4128 5.66397C12.4205 5.66397 12.4546 5.66862 12.4964 5.6779C12.7597 5.73675 13.232 5.82658 13.534 5.87769C13.5851 5.88542 13.6254 5.89474 13.6254 5.89782C13.6254 5.90093 13.6068 5.91175 13.5835 5.92415C13.5325 5.95047 13.3265 6.07281 13.2583 6.11928C13.0864 6.23388 12.9316 6.35777 12.8201 6.46927C12.7752 6.51419 12.7364 6.55136 12.7364 6.55136C12.7364 6.55136 12.7272 6.52504 12.7194 6.4925C12.6637 6.27723 12.5475 5.95819 12.4422 5.73364C12.4251 5.69804 12.4112 5.66551 12.4112 5.66242C12.4112 5.66551 12.4112 5.66397 12.4128 5.66397ZM13.7539 5.9195C13.7632 5.92259 13.7787 5.97525 13.8097 6.0914C13.867 6.31597 13.8933 6.56685 13.884 6.80071C13.8809 6.86575 13.8778 6.92614 13.8747 6.9339L13.8701 6.94937L13.7895 6.92306C13.6238 6.8704 13.3544 6.7914 13.1236 6.72637C12.992 6.69075 12.8851 6.65822 12.8851 6.65513C12.8851 6.64583 13.0772 6.4538 13.1592 6.38102C13.3156 6.24316 13.74 5.91485 13.7539 5.9195ZM13.8608 5.93497C13.8654 5.93035 14.5019 6.04028 14.7915 6.09604C15.0068 6.13785 15.3197 6.2029 15.3382 6.21066C15.3475 6.21375 15.315 6.23233 15.2112 6.27878C14.8024 6.46309 14.4988 6.62878 14.1969 6.83013C14.1179 6.88278 14.0513 6.92614 14.0497 6.92614C14.0482 6.92614 14.0466 6.88124 14.0466 6.82703C14.0466 6.53279 13.9878 6.23543 13.8794 5.98455C13.8685 5.95977 13.8592 5.93654 13.8608 5.93497ZM15.507 6.26022C15.5117 6.26486 15.4915 6.39031 15.473 6.46464C15.4172 6.6954 15.267 7.03768 15.0827 7.35979C15.0502 7.41709 15.0208 7.46355 15.0176 7.4651C15.0146 7.46664 14.9727 7.4434 14.9247 7.41553C14.7451 7.31022 14.5407 7.21111 14.3176 7.11817C14.2557 7.09185 14.2015 7.07016 14.1999 7.06709C14.1891 7.05778 14.6878 6.72791 14.9511 6.56995C15.1601 6.44296 15.5008 6.25401 15.507 6.26022ZM15.6247 6.27879C15.6387 6.27879 15.9205 6.35623 16.0676 6.3996C16.4316 6.50801 16.8497 6.66132 17.1223 6.78522L17.2353 6.83634L17.1564 6.85491C16.4905 7.00822 15.9205 7.1848 15.3707 7.4078C15.3258 7.42638 15.2856 7.44187 15.2825 7.44187C15.2794 7.44187 15.2949 7.40626 15.315 7.36288C15.4807 7.01133 15.5876 6.64429 15.6139 6.33144C15.6155 6.30201 15.6201 6.27879 15.6247 6.27879ZM12.8185 6.92306C12.8232 6.9184 13.0384 6.96952 13.1546 7.00201C13.3311 7.05159 13.7059 7.17702 13.7059 7.18632C13.7059 7.18787 13.6641 7.22349 13.6146 7.26687C13.4117 7.43567 13.2165 7.61375 12.9827 7.83987C12.913 7.90648 12.8541 7.96068 12.851 7.96068C12.8479 7.96068 12.8464 7.95137 12.8479 7.93898C12.8835 7.67879 12.8758 7.34429 12.8263 7.00513C12.8216 6.96175 12.817 6.9246 12.8185 6.92306ZM17.3422 6.92771C17.3453 6.93079 17.2431 7.09186 17.1781 7.18322C17.0852 7.3164 16.9488 7.49298 16.6406 7.88015C16.4781 8.08456 16.2953 8.31533 16.2349 8.39276C16.1729 8.47019 16.1219 8.53522 16.1203 8.53522C16.1187 8.53522 16.0986 8.50736 16.0769 8.4733C15.9035 8.21311 15.696 7.98545 15.4497 7.78103C15.4033 7.7423 15.3522 7.70048 15.3351 7.68809C15.3181 7.67571 15.3041 7.66332 15.3041 7.66178C15.3041 7.65714 15.5674 7.54406 15.7672 7.46355C16.1172 7.32106 16.5942 7.15071 16.9519 7.04074C17.1393 6.9819 17.3391 6.9246 17.3422 6.92771ZM17.4615 6.95866C17.4677 6.95713 17.5048 6.97571 17.5498 7.00201C17.9261 7.21728 18.2947 7.49451 18.5858 7.77948C18.6679 7.86002 18.8708 8.07064 18.8677 8.07218C18.8677 8.07218 18.7964 8.07837 18.7128 8.08456C18.0608 8.13414 17.2261 8.27195 16.4239 8.46553C16.3697 8.4779 16.3217 8.48875 16.3185 8.48875C16.3155 8.48875 16.3759 8.42836 16.4518 8.35558C16.9226 7.90182 17.1378 7.61531 17.3918 7.10423C17.4274 7.02837 17.4584 6.96332 17.4615 6.95866C17.4599 6.95866 17.4599 6.95866 17.4615 6.95866ZM14.0125 7.31179C14.0342 7.31641 14.2356 7.41091 14.3873 7.48678C14.5267 7.55644 14.7358 7.66797 14.7466 7.67725C14.7482 7.67879 14.6738 7.71752 14.5825 7.76244C14.2913 7.90801 14.042 8.04583 13.7818 8.2038C13.7075 8.24872 13.6455 8.28591 13.644 8.28591C13.6378 8.28591 13.6393 8.27968 13.6811 8.2038C13.8205 7.94984 13.932 7.64629 13.9955 7.35048C14.0017 7.32726 14.0079 7.31179 14.0125 7.31179ZM13.8112 7.34894C13.8159 7.35359 13.7632 7.54407 13.7307 7.64784C13.6672 7.84452 13.5603 8.09076 13.4566 8.2766C13.4318 8.31995 13.3946 8.38345 13.3745 8.41906L13.3358 8.48101L13.249 8.3974C13.1484 8.29983 13.0663 8.23943 12.961 8.18521C12.9192 8.16355 12.8867 8.14495 12.8867 8.14187C12.8867 8.12948 13.1515 7.88944 13.3544 7.71598C13.4999 7.59053 13.8066 7.3443 13.8112 7.34894ZM15.0424 7.85537L15.1183 7.90491C15.2918 8.01798 15.4962 8.16819 15.6526 8.29983C15.7409 8.3726 15.9112 8.52594 15.9453 8.56311L15.9639 8.58326L15.8385 8.61887C15.1292 8.81554 14.5809 8.99054 13.9413 9.22596C13.8701 9.25227 13.8097 9.27396 13.805 9.27396C13.7957 9.27396 13.788 9.28169 13.9475 9.13456C14.3564 8.75826 14.7187 8.34318 14.9882 7.93898L15.0424 7.85537ZM14.7188 7.9359C14.7218 7.93898 14.5097 8.23787 14.3827 8.40669C14.2309 8.60802 13.9614 8.94563 13.7756 9.16553C13.6982 9.25692 13.6316 9.3328 13.6285 9.33435C13.6238 9.3359 13.6223 9.31267 13.6223 9.27705C13.6223 9.08964 13.5743 8.88986 13.4906 8.71952C13.455 8.64828 13.4488 8.63124 13.4566 8.62351C13.486 8.59717 13.9367 8.34009 14.2216 8.18678C14.4137 8.08457 14.7141 7.9328 14.7188 7.9359ZM12.7612 8.41599C12.7659 8.41599 12.8015 8.43456 12.8417 8.45626C12.9409 8.51046 13.0291 8.57085 13.1081 8.63591C13.1112 8.639 13.071 8.67153 13.0183 8.71023C12.8712 8.81554 12.6482 8.98436 12.5181 9.08812C12.3818 9.19653 12.3772 9.19963 12.3926 9.1764C12.4949 9.01998 12.5459 8.9317 12.6002 8.81866C12.6482 8.718 12.6962 8.59875 12.7302 8.49498C12.7426 8.45007 12.7581 8.41599 12.7612 8.41599ZM13.2831 8.82484C13.2908 8.82331 13.3002 8.83723 13.342 8.89919C13.4302 9.0308 13.4984 9.20738 13.5154 9.34985L13.5185 9.38084L13.3064 9.46292C12.9269 9.61003 12.5769 9.75562 12.34 9.86401C12.2734 9.895 12.1572 9.95074 12.0813 9.98793C12.0055 10.0266 11.9435 10.0561 11.9435 10.0545C11.9435 10.053 11.9915 10.0173 12.0504 9.97397C12.5134 9.63792 12.9145 9.26931 13.215 8.90074C13.2475 8.86201 13.2769 8.82638 13.28 8.82484L13.2831 8.82484ZM13.0431 8.8837C13.0493 8.88989 12.8727 9.08966 12.7519 9.212C12.453 9.51711 12.1572 9.75562 11.7902 9.98793C11.7437 10.0173 11.7019 10.0437 11.6973 10.0468C11.6864 10.053 11.7003 10.0375 11.8614 9.86247C11.9636 9.75251 12.0411 9.65959 12.1293 9.545C12.1882 9.46913 12.199 9.45828 12.2842 9.39786C12.5119 9.23369 13.0369 8.87749 13.0431 8.8837Z",
        fill: "url(#paint2_radial_849_49341)"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M6.33689 15.2973C6.30832 15.2973 6.27974 15.3 6.25143 15.3C5.67439 15.3307 5.2852 15.5847 5.05765 16.0806C4.86303 16.5291 4.88428 17.1154 5.05984 17.5666C5.26398 18.0076 5.59385 18.2403 6.14446 18.3282C6.26095 18.3473 6.33907 18.4112 6.56471 18.6747L6.84234 18.9999H7.34586L7.01105 18.6624C6.82597 18.4773 6.67627 18.3162 6.67627 18.302C6.67627 18.2879 6.74707 18.2569 6.83277 18.2308C7.1153 18.1453 7.34992 17.927 7.51404 17.5925C7.64686 17.3239 7.66593 17.2408 7.68497 16.9066C7.73479 15.9118 7.21029 15.2899 6.33686 15.297L6.33689 15.2973ZM6.77835 17.8987C6.53339 18.0174 6.17769 18.0411 5.94551 17.9559C5.70544 17.8677 5.47301 17.6184 5.36847 17.3361C5.25226 17.0275 5.26885 16.4581 5.40168 16.2017C5.61534 15.7934 5.89788 15.6056 6.31076 15.6056C6.92315 15.6056 7.27153 15.9807 7.317 16.6856C7.35293 17.2741 7.15586 17.7156 6.77861 17.8985L6.77835 17.8987ZM15.4766 16.147C15.2654 16.147 15.1037 16.2325 14.9948 16.4009L14.9094 16.5343V16.1875H14.5438V18.267H14.9091V17.6023C14.9091 16.9945 14.9167 16.9235 15.0016 16.7572C15.1187 16.5291 15.3201 16.4154 15.5147 16.4698L15.6454 16.5079V16.1475H15.4766V16.147ZM13.3291 16.1279C13.2575 16.1279 13.1816 16.1375 13.106 16.1541C12.6168 16.282 12.3411 16.7501 12.358 17.2319C12.358 17.6353 12.4364 17.8369 12.631 18.0484C13.0297 18.3756 13.3904 18.4017 13.877 18.2262C13.96 18.1908 14.0504 18.15 14.0504 18.15V17.8228L13.877 17.9126C13.4832 18.0841 13.1865 18.0841 12.9489 17.8821C12.7973 17.7278 12.7306 17.5427 12.6999 17.3315H14.1737V17.0511C14.1737 16.4796 13.8297 16.1187 13.3288 16.1279H13.3291ZM12.733 17.0397C12.733 17.0397 12.7875 16.6832 12.9894 16.5433C13.0866 16.4747 13.1982 16.4415 13.3073 16.4415C13.4168 16.4415 13.5259 16.4769 13.616 16.5457C13.8011 16.6881 13.8321 17.037 13.8321 17.037H12.7331V17.0397H12.733ZM3.92076 16.6647C3.52448 16.4246 3.34865 16.2515 3.37015 16.0474C3.43165 15.4826 4.12953 15.5607 4.51601 15.7744L4.51876 15.3944C4.51876 15.3944 4.30509 15.3019 3.99888 15.297C3.5291 15.2899 3.22535 15.444 3.08302 15.7575C2.87397 16.2202 3.05907 16.5691 3.7281 16.9584C4.10369 17.1769 4.2697 17.3666 4.2697 17.5735C4.2697 18.0008 3.75448 18.15 3.22293 17.8818C3.11353 17.8274 3.02098 17.782 3.01608 17.782C2.99702 17.9031 3.00685 18.1929 3.00685 18.1929C3.00685 18.1929 3.17016 18.2615 3.4151 18.3089C4.02257 18.43 4.57539 18.145 4.62764 17.6823C4.6731 17.2479 4.51602 17.0201 3.92078 16.6644L3.92076 16.6647ZM18.7117 16.123C18.6404 16.123 18.5647 16.1328 18.4858 16.1494C17.9972 16.2774 17.722 16.7455 17.7408 17.2273C17.7408 17.6301 17.8189 17.8299 18.0135 18.0411C18.4123 18.3685 18.7729 18.3949 19.262 18.2191C19.3448 18.1837 19.4349 18.1435 19.4349 18.1435V17.8158L19.2618 17.9061C18.8671 18.077 18.5704 18.077 18.3337 17.8751C18.1812 17.721 18.1151 17.5381 18.0843 17.3244H19.5557V17.0441C19.5557 16.4753 19.2117 16.1141 18.7109 16.1236L18.7117 16.123ZM18.1156 17.0348C18.1156 17.0348 18.1706 16.6788 18.3723 16.5362C18.4692 16.4673 18.5808 16.4341 18.6899 16.4341C18.7988 16.4341 18.9085 16.4695 18.9986 16.5386C19.1837 16.681 19.2147 17.0324 19.2147 17.0324H18.1159L18.1156 17.0348ZM11.4157 16.6693C11.0194 16.4298 10.8441 16.2561 10.8654 16.052C10.9269 15.4869 11.6248 15.5653 12.0112 15.779L12.014 15.3991C12.014 15.3991 11.8003 15.3065 11.4941 15.3021C11.0243 15.2951 10.7206 15.4491 10.578 15.7627C10.3692 16.2253 10.5567 16.5743 11.2236 16.9635C11.5986 17.1818 11.7647 17.3691 11.7647 17.5759C11.7647 18.0032 11.2497 18.1548 10.7181 17.8843C10.6093 17.8298 10.5167 17.7849 10.5113 17.7849C10.4922 17.906 10.502 18.1959 10.502 18.1959C10.502 18.1959 10.6634 18.2621 10.9076 18.3119C11.5156 18.4333 12.0687 18.1485 12.1207 17.6858C12.1659 17.2536 12.0091 17.0258 11.4157 16.6698V16.6693H11.4157ZM20.8594 16.1421C20.6482 16.1421 20.4847 16.2278 20.3777 16.3963L20.2922 16.5291V16.1829H19.9267V18.2618H20.2919V17.5972C20.2919 16.9897 20.2993 16.9183 20.3845 16.7523C20.5015 16.5245 20.7029 16.4105 20.8975 16.4652L21.0282 16.5033V16.1421H20.8594V16.1421ZM8.50886 16.6573V15.3329H8.14035V18.2664H9.69014V17.92H8.50888V16.6573H8.50886ZM17.0313 17.0702L16.7275 17.8606L16.4355 17.0658L16.1388 16.1851H15.7616C16.006 16.8781 16.2719 17.583 16.54 18.2664C16.6562 18.2691 16.7727 18.2664 16.8889 18.2664L17.2991 17.2365L17.7169 16.1854H17.3563C17.3563 16.1854 17.197 16.6029 17.031 17.0705L17.0313 17.0702ZM9.35805 14.5335C9.41739 14.5335 9.46692 14.5145 9.50775 14.4736C9.54801 14.4333 9.56925 14.386 9.56925 14.3267C9.56925 14.2673 9.54801 14.2178 9.50775 14.1797C9.46692 14.1416 9.41983 14.1225 9.36076 14.1225C9.3009 14.1225 9.25135 14.1416 9.21106 14.1818C9.17025 14.2221 9.15173 14.2717 9.15173 14.3288C9.15173 14.3887 9.1708 14.4382 9.21106 14.4758C9.24918 14.5139 9.29872 14.533 9.35805 14.533V14.5335ZM9.22742 14.196C9.26279 14.1606 9.3058 14.1443 9.36077 14.1443C9.4125 14.1443 9.45551 14.1606 9.49144 14.196C9.52682 14.2314 9.54588 14.2744 9.54588 14.3267C9.54588 14.3789 9.52682 14.4241 9.49144 14.4595C9.45552 14.4948 9.4125 14.5117 9.36077 14.5117C9.30825 14.5117 9.26551 14.4954 9.23014 14.4595C9.19476 14.4241 9.17571 14.3789 9.17571 14.3267C9.17571 14.2744 9.19203 14.2314 9.22742 14.196ZM9.31531 14.3457H9.33926C9.35615 14.3457 9.37275 14.362 9.38689 14.3931L9.4155 14.4573H9.46039L9.42502 14.386C9.4106 14.3574 9.39646 14.3408 9.37984 14.3361C9.4008 14.3313 9.41739 14.3242 9.42938 14.31C9.44133 14.2978 9.44569 14.2812 9.44569 14.2624C9.44569 14.2406 9.43889 14.2243 9.42448 14.2123C9.40814 14.1987 9.38201 14.1914 9.34825 14.1914H9.27261V14.4573H9.31071V14.3457L9.31531 14.3457ZM9.31531 14.2221H9.34854C9.37248 14.2221 9.38936 14.227 9.39861 14.2341C9.4076 14.2412 9.41005 14.2505 9.41005 14.2673C9.41005 14.2981 9.39097 14.3125 9.35561 14.3125H9.3148V14.2221H9.31531ZM3.22778 14.322C3.22778 14.2295 3.22507 14.1606 3.22289 14.1201H3.22507C3.23459 14.168 3.2463 14.2036 3.25582 14.2273L3.60964 15.0177H3.66898L4.0228 14.2202C4.03235 14.1985 4.04188 14.1658 4.05357 14.1203H4.05629C4.04922 14.1993 4.04677 14.2679 4.04677 14.3226V15.0202H4.16786V13.9832H4.016L3.69076 14.7044C3.67877 14.733 3.66217 14.7758 3.64094 14.8324H3.63602C3.62896 14.8043 3.61235 14.7616 3.58868 14.7093L3.27076 13.9807H3.10938V15.0177H3.22586V14.3225L3.22778 14.322ZM4.43326 14.324H4.5378V14.9698H4.43326V14.324ZM4.48552 14.0871C4.50731 14.0871 4.52581 14.0798 4.53996 14.0654C4.55439 14.0512 4.56393 14.0327 4.56393 14.011C4.56393 13.9897 4.55684 13.9706 4.54024 13.9565C4.52555 13.9421 4.50676 13.9347 4.48526 13.9347C4.46405 13.9347 4.44499 13.9421 4.43081 13.9565C4.41643 13.9706 4.40688 13.9897 4.40688 14.011C4.40688 14.0346 4.41423 14.0512 4.43081 14.0654C4.44718 14.0798 4.46403 14.0871 4.48526 14.0871H4.48552ZM5.28302 14.984V14.8702C5.22585 14.9129 5.16434 14.9342 5.10065 14.9342C5.02447 14.9342 4.96265 14.9081 4.91747 14.858C4.87257 14.8085 4.84863 14.7396 4.84863 14.6538C4.84863 14.564 4.87257 14.4927 4.9221 14.4383C4.96973 14.386 5.03153 14.3599 5.1072 14.3599C5.16898 14.3599 5.22829 14.3789 5.28303 14.4171V14.2959C5.23323 14.2698 5.17635 14.2578 5.1121 14.2578C4.99342 14.2578 4.9009 14.2959 4.83177 14.3695C4.76317 14.4429 4.72778 14.5428 4.72778 14.6634C4.72778 14.7706 4.75853 14.8607 4.82252 14.9296C4.88919 15.0004 4.97441 15.0363 5.07891 15.0363C5.15972 15.0341 5.22585 15.0172 5.28302 14.984ZM5.58213 14.6397C5.58213 14.5545 5.60118 14.4856 5.63656 14.4382C5.66978 14.3955 5.71005 14.374 5.75768 14.374C5.79797 14.374 5.82653 14.3814 5.84748 14.398V14.2744C5.83117 14.2673 5.80748 14.2649 5.77673 14.2649C5.734 14.2649 5.69592 14.2793 5.66243 14.3057C5.62705 14.3337 5.59874 14.3765 5.58214 14.4309H5.57943V14.2793H5.46103V15.0196H5.57969V14.6397H5.58213ZM6.26339 15.0343C6.37499 15.0343 6.46481 14.9984 6.53148 14.9271C6.59788 14.8563 6.63109 14.7611 6.63109 14.6424C6.63109 14.5213 6.60063 14.4287 6.53856 14.3598C6.47706 14.291 6.39158 14.2578 6.27997 14.2578C6.16837 14.2578 6.07855 14.291 6.01188 14.3552C5.94057 14.426 5.90301 14.5259 5.90301 14.6541C5.90301 14.7657 5.9335 14.8582 5.99775 14.9271C6.06414 14.9984 6.15206 15.034 6.26339 15.034V15.0343ZM6.09464 14.4312C6.13982 14.3835 6.19918 14.3598 6.27264 14.3598C6.34888 14.3598 6.40602 14.3835 6.44848 14.4312C6.49121 14.481 6.51245 14.552 6.51245 14.647C6.51245 14.7374 6.49339 14.8084 6.4531 14.856C6.41284 14.9059 6.35349 14.9322 6.27509 14.9322C6.19889 14.9322 6.13982 14.9058 6.09464 14.856C6.04974 14.806 6.02823 14.7374 6.02823 14.647C6.02361 14.5572 6.0473 14.4837 6.09464 14.4312ZM7.15071 14.9698C7.19588 14.9296 7.21985 14.88 7.21985 14.8179C7.21985 14.7635 7.20077 14.7183 7.1654 14.6827C7.13654 14.6541 7.09193 14.6282 7.02742 14.6021C6.97023 14.5782 6.93486 14.5569 6.9158 14.5403C6.89676 14.5213 6.88505 14.4976 6.88505 14.4641C6.88505 14.4334 6.89703 14.4097 6.92045 14.3906C6.9444 14.3716 6.97489 14.3623 7.01572 14.3623C7.07968 14.3623 7.13438 14.3792 7.18444 14.4149V14.2962C7.13655 14.2723 7.08456 14.2608 7.02522 14.2608C6.94902 14.2608 6.88478 14.2818 6.8374 14.3223C6.78759 14.3626 6.76393 14.4149 6.76393 14.4764C6.76393 14.5308 6.78025 14.576 6.81126 14.6092C6.83739 14.6375 6.88206 14.6664 6.94409 14.6922C7.00344 14.7183 7.04372 14.742 7.06521 14.761C7.08643 14.7801 7.09596 14.8038 7.09596 14.8318C7.09596 14.901 7.04861 14.9366 6.95606 14.9366C6.88475 14.9366 6.82081 14.9132 6.76362 14.8659V14.9938C6.81534 15.0248 6.8774 15.039 6.94598 15.039C7.0339 15.0343 7.10275 15.0128 7.15012 14.9701L7.15071 14.9698ZM7.71574 14.2578C7.60413 14.2578 7.51432 14.291 7.44764 14.3552C7.37688 14.426 7.33877 14.5259 7.33877 14.6541C7.33877 14.7657 7.36955 14.8583 7.4335 14.9271C7.50018 14.9984 7.58781 15.0341 7.69942 15.0341C7.81372 15.0341 7.90084 14.9982 7.96751 14.9268C8.03419 14.8561 8.06739 14.7608 8.06739 14.6421C8.06739 14.521 8.03636 14.4285 7.97484 14.3596C7.91064 14.2907 7.82514 14.2575 7.71627 14.2575L7.71574 14.2578ZM7.946 14.647C7.946 14.7374 7.92694 14.8084 7.88667 14.8561C7.84638 14.9059 7.78704 14.9323 7.70864 14.9323C7.63241 14.9323 7.57337 14.9058 7.52817 14.8561C7.48327 14.806 7.46177 14.7374 7.46177 14.647C7.46177 14.5518 7.48547 14.4783 7.5331 14.4287C7.57798 14.3814 7.63735 14.3574 7.7111 14.3574C7.78458 14.3574 7.84365 14.3813 7.88637 14.4287C7.92448 14.481 7.94572 14.552 7.94572 14.647H7.946ZM8.26664 15.0175H8.38503V14.3765H8.5584V14.2769H8.38502V14.1625C8.38502 14.0586 8.42529 14.0063 8.50859 14.0063C8.53663 14.0063 8.56521 14.0134 8.58644 14.0254V13.9184C8.56521 13.9089 8.53663 13.9067 8.50094 13.9067C8.437 13.9067 8.38475 13.9258 8.342 13.9661C8.29218 14.0134 8.2658 14.0749 8.2658 14.1583V14.2796H8.14056V14.3793H8.2658V15.0178L8.26664 15.0175ZM8.753 14.8155C8.753 14.9603 8.81698 15.0341 8.94761 15.0341C8.99498 15.0341 9.03063 15.0265 9.05921 15.0096V14.9078C9.03744 14.9241 9.01157 14.9318 8.98301 14.9318C8.94274 14.9318 8.91443 14.9222 8.89781 14.9007C8.88093 14.8795 8.87142 14.8435 8.87142 14.794V14.3762H9.05919V14.2766H8.87142V14.0583C8.83059 14.0725 8.79059 14.0844 8.75273 14.0964V14.2766H8.62481V14.3762H8.75273V14.8152L8.753 14.8155ZM21.4909 16.1802C21.4506 16.1421 21.403 16.123 21.3439 16.123C21.2841 16.123 21.2345 16.1421 21.1942 16.1829C21.1539 16.2229 21.1349 16.2727 21.1349 16.3299C21.1349 16.3892 21.1539 16.4388 21.1939 16.4769C21.2342 16.515 21.2837 16.534 21.3436 16.534C21.4027 16.534 21.4525 16.515 21.4933 16.4747C21.5334 16.4339 21.5546 16.3868 21.5546 16.3277C21.5524 16.2678 21.5309 16.2183 21.4906 16.1802L21.4909 16.1802ZM21.4719 16.4605C21.4365 16.4959 21.3935 16.5122 21.3412 16.5122C21.2895 16.5122 21.2465 16.4959 21.2106 16.4605C21.1752 16.4246 21.1561 16.3797 21.1561 16.3272C21.1561 16.2754 21.1724 16.2325 21.2084 16.1965C21.2437 16.1612 21.2865 16.1448 21.3412 16.1448C21.3929 16.1448 21.4359 16.1612 21.4719 16.1965C21.5072 16.2325 21.5263 16.2754 21.5263 16.3272C21.5263 16.3822 21.5099 16.4246 21.4719 16.4605ZM21.3651 16.3394C21.3864 16.3345 21.4033 16.325 21.415 16.3133C21.4269 16.301 21.4313 16.2844 21.4313 16.2654C21.4313 16.2442 21.4245 16.2273 21.4101 16.2156C21.3938 16.202 21.3674 16.1946 21.3339 16.1946H21.2582V16.4603H21.2964V16.3487H21.32C21.3364 16.3487 21.3527 16.365 21.3674 16.396L21.3957 16.46H21.4409L21.4055 16.3886C21.3932 16.3576 21.3791 16.3435 21.3647 16.3388L21.3651 16.3394ZM21.339 16.3155H21.2982V16.2257H21.3317C21.3554 16.2257 21.372 16.23 21.3815 16.2374C21.391 16.2444 21.3932 16.2537 21.3932 16.2706C21.3932 16.3013 21.3741 16.3155 21.3388 16.3155L21.339 16.3155ZM14.7172 14.2461H14.7504V13.9802H14.8383V13.947H14.6293V13.9802H14.7173V14.2461H14.7172ZM14.9186 14.0463C14.9186 14.0205 14.9186 13.9992 14.9167 13.9873C14.9189 14.0014 14.9238 14.011 14.926 14.018L15.0281 14.2461H15.0444L15.1467 14.0158C15.1495 14.0088 15.1517 13.9995 15.1563 13.9873C15.1541 14.011 15.1541 14.03 15.1541 14.0444V14.2458H15.1895V13.947H15.1467L15.0542 14.1533C15.052 14.1607 15.0446 14.1751 15.04 14.1914H15.0373C15.0354 14.1819 15.0305 14.1723 15.0237 14.156L14.9312 13.947H14.8833V14.2464H14.9167V14.0466L14.9186 14.0463Z",
        fill: "#231F1F"
      })]
    }), /*#__PURE__*/jsxRuntime.jsxs("defs", {
      children: [/*#__PURE__*/jsxRuntime.jsxs("linearGradient", {
        id: "paint0_linear_849_49341",
        x1: "11.2197",
        y1: "13.2187",
        x2: "11.9606",
        y2: "12.781",
        gradientUnits: "userSpaceOnUse",
        children: [/*#__PURE__*/jsxRuntime.jsx("stop", {
          stopColor: "#909CA9"
        }), /*#__PURE__*/jsxRuntime.jsx("stop", {
          offset: "1",
          stopColor: "#EDEDEE"
        })]
      }), /*#__PURE__*/jsxRuntime.jsxs("linearGradient", {
        id: "paint1_linear_849_49341",
        x1: "11.2364",
        y1: "4.96503",
        x2: "11.8325",
        y2: "4.96503",
        gradientUnits: "userSpaceOnUse",
        children: [/*#__PURE__*/jsxRuntime.jsx("stop", {
          stopColor: "#939FAB"
        }), /*#__PURE__*/jsxRuntime.jsx("stop", {
          offset: "1",
          stopColor: "#DCDEE1"
        })]
      }), /*#__PURE__*/jsxRuntime.jsxs("radialGradient", {
        id: "paint2_radial_849_49341",
        cx: "0",
        cy: "0",
        r: "1",
        gradientUnits: "userSpaceOnUse",
        gradientTransform: "translate(14.2447 7.69887) rotate(-171.457) scale(0.768587 1.53756)",
        children: [/*#__PURE__*/jsxRuntime.jsx("stop", {
          stopColor: "#EE352C"
        }), /*#__PURE__*/jsxRuntime.jsx("stop", {
          offset: "1",
          stopColor: "#A91D22"
        })]
      }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
        id: "clip0_849_49341",
        children: /*#__PURE__*/jsxRuntime.jsx("rect", {
          width: "18.5552",
          height: "15",
          fill: "white",
          transform: "translate(3 4)"
        })
      })]
    })]
  });
};
var MongoDB = function MongoDB(_ref5) {
  var className = _ref5.className,
    _ref5$circular = _ref5.circular,
    circular = _ref5$circular === void 0 ? false : _ref5$circular;
  if (circular) {
    return /*#__PURE__*/jsxRuntime.jsxs("svg", {
      className: className,
      width: "1.5rem",
      height: "1.5rem",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
        cx: "12",
        cy: "12",
        r: "12",
        fill: "#DEFBE6"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M11.9864 3.04956L12.4667 3.95171C12.5747 4.11819 12.6917 4.26555 12.8295 4.40279C13.2335 4.80174 13.61 5.22754 13.9566 5.67727C14.7704 6.74591 15.3194 7.93265 15.7114 9.21614C15.9465 10.0002 16.0742 10.8045 16.0837 11.6178C16.1231 14.0492 15.2896 16.1369 13.609 17.8721C13.3356 18.1472 13.0403 18.3997 12.726 18.6269C12.5595 18.6269 12.4807 18.4992 12.4121 18.3816C12.2872 18.1637 12.204 17.9243 12.1669 17.6758C12.1079 17.3816 12.069 17.0875 12.0882 16.7838V16.6465C12.0747 16.6173 11.9279 3.11874 11.9864 3.04956Z",
        fill: "#599636"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M11.986 3.01935C11.9664 2.97998 11.9467 3.00979 11.927 3.02891C11.9366 3.22576 11.8679 3.40125 11.7605 3.56885C11.6424 3.73533 11.486 3.86301 11.3291 4.00024C10.4573 4.75504 9.77116 5.66675 9.22166 6.68645C8.49049 8.0588 8.11366 9.52958 8.00679 11.078C7.95786 11.6365 8.1834 13.6073 8.35944 14.1759C8.83976 15.6855 9.70255 16.9504 10.8201 18.0483C11.0946 18.3126 11.3882 18.5578 11.6919 18.7935C11.7802 18.7935 11.7898 18.7148 11.81 18.6563C11.8487 18.5311 11.8782 18.4033 11.8983 18.2738L12.0952 16.8036L11.986 3.01935Z",
        fill: "#6CAC48"
      }), /*#__PURE__*/jsxRuntime.jsx("path", {
        d: "M12.4659 19.2243C12.4856 18.9993 12.5936 18.8126 12.7111 18.6264C12.593 18.5775 12.5053 18.4802 12.4366 18.3716C12.3775 18.2688 12.3285 18.1605 12.2904 18.0482C12.1532 17.6365 12.1239 17.2045 12.0846 16.7838V16.5291C12.0356 16.5684 12.0255 16.9014 12.0255 16.9509C11.9969 17.3955 11.9379 17.8377 11.8489 18.2743C11.8196 18.4509 11.8 18.6269 11.6914 18.7839C11.6914 18.8036 11.6914 18.8232 11.701 18.8525C11.8776 19.3722 11.9259 19.9014 11.9558 20.4408V20.6377C11.9558 20.8728 11.9462 20.8233 12.1414 20.902C12.2201 20.9313 12.3078 20.9414 12.3866 20.9999C12.4456 20.9999 12.4552 20.9509 12.4552 20.9116L12.426 20.5882V19.686C12.4164 19.5285 12.4456 19.3722 12.4653 19.2248L12.4659 19.2243Z",
        fill: "#C2BFBF"
      })]
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs("svg", {
    className: className,
    width: "1.5rem",
    height: "1.5rem",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M11.1249 3.8606L11.6017 4.75609C11.7089 4.92134 11.825 5.06761 11.9618 5.20384C12.3628 5.59984 12.7366 6.0225 13.0806 6.46892C13.8885 7.52966 14.4334 8.70765 14.8225 9.98166C15.0558 10.7599 15.1826 11.5583 15.1921 12.3656C15.2311 14.779 14.4038 16.8514 12.7356 18.5737C12.4643 18.8468 12.1711 19.0974 11.8591 19.3229C11.6938 19.3229 11.6157 19.1962 11.5476 19.0795C11.4235 18.8632 11.341 18.6255 11.3041 18.3789C11.2455 18.0869 11.207 17.7949 11.226 17.4934V17.3572C11.2126 17.3282 11.0669 3.92927 11.1249 3.8606Z",
      fill: "#599636"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M11.1246 3.83049C11.1051 3.79141 11.0855 3.821 11.066 3.83998C11.0755 4.03538 11.0074 4.20956 10.9007 4.37593C10.7835 4.54119 10.6283 4.66792 10.4725 4.80414C9.60717 5.55336 8.92606 6.45835 8.38061 7.47052C7.65484 8.83275 7.28079 10.2927 7.17471 11.8296C7.12614 12.384 7.35001 14.3403 7.52476 14.9047C8.00154 16.4031 8.85795 17.6587 9.96727 18.7485C10.2397 19.0109 10.5311 19.2543 10.8326 19.4882C10.9203 19.4882 10.9298 19.4101 10.9499 19.352C10.9883 19.2278 11.0176 19.1009 11.0375 18.9724L11.2329 17.513L11.1246 3.83049Z",
      fill: "#6CAC48"
    }), /*#__PURE__*/jsxRuntime.jsx("path", {
      d: "M11.6013 19.916C11.6208 19.6927 11.728 19.5074 11.8447 19.3226C11.7275 19.274 11.6404 19.1774 11.5723 19.0697C11.5135 18.9677 11.4649 18.8601 11.4271 18.7487C11.2909 18.34 11.2618 17.9112 11.2228 17.4936V17.2407C11.1742 17.2798 11.1641 17.6103 11.1641 17.6594C11.1357 18.1008 11.0772 18.5397 10.9888 18.9731C10.9598 19.1484 10.9403 19.3231 10.8325 19.4789C10.8325 19.4984 10.8325 19.518 10.842 19.547C11.0173 20.0629 11.0653 20.5882 11.0949 21.1236V21.319C11.0949 21.5524 11.0854 21.5033 11.2791 21.5814C11.3573 21.6104 11.4444 21.6205 11.5226 21.6786C11.5812 21.6786 11.5907 21.63 11.5907 21.5909L11.5616 21.2699V20.3744C11.5522 20.2181 11.5812 20.0629 11.6007 19.9166L11.6013 19.916Z",
      fill: "#C2BFBF"
    })]
  });
};
var Databases = {
  Oracle: Oracle,
  MSSql: MSSql,
  MongoDB: MongoDB,
  PgSql: PgSql,
  MySql: MySql
};

var css$11 = ".Accordion_module_root__679b7121 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  width: 100%;\n}\n.Accordion_module_root__679b7121 > .Accordion_module_header__679b7121[data-elem=base-cell] {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.5rem 1rem;\n  cursor: pointer;\n}\n.Accordion_module_root__679b7121 > .Accordion_module_header__679b7121[data-elem=base-cell] > [data-elem=component1] {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n}\n.Accordion_module_root__679b7121 > .Accordion_module_header__679b7121[data-elem=base-cell] > [data-elem=component1] .Accordion_module_icon__679b7121 {\n  transform: rotate(-90deg);\n  width: 1rem;\n  height: 1rem;\n  fill: var(--dark-grey);\n}\n.Accordion_module_root__679b7121 > .Accordion_module_header__679b7121[data-elem=base-cell] .Accordion_module_title__679b7121 {\n  flex: 1 1 auto;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.Accordion_module_root__679b7121 > .Accordion_module_header__679b7121[data-elem=base-cell]:hover {\n  background: var(--background);\n}\n.Accordion_module_root__679b7121 > .Accordion_module_header__679b7121[data-elem=base-cell]:hover .Accordion_module_icon__679b7121,\n.Accordion_module_root__679b7121 > .Accordion_module_header__679b7121[data-elem=base-cell]:hover .Accordion_module_title__679b7121 {\n  color: var(--highlight);\n  fill: var(--highlight);\n}\n.Accordion_module_root__679b7121 > .Accordion_module_body__679b7121 {\n  display: none;\n  padding: 0.5rem 2.5rem;\n}\n.Accordion_module_root__679b7121.Accordion_module_open__679b7121 > .Accordion_module_header__679b7121[data-elem=base-cell] [data-elem=component1] .Accordion_module_icon__679b7121 {\n  transform: none;\n}\n.Accordion_module_root__679b7121.Accordion_module_open__679b7121 > .Accordion_module_body__679b7121 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.Accordion_module_root__679b7121.Accordion_module_open__679b7121 > .Accordion_module_body__679b7121 > button[data-elem=base-cell] {\n  width: -webkit-fit-content;\n  width: -moz-fit-content;\n  width: fit-content;\n  align-self: flex-end;\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  align-items: center;\n}\n.Accordion_module_root__679b7121.Accordion_module_open__679b7121 > .Accordion_module_body__679b7121 > button[data-elem=base-cell] .Accordion_module_expand__679b7121 {\n  height: 1.5rem;\n  width: 1.5rem;\n}";
var modules_8207625f = {"root":"Accordion_module_root__679b7121","header":"Accordion_module_header__679b7121","icon":"Accordion_module_icon__679b7121","title":"Accordion_module_title__679b7121","body":"Accordion_module_body__679b7121","open":"Accordion_module_open__679b7121","expand":"Accordion_module_expand__679b7121"};
n(css$11,{});

var Accordion = function Accordion(props) {
  var open = props.open,
    onToggle = props.onToggle,
    defaultOpen = props.defaultOpen,
    iconPlacement = props.iconPlacement,
    title = props.title,
    description = props.description,
    children = props.children,
    _onClick = props.onClick,
    className = props.className,
    onExpand = props.onExpand,
    CustomIcon = props.icon;

  // uncontrolled
  var _useState = React.useState(defaultOpen),
    _useState2 = _slicedToArray(_useState, 2),
    uncontrolledOpen = _useState2[0],
    setUncontrolledOpen = _useState2[1];
  var _useRef = React.useRef(open !== undefined),
    isControlled = _useRef.current;
  var isOpen = isControlled ? open : uncontrolledOpen;
  var Icon = Caret;
  if (CustomIcon) {
    Icon = CustomIcon;
  }
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(className, modules_8207625f.root, isOpen ? modules_8207625f.open : ''),
    "data-state-open": isOpen,
    children: [/*#__PURE__*/jsxRuntime.jsx(BaseCell, {
      flexible: true,
      size: "auto",
      rootDOM: "button",
      className: modules_8207625f.header,
      attrs: {
        onClick: function onClick() {
          if (isControlled) {
            onToggle(open);
          } else {
            setUncontrolledOpen(function (prevState) {
              var newState = !prevState;
              _onClick(newState);
              return newState;
            });
          }
        }
      },
      component1: iconPlacement === 'left' && /*#__PURE__*/jsxRuntime.jsx(Icon, {
        className: modules_8207625f.icon
      }),
      component2: /*#__PURE__*/jsxRuntime.jsx("span", {
        className: modules_8207625f.title,
        children: title
      }),
      component3: iconPlacement === 'right' && /*#__PURE__*/jsxRuntime.jsx(Icon, {
        className: modules_8207625f.icon
      })
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      "data-elem": "body",
      className: modules_8207625f.body,
      children: [description && /*#__PURE__*/jsxRuntime.jsx("p", {
        children: description
      }), children, onExpand && /*#__PURE__*/jsxRuntime.jsx(Button, {
        size: "auto",
        variant: "text",
        onClick: function onClick() {
          onExpand();
        },
        rightComponent: function rightComponent() {
          return /*#__PURE__*/jsxRuntime.jsx(ExpandArrowAlt, {
            className: modules_8207625f.expand
          });
        }
      })]
    })]
  });
};
Accordion.propTypes = {
  open: propTypes$1.exports.bool,
  onToggle: propTypes$1.exports.func,
  iconPlacement: propTypes$1.exports.oneOf(['left', 'right', 'none']),
  title: propTypes$1.exports.node,
  description: propTypes$1.exports.string,
  defaultOpen: propTypes$1.exports.bool,
  onClick: propTypes$1.exports.func,
  className: propTypes$1.exports.string,
  onExpand: propTypes$1.exports.func
};
Accordion.defaultProps = {
  open: undefined,
  onToggle: null,
  iconPlacement: 'left',
  title: null,
  description: null,
  defaultOpen: false,
  onClick: function onClick() {},
  className: '',
  onExpand: null
};

function getSide(placement) {
  return placement.split('-')[0];
}

function getAlignment(placement) {
  return placement.split('-')[1];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';
}

function getLengthFromAxis(axis) {
  return axis === 'y' ? 'height' : 'width';
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === 'x';
  let coords;

  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;

    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;

    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }

  switch (getAlignment(placement)) {
    case 'start':
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;

    case 'end':
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }

  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */

const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));

  if (process.env.NODE_ENV !== "production") {
    if (platform == null) {
      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));
    }

    if (middleware.filter(_ref => {
      let {
        name
      } = _ref;
      return name === 'autoPlacement' || name === 'flip';
    }).length > 1) {
      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));
    }
  }

  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;

  for (let i = 0; i < middleware.length; i++) {
    const {
      name,
      fn
    } = middleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = { ...middlewareData,
      [name]: { ...middlewareData[name],
        ...data
      }
    };

    if (process.env.NODE_ENV !== "production") {
      if (resetCount > 50) {
        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));
      }
    }

    if (reset && resetCount <= 50) {
      resetCount++;

      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }

        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }

        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }

      i = -1;
      continue;
    }
  }

  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}

function getSideObjectFromPadding(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}

function rectToClientRect(rect) {
  return { ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;

  if (options === void 0) {
    options = {};
  }

  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === 'floating' ? { ...rects.floating,
      x,
      y
    } : rects.reference,
    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]);
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}

const min$3 = Math.min;
const max$3 = Math.max;

function within$1(min$1, value, max$1) {
  return max$3(min$1, min$3(value, max$1));
}

/**
 * Positions an inner element of the floating element such that it is centered
 * to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow$1 = options => ({
  name: 'arrow',
  options,

  async fn(middlewareArguments) {
    // Since `element` is required, we don't Partial<> the type
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x,
      y,
      placement,
      rects,
      platform
    } = middlewareArguments;

    if (element == null) {
      if (process.env.NODE_ENV !== "production") {
        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');
      }

      return {};
    }

    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const alignment = getAlignment(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const minProp = axis === 'y' ? 'top' : 'left';
    const maxProp = axis === 'y' ? 'bottom' : 'right';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;

    if (clientSize === 0) {
      clientSize = rects.floating[length];
    }

    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds

    const min = paddingObject[minProp];
    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = within$1(min, center, max); // Make sure that arrow points at the reference

    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];
    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];
    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset
      }
    };
  }

});

const hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);
}

function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }

  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';

  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }

  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}

const hash = {
  start: 'end',
  end: 'start'
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, matched => hash[matched]);
}

function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}

/**
 * Changes the placement of the floating element to one that will fit if the
 * initially specified `placement` does not.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'flip',
    options,

    async fn(middlewareArguments) {
      var _middlewareData$flip;

      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];

      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }

      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
        overflows.push(overflow[main], overflow[cross]);
      }

      overflowsData = [...overflowsData, {
        placement,
        overflows
      }]; // One or more sides is overflowing

      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;

        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];

        if (nextPlacement) {
          // Try next placement and re-run the lifecycle
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        let resetPlacement = 'bottom';

        switch (fallbackStrategy) {
          case 'bestFit':
            {
              var _overflowsData$map$so;

              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;

              if (placement) {
                resetPlacement = placement;
              }

              break;
            }

          case 'initialPlacement':
            resetPlacement = initialPlacement;
            break;
        }

        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }

      return {};
    }

  };
};

async function convertValueToCoords(middlewareArguments, value) {
  const {
    placement,
    platform,
    elements
  } = middlewareArguments;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === 'x';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const

  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };

  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }

  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
/**
 * Displaces the floating element from its reference element.
 * @see https://floating-ui.com/docs/offset
 */

const offset = function (value) {
  if (value === void 0) {
    value = 0;
  }

  return {
    name: 'offset',
    options: value,

    async fn(middlewareArguments) {
      const {
        x,
        y
      } = middlewareArguments;
      const diffCoords = await convertValueToCoords(middlewareArguments, value);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }

  };
};

function getCrossAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/**
 * Shifts the floating element in order to keep it in view when it will overflow
 * a clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'shift',
    options,

    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];

      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within$1(min, mainAxisCoord, max);
      }

      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within$1(min, crossAxisCoord, max);
      }

      const limitedCoords = limiter.fn({ ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return { ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }

  };
};

/**
 * Provides data to change the size of the floating element. For instance,
 * prevent it from overflowing its clipping boundary or match the width of the
 * reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'size',
    options,

    async fn(middlewareArguments) {
      const {
        placement,
        rects,
        platform,
        elements
      } = middlewareArguments;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = options;
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      let heightSide;
      let widthSide;

      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }

      const xMin = max$3(overflow.left, 0);
      const xMax = max$3(overflow.right, 0);
      const yMin = max$3(overflow.top, 0);
      const yMax = max$3(overflow.bottom, 0);
      const dimensions = {
        availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$3(overflow.top, overflow.bottom)) : overflow[heightSide]),
        availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$3(overflow.left, overflow.right)) : overflow[widthSide])
      };
      await apply({ ...middlewareArguments,
        ...dimensions
      });
      const nextDimensions = await platform.getDimensions(elements.floating);

      if (rects.floating.width !== nextDimensions.width || rects.floating.height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }

      return {};
    }

  };
};

function isWindow(value) {
  return value && value.document && value.location && value.alert && value.setInterval;
}
function getWindow$1(node) {
  if (node == null) {
    return window;
  }

  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function getComputedStyle$2(element) {
  return getWindow$1(element).getComputedStyle(element);
}

function getNodeName(node) {
  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';
}

function getUAString() {
  const uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands) {
    return uaData.brands.map(item => item.brand + "/" + item.version).join(' ');
  }

  return navigator.userAgent;
}

function isHTMLElement$1(value) {
  return value instanceof getWindow$1(value).HTMLElement;
}
function isElement$1(value) {
  return value instanceof getWindow$1(value).Element;
}
function isNode$1(value) {
  return value instanceof getWindow$1(value).Node;
}
function isShadowRoot(node) {
  // Browsers without `ShadowRoot` support
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  const OwnElement = getWindow$1(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$2(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  // TODO: Try and use feature detection here instead
  const isFirefox = /firefox/i.test(getUAString());
  const css = getComputedStyle$2(element); // This is non-exhaustive but covers the most common CSS properties that
  // create a containing block.
  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

  return css.transform !== 'none' || css.perspective !== 'none' || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some( // TS 4.1 compat
  value => {
    const contain = css.contain;
    return contain != null ? contain.includes(value) : false;
  });
}
function isLayoutViewport() {
  // Not Safari
  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways
  // • Always-visible scrollbar or not
  // • Width of <html>, etc.
  // const vV = win.visualViewport;
  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}

const min$2 = Math.min;
const max$2 = Math.max;
const round$2 = Math.round;

function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;

  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;

  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round$2(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$2(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  const win = isElement$1(element) ? getWindow$1(element) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
  const width = clientRect.width / scaleX;
  const height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

function getDocumentElement(node) {
  return ((isNode$1(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}

function getNodeScroll(element) {
  if (isElement$1(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}

function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round$2(rect.width) !== element.offsetWidth || round$2(rect.height) !== element.offsetHeight;
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)
  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // @ts-ignore
    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    node.parentNode || ( // DOM Element detected
    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected
    getDocumentElement(node) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement$1(element) || getComputedStyle$2(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
}

function getContainingBlock(element) {
  let currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      const parent = currentNode.parentNode;
      currentNode = isShadowRoot(parent) ? parent.host : parent;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  const window = getWindow$1(element);
  let offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$2(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$2(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getDimensions(element) {
  if (isHTMLElement$1(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }

  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);

  if (offsetParent === documentElement) {
    return rect;
  }

  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } // This doesn't appear to be need to be negated.
    // else if (documentElement) {
    //   offsets.x = getWindowScrollBarX(documentElement);
    // }

  }

  return { ...rect,
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  };
}

function getViewportRect(element, strategy) {
  const win = getWindow$1(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width,
    height,
    x,
    y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max$2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max$2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;

  if (getComputedStyle$2(body || html).direction === 'rtl') {
    x += max$2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width,
    height,
    x,
    y
  };
}

function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);

  if (isLastTraversableNode(parentNode)) {
    // @ts-ignore assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }

  return getNearestOverflowAncestor(parentNode);
}

function getOverflowAncestors(node, list) {
  var _node$ownerDocument;

  if (list === void 0) {
    list = [];
  }

  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow$1(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here
  updatedList.concat(getOverflowAncestors(target));
}

function contains(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;

    do {
      // use `===` replace node.isSameNode()
      if (next && parent === next) {
        return true;
      } // @ts-ignore: need a better way to handle this...


      next = next.parentNode || next.host;
    } while (next);
  }

  return false;
}

function getNearestParentCapableOfEscapingClipping(element, clippingAncestors) {
  let currentNode = element;

  while (currentNode && !isLastTraversableNode(currentNode) && // @ts-expect-error
  !clippingAncestors.includes(currentNode)) {
    if (isElement$1(currentNode) && ['absolute', 'fixed'].includes(getComputedStyle$2(currentNode).position)) {
      break;
    }

    const parentNode = getParentNode(currentNode);
    currentNode = isShadowRoot(parentNode) ? parentNode.host : parentNode;
  }

  return currentNode;
}

function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}

function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
  if (clippingParent === 'viewport') {
    return rectToClientRect(getViewportRect(element, strategy));
  }

  if (isElement$1(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent, strategy);
  }

  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping ancestor" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(element);
  const nearestEscapableParent = getNearestParentCapableOfEscapingClipping(element, clippingAncestors);
  let clipperElement = null;

  if (nearestEscapableParent && isHTMLElement$1(nearestEscapableParent)) {
    const offsetParent = getOffsetParent(nearestEscapableParent);

    if (isOverflowElement(nearestEscapableParent)) {
      clipperElement = nearestEscapableParent;
    } else if (isHTMLElement$1(offsetParent)) {
      clipperElement = offsetParent;
    }
  }

  if (!isElement$1(clipperElement)) {
    return [];
  } // @ts-ignore isElement check ensures we return Array<Element>


  return clippingAncestors.filter(clippingAncestors => clipperElement && isElement$1(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');
} // Gets the maximum area that the element is visible in due to any number of
// clipping ancestors


function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max$2(rect.top, accRect.top);
    accRect.right = min$2(rect.right, accRect.right);
    accRect.bottom = min$2(rect.bottom, accRect.bottom);
    accRect.left = max$2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

const platform$1 = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement: isElement$1,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: _ref => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: { ...getDimensions(floating),
        x: 0,
        y: 0
      }
    };
  },
  getClientRects: element => Array.from(element.getClientRects()),
  isRTL: element => getComputedStyle$2(element).direction === 'rtl'
};

/**
 * Automatically updates the position of the floating element when necessary.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }

  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...(isElement$1(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  let observer = null;

  if (elementResize) {
    let initialUpdate = true;
    observer = new ResizeObserver(() => {
      if (!initialUpdate) {
        update();
      }

      initialUpdate = false;
    });
    isElement$1(reference) && !animationFrame && observer.observe(reference);
    observer.observe(floating);
  }

  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;

  if (animationFrame) {
    frameLoop();
  }

  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);

    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }

    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }

  update();
  return () => {
    var _observer;

    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;

    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */

const computePosition = (reference, floating, options) => computePosition$1(reference, floating, {
  platform: platform$1,
  ...options
});

var index$1 = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;

// Fork of `fast-deep-equal` that only does the comparisons we need and compares
// functions
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (typeof a !== typeof b) {
    return false;
  }

  if (typeof a === 'function' && a.toString() === b.toString()) {
    return true;
  }

  let length, i, keys;

  if (a && b && typeof a == 'object') {
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;

      for (i = length; i-- !== 0;) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }

      return true;
    }

    keys = Object.keys(a);
    length = keys.length;

    if (length !== Object.keys(b).length) {
      return false;
    }

    for (i = length; i-- !== 0;) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }

    for (i = length; i-- !== 0;) {
      const key = keys[i];

      if (key === '_owner' && a.$$typeof) {
        continue;
      }

      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }

    return true;
  }

  return a !== a && b !== b;
}

function useLatestRef$1(value) {
  const ref = React__namespace.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}

function useFloating$1(_temp) {
  let {
    middleware,
    placement = 'bottom',
    strategy = 'absolute',
    whileElementsMounted
  } = _temp === void 0 ? {} : _temp;
  const [data, setData] = React__namespace.useState({
    // Setting these to `null` will allow the consumer to determine if
    // `computePosition()` has run yet
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {}
  });
  const [latestMiddleware, setLatestMiddleware] = React__namespace.useState(middleware);

  if (!deepEqual(latestMiddleware == null ? void 0 : latestMiddleware.map(_ref => {
    let {
      name,
      options
    } = _ref;
    return {
      name,
      options
    };
  }), middleware == null ? void 0 : middleware.map(_ref2 => {
    let {
      name,
      options
    } = _ref2;
    return {
      name,
      options
    };
  }))) {
    setLatestMiddleware(middleware);
  }

  const reference = React__namespace.useRef(null);
  const floating = React__namespace.useRef(null);
  const cleanupRef = React__namespace.useRef(null);
  const dataRef = React__namespace.useRef(data);
  const whileElementsMountedRef = useLatestRef$1(whileElementsMounted);
  const update = React__namespace.useCallback(() => {
    if (!reference.current || !floating.current) {
      return;
    }

    computePosition(reference.current, floating.current, {
      middleware: latestMiddleware,
      placement,
      strategy
    }).then(data => {
      if (isMountedRef.current && !deepEqual(dataRef.current, data)) {
        dataRef.current = data;
        ReactDOM__namespace.flushSync(() => {
          setData(data);
        });
      }
    });
  }, [latestMiddleware, placement, strategy]);
  index$1(() => {
    // Skip first update
    if (isMountedRef.current) {
      update();
    }
  }, [update]);
  const isMountedRef = React__namespace.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const runElementMountCallback = React__namespace.useCallback(() => {
    if (typeof cleanupRef.current === 'function') {
      cleanupRef.current();
      cleanupRef.current = null;
    }

    if (reference.current && floating.current) {
      if (whileElementsMountedRef.current) {
        const cleanupFn = whileElementsMountedRef.current(reference.current, floating.current, update);
        cleanupRef.current = cleanupFn;
      } else {
        update();
      }
    }
  }, [update, whileElementsMountedRef]);
  const setReference = React__namespace.useCallback(node => {
    reference.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const setFloating = React__namespace.useCallback(node => {
    floating.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const refs = React__namespace.useMemo(() => ({
    reference,
    floating
  }), []);
  return React__namespace.useMemo(() => ({ ...data,
    update,
    refs,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, setReference, setFloating]);
}

/**
 * Positions an inner element of the floating element such that it is centered
 * to the reference element.
 * This wraps the core `arrow` middleware to allow React refs as the element.
 * @see https://floating-ui.com/docs/arrow
 */

const arrow = options => {
  const {
    element,
    padding
  } = options;

  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, 'current');
  }

  return {
    name: 'arrow',
    options,

    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return arrow$1({
            element: element.current,
            padding
          }).fn(args);
        }

        return {};
      } else if (element) {
        return arrow$1({
          element,
          padding
        }).fn(args);
      }

      return {};
    }

  };
};

var getDefaultParent = function (originalTarget) {
    if (typeof document === 'undefined') {
        return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
};
var counterMap = new WeakMap();
var uncontrolledNodes = new WeakMap();
var markerMap = {};
var lockCount = 0;
/**
 * Marks everything except given node(or nodes) as aria-hidden
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @param {String} [controlAttribute] - html Attribute to control
 * @return {Undo} undo command
 */
var applyAttributeToOthers = function (originalTarget, parentNode, markerName, controlAttribute) {
    var targets = Array.isArray(originalTarget) ? originalTarget : [originalTarget];
    if (!markerMap[markerName]) {
        markerMap[markerName] = new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = new Set();
    var elementsToStop = new Set(targets);
    var keep = function (el) {
        if (!el || elementsToKeep.has(el)) {
            return;
        }
        elementsToKeep.add(el);
        keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function (parent) {
        if (!parent || elementsToStop.has(parent)) {
            return;
        }
        Array.prototype.forEach.call(parent.children, function (node) {
            if (elementsToKeep.has(node)) {
                deep(node);
            }
            else {
                var attr = node.getAttribute(controlAttribute);
                var alreadyHidden = attr !== null && attr !== 'false';
                var counterValue = (counterMap.get(node) || 0) + 1;
                var markerValue = (markerCounter.get(node) || 0) + 1;
                counterMap.set(node, counterValue);
                markerCounter.set(node, markerValue);
                hiddenNodes.push(node);
                if (counterValue === 1 && alreadyHidden) {
                    uncontrolledNodes.set(node, true);
                }
                if (markerValue === 1) {
                    node.setAttribute(markerName, 'true');
                }
                if (!alreadyHidden) {
                    node.setAttribute(controlAttribute, 'true');
                }
            }
        });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function () {
        hiddenNodes.forEach(function (node) {
            var counterValue = counterMap.get(node) - 1;
            var markerValue = markerCounter.get(node) - 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            if (!counterValue) {
                if (!uncontrolledNodes.has(node)) {
                    node.removeAttribute(controlAttribute);
                }
                uncontrolledNodes.delete(node);
            }
            if (!markerValue) {
                node.removeAttribute(markerName);
            }
        });
        lockCount--;
        if (!lockCount) {
            // clear
            counterMap = new WeakMap();
            counterMap = new WeakMap();
            uncontrolledNodes = new WeakMap();
            markerMap = {};
        }
    };
};
/**
 * Marks everything except given node(or nodes) as aria-hidden
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @return {Undo} undo command
 */
var hideOthers = function (originalTarget, parentNode, markerName) {
    if (markerName === void 0) { markerName = 'data-aria-hidden'; }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
        return function () { return null; };
    }
    // we should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live]')));
    return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');
};

var index = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;

function createPubSub() {
  const map = new Map();
  return {
    emit(event, data) {
      var _map$get;

      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach(handler => handler(data));
    },

    on(event, listener) {
      map.set(event, [...(map.get(event) || []), listener]);
    },

    off(event, listener) {
      map.set(event, (map.get(event) || []).filter(l => l !== listener));
    }

  };
}

let serverHandoffComplete = false;
let count = 0;

const genId = () => "floating-ui-" + count++;

function useFloatingId() {
  const [id, setId] = React__namespace.useState(() => serverHandoffComplete ? genId() : undefined);
  index(() => {
    if (id == null) {
      setId(genId());
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  React__namespace.useEffect(() => {
    if (!serverHandoffComplete) {
      serverHandoffComplete = true;
    }
  }, []);
  return id;
} // `toString()` prevents bundlers from trying to `import { useId } from 'react'`


const useReactId = React__namespace[/*#__PURE__*/'useId'.toString()];
/**
 * Uses React 18's built-in `useId()` when available, or falls back to a
 * slightly less performant (requiring a double render) implementation for
 * earlier React versions.
 * @see https://floating-ui.com/docs/useId
 */

const useId = useReactId != null ? useReactId : useFloatingId;

const FloatingNodeContext = /*#__PURE__*/React__namespace.createContext(null);
const FloatingTreeContext = /*#__PURE__*/React__namespace.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext$id, _React$useContext;

  return (_React$useContext$id = (_React$useContext = React__namespace.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) != null ? _React$useContext$id : null;
};
const useFloatingTree = () => React__namespace.useContext(FloatingTreeContext);

function getDocument(floating) {
  var _floating$ownerDocume;

  return (_floating$ownerDocume = floating == null ? void 0 : floating.ownerDocument) != null ? _floating$ownerDocume : document;
}

function getWindow(value) {
  var _getDocument$defaultV;

  return (_getDocument$defaultV = getDocument(value).defaultView) != null ? _getDocument$defaultV : window;
}

function isElement(value) {
  return value ? value instanceof getWindow(value).Element : false;
}
function isHTMLElement(value) {
  return value ? value instanceof getWindow(value).HTMLElement : false;
}

// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`
const useInsertionEffect = React__namespace[/*#__PURE__*/'useInsertionEffect'.toString()];
function useEvent(callback) {
  const ref = React__namespace.useRef(() => {
    if (process.env.NODE_ENV !== "production") {
      throw new Error('Cannot call an event handler while rendering.');
    }
  });

  if (useInsertionEffect) {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useInsertionEffect(() => {
      ref.current = callback;
    });
  } else {
    ref.current = callback;
  }

  return React__namespace.useCallback(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}

function useFloating(_temp) {
  let {
    open = false,
    onOpenChange: unstable_onOpenChange,
    whileElementsMounted,
    placement,
    middleware,
    strategy,
    nodeId
  } = _temp === void 0 ? {} : _temp;
  const [domReference, setDomReference] = React__namespace.useState(null);
  const tree = useFloatingTree();
  const domReferenceRef = React__namespace.useRef(null);
  const dataRef = React__namespace.useRef({});
  const events = React__namespace.useState(() => createPubSub())[0];
  const position = useFloating$1({
    placement,
    middleware,
    strategy,
    whileElementsMounted
  });
  const onOpenChange = useEvent(unstable_onOpenChange);
  const refs = React__namespace.useMemo(() => ({ ...position.refs,
    domReference: domReferenceRef
  }), [position.refs]);
  const context = React__namespace.useMemo(() => ({ ...position,
    refs,
    dataRef,
    nodeId,
    events,
    open,
    onOpenChange,
    _: {
      domReference
    }
  }), [position, nodeId, events, open, onOpenChange, refs, domReference]);
  index(() => {
    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);

    if (node) {
      node.context = context;
    }
  });
  const {
    reference
  } = position;
  const setReference = React__namespace.useCallback(node => {
    if (isElement(node) || node === null) {
      context.refs.domReference.current = node;
      setDomReference(node);
    }

    reference(node);
  }, [reference, context.refs]);
  return React__namespace.useMemo(() => ({ ...position,
    context,
    refs,
    reference: setReference
  }), [position, refs, context, setReference]);
}

function mergeProps(userProps, propsList, elementKey) {
  const map = new Map();
  return { ...(elementKey === 'floating' && {
      tabIndex: -1
    }),
    ...userProps,
    ...propsList.map(value => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }

      Object.entries(props).forEach(_ref => {
        let [key, value] = _ref;

        if (key.indexOf('on') === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }

          if (typeof value === 'function') {
            var _map$get;

            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);

            acc[key] = function () {
              var _map$get2;

              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.forEach(fn => fn(...args));
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}

const useInteractions = function (propsList) {
  if (propsList === void 0) {
    propsList = [];
  }

  return {
    getReferenceProps: userProps => mergeProps(userProps, propsList, 'reference'),
    getFloatingProps: userProps => mergeProps(userProps, propsList, 'floating'),
    getItemProps: userProps => mergeProps(userProps, propsList, 'item')
  };
};

function getChildren(nodes, id) {
  var _nodes$filter;

  let allChildren = (_nodes$filter = nodes.filter(node => {
    var _node$context;

    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);
  })) != null ? _nodes$filter : [];
  let currentChildren = allChildren;

  while (currentChildren.length) {
    var _nodes$filter2;

    currentChildren = (_nodes$filter2 = nodes.filter(node => {
      var _currentChildren;

      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {
        var _node$context2;

        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);
      });
    })) != null ? _nodes$filter2 : [];
    allChildren = allChildren.concat(currentChildren);
  }

  return allChildren;
}

const DEFAULT_ID$1 = 'floating-ui-root';
const useFloatingPortalNode = function (_temp) {
  let {
    id = DEFAULT_ID$1,
    enabled = true
  } = _temp === void 0 ? {} : _temp;
  const [portalEl, setPortalEl] = React__namespace.useState(null);
  index(() => {
    if (!enabled) {
      return;
    }

    const rootNode = document.getElementById(id);

    if (rootNode) {
      setPortalEl(rootNode);
    } else {
      const newPortalEl = document.createElement('div');
      newPortalEl.id = id;
      setPortalEl(newPortalEl);

      if (!document.body.contains(newPortalEl)) {
        document.body.appendChild(newPortalEl);
      }
    }
  }, [id, enabled]);
  return portalEl;
};
/**
 * Portals your floating element outside of the main app node.
 * @see https://floating-ui.com/docs/FloatingPortal
 */

const FloatingPortal = _ref => {
  let {
    children,
    id = DEFAULT_ID$1,
    root = null
  } = _ref;
  const portalNode = useFloatingPortalNode({
    id,
    enabled: !root
  });

  if (root) {
    return /*#__PURE__*/ReactDOM.createPortal(children, root);
  }

  if (portalNode) {
    return /*#__PURE__*/ReactDOM.createPortal(children, portalNode);
  }

  return null;
};

function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$1.apply(this, arguments);
}

// Avoid Chrome DevTools blue warning
function getPlatform() {
  const uaData = navigator.userAgentData;

  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }

  return navigator.platform;
}

const identifier = 'data-floating-ui-scroll-lock';
/**
 * Provides base styling for a fixed overlay element to dim content or block
 * pointer events behind a floating element.
 * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.
 * @see https://floating-ui.com/docs/FloatingOverlay
 */

const FloatingOverlay = /*#__PURE__*/React__namespace.forwardRef(function FloatingOverlay(_ref, ref) {
  let {
    lockScroll = false,
    ...rest
  } = _ref;
  index(() => {
    var _window$visualViewpor, _window$visualViewpor2, _window$visualViewpor3, _window$visualViewpor4;

    if (!lockScroll) {
      return;
    }

    const alreadyLocked = document.body.hasAttribute(identifier);

    if (alreadyLocked) {
      return;
    }

    document.body.setAttribute(identifier, ''); // RTL <body> scrollbar

    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth; // Only iOS doesn't respect `overflow: hidden` on document.body, and this
    // technique has fewer side effects.

    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {
      Object.assign(document.body.style, {
        overflow: 'hidden',
        [paddingProp]: scrollbarWidth + "px"
      });
      return () => {
        document.body.removeAttribute(identifier);
        Object.assign(document.body.style, {
          overflow: '',
          [paddingProp]: ''
        });
      };
    } // iOS 12 does not support `visuaViewport`.


    const offsetLeft = (_window$visualViewpor = (_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetLeft) != null ? _window$visualViewpor : 0;
    const offsetTop = (_window$visualViewpor3 = (_window$visualViewpor4 = window.visualViewport) == null ? void 0 : _window$visualViewpor4.offsetTop) != null ? _window$visualViewpor3 : 0;
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    Object.assign(document.body.style, {
      position: 'fixed',
      overflow: 'hidden',
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: '0',
      [paddingProp]: scrollbarWidth + "px"
    });
    return () => {
      Object.assign(document.body.style, {
        position: '',
        overflow: '',
        top: '',
        left: '',
        right: '',
        [paddingProp]: ''
      });
      document.body.removeAttribute(identifier);
      window.scrollTo(scrollX, scrollY);
    };
  }, [lockScroll]);
  return /*#__PURE__*/React__namespace.createElement("div", _extends$1({
    ref: ref
  }, rest, {
    style: {
      position: 'fixed',
      overflow: 'auto',
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});

/**
 * Find the real active element. Traverses into shadowRoots.
 */
function activeElement(doc) {
  let activeElement = doc.activeElement;

  while (((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {
    var _activeElement, _activeElement$shadow;

    activeElement = activeElement.shadowRoot.activeElement;
  }

  return activeElement;
}

function getAncestors(nodes, id) {
  var _nodes$find;

  let allAncestors = [];
  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;

  while (currentParentId) {
    const currentNode = nodes.find(node => node.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;

    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }

  return allAncestors;
}

function getTarget(event) {
  if ('composedPath' in event) {
    return event.composedPath()[0];
  } // TS thinks `event` is of type never as it assumes all browsers support
  // `composedPath()`, but browsers without shadow DOM don't.


  return event.target;
}

const TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled])," + "[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}

function stopEvent$1(event) {
  event.preventDefault();
  event.stopPropagation();
}

function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}

function focus(el, preventScroll) {
  if (preventScroll === void 0) {
    preventScroll = false;
  }

  // `mousedown` clicks occur before `focus`, so the button will steal the
  // focus unless we wait a frame.
  requestAnimationFrame(() => {
    el == null ? void 0 : el.focus({
      preventScroll
    });
  });
}

const SELECTOR = 'select:not([disabled]),a[href],button:not([disabled]),[tabindex],' + 'iframe,object,embed,area[href],audio[controls],video[controls],' + TYPEABLE_SELECTOR;
const FocusGuard = /*#__PURE__*/React__namespace.forwardRef(function FocusGuard(props, ref) {
  return /*#__PURE__*/React__namespace.createElement("span", _extends$1({}, props, {
    ref: ref,
    tabIndex: 0,
    style: {
      position: 'fixed',
      opacity: '0',
      pointerEvents: 'none',
      outline: '0'
    }
  }));
});

/**
 * Provides focus management for the floating element.
 * @see https://floating-ui.com/docs/FloatingFocusManager
 */
function FloatingFocusManager(_ref) {
  let {
    context: {
      refs,
      nodeId,
      onOpenChange,
      dataRef,
      events
    },
    children,
    order = ['content'],
    endGuard = true,
    initialFocus = 0,
    returnFocus = true,
    modal = true
  } = _ref;
  const orderRef = useLatestRef(order);
  const tree = useFloatingTree();
  const getTabbableElements = React__namespace.useCallback(() => {
    return orderRef.current.map(type => {
      if (type === 'reference') {
        return refs.domReference.current;
      }

      if (refs.floating.current && type === 'floating') {
        return refs.floating.current;
      }

      if (type === 'content') {
        var _refs$floating$curren, _refs$floating$curren2;

        return Array.from((_refs$floating$curren = (_refs$floating$curren2 = refs.floating.current) == null ? void 0 : _refs$floating$curren2.querySelectorAll(SELECTOR)) != null ? _refs$floating$curren : []);
      }

      return null;
    }).flat().filter(el => {
      if (el === refs.floating.current || el === refs.domReference.current) {
        return true;
      }

      if (isHTMLElement(el)) {
        var _el$getAttribute;

        const tabIndex = (_el$getAttribute = el.getAttribute('tabindex')) != null ? _el$getAttribute : '0';
        return tabIndex[0].trim() !== '-';
      }
    });
  }, [orderRef, refs]);
  React__namespace.useEffect(() => {
    if (!modal) {
      return;
    } // If the floating element has no focusable elements inside it, fallback
    // to focusing the floating element and preventing tab navigation


    const noTabbableContentElements = getTabbableElements().filter(el => el !== refs.floating.current && el !== refs.domReference.current).length === 0;

    function onKeyDown(event) {
      if (event.key === 'Tab') {
        if (noTabbableContentElements) {
          stopEvent$1(event);
        }

        const els = getTabbableElements();
        const target = getTarget(event);

        if (orderRef.current[0] === 'reference' && target === refs.domReference.current) {
          stopEvent$1(event);

          if (event.shiftKey) {
            focus(els[els.length - 1]);
          } else {
            focus(els[1]);
          }
        }

        if (orderRef.current[1] === 'floating' && target === refs.floating.current && event.shiftKey) {
          stopEvent$1(event);
          focus(els[0]);
        }
      }
    }

    const doc = getDocument(refs.floating.current);
    doc.addEventListener('keydown', onKeyDown);
    return () => {
      doc.removeEventListener('keydown', onKeyDown);
    };
  }, [modal, getTabbableElements, orderRef, refs]);
  React__namespace.useEffect(() => {
    let isPointerDown = false;

    function onFocusOut(event) {
      var _refs$floating$curren3, _getAncestors;

      const relatedTarget = event.relatedTarget;
      const focusMovedOutsideFloating = !((_refs$floating$curren3 = refs.floating.current) != null && _refs$floating$curren3.contains(relatedTarget));
      const focusMovedOutsideReference = isElement(refs.domReference.current) && !refs.domReference.current.contains(relatedTarget);
      const isChildOpen = tree && getChildren(tree.nodesRef.current, nodeId).length > 0;
      const isParentRelated = tree && event.currentTarget === refs.domReference.current && ((_getAncestors = getAncestors(tree.nodesRef.current, nodeId)) == null ? void 0 : _getAncestors.some(node => {
        var _node$context, _node$context$refs$fl;

        return (_node$context = node.context) == null ? void 0 : (_node$context$refs$fl = _node$context.refs.floating.current) == null ? void 0 : _node$context$refs$fl.contains(relatedTarget);
      }));

      if (focusMovedOutsideFloating && focusMovedOutsideReference && !isChildOpen && !isParentRelated && !isPointerDown) {
        onOpenChange(false);
      }
    }

    function onPointerDown() {
      // In Safari, buttons *lose* focus when pressing them. This causes the
      // reference `focusout` to fire, which closes the floating element.
      isPointerDown = true;
      setTimeout(() => {
        isPointerDown = false;
      });
    }

    const floating = refs.floating.current;
    const reference = refs.domReference.current;

    if (floating && isHTMLElement(reference)) {
      if (!modal) {
        floating.addEventListener('focusout', onFocusOut);
        reference.addEventListener('focusout', onFocusOut);
        reference.addEventListener('pointerdown', onPointerDown);
      }

      let cleanup;

      if (modal) {
        if (orderRef.current.includes('reference')) {
          cleanup = hideOthers([reference, floating]);
        } else {
          cleanup = hideOthers(floating);
        }
      }

      return () => {
        if (!modal) {
          floating.removeEventListener('focusout', onFocusOut);
          reference.removeEventListener('focusout', onFocusOut);
          reference.removeEventListener('pointerdown', onPointerDown);
        }

        cleanup == null ? void 0 : cleanup();
      };
    }
  }, [nodeId, tree, modal, onOpenChange, orderRef, dataRef, getTabbableElements, refs]);
  React__namespace.useEffect(() => {
    const floating = refs.floating.current;
    const doc = getDocument(floating);
    let returnFocusValue = returnFocus;
    let preventReturnFocusScroll = false;
    let previouslyFocusedElement = activeElement(doc);

    if (previouslyFocusedElement === doc.body && refs.domReference.current) {
      previouslyFocusedElement = refs.domReference.current;
    }

    if (typeof initialFocus === 'number') {
      var _getTabbableElements$;

      const el = (_getTabbableElements$ = getTabbableElements()[initialFocus]) != null ? _getTabbableElements$ : floating;
      focus(el, el === floating);
    } else if (isHTMLElement(initialFocus.current)) {
      var _initialFocus$current;

      const el = (_initialFocus$current = initialFocus.current) != null ? _initialFocus$current : floating;
      focus(el, el === floating);
    } // Dismissing via outside press should always ignore `returnFocus` to
    // prevent unwanted scrolling.


    function onDismiss(allowReturnFocus) {
      if (allowReturnFocus === void 0) {
        allowReturnFocus = false;
      }

      if (typeof allowReturnFocus === 'object') {
        returnFocusValue = true;
        preventReturnFocusScroll = allowReturnFocus.preventScroll;
      } else {
        returnFocusValue = allowReturnFocus;
      }
    }

    events.on('dismiss', onDismiss);
    return () => {
      events.off('dismiss', onDismiss);

      if (returnFocusValue && isHTMLElement(previouslyFocusedElement)) {
        focus(previouslyFocusedElement, preventReturnFocusScroll);
      }
    };
  }, [getTabbableElements, initialFocus, returnFocus, refs, events]);

  const isTypeableCombobox = () => {
    var _refs$domReference$cu;

    return ((_refs$domReference$cu = refs.domReference.current) == null ? void 0 : _refs$domReference$cu.getAttribute('role')) === 'combobox' && isTypeableElement(refs.domReference.current);
  };

  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, modal && /*#__PURE__*/React__namespace.createElement(FocusGuard, {
    onFocus: event => {
      if (isTypeableCombobox()) {
        return;
      }

      stopEvent$1(event);
      const els = getTabbableElements();

      if (order[0] === 'reference') {
        focus(els[0]);
      } else {
        focus(els[els.length - 1]);
      }
    }
  }), /*#__PURE__*/React__namespace.cloneElement(children, order.includes('floating') ? {
    tabIndex: 0
  } : {}), modal && endGuard && /*#__PURE__*/React__namespace.createElement(FocusGuard, {
    onFocus: event => {
      if (isTypeableCombobox()) {
        return;
      }

      stopEvent$1(event);
      focus(getTabbableElements()[0]);
    }
  }));
}

function usePrevious(value) {
  const ref = React.useRef();
  index(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}

function getDelay(value, prop, pointerType) {
  if (pointerType && pointerType !== 'mouse') {
    return 0;
  }

  if (typeof value === 'number') {
    return value;
  }

  return value == null ? void 0 : value[prop];
}

/**
 * Adds hover event listeners that change the open state, like CSS :hover.
 * @see https://floating-ui.com/docs/useHover
 */
const useHover = function (context, _temp) {
  let {
    enabled = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = _temp === void 0 ? {} : _temp;
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    refs,
    _
  } = context;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef(handleClose);
  const delayRef = useLatestRef(delay);
  const previousOpen = usePrevious(open);
  const pointerTypeRef = React__namespace.useRef();
  const timeoutRef = React__namespace.useRef();
  const handlerRef = React__namespace.useRef();
  const restTimeoutRef = React__namespace.useRef();
  const blockMouseMoveRef = React__namespace.useRef(true);
  const performedPointerEventsMutationRef = React__namespace.useRef(false);
  const isHoverOpen = React__namespace.useCallback(() => {
    var _dataRef$current$open;

    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';
  }, [dataRef]);
  React__namespace.useEffect(() => {
    if (!enabled) {
      return;
    }

    function onDismiss() {
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      blockMouseMoveRef.current = true;
    }

    events.on('dismiss', onDismiss);
    return () => {
      events.off('dismiss', onDismiss);
    };
  }, [enabled, events, refs]);
  React__namespace.useEffect(() => {
    if (!enabled || !handleCloseRef.current) {
      return;
    }

    function onLeave() {
      if (isHoverOpen()) {
        onOpenChange(false);
      }
    }

    const html = getDocument(refs.floating.current).documentElement;
    html.addEventListener('mouseleave', onLeave);
    return () => {
      html.removeEventListener('mouseleave', onLeave);
    };
  }, [refs, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);
  const closeWithDelay = React__namespace.useCallback(function (runElseBranch) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }

    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);

    if (closeDelay && !handlerRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = setTimeout(() => onOpenChange(false), closeDelay);
    } else if (runElseBranch) {
      clearTimeout(timeoutRef.current);
      onOpenChange(false);
    }
  }, [delayRef, onOpenChange]);
  const cleanupPointerMoveHandler = React__namespace.useCallback(() => {
    if (handlerRef.current) {
      getDocument(refs.floating.current).removeEventListener('pointermove', handlerRef.current);
      handlerRef.current = undefined;
    }
  }, [refs]);
  const clearPointerEvents = React__namespace.useCallback(() => {
    getDocument(refs.floating.current).body.style.pointerEvents = '';
    performedPointerEventsMutationRef.current = false;
  }, [refs]); // Registering the mouse events on the reference directly to bypass React's
  // delegation system. If the cursor was on a disabled element and then entered
  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.

  React__namespace.useEffect(() => {
    if (!enabled) {
      return;
    }

    function isClickLikeOpenEvent() {
      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;
    }

    function onMouseEnter(event) {
      clearTimeout(timeoutRef.current);
      blockMouseMoveRef.current = false;

      if (mouseOnly && pointerTypeRef.current !== 'mouse' || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {
        return;
      }

      dataRef.current.openEvent = event;
      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);

      if (openDelay) {
        timeoutRef.current = setTimeout(() => {
          onOpenChange(true);
        }, openDelay);
      } else {
        onOpenChange(true);
      }
    }

    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }

      const doc = getDocument(refs.floating.current);
      clearTimeout(restTimeoutRef.current);

      if (handleCloseRef.current) {
        clearTimeout(timeoutRef.current);
        handlerRef.current && doc.removeEventListener('pointermove', handlerRef.current);
        handlerRef.current = handleCloseRef.current({ ...context,
          tree,
          x: event.clientX,
          y: event.clientY,

          onClose() {
            clearPointerEvents();
            cleanupPointerMoveHandler();
            closeWithDelay();
          }

        });
        doc.addEventListener('pointermove', handlerRef.current);
        return;
      }

      closeWithDelay();
    } // Ensure the floating element closes after scrolling even if the pointer
    // did not move.
    // https://github.com/floating-ui/floating-ui/discussions/1692


    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }

      handleCloseRef.current == null ? void 0 : handleCloseRef.current({ ...context,
        tree,
        x: event.clientX,
        y: event.clientY,
        leave: true,

        onClose() {
          clearPointerEvents();
          cleanupPointerMoveHandler();
          closeWithDelay();
        }

      })(event);
    }

    const floating = refs.floating.current;
    const reference = refs.domReference.current;

    if (isElement(reference)) {
      open && reference.addEventListener('mouseleave', onScrollMouseLeave);
      floating == null ? void 0 : floating.addEventListener('mouseleave', onScrollMouseLeave);
      move && reference.addEventListener('mousemove', onMouseEnter, {
        once: true
      });
      reference.addEventListener('mouseenter', onMouseEnter);
      reference.addEventListener('mouseleave', onMouseLeave);
      return () => {
        open && reference.removeEventListener('mouseleave', onScrollMouseLeave);
        floating == null ? void 0 : floating.removeEventListener('mouseleave', onScrollMouseLeave);
        move && reference.removeEventListener('mousemove', onMouseEnter);
        reference.removeEventListener('mouseenter', onMouseEnter);
        reference.removeEventListener('mouseleave', onMouseLeave);
      };
    }
  }, [// Ensure the effect is re-run when the reference changes.
  // https://github.com/floating-ui/floating-ui/issues/1833
  _.domReference, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupPointerMoveHandler, clearPointerEvents, onOpenChange, open, tree, refs, delayRef, handleCloseRef, dataRef]); // Block pointer-events of every element other than the reference and floating
  // while the floating element is open and has a `handleClose` handler. Also
  // handles nested floating elements.
  // https://github.com/floating-ui/floating-ui/issues/1722

  index(() => {
    if (!enabled) {
      return;
    }

    if (open && handleCloseRef.current && handleCloseRef.current.__options.blockPointerEvents && isHoverOpen()) {
      getDocument(refs.floating.current).body.style.pointerEvents = 'none';
      performedPointerEventsMutationRef.current = true;
      const reference = refs.domReference.current;
      const floating = refs.floating.current;

      if (isElement(reference) && floating) {
        var _tree$nodesRef$curren, _tree$nodesRef$curren2;

        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.refs.floating.current;

        if (parentFloating) {
          parentFloating.style.pointerEvents = '';
        }

        reference.style.pointerEvents = 'auto';
        floating.style.pointerEvents = 'auto';
        return () => {
          reference.style.pointerEvents = '';
          floating.style.pointerEvents = '';
        };
      }
    }
  }, [enabled, open, parentId, refs, tree, handleCloseRef, dataRef, isHoverOpen]);
  index(() => {
    if (previousOpen && !open) {
      pointerTypeRef.current = undefined;
      cleanupPointerMoveHandler();
      clearPointerEvents();
    }
  });
  React__namespace.useEffect(() => {
    return () => {
      cleanupPointerMoveHandler();
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);

      if (performedPointerEventsMutationRef.current) {
        clearPointerEvents();
      }
    };
  }, [enabled, cleanupPointerMoveHandler, clearPointerEvents]);

  if (!enabled) {
    return {};
  }

  function setPointerRef(event) {
    pointerTypeRef.current = event.pointerType;
  }

  return {
    reference: {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,

      onMouseMove() {
        if (open || restMs === 0) {
          return;
        }

        clearTimeout(restTimeoutRef.current);
        restTimeoutRef.current = setTimeout(() => {
          if (!blockMouseMoveRef.current) {
            onOpenChange(true);
          }
        }, restMs);
      }

    },
    floating: {
      onMouseEnter() {
        clearTimeout(timeoutRef.current);
      },

      onMouseLeave() {
        closeWithDelay(false);
      }

    }
  };
};

/**
 * Adds relevant screen reader props for a given element `role`.
 * @see https://floating-ui.com/docs/useRole
 */
const useRole = function (_ref, _temp) {
  let {
    open
  } = _ref;
  let {
    enabled = true,
    role = 'dialog'
  } = _temp === void 0 ? {} : _temp;
  const rootId = useId();
  const referenceId = useId();
  const floatingProps = {
    id: rootId,
    role
  };

  if (!enabled) {
    return {};
  }

  if (role === 'tooltip') {
    return {
      reference: {
        'aria-describedby': open ? rootId : undefined
      },
      floating: floatingProps
    };
  }

  return {
    reference: {
      'aria-expanded': open ? 'true' : 'false',
      'aria-haspopup': role === 'alertdialog' ? 'dialog' : role,
      'aria-controls': open ? rootId : undefined,
      ...(role === 'listbox' && {
        role: 'combobox'
      }),
      ...(role === 'menu' && {
        id: referenceId
      })
    },
    floating: { ...floatingProps,
      ...(role === 'menu' && {
        'aria-labelledby': referenceId
      })
    }
  };
};

function isButtonTarget(event) {
  return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';
}

/**
 * Adds click event listeners that change the open state.
 * @see https://floating-ui.com/docs/useClick
 */
const useClick = function (_ref, _temp) {
  let {
    open,
    onOpenChange,
    dataRef,
    refs
  } = _ref;
  let {
    enabled = true,
    event: eventOption = 'click',
    toggle = true,
    ignoreMouse = false,
    keyboardHandlers = true
  } = _temp === void 0 ? {} : _temp;
  const pointerTypeRef = React__namespace.useRef();

  function isSpaceIgnored() {
    return isTypeableElement(refs.domReference.current);
  }

  if (!enabled) {
    return {};
  }

  return {
    reference: {
      onPointerDown(event) {
        pointerTypeRef.current = event.pointerType;
      },

      onMouseDown(event) {
        // Ignore all buttons except for the "main" button.
        // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
        if (event.button !== 0) {
          return;
        }

        if (pointerTypeRef.current === 'mouse' && ignoreMouse) {
          return;
        }

        if (eventOption === 'click') {
          return;
        }

        if (open) {
          if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {
            onOpenChange(false);
          }
        } else {
          onOpenChange(true);
        }

        dataRef.current.openEvent = event.nativeEvent;
      },

      onClick(event) {
        if (eventOption === 'mousedown' && pointerTypeRef.current) {
          pointerTypeRef.current = undefined;
          return;
        }

        if (pointerTypeRef.current === 'mouse' && ignoreMouse) {
          return;
        }

        if (open) {
          if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {
            onOpenChange(false);
          }
        } else {
          onOpenChange(true);
        }

        dataRef.current.openEvent = event.nativeEvent;
      },

      onKeyDown(event) {
        pointerTypeRef.current = undefined;

        if (!keyboardHandlers) {
          return;
        }

        if (isButtonTarget(event)) {
          return;
        }

        if (event.key === ' ' && !isSpaceIgnored()) {
          // Prvent scrolling
          event.preventDefault();
        }

        if (event.key === 'Enter') {
          if (open) {
            if (toggle) {
              onOpenChange(false);
            }
          } else {
            onOpenChange(true);
          }
        }
      },

      onKeyUp(event) {
        if (!keyboardHandlers) {
          return;
        }

        if (isButtonTarget(event) || isSpaceIgnored()) {
          return;
        }

        if (event.key === ' ') {
          if (open) {
            if (toggle) {
              onOpenChange(false);
            }
          } else {
            onOpenChange(true);
          }
        }
      }

    }
  };
};

/**
 * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.
 *
 * @param event The event whose target/composedPath to check
 * @param node The node to check against
 * @returns Whether the event.target/composedPath is within the node.
 */
function isEventTargetWithin(event, node) {
  if (node == null) {
    return false;
  }

  if ('composedPath' in event) {
    return event.composedPath().includes(node);
  } // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't


  const e = event;
  return e.target != null && node.contains(e.target);
}

const bubbleHandlerKeys = {
  pointerdown: 'onPointerDown',
  mousedown: 'onMouseDown',
  click: 'onClick'
};
const captureHandlerKeys = {
  pointerdown: 'onPointerDownCapture',
  mousedown: 'onMouseDownCapture',
  click: 'onClickCapture'
};

/**
 * Adds listeners that dismiss (close) the floating element.
 * @see https://floating-ui.com/docs/useDismiss
 */
const useDismiss = function (_ref, _temp) {
  let {
    open,
    onOpenChange,
    refs,
    events,
    nodeId
  } = _ref;
  let {
    enabled = true,
    escapeKey = true,
    outsidePress = true,
    outsidePressEvent = 'pointerdown',
    referencePress = false,
    referencePressEvent = 'pointerdown',
    ancestorScroll = false,
    bubbles = true
  } = _temp === void 0 ? {} : _temp;
  const tree = useFloatingTree();
  const nested = useFloatingParentNodeId() != null;
  const insideReactTreeRef = React__namespace.useRef(false);
  React__namespace.useEffect(() => {
    if (!open || !enabled) {
      return;
    }

    function onKeyDown(event) {
      if (event.key === 'Escape') {
        if (!bubbles && tree && getChildren(tree.nodesRef.current, nodeId).length > 0) {
          return;
        }

        events.emit('dismiss', {
          preventScroll: false
        });
        onOpenChange(false);
      }
    }

    function onOutsidePress(event) {
      // Given developers can stop the propagation of the synthetic event,
      // we can only be confident with a positive value.
      const insideReactTree = insideReactTreeRef.current;
      insideReactTreeRef.current = false;

      if (insideReactTree) {
        return;
      }

      const target = getTarget(event); // Check if the click occurred on the scrollbar

      if (isElement(target) && refs.floating.current) {
        var _refs$floating$curren;

        const win = (_refs$floating$curren = refs.floating.current.ownerDocument.defaultView) != null ? _refs$floating$curren : window;
        const canScrollX = target.scrollWidth > target.clientWidth;
        const canScrollY = target.scrollHeight > target.clientHeight;
        let xCond = canScrollY && event.offsetX > target.clientWidth; // In some browsers it is possible to change the <body> (or window)
        // scrollbar to the left side, but is very rare and is difficult to
        // check for. Plus, for modal dialogs with backdrops, it is more
        // important that the backdrop is checked but not so much the window.

        if (canScrollY) {
          const isRTL = win.getComputedStyle(target).direction === 'rtl';

          if (isRTL) {
            xCond = event.offsetX <= target.offsetWidth - target.clientWidth;
          }
        }

        if (xCond || canScrollX && event.offsetY > target.clientHeight) {
          return;
        }
      }

      const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {
        var _node$context;

        return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.refs.floating.current);
      });

      if (isEventTargetWithin(event, refs.floating.current) || isEventTargetWithin(event, refs.domReference.current) || targetIsInsideChildren) {
        return;
      }

      if (!bubbles && tree && getChildren(tree.nodesRef.current, nodeId).length > 0) {
        return;
      }

      events.emit('dismiss', nested ? {
        preventScroll: true
      } : false);
      onOpenChange(false);
    }

    function onScroll() {
      onOpenChange(false);
    }

    const doc = getDocument(refs.floating.current);
    escapeKey && doc.addEventListener('keydown', onKeyDown);
    outsidePress && doc.addEventListener(outsidePressEvent, onOutsidePress);
    const ancestors = (ancestorScroll ? [...(isElement(refs.reference.current) ? getOverflowAncestors(refs.reference.current) : []), ...(isElement(refs.floating.current) ? getOverflowAncestors(refs.floating.current) : [])] : []).filter(ancestor => {
      var _doc$defaultView;

      return (// Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)
        ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport)
      );
    });
    ancestors.forEach(ancestor => ancestor.addEventListener('scroll', onScroll, {
      passive: true
    }));
    return () => {
      escapeKey && doc.removeEventListener('keydown', onKeyDown);
      outsidePress && doc.removeEventListener(outsidePressEvent, onOutsidePress);
      ancestors.forEach(ancestor => ancestor.removeEventListener('scroll', onScroll));
    };
  }, [escapeKey, outsidePress, outsidePressEvent, events, tree, nodeId, open, onOpenChange, ancestorScroll, enabled, bubbles, refs, nested]);

  if (!enabled) {
    return {};
  }

  return {
    reference: {
      [bubbleHandlerKeys[referencePressEvent]]: () => {
        if (referencePress) {
          events.emit('dismiss');
          onOpenChange(false);
        }
      }
    },
    floating: {
      [captureHandlerKeys[outsidePressEvent]]: () => {
        insideReactTreeRef.current = true;
      }
    }
  };
};

/**
 * Adds focus event listeners that change the open state, like CSS :focus.
 * @see https://floating-ui.com/docs/useFocus
 */
const useFocus = function (_ref, _temp) {
  let {
    open,
    onOpenChange,
    dataRef,
    refs,
    events
  } = _ref;
  let {
    enabled = true,
    keyboardOnly = true
  } = _temp === void 0 ? {} : _temp;
  const pointerTypeRef = React__namespace.useRef('');
  const blockFocusRef = React__namespace.useRef(false);
  const timeoutRef = React__namespace.useRef();
  React__namespace.useEffect(() => {
    var _doc$defaultView;

    if (!enabled) {
      return;
    }

    const doc = getDocument(refs.floating.current);
    const win = (_doc$defaultView = doc.defaultView) != null ? _doc$defaultView : window;

    function onBlur() {
      if (!open && isHTMLElement(refs.domReference.current)) {
        refs.domReference.current.blur();
      }
    }

    win.addEventListener('blur', onBlur);
    return () => {
      win.removeEventListener('blur', onBlur);
    };
  }, [refs, open, enabled]);
  React__namespace.useEffect(() => {
    if (!enabled) {
      return;
    }

    function onDismiss() {
      blockFocusRef.current = true;
    }

    events.on('dismiss', onDismiss);
    return () => {
      events.off('dismiss', onDismiss);
    };
  }, [events, enabled]);
  React__namespace.useEffect(() => {
    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, []);

  if (!enabled) {
    return {};
  }

  return {
    reference: {
      onPointerDown(_ref2) {
        let {
          pointerType
        } = _ref2;
        pointerTypeRef.current = pointerType;
        blockFocusRef.current = !!(pointerType && keyboardOnly);
      },

      onPointerLeave() {
        blockFocusRef.current = false;
      },

      onFocus(event) {
        var _dataRef$current$open, _refs$domReference$cu, _dataRef$current$open2;

        if (blockFocusRef.current) {
          return;
        } // Dismiss with click should ignore the subsequent `focus` trigger, but
        // only if the click originated inside the reference element.


        if (event.type === 'focus' && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === 'mousedown' && (_refs$domReference$cu = refs.domReference.current) != null && _refs$domReference$cu.contains((_dataRef$current$open2 = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open2.target)) {
          return;
        }

        dataRef.current.openEvent = event.nativeEvent;
        onOpenChange(true);
      },

      onBlur(event) {
        const target = event.relatedTarget; // Wait for the window blur listener to fire.

        timeoutRef.current = setTimeout(() => {
          var _refs$floating$curren, _refs$domReference$cu2;

          // When focusing the reference element (e.g. regular click), then
          // clicking into the floating element, prevent it from hiding.
          // Note: it must be focusable, e.g. `tabindex="-1"`.
          if ((_refs$floating$curren = refs.floating.current) != null && _refs$floating$curren.contains(target) || (_refs$domReference$cu2 = refs.domReference.current) != null && _refs$domReference$cu2.contains(target)) {
            return;
          }

          blockFocusRef.current = false;
          onOpenChange(false);
        });
      }

    }
  };
};

const ARROW_UP = 'ArrowUp';
const ARROW_DOWN = 'ArrowDown';
const ARROW_LEFT = 'ArrowLeft';
const ARROW_RIGHT = 'ArrowRight';

function isDifferentRow(index, cols, prevRow) {
  return Math.floor(index / cols) !== prevRow;
}

function isIndexOutOfBounds(listRef, index) {
  return index < 0 || index >= listRef.current.length;
}

function findNonDisabledIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  const list = listRef.current;
  let index = startingIndex;

  do {
    var _list$index, _list$index2;

    index = index + (decrement ? -amount : amount);
  } while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute('disabled')) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute('aria-disabled')) === 'true'));

  return index;
}

function doSwitch(orientation, vertical, horizontal) {
  switch (orientation) {
    case 'vertical':
      return vertical;

    case 'horizontal':
      return horizontal;

    default:
      return vertical || horizontal;
  }
}

function isMainOrientationKey(key, orientation) {
  const vertical = key === ARROW_UP || key === ARROW_DOWN;
  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal);
}

function isMainOrientationToEndKey(key, orientation, rtl) {
  const vertical = key === ARROW_DOWN;
  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key == ' ' || key === '';
}

function isCrossOrientationOpenKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;
  const horizontal = key === ARROW_DOWN;
  return doSwitch(orientation, vertical, horizontal);
}

function isCrossOrientationCloseKey(key, orientation, rtl) {
  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;
  const horizontal = key === ARROW_UP;
  return doSwitch(orientation, vertical, horizontal);
}

function getMinIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    disabledIndices
  });
}

function getMaxIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}

/**
 * Adds focus-managed indexed navigation via arrow keys to a list of items
 * within the floating element.
 * @see https://floating-ui.com/docs/useListNavigation
 */
const useListNavigation = function (_ref, _temp2) {
  let {
    open,
    onOpenChange,
    refs
  } = _ref;
  let {
    listRef,
    activeIndex,
    onNavigate: unstable_onNavigate = () => {},
    enabled = true,
    selectedIndex = null,
    allowEscape = false,
    loop = false,
    nested = false,
    rtl = false,
    virtual = false,
    focusItemOnOpen = 'auto',
    focusItemOnHover = true,
    openOnArrowKeyDown = true,
    disabledIndices = undefined,
    orientation = 'vertical',
    cols = 1
  } = _temp2 === void 0 ? {
    listRef: {
      current: []
    },
    activeIndex: null,
    onNavigate: () => {}
  } : _temp2;

  if (process.env.NODE_ENV !== "production") {
    if (allowEscape) {
      if (!loop) {
        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));
      }

      if (!virtual) {
        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));
      }
    }

    if (orientation === 'vertical' && cols > 1) {
      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either "horizontal" or "both".'].join(' '));
    }
  }

  const parentId = useFloatingParentNodeId();
  const tree = useFloatingTree();
  const previousOpen = usePrevious(open);
  const onNavigate = useEvent(unstable_onNavigate);
  const previousOnNavigate = useEvent(usePrevious(unstable_onNavigate));
  const focusItemOnOpenRef = React__namespace.useRef(focusItemOnOpen);
  const indexRef = React__namespace.useRef(selectedIndex != null ? selectedIndex : -1);
  const keyRef = React__namespace.useRef(null);
  const disabledIndicesRef = useLatestRef(disabledIndices);
  const blockPointerLeaveRef = React__namespace.useRef(false);
  const frameRef = React__namespace.useRef(-1);
  const [activeId, setActiveId] = React__namespace.useState();
  const focusItem = React__namespace.useCallback((listRef, indexRef) => {
    // `mousedown` clicks occur before `focus`, so the button will steal the
    // focus unless we wait a frame.
    frameRef.current = requestAnimationFrame(() => {
      if (virtual) {
        var _listRef$current$inde;

        setActiveId((_listRef$current$inde = listRef.current[indexRef.current]) == null ? void 0 : _listRef$current$inde.id);
      } else {
        var _listRef$current$inde2;

        (_listRef$current$inde2 = listRef.current[indexRef.current]) == null ? void 0 : _listRef$current$inde2.focus({
          preventScroll: true
        });
      }
    });
  }, [virtual]); // Sync `selectedIndex` to be the `activeIndex` upon opening the floating
  // element. Also, reset `activeIndex` upon closing the floating element.

  index(() => {
    if (!enabled) {
      return;
    }

    if (!previousOpen && open && focusItemOnOpenRef.current && selectedIndex != null) {
      onNavigate(selectedIndex);
    } // Unset `activeIndex`. Since the user can specify `onNavigate`
    // conditionally (onNavigate: open ? setActiveIndex : setSelectedIndex)
    // we store and call the previous function


    if (previousOpen && !open) {
      cancelAnimationFrame(frameRef.current);
      indexRef.current = -1;
      previousOnNavigate(null);
    }
  }, [open, previousOpen, selectedIndex, listRef, focusItem, enabled, onNavigate, previousOnNavigate]); // Sync `activeIndex` to be the focused item while the floating element is
  // open.

  index(() => {
    if (!enabled) {
      return;
    }

    if (open) {
      if (activeIndex == null) {
        if (selectedIndex != null) {
          return;
        } // Reset while the floating element was open (e.g. the list changed).


        if (previousOpen) {
          indexRef.current = -1;
          focusItem(listRef, indexRef);
        } // Initial sync


        if (!previousOpen && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {
          indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);
          onNavigate(indexRef.current);
          focusItem(listRef, indexRef);
        }
      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {
        indexRef.current = activeIndex;
        focusItem(listRef, indexRef);
      }
    }
  }, [open, previousOpen, activeIndex, selectedIndex, nested, listRef, onNavigate, focusItem, enabled, allowEscape, orientation, rtl, virtual, disabledIndicesRef]); // Ensure the parent floating element has focus when a nested child closes
  // to allow arrow key navigation to work after the pointer leaves the child.

  index(() => {
    if (!enabled) {
      return;
    }

    if (!open && previousOpen) {
      var _tree$nodesRef$curren, _tree$nodesRef$curren2;

      const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.refs.floating.current;

      if (parentFloating && !parentFloating.contains(activeElement(getDocument(parentFloating)))) {
        parentFloating.focus({
          preventScroll: true
        });
      }
    }
  }, [enabled, open, previousOpen, tree, parentId]);
  index(() => {
    keyRef.current = null;
  });

  function onKeyDown(event) {
    blockPointerLeaveRef.current = true;

    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {
      stopEvent$1(event);
      onOpenChange(false);

      if (isHTMLElement(refs.domReference.current)) {
        refs.domReference.current.focus();
      }

      return;
    }

    const currentIndex = indexRef.current;
    const minIndex = getMinIndex(listRef, disabledIndices);
    const maxIndex = getMaxIndex(listRef, disabledIndices);

    if (event.key === 'Home') {
      indexRef.current = minIndex;
      onNavigate(indexRef.current);
    }

    if (event.key === 'End') {
      indexRef.current = maxIndex;
      onNavigate(indexRef.current);
    } // Grid navigation


    if (cols > 1) {
      const prevIndex = indexRef.current;

      if (event.key === ARROW_UP) {
        stopEvent$1(event);

        if (prevIndex === -1) {
          indexRef.current = maxIndex;
        } else {
          indexRef.current = findNonDisabledIndex(listRef, {
            startingIndex: prevIndex,
            amount: cols,
            decrement: true,
            disabledIndices
          });

          if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {
            const col = prevIndex % cols;
            const maxCol = maxIndex % cols;
            const offset = maxIndex - (maxCol - col);

            if (maxCol === col) {
              indexRef.current = maxIndex;
            } else {
              indexRef.current = maxCol > col ? offset : offset - cols;
            }
          }
        }

        if (isIndexOutOfBounds(listRef, indexRef.current)) {
          indexRef.current = prevIndex;
        }

        onNavigate(indexRef.current);
      }

      if (event.key === ARROW_DOWN) {
        stopEvent$1(event);

        if (prevIndex === -1) {
          indexRef.current = minIndex;
        } else {
          indexRef.current = findNonDisabledIndex(listRef, {
            startingIndex: prevIndex,
            amount: cols,
            disabledIndices
          });

          if (loop && prevIndex + cols > maxIndex) {
            indexRef.current = findNonDisabledIndex(listRef, {
              startingIndex: prevIndex % cols - cols,
              amount: cols,
              disabledIndices
            });
          }
        }

        if (isIndexOutOfBounds(listRef, indexRef.current)) {
          indexRef.current = prevIndex;
        }

        onNavigate(indexRef.current);
      } // Remains on the same row/column


      if (orientation === 'both') {
        const prevRow = Math.floor(prevIndex / cols);

        if (event.key === ARROW_RIGHT) {
          stopEvent$1(event);

          if (prevIndex % cols !== cols - 1) {
            indexRef.current = findNonDisabledIndex(listRef, {
              startingIndex: prevIndex,
              disabledIndices
            });

            if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex - prevIndex % cols - 1,
                disabledIndices
              });
            }
          } else if (loop) {
            indexRef.current = findNonDisabledIndex(listRef, {
              startingIndex: prevIndex - prevIndex % cols - 1,
              disabledIndices
            });
          }

          if (isDifferentRow(indexRef.current, cols, prevRow)) {
            indexRef.current = prevIndex;
          }
        }

        if (event.key === ARROW_LEFT) {
          stopEvent$1(event);

          if (prevIndex % cols !== 0) {
            indexRef.current = findNonDisabledIndex(listRef, {
              startingIndex: prevIndex,
              disabledIndices,
              decrement: true
            });

            if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {
              indexRef.current = findNonDisabledIndex(listRef, {
                startingIndex: prevIndex + (cols - prevIndex % cols),
                decrement: true,
                disabledIndices
              });
            }
          } else if (loop) {
            indexRef.current = findNonDisabledIndex(listRef, {
              startingIndex: prevIndex + (cols - prevIndex % cols),
              decrement: true,
              disabledIndices
            });
          }

          if (isDifferentRow(indexRef.current, cols, prevRow)) {
            indexRef.current = prevIndex;
          }
        }

        const lastRow = Math.floor(maxIndex / cols) === prevRow;

        if (isIndexOutOfBounds(listRef, indexRef.current)) {
          if (loop && lastRow) {
            indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {
              startingIndex: prevIndex - prevIndex % cols - 1,
              disabledIndices
            });
          } else {
            indexRef.current = prevIndex;
          }
        }

        onNavigate(indexRef.current);
        return;
      }
    }

    if (isMainOrientationKey(event.key, orientation)) {
      stopEvent$1(event); // Reset the index if no item is focused.

      if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {
        indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;
        onNavigate(indexRef.current);
        return;
      }

      if (isMainOrientationToEndKey(event.key, orientation, rtl)) {
        if (loop) {
          indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            disabledIndices
          });
        } else {
          indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            disabledIndices
          }));
        }
      } else {
        if (loop) {
          indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true,
            disabledIndices
          });
        } else {
          indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {
            startingIndex: currentIndex,
            decrement: true,
            disabledIndices
          }));
        }
      }

      if (isIndexOutOfBounds(listRef, indexRef.current)) {
        onNavigate(null);
      } else {
        onNavigate(indexRef.current);
      }
    }
  }

  if (!enabled) {
    return {};
  }

  return {
    reference: { ...(virtual && open && activeIndex != null && {
        'aria-activedescendant': activeId
      }),

      onKeyDown(event) {
        blockPointerLeaveRef.current = true;

        if (virtual && open) {
          return onKeyDown(event);
        }

        const isNavigationKey = event.key.indexOf('Arrow') === 0 || event.key === 'Enter' || event.key === ' ' || event.key === '';

        if (isNavigationKey) {
          keyRef.current = event.key;
        }

        if (nested) {
          if (isCrossOrientationOpenKey(event.key, orientation, rtl)) {
            stopEvent$1(event);

            if (open) {
              indexRef.current = getMinIndex(listRef, disabledIndices);
              onNavigate(indexRef.current);
            } else {
              onOpenChange(true);
            }
          }

          return;
        }

        if (isMainOrientationKey(event.key, orientation)) {
          if (selectedIndex != null) {
            indexRef.current = selectedIndex;
          }

          stopEvent$1(event);

          if (!open && openOnArrowKeyDown) {
            onOpenChange(true);
          } else {
            onKeyDown(event);
          }

          if (open) {
            onNavigate(indexRef.current);
          }
        }
      }

    },
    floating: {
      'aria-orientation': orientation === 'both' ? undefined : orientation,
      ...(virtual && activeIndex != null && {
        'aria-activedescendant': activeId
      }),
      onKeyDown,

      onPointerMove() {
        blockPointerLeaveRef.current = false;
      }

    },
    item: {
      onFocus(_ref2) {
        let {
          currentTarget
        } = _ref2;
        const index = listRef.current.indexOf(currentTarget);

        if (index !== -1) {
          onNavigate(index);
        }
      },

      onClick: _ref3 => {
        let {
          currentTarget
        } = _ref3;
        return currentTarget.focus({
          preventScroll: true
        });
      },
      // Safari
      ...(focusItemOnHover && {
        onMouseMove(_ref4) {
          let {
            currentTarget
          } = _ref4;
          const target = currentTarget;

          if (target) {
            const index = listRef.current.indexOf(target);

            if (index !== -1) {
              onNavigate(index);
            }
          }
        },

        onPointerLeave() {
          if (!blockPointerLeaveRef.current) {
            indexRef.current = -1;
            focusItem(listRef, indexRef);
            onNavigate(null);

            if (!virtual) {
              requestAnimationFrame(() => {
                var _refs$floating$curren;

                (_refs$floating$curren = refs.floating.current) == null ? void 0 : _refs$floating$curren.focus({
                  preventScroll: true
                });
              });
            }
          }
        }

      })
    }
  };
};

var css$10 = ".Alert_module_root__f2bc8467 {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: flex-start;\n  position: fixed;\n  padding: 0.938rem;\n  width: 500px;\n}\n.Alert_module_root__f2bc8467.Alert_module_positionBottomCenter__f2bc8467 {\n  left: 50%;\n  bottom: 1rem;\n  transform: translate(-50%, 0);\n}\n.Alert_module_root__f2bc8467.Alert_module_positionTopRight__f2bc8467 {\n  right: 1rem;\n  top: 1rem;\n}\n.Alert_module_root__f2bc8467 .Alert_module_left__f2bc8467 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: flex-start;\n}\n.Alert_module_root__f2bc8467 .Alert_module_left__f2bc8467 .Alert_module_icons__f2bc8467 {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  padding: 0.313rem 0.938rem 0rem 0rem;\n  height: auto;\n}\n.Alert_module_root__f2bc8467 .Alert_module_left__f2bc8467 .Alert_module_icons__f2bc8467 .Alert_module_icon__f2bc8467 {\n  width: 1.25rem;\n  height: 1.25rem;\n}\n.Alert_module_root__f2bc8467 .Alert_module_left__f2bc8467 .Alert_module_content__f2bc8467 {\n  padding: 0.188rem 0.938rem 0rem 0rem;\n}\n.Alert_module_root__f2bc8467 .Alert_module_left__f2bc8467 .Alert_module_content__f2bc8467 .Alert_module_title__f2bc8467 {\n  font-size: 0.875rem;\n  font-weight: 600;\n  padding-right: 2px;\n}\n.Alert_module_root__f2bc8467 .Alert_module_left__f2bc8467 .Alert_module_content__f2bc8467 .Alert_module_description__f2bc8467 {\n  word-wrap: break-word;\n  height: auto;\n  font-size: 0.875rem;\n  font-weight: 400;\n  margin-bottom: 0.5rem;\n}\n.Alert_module_root__f2bc8467 .Alert_module_actions__f2bc8467 {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: flex-start;\n  gap: 5px;\n}\n.Alert_module_root__f2bc8467 .Alert_module_actions__f2bc8467 .Alert_module_button__f2bc8467 {\n  padding: 0.313rem 1rem;\n  font-weight: 400;\n}\n.Alert_module_root__f2bc8467 .Alert_module_actions__f2bc8467 .Alert_module_close__f2bc8467 {\n  height: auto;\n}\n.Alert_module_root__f2bc8467 .Alert_module_actions__f2bc8467 .Alert_module_close__f2bc8467 .Alert_module_icon__f2bc8467 {\n  width: 1.25rem;\n  height: 1.25rem;\n  fill: var(--black);\n}\n.Alert_module_root__f2bc8467.Alert_module_borderDefault__f2bc8467 {\n  border-width: 0.063rem;\n}\n.Alert_module_root__f2bc8467.Alert_module_borderThickLeft__f2bc8467 {\n  border-width: 0.063rem 0.063rem 0.063rem 0.25rem;\n}\n.Alert_module_root__f2bc8467.Alert_module_borderNone__f2bc8467 {\n  border-width: 0rem 0rem 0rem 0.25rem;\n}\n.Alert_module_root__f2bc8467.Alert_module_info__f2bc8467 {\n  border-style: solid;\n  border-color: var(--info);\n  background-color: #edf5ff;\n}\n.Alert_module_root__f2bc8467.Alert_module_info__f2bc8467 .Alert_module_icon__f2bc8467 {\n  fill: var(--info);\n}\n.Alert_module_root__f2bc8467.Alert_module_success__f2bc8467 {\n  border-style: solid;\n  border-color: var(--success);\n  background-color: var(--success-bg);\n}\n.Alert_module_root__f2bc8467.Alert_module_success__f2bc8467 .Alert_module_icon__f2bc8467 {\n  fill: var(--success);\n}\n.Alert_module_root__f2bc8467.Alert_module_danger__f2bc8467 {\n  border-style: solid;\n  border-color: var(--error);\n  background-color: var(--error-bg);\n}\n.Alert_module_root__f2bc8467.Alert_module_danger__f2bc8467 .Alert_module_icon__f2bc8467 {\n  fill: var(--error);\n}\n.Alert_module_root__f2bc8467.Alert_module_warning__f2bc8467 {\n  border-style: solid;\n  border-color: var(--warning);\n  background-color: var(--warning-bg);\n}\n.Alert_module_root__f2bc8467.Alert_module_warning__f2bc8467 .Alert_module_icon__f2bc8467 {\n  fill: var(--warning);\n}\n.Alert_module_root__f2bc8467.Alert_module_shadow__f2bc8467 {\n  box-shadow: 0.125rem 0.5rem 1rem rgba(60, 60, 60, 0.12);\n}";
var modules_3a764ea3 = {"root":"Alert_module_root__f2bc8467","position-bottom-center":"Alert_module_positionBottomCenter__f2bc8467","position-top-right":"Alert_module_positionTopRight__f2bc8467","left":"Alert_module_left__f2bc8467","icons":"Alert_module_icons__f2bc8467","icon":"Alert_module_icon__f2bc8467","content":"Alert_module_content__f2bc8467","title":"Alert_module_title__f2bc8467","description":"Alert_module_description__f2bc8467","actions":"Alert_module_actions__f2bc8467","button":"Alert_module_button__f2bc8467","close":"Alert_module_close__f2bc8467","border-default":"Alert_module_borderDefault__f2bc8467","border-thick-left":"Alert_module_borderThickLeft__f2bc8467","border-none":"Alert_module_borderNone__f2bc8467","info":"Alert_module_info__f2bc8467","success":"Alert_module_success__f2bc8467","danger":"Alert_module_danger__f2bc8467","warning":"Alert_module_warning__f2bc8467","shadow":"Alert_module_shadow__f2bc8467"};
n(css$10,{});

var css$$ = ".Popper_module_backdrop__0c794282 {\n  position: fixed;\n  z-index: 100;\n  inset: 0;\n  background: rgba(0, 0, 0, 0.4);\n}\n.Popper_module_backdrop__0c794282.Popper_module_transparent__0c794282 {\n  background: none;\n}\n.Popper_module_backdrop__0c794282.Popper_module_hideBackdrop__0c794282 {\n  position: static !important;\n}";
var modules_fe46b225 = {"backdrop":"Popper_module_backdrop__0c794282","transparent":"Popper_module_transparent__0c794282","hide-backdrop":"Popper_module_hideBackdrop__0c794282"};
n(css$$,{});

var Popper = function Popper(props) {
  var open = props.open,
    children = props.children,
    wrapperId = props.wrapperId,
    backdrop = props.backdrop,
    className = props.className,
    transparent = props.transparent;
  var id = useId();
  var portalId = "".concat(wrapperId).concat(id);
  React.useEffect(function () {
    return function () {
      var portalDOM = document.getElementById(portalId);
      if (portalDOM) {
        document.body.removeChild(portalDOM);
      }
    };
  }, []);
  return /*#__PURE__*/jsxRuntime.jsx(FloatingPortal, {
    id: portalId,
    children: open && /*#__PURE__*/jsxRuntime.jsx(FloatingOverlay, {
      lockScroll: true,
      className: classes(className, modules_fe46b225.backdrop, transparent ? modules_fe46b225.transparent : '', backdrop ? '' : modules_fe46b225['hide-backdrop']),
      children: children
    })
  });
};
Popper.propTypes = {
  className: propTypes$1.exports.string,
  open: propTypes$1.exports.bool,
  backdrop: propTypes$1.exports.bool,
  wrapperId: propTypes$1.exports.string,
  transparent: propTypes$1.exports.bool
};
Popper.defaultProps = {
  className: '',
  open: false,
  backdrop: true,
  wrapperId: 'default-popper',
  transparent: true
};

var Alert = function Alert(props) {
  var action = props.action,
    AlertTypeIcon = props.icon,
    showIcon = props.showIcon,
    close = props.close,
    title = props.title,
    description = props.description,
    border = props.border,
    color = props.color,
    shadow = props.shadow,
    open = props.open,
    toggle = props.toggle,
    position = props.position;
  var Icon = null;
  if (AlertTypeIcon != null) {
    Icon = /*#__PURE__*/jsxRuntime.jsx(AlertTypeIcon, {
      className: modules_3a764ea3.icon
    });
  } else {
    switch (color) {
      case 'info':
        Icon = /*#__PURE__*/jsxRuntime.jsx(AlertIcon.Info, {
          className: modules_3a764ea3.icon
        });
        break;
      case 'warning':
        Icon = /*#__PURE__*/jsxRuntime.jsx(AlertIcon.Warning, {
          className: modules_3a764ea3.icon
        });
        break;
      case 'success':
        Icon = /*#__PURE__*/jsxRuntime.jsx(AlertIcon.Success, {
          className: modules_3a764ea3.icon
        });
        break;
      case 'danger':
        Icon = /*#__PURE__*/jsxRuntime.jsx(AlertIcon.Danger, {
          className: modules_3a764ea3.icon
        });
        break;
      default:
        Icon = /*#__PURE__*/jsxRuntime.jsx(AlertTypeIcon, {});
        break;
    }
  }
  var _useFloating = useFloating({
      open: open,
      onOpenChange: toggle
    }),
    floating = _useFloating.floating,
    context = _useFloating.context;
  var _useInteractions = useInteractions([useDismiss(context)]),
    getFloatingProps = _useInteractions.getFloatingProps;
  return /*#__PURE__*/jsxRuntime.jsx(Popper, {
    open: open,
    className: modules_3a764ea3.popper,
    id: "alert-popper",
    children: /*#__PURE__*/jsxRuntime.jsxs("div", _objectSpread2(_objectSpread2({}, getFloatingProps({
      ref: floating,
      className: classes(modules_3a764ea3.root, modules_3a764ea3[color], modules_3a764ea3["border-".concat(border)], shadow ? modules_3a764ea3.shadow : '', modules_3a764ea3["position-".concat(position)])
    })), {}, {
      children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
        className: modules_3a764ea3.left,
        children: [/*#__PURE__*/jsxRuntime.jsx("div", {
          className: modules_3a764ea3.icons,
          children: showIcon && Icon
        }), /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: modules_3a764ea3.content,
          children: [/*#__PURE__*/jsxRuntime.jsx("span", {
            className: modules_3a764ea3.title,
            children: title
          }), /*#__PURE__*/jsxRuntime.jsx("span", {
            className: modules_3a764ea3.description,
            children: description
          })]
        })]
      }), (action || close) && /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: modules_3a764ea3.actions,
        children: [action && /*#__PURE__*/jsxRuntime.jsx(Button, {
          title: action,
          size: "small",
          variant: "text",
          color: "primary",
          className: modules_3a764ea3.button
        }), close && /*#__PURE__*/jsxRuntime.jsx(Button, {
          size: "auto",
          variant: "text",
          onClick: toggle,
          className: modules_3a764ea3.close,
          leftComponent: function leftComponent() {
            return /*#__PURE__*/jsxRuntime.jsx(Cross$1, {
              className: modules_3a764ea3.icon
            });
          }
        })]
      })]
    }))
  });
};
Alert.propTypes = {
  action: propTypes$1.exports.string,
  showIcon: propTypes$1.exports.bool,
  icon: propTypes$1.exports.node,
  title: propTypes$1.exports.string,
  close: propTypes$1.exports.bool,
  description: propTypes$1.exports.string,
  border: propTypes$1.exports.oneOf(['default', 'thick-left', 'none']),
  color: propTypes$1.exports.oneOf(['info', 'success', 'danger', 'warning']),
  shadow: propTypes$1.exports.bool,
  toggle: propTypes$1.exports.func,
  open: propTypes$1.exports.bool,
  position: propTypes$1.exports.oneOf(['bottom-center', 'top-right'])
};
Alert.defaultProps = {
  action: '',
  showIcon: true,
  icon: null,
  title: 'Alert Title',
  close: true,
  description: 'Alert Description in single line',
  border: 'default',
  color: 'info',
  shadow: false,
  toggle: function toggle() {},
  open: true,
  position: 'bottom-center'
};

var css$_ = ".Breadcrumbs_module_root__f527a278 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  gap: 0.5rem;\n  width: auto;\n}\n.Breadcrumbs_module_root__f527a278 .Breadcrumbs_module_seperator__f527a278 {\n  width: 1.5rem;\n  height: 1.5rem;\n  stroke: var(--grey2);\n}\n.Breadcrumbs_module_root__f527a278 button.Breadcrumbs_module_expand__f527a278[data-elem=base-cell] {\n  background: var(--grey6);\n  color: var(--dark-grey);\n  height: 0.75rem;\n  padding: 0.25rem;\n}\n.Breadcrumbs_module_root__f527a278 button.Breadcrumbs_module_expand__f527a278[data-elem=base-cell] [data-elem=title] {\n  margin-bottom: 0.4rem;\n}\n.Breadcrumbs_module_root__f527a278 .Breadcrumbs_module_crumb__f527a278 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  color: var(--grey2);\n}\n.Breadcrumbs_module_root__f527a278 .Breadcrumbs_module_crumb__f527a278.Breadcrumbs_module_active__f527a278 {\n  color: var(--black);\n}\n.Breadcrumbs_module_root__f527a278 .Breadcrumbs_module_crumb__f527a278:hover:not(.Breadcrumbs_module_active__f527a278) {\n  color: var(--info);\n}\n.Breadcrumbs_module_root__f527a278.Breadcrumbs_module_themeLight__f527a278 .Breadcrumbs_module_crumb__f527a278 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  color: var(--grey2);\n}\n.Breadcrumbs_module_root__f527a278.Breadcrumbs_module_themeLight__f527a278 .Breadcrumbs_module_crumb__f527a278.Breadcrumbs_module_active__f527a278 {\n  color: var(--black);\n}\n.Breadcrumbs_module_root__f527a278.Breadcrumbs_module_themeLight__f527a278 .Breadcrumbs_module_crumb__f527a278:hover:not(.Breadcrumbs_module_active__f527a278) {\n  color: var(--info);\n}\n.Breadcrumbs_module_root__f527a278.Breadcrumbs_module_themeDark__f527a278 .Breadcrumbs_module_crumb__f527a278 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  color: var(--grey2);\n}\n.Breadcrumbs_module_root__f527a278.Breadcrumbs_module_themeDark__f527a278 .Breadcrumbs_module_crumb__f527a278.Breadcrumbs_module_active__f527a278 {\n  color: var(--white);\n}\n.Breadcrumbs_module_root__f527a278.Breadcrumbs_module_themeDark__f527a278 .Breadcrumbs_module_crumb__f527a278:hover:not(.Breadcrumbs_module_active__f527a278) {\n  color: var(--info);\n}";
var modules_651f50a9 = {"root":"Breadcrumbs_module_root__f527a278","seperator":"Breadcrumbs_module_seperator__f527a278","expand":"Breadcrumbs_module_expand__f527a278","crumb":"Breadcrumbs_module_crumb__f527a278","active":"Breadcrumbs_module_active__f527a278","theme-light":"Breadcrumbs_module_themeLight__f527a278","theme-dark":"Breadcrumbs_module_themeDark__f527a278"};
n(css$_,{});

var css$Z = ".Text_module_root__71f59b14 {\n  color: var(--dark-grey);\n}\n.Text_module_root__71f59b14.Text_module_h1__71f59b14 {\n  font-size: 2.25rem;\n  line-height: 2.75rem;\n}\n.Text_module_root__71f59b14.Text_module_h2__71f59b14 {\n  font-size: 1.375rem;\n  line-height: 1.688rem;\n}\n.Text_module_root__71f59b14.Text_module_b1__71f59b14 {\n  font-size: 1rem;\n  line-height: 1.188rem;\n}\n.Text_module_root__71f59b14.Text_module_b2__71f59b14 {\n  font-size: 0.875rem;\n  line-height: 1.188rem;\n}\n.Text_module_root__71f59b14.Text_module_b3__71f59b14 {\n  font-size: 0.75rem;\n  line-height: 1.063rem;\n}\n.Text_module_root__71f59b14.Text_module_regularStroke__71f59b14 {\n  font-weight: 400;\n}\n.Text_module_root__71f59b14.Text_module_mediumStroke__71f59b14 {\n  font-weight: 500;\n}\n.Text_module_root__71f59b14.Text_module_semiboldStroke__71f59b14 {\n  font-weight: 600;\n}\n.Text_module_root__71f59b14.Text_module_boldStroke__71f59b14 {\n  font-weight: 800;\n}";
var modules_22fa3f10 = {"root":"Text_module_root__71f59b14","h1":"Text_module_h1__71f59b14","h2":"Text_module_h2__71f59b14","b1":"Text_module_b1__71f59b14","b2":"Text_module_b2__71f59b14","b3":"Text_module_b3__71f59b14","regular-stroke":"Text_module_regularStroke__71f59b14","medium-stroke":"Text_module_mediumStroke__71f59b14","semibold-stroke":"Text_module_semiboldStroke__71f59b14","bold-stroke":"Text_module_boldStroke__71f59b14"};
n(css$Z,{});

// eslint-disable-next-line prefer-arrow-callback
var Text = /*#__PURE__*/React.forwardRef(function Text(props, ref) {
  // eslint-disable-next-line object-curly-newline
  var variant = props.variant,
    component = props.component,
    stroke = props.stroke,
    weight = props.weight,
    italic = props.italic,
    underline = props.underline,
    children = props.children,
    className = props.className,
    attrs = props.attrs;
  var TextDOM = /*#__PURE__*/React.createElement(component, _objectSpread2({
    ref: ref,
    style: _objectSpread2(_objectSpread2(_objectSpread2({}, italic && {
      fontStyle: 'italic'
    }), underline && {
      textDecoration: 'underline'
    }), weight && {
      fontWeight: weight
    }),
    className: classes(className, modules_22fa3f10.root, modules_22fa3f10[variant], modules_22fa3f10["".concat(stroke, "-stroke")])
  }, attrs), children);
  if ( /*#__PURE__*/React.isValidElement(TextDOM)) {
    return TextDOM;
  }
  return null;
});
Text.propTypes = {
  variant: propTypes$1.exports.oneOf(['h1', 'h2', 'b1', 'b2', 'b3']),
  component: propTypes$1.exports.oneOf(['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'span', 'a']),
  weight: propTypes$1.exports.oneOf([100, 200, 300, 400, 500, 600]),
  stroke: propTypes$1.exports.oneOf(['regular', 'medium', 'semibold', 'bold']),
  italic: propTypes$1.exports.bool,
  underline: propTypes$1.exports.bool,
  className: propTypes$1.exports.string,
  attrs: propTypes$1.exports.object
};
Text.defaultProps = {
  variant: 'b2',
  weight: null,
  component: 'span',
  stroke: 'regular',
  italic: false,
  underline: false,
  className: '',
  attrs: {}
};

var css$Y = ".Link_module_root__51df30d3 {\n  color: var(--highlight);\n  text-decoration: none;\n}\n.Link_module_root__51df30d3.Link_module_underlineNone__51df30d3 {\n  text-decoration: none;\n}\n.Link_module_root__51df30d3.Link_module_underlineHover__51df30d3:hover {\n  text-decoration: underline;\n}\n.Link_module_root__51df30d3.Link_module_underlineAlways__51df30d3 {\n  text-decoration: underline;\n}";
var modules_475441e2 = {"root":"Link_module_root__51df30d3","underline-none":"Link_module_underlineNone__51df30d3","underline-hover":"Link_module_underlineHover__51df30d3","underline-always":"Link_module_underlineAlways__51df30d3"};
n(css$Y,{});

var Link = /*#__PURE__*/React.forwardRef(function Link(props, ref) {
  var variant = props.variant,
    component = props.component,
    stroke = props.stroke,
    weight = props.weight,
    italic = props.italic,
    children = props.children,
    href = props.href,
    target = props.target,
    attrs = props.attrs,
    className = props.className,
    underline = props.underline;
  return /*#__PURE__*/jsxRuntime.jsx(Text, {
    ref: ref,
    variant: variant,
    component: component,
    stroke: stroke,
    weight: weight,
    italic: italic,
    className: classes(className, modules_475441e2.root, modules_475441e2["underline-".concat(underline)]),
    attrs: _objectSpread2({
      to: href,
      href: href,
      target: target
    }, attrs),
    children: children
  });
});
Link.propTypes = _objectSpread2(_objectSpread2({}, Text.propTypes), {}, {
  href: propTypes$1.exports.string,
  target: propTypes$1.exports.oneOf(['_self', '_blank', '_parent', '_top']),
  component: propTypes$1.exports.oneOfType([propTypes$1.exports.string, propTypes$1.exports.element]),
  className: propTypes$1.exports.string,
  attrs: propTypes$1.exports.object,
  underline: propTypes$1.exports.oneOf(['always', 'hover', 'none'])
});
Link.defaultProps = _objectSpread2(_objectSpread2({}, Text.defaultProps), {}, {
  href: null,
  target: '_self',
  component: 'a',
  className: '',
  attrs: {},
  underline: 'always'
});

var BreadCrumbs = function BreadCrumbs(props) {
  var crumbs = props.crumbs,
    maxItems = props.maxItems,
    itemsBeforeCollapse = props.itemsBeforeCollapse,
    itemsAfterCollapse = props.itemsAfterCollapse,
    linkComponent = props.linkComponent,
    theme = props.theme;
  var _useState = React.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    expand = _useState2[0],
    setExpand = _useState2[1];
  var href = '';
  var CrumbsDOM = crumbs.map(function (crumb, index) {
    var title = crumb.title,
      path = crumb.path,
      search = crumb.search,
      icon = crumb.icon;
    var active = index === crumbs.length - 1;
    var showSeperator = index < crumbs.length - 1;
    href += "/".concat(path);
    return /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
      children: [/*#__PURE__*/jsxRuntime.jsxs(Link, {
        href: !active && "".concat(href).concat(search !== null && search !== void 0 ? search : ''),
        underline: !active ? 'hover' : 'none',
        className: classes(modules_651f50a9.crumb, active ? modules_651f50a9.active : ''),
        dataAttrs: {
          'data-state': active
        },
        component: !active ? linkComponent : 'span',
        stroke: !active ? 'regular' : 'medium',
        children: [icon && icon, title && /*#__PURE__*/jsxRuntime.jsx("span", {
          children: getSpacedDisplayName(title).replace(/-/g, ' ')
        })]
      }), showSeperator && /*#__PURE__*/jsxRuntime.jsx(BreadcrumbSeperator, {
        className: modules_651f50a9.seperator
      })]
    }, path);
  });
  if (CrumbsDOM.length > maxItems && !expand) {
    CrumbsDOM.splice(itemsBeforeCollapse, CrumbsDOM.length - (itemsAfterCollapse + itemsBeforeCollapse), /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
      children: [/*#__PURE__*/jsxRuntime.jsx(Button, {
        className: modules_651f50a9.expand,
        size: "auto",
        color: "default",
        title: "...",
        onClick: function onClick() {
          setExpand(true);
        }
      }), /*#__PURE__*/jsxRuntime.jsx(BreadcrumbSeperator, {
        className: modules_651f50a9.seperator
      })]
    }, 'expand'));
  }
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: classes(modules_651f50a9.root, modules_651f50a9["theme-".concat(theme)]),
    children: CrumbsDOM
  });
};
BreadCrumbs.propTypes = {
  theme: propTypes$1.exports.oneOf(['light', 'dark']),
  crumbs: propTypes$1.exports.arrayOf(propTypes$1.exports.shape({
    title: propTypes$1.exports.string,
    path: propTypes$1.exports.string,
    icon: propTypes$1.exports.node
  })),
  maxItems: propTypes$1.exports.number,
  itemsBeforeCollapse: propTypes$1.exports.number,
  itemsAfterCollapse: propTypes$1.exports.number,
  linkComponent: propTypes$1.exports.oneOfType([propTypes$1.exports.string, propTypes$1.exports.element])
};
BreadCrumbs.defaultProps = {
  theme: 'dark',
  crumbs: [],
  maxItems: 4,
  itemsBeforeCollapse: 2,
  itemsAfterCollapse: 1,
  linkComponent: 'a'
};

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
//
// Super simple, non-algorithmic solution since the
// number of class names will not be greater than 4

function powerSetPermutations(arr) {
  var arrLength = arr.length;
  if (arrLength === 0 || arrLength === 1) return arr;

  if (arrLength === 2) {
    // prettier-ignore
    return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
  }

  if (arrLength === 3) {
    return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }

  if (arrLength >= 4) {
    // Currently does not support more than 4 extra
    // class names (after `.token` has been removed)
    return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
}

var classNameCombinations = {};

function getClassNameCombinations(classNames) {
  if (classNames.length === 0 || classNames.length === 1) return classNames;
  var key = classNames.join('.');

  if (!classNameCombinations[key]) {
    classNameCombinations[key] = powerSetPermutations(classNames);
  }

  return classNameCombinations[key];
}

function createStyleObject(classNames) {
  var elementStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var stylesheet = arguments.length > 2 ? arguments[2] : undefined;
  var nonTokenClassNames = classNames.filter(function (className) {
    return className !== 'token';
  });
  var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
  return classNamesCombinations.reduce(function (styleObject, className) {
    return _objectSpread$1(_objectSpread$1({}, styleObject), stylesheet[className]);
  }, elementStyle);
}
function createClassNameString(classNames) {
  return classNames.join(' ');
}
function createChildren(stylesheet, useInlineStyles) {
  var childrenCount = 0;
  return function (children) {
    childrenCount += 1;
    return children.map(function (child, i) {
      return createElement({
        node: child,
        stylesheet: stylesheet,
        useInlineStyles: useInlineStyles,
        key: "code-segment-".concat(childrenCount, "-").concat(i)
      });
    });
  };
}
function createElement(_ref) {
  var node = _ref.node,
      stylesheet = _ref.stylesheet,
      _ref$style = _ref.style,
      style = _ref$style === void 0 ? {} : _ref$style,
      useInlineStyles = _ref.useInlineStyles,
      key = _ref.key;
  var properties = node.properties,
      type = node.type,
      TagName = node.tagName,
      value = node.value;

  if (type === 'text') {
    return value;
  } else if (TagName) {
    var childrenCreator = createChildren(stylesheet, useInlineStyles);
    var props;

    if (!useInlineStyles) {
      props = _objectSpread$1(_objectSpread$1({}, properties), {}, {
        className: createClassNameString(properties.className)
      });
    } else {
      var allStylesheetSelectors = Object.keys(stylesheet).reduce(function (classes, selector) {
        selector.split('.').forEach(function (className) {
          if (!classes.includes(className)) classes.push(className);
        });
        return classes;
      }, []); // For compatibility with older versions of react-syntax-highlighter

      var startingClassName = properties.className && properties.className.includes('token') ? ['token'] : [];
      var className = properties.className && startingClassName.concat(properties.className.filter(function (className) {
        return !allStylesheetSelectors.includes(className);
      }));
      props = _objectSpread$1(_objectSpread$1({}, properties), {}, {
        className: createClassNameString(className) || undefined,
        style: createStyleObject(properties.className, Object.assign({}, properties.style, style), stylesheet)
      });
    }

    var children = childrenCreator(node.children);
    return /*#__PURE__*/React.createElement(TagName, _extends({
      key: key
    }, props), children);
  }
}

var checkForListedLanguage = (function (astGenerator, language) {
  var langs = astGenerator.listLanguages();
  return langs.indexOf(language) !== -1;
});

var _excluded$2 = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var newLineRegex = /\n/g;

function getNewLines(str) {
  return str.match(newLineRegex);
}

function getAllLineNumbers(_ref) {
  var lines = _ref.lines,
      startingLineNumber = _ref.startingLineNumber,
      style = _ref.style;
  return lines.map(function (_, i) {
    var number = i + startingLineNumber;
    return /*#__PURE__*/React.createElement("span", {
      key: "line-".concat(i),
      className: "react-syntax-highlighter-line-number",
      style: typeof style === 'function' ? style(number) : style
    }, "".concat(number, "\n"));
  });
}

function AllLineNumbers(_ref2) {
  var codeString = _ref2.codeString,
      codeStyle = _ref2.codeStyle,
      _ref2$containerStyle = _ref2.containerStyle,
      containerStyle = _ref2$containerStyle === void 0 ? {
    "float": 'left',
    paddingRight: '10px'
  } : _ref2$containerStyle,
      _ref2$numberStyle = _ref2.numberStyle,
      numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle,
      startingLineNumber = _ref2.startingLineNumber;
  return /*#__PURE__*/React.createElement("code", {
    style: Object.assign({}, codeStyle, containerStyle)
  }, getAllLineNumbers({
    lines: codeString.replace(/\n$/, '').split('\n'),
    style: numberStyle,
    startingLineNumber: startingLineNumber
  }));
}

function getEmWidthOfNumber(num) {
  return "".concat(num.toString().length, ".25em");
}

function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
  return {
    type: 'element',
    tagName: 'span',
    properties: {
      key: "line-number--".concat(lineNumber),
      className: ['comment', 'linenumber', 'react-syntax-highlighter-line-number'],
      style: inlineLineNumberStyle
    },
    children: [{
      type: 'text',
      value: lineNumber
    }]
  };
}

function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
  // minimally necessary styling for line numbers
  var defaultLineNumberStyle = {
    display: 'inline-block',
    minWidth: getEmWidthOfNumber(largestLineNumber),
    paddingRight: '1em',
    textAlign: 'right',
    userSelect: 'none'
  }; // prep custom styling

  var customLineNumberStyle = typeof lineNumberStyle === 'function' ? lineNumberStyle(lineNumber) : lineNumberStyle; // combine

  var assembledStyle = _objectSpread(_objectSpread({}, defaultLineNumberStyle), customLineNumberStyle);

  return assembledStyle;
}

function createLineElement(_ref3) {
  var children = _ref3.children,
      lineNumber = _ref3.lineNumber,
      lineNumberStyle = _ref3.lineNumberStyle,
      largestLineNumber = _ref3.largestLineNumber,
      showInlineLineNumbers = _ref3.showInlineLineNumbers,
      _ref3$lineProps = _ref3.lineProps,
      lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps,
      _ref3$className = _ref3.className,
      className = _ref3$className === void 0 ? [] : _ref3$className,
      showLineNumbers = _ref3.showLineNumbers,
      wrapLongLines = _ref3.wrapLongLines;
  var properties = typeof lineProps === 'function' ? lineProps(lineNumber) : lineProps;
  properties['className'] = className;

  if (lineNumber && showInlineLineNumbers) {
    var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
    children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
  }

  if (wrapLongLines & showLineNumbers) {
    properties.style = _objectSpread(_objectSpread({}, properties.style), {}, {
      display: 'flex'
    });
  }

  return {
    type: 'element',
    tagName: 'span',
    properties: properties,
    children: children
  };
}

function flattenCodeTree(tree) {
  var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var newTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  for (var i = 0; i < tree.length; i++) {
    var node = tree[i];

    if (node.type === 'text') {
      newTree.push(createLineElement({
        children: [node],
        className: _toConsumableArray(new Set(className))
      }));
    } else if (node.children) {
      var classNames = className.concat(node.properties.className);
      flattenCodeTree(node.children, classNames).forEach(function (i) {
        return newTree.push(i);
      });
    }
  }

  return newTree;
}

function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
  var _ref4;

  var tree = flattenCodeTree(codeTree.value);
  var newTree = [];
  var lastLineBreakIndex = -1;
  var index = 0;

  function createWrappedLine(children, lineNumber) {
    var className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    return createLineElement({
      children: children,
      lineNumber: lineNumber,
      lineNumberStyle: lineNumberStyle,
      largestLineNumber: largestLineNumber,
      showInlineLineNumbers: showInlineLineNumbers,
      lineProps: lineProps,
      className: className,
      showLineNumbers: showLineNumbers,
      wrapLongLines: wrapLongLines
    });
  }

  function createUnwrappedLine(children, lineNumber) {
    if (showLineNumbers && lineNumber && showInlineLineNumbers) {
      var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
      children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
    }

    return children;
  }

  function createLine(children, lineNumber) {
    var className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    return wrapLines || className.length > 0 ? createWrappedLine(children, lineNumber, className) : createUnwrappedLine(children, lineNumber);
  }

  var _loop = function _loop() {
    var node = tree[index];
    var value = node.children[0].value;
    var newLines = getNewLines(value);

    if (newLines) {
      var splitValue = value.split('\n');
      splitValue.forEach(function (text, i) {
        var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
        var newChild = {
          type: 'text',
          value: "".concat(text, "\n")
        }; // if it's the first line

        if (i === 0) {
          var _children = tree.slice(lastLineBreakIndex + 1, index).concat(createLineElement({
            children: [newChild],
            className: node.properties.className
          }));

          var _line = createLine(_children, lineNumber);

          newTree.push(_line); // if it's the last line
        } else if (i === splitValue.length - 1) {
          var stringChild = tree[index + 1] && tree[index + 1].children && tree[index + 1].children[0];
          var lastLineInPreviousSpan = {
            type: 'text',
            value: "".concat(text)
          };

          if (stringChild) {
            var newElem = createLineElement({
              children: [lastLineInPreviousSpan],
              className: node.properties.className
            });
            tree.splice(index + 1, 0, newElem);
          } else {
            var _children2 = [lastLineInPreviousSpan];

            var _line2 = createLine(_children2, lineNumber, node.properties.className);

            newTree.push(_line2);
          } // if it's neither the first nor the last line

        } else {
          var _children3 = [newChild];

          var _line3 = createLine(_children3, lineNumber, node.properties.className);

          newTree.push(_line3);
        }
      });
      lastLineBreakIndex = index;
    }

    index++;
  };

  while (index < tree.length) {
    _loop();
  }

  if (lastLineBreakIndex !== tree.length - 1) {
    var children = tree.slice(lastLineBreakIndex + 1, tree.length);

    if (children && children.length) {
      var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
      var line = createLine(children, lineNumber);
      newTree.push(line);
    }
  }

  return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}

function defaultRenderer(_ref5) {
  var rows = _ref5.rows,
      stylesheet = _ref5.stylesheet,
      useInlineStyles = _ref5.useInlineStyles;
  return rows.map(function (node, i) {
    return createElement({
      node: node,
      stylesheet: stylesheet,
      useInlineStyles: useInlineStyles,
      key: "code-segement".concat(i)
    });
  });
} // only highlight.js has the highlightAuto method


function isHighlightJs(astGenerator) {
  return astGenerator && typeof astGenerator.highlightAuto !== 'undefined';
}

function getCodeTree(_ref6) {
  var astGenerator = _ref6.astGenerator,
      language = _ref6.language,
      code = _ref6.code,
      defaultCodeValue = _ref6.defaultCodeValue;

  // figure out whether we're using lowlight/highlight or refractor/prism
  // then attempt highlighting accordingly
  // lowlight/highlight?
  if (isHighlightJs(astGenerator)) {
    var hasLanguage = checkForListedLanguage(astGenerator, language);

    if (language === 'text') {
      return {
        value: defaultCodeValue,
        language: 'text'
      };
    } else if (hasLanguage) {
      return astGenerator.highlight(language, code);
    } else {
      return astGenerator.highlightAuto(code);
    }
  } // must be refractor/prism, then


  try {
    return language && language !== 'text' ? {
      value: astGenerator.highlight(code, language)
    } : {
      value: defaultCodeValue
    };
  } catch (e) {
    return {
      value: defaultCodeValue
    };
  }
}

function highlight$1 (defaultAstGenerator, defaultStyle) {
  return function SyntaxHighlighter(_ref7) {
    var language = _ref7.language,
        children = _ref7.children,
        _ref7$style = _ref7.style,
        style = _ref7$style === void 0 ? defaultStyle : _ref7$style,
        _ref7$customStyle = _ref7.customStyle,
        customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle,
        _ref7$codeTagProps = _ref7.codeTagProps,
        codeTagProps = _ref7$codeTagProps === void 0 ? {
      className: language ? "language-".concat(language) : undefined,
      style: _objectSpread(_objectSpread({}, style['code[class*="language-"]']), style["code[class*=\"language-".concat(language, "\"]")])
    } : _ref7$codeTagProps,
        _ref7$useInlineStyles = _ref7.useInlineStyles,
        useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles,
        _ref7$showLineNumbers = _ref7.showLineNumbers,
        showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers,
        _ref7$showInlineLineN = _ref7.showInlineLineNumbers,
        showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN,
        _ref7$startingLineNum = _ref7.startingLineNumber,
        startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum,
        lineNumberContainerStyle = _ref7.lineNumberContainerStyle,
        _ref7$lineNumberStyle = _ref7.lineNumberStyle,
        lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle,
        wrapLines = _ref7.wrapLines,
        _ref7$wrapLongLines = _ref7.wrapLongLines,
        wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines,
        _ref7$lineProps = _ref7.lineProps,
        lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps,
        renderer = _ref7.renderer,
        _ref7$PreTag = _ref7.PreTag,
        PreTag = _ref7$PreTag === void 0 ? 'pre' : _ref7$PreTag,
        _ref7$CodeTag = _ref7.CodeTag,
        CodeTag = _ref7$CodeTag === void 0 ? 'code' : _ref7$CodeTag,
        _ref7$code = _ref7.code,
        code = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || '' : _ref7$code,
        astGenerator = _ref7.astGenerator,
        rest = _objectWithoutProperties(_ref7, _excluded$2);

    astGenerator = astGenerator || defaultAstGenerator;
    var allLineNumbers = showLineNumbers ? /*#__PURE__*/React.createElement(AllLineNumbers, {
      containerStyle: lineNumberContainerStyle,
      codeStyle: codeTagProps.style || {},
      numberStyle: lineNumberStyle,
      startingLineNumber: startingLineNumber,
      codeString: code
    }) : null;
    var defaultPreStyle = style.hljs || style['pre[class*="language-"]'] || {
      backgroundColor: '#fff'
    };
    var generatorClassName = isHighlightJs(astGenerator) ? 'hljs' : 'prismjs';
    var preProps = useInlineStyles ? Object.assign({}, rest, {
      style: Object.assign({}, defaultPreStyle, customStyle)
    }) : Object.assign({}, rest, {
      className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName,
      style: Object.assign({}, customStyle)
    });

    if (wrapLongLines) {
      codeTagProps.style = _objectSpread(_objectSpread({}, codeTagProps.style), {}, {
        whiteSpace: 'pre-wrap'
      });
    } else {
      codeTagProps.style = _objectSpread(_objectSpread({}, codeTagProps.style), {}, {
        whiteSpace: 'pre'
      });
    }

    if (!astGenerator) {
      return /*#__PURE__*/React.createElement(PreTag, preProps, allLineNumbers, /*#__PURE__*/React.createElement(CodeTag, codeTagProps, code));
    }
    /*
     * Some custom renderers rely on individual row elements so we need to turn wrapLines on
     * if renderer is provided and wrapLines is undefined.
     */


    if (wrapLines === undefined && renderer || wrapLongLines) wrapLines = true;
    renderer = renderer || defaultRenderer;
    var defaultCodeValue = [{
      type: 'text',
      value: code
    }];
    var codeTree = getCodeTree({
      astGenerator: astGenerator,
      language: language,
      code: code,
      defaultCodeValue: defaultCodeValue
    });

    if (codeTree.language === null) {
      codeTree.value = defaultCodeValue;
    } // determine largest line number so that we can force minWidth on all linenumber elements


    var largestLineNumber = codeTree.value.length + startingLineNumber;
    var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
    return /*#__PURE__*/React.createElement(PreTag, preProps, /*#__PURE__*/React.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
      rows: rows,
      stylesheet: style,
      useInlineStyles: useInlineStyles
    })));
  };
}

//
// This file has been auto-generated by the `npm run build-languages-prism` task
//
var supportedLanguages = ['abap', 'abnf', 'actionscript', 'ada', 'agda', 'al', 'antlr4', 'apacheconf', 'apex', 'apl', 'applescript', 'aql', 'arduino', 'arff', 'asciidoc', 'asm6502', 'asmatmel', 'aspnet', 'autohotkey', 'autoit', 'avisynth', 'avro-idl', 'bash', 'basic', 'batch', 'bbcode', 'bicep', 'birb', 'bison', 'bnf', 'brainfuck', 'brightscript', 'bro', 'bsl', 'c', 'cfscript', 'chaiscript', 'cil', 'clike', 'clojure', 'cmake', 'cobol', 'coffeescript', 'concurnas', 'coq', 'cpp', 'crystal', 'csharp', 'cshtml', 'csp', 'css-extras', 'css', 'csv', 'cypher', 'd', 'dart', 'dataweave', 'dax', 'dhall', 'diff', 'django', 'dns-zone-file', 'docker', 'dot', 'ebnf', 'editorconfig', 'eiffel', 'ejs', 'elixir', 'elm', 'erb', 'erlang', 'etlua', 'excel-formula', 'factor', 'false', 'firestore-security-rules', 'flow', 'fortran', 'fsharp', 'ftl', 'gap', 'gcode', 'gdscript', 'gedcom', 'gherkin', 'git', 'glsl', 'gml', 'gn', 'go-module', 'go', 'graphql', 'groovy', 'haml', 'handlebars', 'haskell', 'haxe', 'hcl', 'hlsl', 'hoon', 'hpkp', 'hsts', 'http', 'ichigojam', 'icon', 'icu-message-format', 'idris', 'iecst', 'ignore', 'inform7', 'ini', 'io', 'j', 'java', 'javadoc', 'javadoclike', 'javascript', 'javastacktrace', 'jexl', 'jolie', 'jq', 'js-extras', 'js-templates', 'jsdoc', 'json', 'json5', 'jsonp', 'jsstacktrace', 'jsx', 'julia', 'keepalived', 'keyman', 'kotlin', 'kumir', 'kusto', 'latex', 'latte', 'less', 'lilypond', 'liquid', 'lisp', 'livescript', 'llvm', 'log', 'lolcode', 'lua', 'magma', 'makefile', 'markdown', 'markup-templating', 'markup', 'matlab', 'maxscript', 'mel', 'mermaid', 'mizar', 'mongodb', 'monkey', 'moonscript', 'n1ql', 'n4js', 'nand2tetris-hdl', 'naniscript', 'nasm', 'neon', 'nevod', 'nginx', 'nim', 'nix', 'nsis', 'objectivec', 'ocaml', 'opencl', 'openqasm', 'oz', 'parigp', 'parser', 'pascal', 'pascaligo', 'pcaxis', 'peoplecode', 'perl', 'php-extras', 'php', 'phpdoc', 'plsql', 'powerquery', 'powershell', 'processing', 'prolog', 'promql', 'properties', 'protobuf', 'psl', 'pug', 'puppet', 'pure', 'purebasic', 'purescript', 'python', 'q', 'qml', 'qore', 'qsharp', 'r', 'racket', 'reason', 'regex', 'rego', 'renpy', 'rest', 'rip', 'roboconf', 'robotframework', 'ruby', 'rust', 'sas', 'sass', 'scala', 'scheme', 'scss', 'shell-session', 'smali', 'smalltalk', 'smarty', 'sml', 'solidity', 'solution-file', 'soy', 'sparql', 'splunk-spl', 'sqf', 'sql', 'squirrel', 'stan', 'stylus', 'swift', 'systemd', 't4-cs', 't4-templating', 't4-vb', 'tap', 'tcl', 'textile', 'toml', 'tremor', 'tsx', 'tt2', 'turtle', 'twig', 'typescript', 'typoscript', 'unrealscript', 'uorazor', 'uri', 'v', 'vala', 'vbnet', 'velocity', 'verilog', 'vhdl', 'vim', 'visual-basic', 'warpscript', 'wasm', 'web-idl', 'wiki', 'wolfram', 'wren', 'xeora', 'xml-doc', 'xojo', 'xquery', 'yaml', 'yang', 'zig'];

var hastscript = {exports: {}};

var immutable = extend$3;

var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function extend$3() {
    var target = {};

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (hasOwnProperty$1.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target
}

var schema$1 = Schema$2;

var proto$2 = Schema$2.prototype;

proto$2.space = null;
proto$2.normal = {};
proto$2.property = {};

function Schema$2(property, normal, space) {
  this.property = property;
  this.normal = normal;

  if (space) {
    this.space = space;
  }
}

var xtend = immutable;
var Schema$1 = schema$1;

var merge_1 = merge$3;

function merge$3(definitions) {
  var length = definitions.length;
  var property = [];
  var normal = [];
  var index = -1;
  var info;
  var space;

  while (++index < length) {
    info = definitions[index];
    property.push(info.property);
    normal.push(info.normal);
    space = info.space;
  }

  return new Schema$1(
    xtend.apply(null, property),
    xtend.apply(null, normal),
    space
  )
}

var normalize_1 = normalize$5;

function normalize$5(value) {
  return value.toLowerCase()
}

var info = Info$2;

var proto$1 = Info$2.prototype;

proto$1.space = null;
proto$1.attribute = null;
proto$1.property = null;
proto$1.boolean = false;
proto$1.booleanish = false;
proto$1.overloadedBoolean = false;
proto$1.number = false;
proto$1.commaSeparated = false;
proto$1.spaceSeparated = false;
proto$1.commaOrSpaceSeparated = false;
proto$1.mustUseProperty = false;
proto$1.defined = false;

function Info$2(property, attribute) {
  this.property = property;
  this.attribute = attribute;
}

var types$3 = {};

var powers = 0;

types$3.boolean = increment();
types$3.booleanish = increment();
types$3.overloadedBoolean = increment();
types$3.number = increment();
types$3.spaceSeparated = increment();
types$3.commaSeparated = increment();
types$3.commaOrSpaceSeparated = increment();

function increment() {
  return Math.pow(2, ++powers)
}

var Info$1 = info;
var types$2 = types$3;

var definedInfo = DefinedInfo$2;

DefinedInfo$2.prototype = new Info$1();
DefinedInfo$2.prototype.defined = true;

var checks = [
  'boolean',
  'booleanish',
  'overloadedBoolean',
  'number',
  'commaSeparated',
  'spaceSeparated',
  'commaOrSpaceSeparated'
];
var checksLength = checks.length;

function DefinedInfo$2(property, attribute, mask, space) {
  var index = -1;
  var check;

  mark(this, 'space', space);

  Info$1.call(this, property, attribute);

  while (++index < checksLength) {
    check = checks[index];
    mark(this, check, (mask & types$2[check]) === types$2[check]);
  }
}

function mark(values, key, value) {
  if (value) {
    values[key] = value;
  }
}

var normalize$4 = normalize_1;
var Schema = schema$1;
var DefinedInfo$1 = definedInfo;

var create_1 = create$7;

function create$7(definition) {
  var space = definition.space;
  var mustUseProperty = definition.mustUseProperty || [];
  var attributes = definition.attributes || {};
  var props = definition.properties;
  var transform = definition.transform;
  var property = {};
  var normal = {};
  var prop;
  var info;

  for (prop in props) {
    info = new DefinedInfo$1(
      prop,
      transform(attributes, prop),
      props[prop],
      space
    );

    if (mustUseProperty.indexOf(prop) !== -1) {
      info.mustUseProperty = true;
    }

    property[prop] = info;

    normal[normalize$4(prop)] = prop;
    normal[normalize$4(info.attribute)] = prop;
  }

  return new Schema(property, normal, space)
}

var create$6 = create_1;

var xlink$1 = create$6({
  space: 'xlink',
  transform: xlinkTransform,
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});

function xlinkTransform(_, prop) {
  return 'xlink:' + prop.slice(5).toLowerCase()
}

var create$5 = create_1;

var xml$1 = create$5({
  space: 'xml',
  transform: xmlTransform,
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
});

function xmlTransform(_, prop) {
  return 'xml:' + prop.slice(3).toLowerCase()
}

var caseSensitiveTransform_1 = caseSensitiveTransform$1;

function caseSensitiveTransform$1(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute
}

var caseSensitiveTransform = caseSensitiveTransform_1;

var caseInsensitiveTransform_1 = caseInsensitiveTransform$2;

function caseInsensitiveTransform$2(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase())
}

var create$4 = create_1;
var caseInsensitiveTransform$1 = caseInsensitiveTransform_1;

var xmlns$1 = create$4({
  space: 'xmlns',
  attributes: {
    xmlnsxlink: 'xmlns:xlink'
  },
  transform: caseInsensitiveTransform$1,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
});

var types$1 = types$3;
var create$3 = create_1;

var booleanish$1 = types$1.booleanish;
var number$2 = types$1.number;
var spaceSeparated$1 = types$1.spaceSeparated;

var aria$1 = create$3({
  transform: ariaTransform,
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish$1,
    ariaAutoComplete: null,
    ariaBusy: booleanish$1,
    ariaChecked: booleanish$1,
    ariaColCount: number$2,
    ariaColIndex: number$2,
    ariaColSpan: number$2,
    ariaControls: spaceSeparated$1,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated$1,
    ariaDetails: null,
    ariaDisabled: booleanish$1,
    ariaDropEffect: spaceSeparated$1,
    ariaErrorMessage: null,
    ariaExpanded: booleanish$1,
    ariaFlowTo: spaceSeparated$1,
    ariaGrabbed: booleanish$1,
    ariaHasPopup: null,
    ariaHidden: booleanish$1,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated$1,
    ariaLevel: number$2,
    ariaLive: null,
    ariaModal: booleanish$1,
    ariaMultiLine: booleanish$1,
    ariaMultiSelectable: booleanish$1,
    ariaOrientation: null,
    ariaOwns: spaceSeparated$1,
    ariaPlaceholder: null,
    ariaPosInSet: number$2,
    ariaPressed: booleanish$1,
    ariaReadOnly: booleanish$1,
    ariaRelevant: null,
    ariaRequired: booleanish$1,
    ariaRoleDescription: spaceSeparated$1,
    ariaRowCount: number$2,
    ariaRowIndex: number$2,
    ariaRowSpan: number$2,
    ariaSelected: booleanish$1,
    ariaSetSize: number$2,
    ariaSort: null,
    ariaValueMax: number$2,
    ariaValueMin: number$2,
    ariaValueNow: number$2,
    ariaValueText: null,
    role: null
  }
});

function ariaTransform(_, prop) {
  return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()
}

var types = types$3;
var create$2 = create_1;
var caseInsensitiveTransform = caseInsensitiveTransform_1;

var boolean = types.boolean;
var overloadedBoolean = types.overloadedBoolean;
var booleanish = types.booleanish;
var number$1 = types.number;
var spaceSeparated = types.spaceSeparated;
var commaSeparated = types.commaSeparated;

var html$2 = create$2({
  space: 'html',
  attributes: {
    acceptcharset: 'accept-charset',
    classname: 'class',
    htmlfor: 'for',
    httpequiv: 'http-equiv'
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number$1,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number$1 | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number$1,
    hidden: boolean,
    high: number$1,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: commaSeparated,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number$1,
    manifest: null,
    max: null,
    maxLength: number$1,
    media: null,
    method: null,
    min: null,
    minLength: number$1,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextMenu: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number$1,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number$1,
    rowSpan: number$1,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shape: null,
    size: number$1,
    sizes: null,
    slot: null,
    span: number$1,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: commaSeparated,
    start: number$1,
    step: null,
    style: null,
    tabIndex: number$1,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number$1,
    wrap: null,

    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null, // Several. Use CSS `text-align` instead,
    aLink: null, // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated, // `<object>`. List of URIs to archives
    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null, // `<body>`. Use CSS `background-image` instead
    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead
    border: number$1, // `<table>`. Use CSS `border-width` instead,
    borderColor: null, // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number$1, // `<body>`
    cellPadding: null, // `<table>`
    cellSpacing: null, // `<table>`
    char: null, // Several table elements. When `align=char`, sets the character to align on
    charOff: null, // Several table elements. When `char`, offsets the alignment
    classId: null, // `<object>`
    clear: null, // `<br>`. Use CSS `clear` instead
    code: null, // `<object>`
    codeBase: null, // `<object>`
    codeType: null, // `<object>`
    color: null, // `<font>` and `<hr>`. Use CSS instead
    compact: boolean, // Lists. Use CSS to reduce space between items instead
    declare: boolean, // `<object>`
    event: null, // `<script>`
    face: null, // `<font>`. Use CSS instead
    frame: null, // `<table>`
    frameBorder: null, // `<iframe>`. Use CSS `border` instead
    hSpace: number$1, // `<img>` and `<object>`
    leftMargin: number$1, // `<body>`
    link: null, // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null, // `<img>`. Use a `<picture>`
    marginHeight: number$1, // `<body>`
    marginWidth: number$1, // `<body>`
    noResize: boolean, // `<frame>`
    noHref: boolean, // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean, // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean, // `<td>` and `<th>`
    object: null, // `<applet>`
    profile: null, // `<head>`
    prompt: null, // `<isindex>`
    rev: null, // `<link>`
    rightMargin: number$1, // `<body>`
    rules: null, // `<table>`
    scheme: null, // `<meta>`
    scrolling: booleanish, // `<frame>`. Use overflow in the child context
    standby: null, // `<object>`
    summary: null, // `<table>`
    text: null, // `<body>`. Use CSS `color` instead
    topMargin: number$1, // `<body>`
    valueType: null, // `<param>`
    version: null, // `<html>`. Use a doctype.
    vAlign: null, // Several. Use CSS `vertical-align` instead
    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number$1, // `<img>` and `<object>`

    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number$1,
    security: null,
    unselectable: null
  }
});

var merge$2 = merge_1;
var xlink = xlink$1;
var xml = xml$1;
var xmlns = xmlns$1;
var aria = aria$1;
var html$1 = html$2;

var html_1$1 = merge$2([xml, xlink, xmlns, aria, html$1]);

var normalize$3 = normalize_1;
var DefinedInfo = definedInfo;
var Info = info;

var data = 'data';

var find_1 = find$2;

var valid = /^data[-\w.:]+$/i;
var dash$1 = /-[a-z]/g;
var cap$1 = /[A-Z]/g;

function find$2(schema, value) {
  var normal = normalize$3(value);
  var prop = value;
  var Type = Info;

  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]]
  }

  if (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value)) {
    // Attribute or property.
    if (value.charAt(4) === '-') {
      prop = datasetToProperty(value);
    } else {
      value = datasetToAttribute(value);
    }

    Type = DefinedInfo;
  }

  return new Type(prop, value)
}

function datasetToProperty(attribute) {
  var value = attribute.slice(5).replace(dash$1, camelcase);
  return data + value.charAt(0).toUpperCase() + value.slice(1)
}

function datasetToAttribute(property) {
  var value = property.slice(4);

  if (dash$1.test(value)) {
    return property
  }

  value = value.replace(cap$1, kebab);

  if (value.charAt(0) !== '-') {
    value = '-' + value;
  }

  return data + value
}

function kebab($0) {
  return '-' + $0.toLowerCase()
}

function camelcase($0) {
  return $0.charAt(1).toUpperCase()
}

var hastUtilParseSelector = parse$4;

var search = /[#.]/g;

// Create a hast element from a simple CSS selector.
function parse$4(selector, defaultTagName) {
  var value = selector || '';
  var name = defaultTagName || 'div';
  var props = {};
  var start = 0;
  var subvalue;
  var previous;
  var match;

  while (start < value.length) {
    search.lastIndex = start;
    match = search.exec(value);
    subvalue = value.slice(start, match ? match.index : value.length);

    if (subvalue) {
      if (!previous) {
        name = subvalue;
      } else if (previous === '#') {
        props.id = subvalue;
      } else if (props.className) {
        props.className.push(subvalue);
      } else {
        props.className = [subvalue];
      }

      start += subvalue.length;
    }

    if (match) {
      previous = match[0];
      start++;
    }
  }

  return {type: 'element', tagName: name, properties: props, children: []}
}

var spaceSeparatedTokens = {};

spaceSeparatedTokens.parse = parse$3;
spaceSeparatedTokens.stringify = stringify$3;

var empty$2 = '';
var space$2 = ' ';
var whiteSpace = /[ \t\n\r\f]+/g;

function parse$3(value) {
  var input = String(value || empty$2).trim();
  return input === empty$2 ? [] : input.split(whiteSpace)
}

function stringify$3(values) {
  return values.join(space$2).trim()
}

var commaSeparatedTokens = {};

commaSeparatedTokens.parse = parse$2;
commaSeparatedTokens.stringify = stringify$2;

var comma$1 = ',';
var space$1 = ' ';
var empty$1 = '';

// Parse comma-separated tokens to an array.
function parse$2(value) {
  var values = [];
  var input = String(value || empty$1);
  var index = input.indexOf(comma$1);
  var lastIndex = 0;
  var end = false;
  var val;

  while (!end) {
    if (index === -1) {
      index = input.length;
      end = true;
    }

    val = input.slice(lastIndex, index).trim();

    if (val || !end) {
      values.push(val);
    }

    lastIndex = index + 1;
    index = input.indexOf(comma$1, lastIndex);
  }

  return values
}

// Compile an array to comma-separated tokens.
// `options.padLeft` (default: `true`) pads a space left of each token, and
// `options.padRight` (default: `false`) pads a space to the right of each token.
function stringify$2(values, options) {
  var settings = options || {};
  var left = settings.padLeft === false ? empty$1 : space$1;
  var right = settings.padRight ? space$1 : empty$1;

  // Ensure the last empty entry is seen.
  if (values[values.length - 1] === empty$1) {
    values = values.concat(empty$1);
  }

  return values.join(right + comma$1 + left).trim()
}

var find$1 = find_1;
var normalize$2 = normalize_1;
var parseSelector = hastUtilParseSelector;
var spaces = spaceSeparatedTokens.parse;
var commas = commaSeparatedTokens.parse;

var factory_1 = factory$1;

var own$3 = {}.hasOwnProperty;

function factory$1(schema, defaultTagName, caseSensitive) {
  var adjust = caseSensitive ? createAdjustMap(caseSensitive) : null;

  return h

  // Hyperscript compatible DSL for creating virtual hast trees.
  function h(selector, properties) {
    var node = parseSelector(selector, defaultTagName);
    var children = Array.prototype.slice.call(arguments, 2);
    var name = node.tagName.toLowerCase();
    var property;

    node.tagName = adjust && own$3.call(adjust, name) ? adjust[name] : name;

    if (properties && isChildren(properties, node)) {
      children.unshift(properties);
      properties = null;
    }

    if (properties) {
      for (property in properties) {
        addProperty(node.properties, property, properties[property]);
      }
    }

    addChild(node.children, children);

    if (node.tagName === 'template') {
      node.content = {type: 'root', children: node.children};
      node.children = [];
    }

    return node
  }

  function addProperty(properties, key, value) {
    var info;
    var property;
    var result;

    // Ignore nullish and NaN values.
    if (value === null || value === undefined || value !== value) {
      return
    }

    info = find$1(schema, key);
    property = info.property;
    result = value;

    // Handle list values.
    if (typeof result === 'string') {
      if (info.spaceSeparated) {
        result = spaces(result);
      } else if (info.commaSeparated) {
        result = commas(result);
      } else if (info.commaOrSpaceSeparated) {
        result = spaces(commas(result).join(' '));
      }
    }

    // Accept `object` on style.
    if (property === 'style' && typeof value !== 'string') {
      result = style(result);
    }

    // Class-names (which can be added both on the `selector` and here).
    if (property === 'className' && properties.className) {
      result = properties.className.concat(result);
    }

    properties[property] = parsePrimitives(info, property, result);
  }
}

function isChildren(value, node) {
  return (
    typeof value === 'string' ||
    'length' in value ||
    isNode(node.tagName, value)
  )
}

function isNode(tagName, value) {
  var type = value.type;

  if (tagName === 'input' || !type || typeof type !== 'string') {
    return false
  }

  if (typeof value.children === 'object' && 'length' in value.children) {
    return true
  }

  type = type.toLowerCase();

  if (tagName === 'button') {
    return (
      type !== 'menu' &&
      type !== 'submit' &&
      type !== 'reset' &&
      type !== 'button'
    )
  }

  return 'value' in value
}

function addChild(nodes, value) {
  var index;
  var length;

  if (typeof value === 'string' || typeof value === 'number') {
    nodes.push({type: 'text', value: String(value)});
    return
  }

  if (typeof value === 'object' && 'length' in value) {
    index = -1;
    length = value.length;

    while (++index < length) {
      addChild(nodes, value[index]);
    }

    return
  }

  if (typeof value !== 'object' || !('type' in value)) {
    throw new Error('Expected node, nodes, or string, got `' + value + '`')
  }

  nodes.push(value);
}

// Parse a (list of) primitives.
function parsePrimitives(info, name, value) {
  var index;
  var length;
  var result;

  if (typeof value !== 'object' || !('length' in value)) {
    return parsePrimitive(info, name, value)
  }

  length = value.length;
  index = -1;
  result = [];

  while (++index < length) {
    result[index] = parsePrimitive(info, name, value[index]);
  }

  return result
}

// Parse a single primitives.
function parsePrimitive(info, name, value) {
  var result = value;

  if (info.number || info.positiveNumber) {
    if (!isNaN(result) && result !== '') {
      result = Number(result);
    }
  } else if (info.boolean || info.overloadedBoolean) {
    // Accept `boolean` and `string`.
    if (
      typeof result === 'string' &&
      (result === '' || normalize$2(value) === normalize$2(name))
    ) {
      result = true;
    }
  }

  return result
}

function style(value) {
  var result = [];
  var key;

  for (key in value) {
    result.push([key, value[key]].join(': '));
  }

  return result.join('; ')
}

function createAdjustMap(values) {
  var length = values.length;
  var index = -1;
  var result = {};
  var value;

  while (++index < length) {
    value = values[index];
    result[value.toLowerCase()] = value;
  }

  return result
}

var schema = html_1$1;
var factory = factory_1;

var html = factory(schema, 'div');
html.displayName = 'html';

var html_1 = html;

(function (module) {

	module.exports = html_1;
} (hastscript));

var AElig$1 = "Æ";
var AMP$1 = "&";
var Aacute$1 = "Á";
var Acirc$1 = "Â";
var Agrave$1 = "À";
var Aring$1 = "Å";
var Atilde$1 = "Ã";
var Auml$1 = "Ä";
var COPY$1 = "©";
var Ccedil$1 = "Ç";
var ETH$1 = "Ð";
var Eacute$1 = "É";
var Ecirc$1 = "Ê";
var Egrave$1 = "È";
var Euml$1 = "Ë";
var GT$1 = ">";
var Iacute$1 = "Í";
var Icirc$1 = "Î";
var Igrave$1 = "Ì";
var Iuml$1 = "Ï";
var LT$1 = "<";
var Ntilde$1 = "Ñ";
var Oacute$1 = "Ó";
var Ocirc$1 = "Ô";
var Ograve$1 = "Ò";
var Oslash$1 = "Ø";
var Otilde$1 = "Õ";
var Ouml$1 = "Ö";
var QUOT$1 = "\"";
var REG$1 = "®";
var THORN$1 = "Þ";
var Uacute$1 = "Ú";
var Ucirc$1 = "Û";
var Ugrave$1 = "Ù";
var Uuml$1 = "Ü";
var Yacute$1 = "Ý";
var aacute$1 = "á";
var acirc$1 = "â";
var acute$1 = "´";
var aelig$1 = "æ";
var agrave$1 = "à";
var amp$1 = "&";
var aring$1 = "å";
var atilde$1 = "ã";
var auml$1 = "ä";
var brvbar$1 = "¦";
var ccedil$1 = "ç";
var cedil$1 = "¸";
var cent$1 = "¢";
var copy$3 = "©";
var curren$1 = "¤";
var deg$1 = "°";
var divide$1 = "÷";
var eacute$1 = "é";
var ecirc$1 = "ê";
var egrave$1 = "è";
var eth$1 = "ð";
var euml$1 = "ë";
var frac12$1 = "½";
var frac14$1 = "¼";
var frac34$1 = "¾";
var gt$1 = ">";
var iacute$1 = "í";
var icirc$1 = "î";
var iexcl$1 = "¡";
var igrave$1 = "ì";
var iquest$1 = "¿";
var iuml$1 = "ï";
var laquo$1 = "«";
var lt$2 = "<";
var macr$1 = "¯";
var micro$1 = "µ";
var middot$1 = "·";
var nbsp$1 = " ";
var not$1 = "¬";
var ntilde$1 = "ñ";
var oacute$1 = "ó";
var ocirc$1 = "ô";
var ograve$1 = "ò";
var ordf$1 = "ª";
var ordm$1 = "º";
var oslash$1 = "ø";
var otilde$1 = "õ";
var ouml$1 = "ö";
var para$1 = "¶";
var plusmn$1 = "±";
var pound$1 = "£";
var quot$1 = "\"";
var raquo$1 = "»";
var reg$1 = "®";
var sect$1 = "§";
var shy$1 = "­";
var sup1$1 = "¹";
var sup2$1 = "²";
var sup3$1 = "³";
var szlig$1 = "ß";
var thorn$1 = "þ";
var times$1 = "×";
var uacute$1 = "ú";
var ucirc$1 = "û";
var ugrave$1 = "ù";
var uml$1 = "¨";
var uuml$1 = "ü";
var yacute$1 = "ý";
var yen$1 = "¥";
var yuml$1 = "ÿ";
var require$$0$2 = {
	AElig: AElig$1,
	AMP: AMP$1,
	Aacute: Aacute$1,
	Acirc: Acirc$1,
	Agrave: Agrave$1,
	Aring: Aring$1,
	Atilde: Atilde$1,
	Auml: Auml$1,
	COPY: COPY$1,
	Ccedil: Ccedil$1,
	ETH: ETH$1,
	Eacute: Eacute$1,
	Ecirc: Ecirc$1,
	Egrave: Egrave$1,
	Euml: Euml$1,
	GT: GT$1,
	Iacute: Iacute$1,
	Icirc: Icirc$1,
	Igrave: Igrave$1,
	Iuml: Iuml$1,
	LT: LT$1,
	Ntilde: Ntilde$1,
	Oacute: Oacute$1,
	Ocirc: Ocirc$1,
	Ograve: Ograve$1,
	Oslash: Oslash$1,
	Otilde: Otilde$1,
	Ouml: Ouml$1,
	QUOT: QUOT$1,
	REG: REG$1,
	THORN: THORN$1,
	Uacute: Uacute$1,
	Ucirc: Ucirc$1,
	Ugrave: Ugrave$1,
	Uuml: Uuml$1,
	Yacute: Yacute$1,
	aacute: aacute$1,
	acirc: acirc$1,
	acute: acute$1,
	aelig: aelig$1,
	agrave: agrave$1,
	amp: amp$1,
	aring: aring$1,
	atilde: atilde$1,
	auml: auml$1,
	brvbar: brvbar$1,
	ccedil: ccedil$1,
	cedil: cedil$1,
	cent: cent$1,
	copy: copy$3,
	curren: curren$1,
	deg: deg$1,
	divide: divide$1,
	eacute: eacute$1,
	ecirc: ecirc$1,
	egrave: egrave$1,
	eth: eth$1,
	euml: euml$1,
	frac12: frac12$1,
	frac14: frac14$1,
	frac34: frac34$1,
	gt: gt$1,
	iacute: iacute$1,
	icirc: icirc$1,
	iexcl: iexcl$1,
	igrave: igrave$1,
	iquest: iquest$1,
	iuml: iuml$1,
	laquo: laquo$1,
	lt: lt$2,
	macr: macr$1,
	micro: micro$1,
	middot: middot$1,
	nbsp: nbsp$1,
	not: not$1,
	ntilde: ntilde$1,
	oacute: oacute$1,
	ocirc: ocirc$1,
	ograve: ograve$1,
	ordf: ordf$1,
	ordm: ordm$1,
	oslash: oslash$1,
	otilde: otilde$1,
	ouml: ouml$1,
	para: para$1,
	plusmn: plusmn$1,
	pound: pound$1,
	quot: quot$1,
	raquo: raquo$1,
	reg: reg$1,
	sect: sect$1,
	shy: shy$1,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	szlig: szlig$1,
	thorn: thorn$1,
	times: times$1,
	uacute: uacute$1,
	ucirc: ucirc$1,
	ugrave: ugrave$1,
	uml: uml$1,
	uuml: uuml$1,
	yacute: yacute$1,
	yen: yen$1,
	yuml: yuml$1
};

var require$$1 = {
	"0": "�",
	"128": "€",
	"130": "‚",
	"131": "ƒ",
	"132": "„",
	"133": "…",
	"134": "†",
	"135": "‡",
	"136": "ˆ",
	"137": "‰",
	"138": "Š",
	"139": "‹",
	"140": "Œ",
	"142": "Ž",
	"145": "‘",
	"146": "’",
	"147": "“",
	"148": "”",
	"149": "•",
	"150": "–",
	"151": "—",
	"152": "˜",
	"153": "™",
	"154": "š",
	"155": "›",
	"156": "œ",
	"158": "ž",
	"159": "Ÿ"
};

var isDecimal = decimal$2;

// Check if the given character code, or the character code at the first
// character, is decimal.
function decimal$2(character) {
  var code = typeof character === 'string' ? character.charCodeAt(0) : character;

  return code >= 48 && code <= 57 /* 0-9 */
}

var isHexadecimal = hexadecimal$1;

// Check if the given character code, or the character code at the first
// character, is hexadecimal.
function hexadecimal$1(character) {
  var code = typeof character === 'string' ? character.charCodeAt(0) : character;

  return (
    (code >= 97 /* a */ && code <= 102) /* z */ ||
    (code >= 65 /* A */ && code <= 70) /* Z */ ||
    (code >= 48 /* A */ && code <= 57) /* Z */
  )
}

var isAlphabetical = alphabetical$1;

// Check if the given character code, or the character code at the first
// character, is alphabetical.
function alphabetical$1(character) {
  var code = typeof character === 'string' ? character.charCodeAt(0) : character;

  return (
    (code >= 97 && code <= 122) /* a-z */ ||
    (code >= 65 && code <= 90) /* A-Z */
  )
}

var alphabetical = isAlphabetical;
var decimal$1 = isDecimal;

var isAlphanumerical = alphanumerical$1;

// Check if the given character code, or the character code at the first
// character, is alphanumerical.
function alphanumerical$1(character) {
  return alphabetical(character) || decimal$1(character)
}

var AEli = "Æ";
var AElig = "Æ";
var AM = "&";
var AMP = "&";
var Aacut = "Á";
var Aacute = "Á";
var Abreve = "Ă";
var Acir = "Â";
var Acirc = "Â";
var Acy = "А";
var Afr = "𝔄";
var Agrav = "À";
var Agrave = "À";
var Alpha = "Α";
var Amacr = "Ā";
var And = "⩓";
var Aogon = "Ą";
var Aopf = "𝔸";
var ApplyFunction = "⁡";
var Arin = "Å";
var Aring = "Å";
var Ascr = "𝒜";
var Assign = "≔";
var Atild = "Ã";
var Atilde = "Ã";
var Aum = "Ä";
var Auml = "Ä";
var Backslash = "∖";
var Barv = "⫧";
var Barwed = "⌆";
var Bcy = "Б";
var Because = "∵";
var Bernoullis = "ℬ";
var Beta = "Β";
var Bfr = "𝔅";
var Bopf = "𝔹";
var Breve = "˘";
var Bscr = "ℬ";
var Bumpeq = "≎";
var CHcy = "Ч";
var COP = "©";
var COPY = "©";
var Cacute = "Ć";
var Cap = "⋒";
var CapitalDifferentialD = "ⅅ";
var Cayleys = "ℭ";
var Ccaron = "Č";
var Ccedi = "Ç";
var Ccedil = "Ç";
var Ccirc = "Ĉ";
var Cconint = "∰";
var Cdot = "Ċ";
var Cedilla = "¸";
var CenterDot = "·";
var Cfr = "ℭ";
var Chi = "Χ";
var CircleDot = "⊙";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var Colon = "∷";
var Colone = "⩴";
var Congruent = "≡";
var Conint = "∯";
var ContourIntegral = "∮";
var Copf = "ℂ";
var Coproduct = "∐";
var CounterClockwiseContourIntegral = "∳";
var Cross = "⨯";
var Cscr = "𝒞";
var Cup = "⋓";
var CupCap = "≍";
var DD = "ⅅ";
var DDotrahd = "⤑";
var DJcy = "Ђ";
var DScy = "Ѕ";
var DZcy = "Џ";
var Dagger = "‡";
var Darr = "↡";
var Dashv = "⫤";
var Dcaron = "Ď";
var Dcy = "Д";
var Del = "∇";
var Delta = "Δ";
var Dfr = "𝔇";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var Diamond$1 = "⋄";
var DifferentialD = "ⅆ";
var Dopf = "𝔻";
var Dot = "¨";
var DotDot = "⃜";
var DotEqual = "≐";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrow = "↓";
var DownArrowBar = "⤓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVector = "↽";
var DownLeftVectorBar = "⥖";
var DownRightTeeVector = "⥟";
var DownRightVector = "⇁";
var DownRightVectorBar = "⥗";
var DownTee = "⊤";
var DownTeeArrow = "↧";
var Downarrow = "⇓";
var Dscr = "𝒟";
var Dstrok = "Đ";
var ENG = "Ŋ";
var ET = "Ð";
var ETH = "Ð";
var Eacut = "É";
var Eacute = "É";
var Ecaron = "Ě";
var Ecir = "Ê";
var Ecirc = "Ê";
var Ecy = "Э";
var Edot = "Ė";
var Efr = "𝔈";
var Egrav = "È";
var Egrave = "È";
var Element$2 = "∈";
var Emacr = "Ē";
var EmptySmallSquare = "◻";
var EmptyVerySmallSquare = "▫";
var Eogon = "Ę";
var Eopf = "𝔼";
var Epsilon = "Ε";
var Equal = "⩵";
var EqualTilde = "≂";
var Equilibrium = "⇌";
var Escr = "ℰ";
var Esim = "⩳";
var Eta = "Η";
var Eum = "Ë";
var Euml = "Ë";
var Exists = "∃";
var ExponentialE = "ⅇ";
var Fcy = "Ф";
var Ffr = "𝔉";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var Fopf = "𝔽";
var ForAll = "∀";
var Fouriertrf = "ℱ";
var Fscr = "ℱ";
var GJcy = "Ѓ";
var G = ">";
var GT = ">";
var Gamma = "Γ";
var Gammad = "Ϝ";
var Gbreve = "Ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var Gcy = "Г";
var Gdot = "Ġ";
var Gfr = "𝔊";
var Gg = "⋙";
var Gopf = "𝔾";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var Gt = "≫";
var HARDcy = "Ъ";
var Hacek = "ˇ";
var Hat = "^";
var Hcirc = "Ĥ";
var Hfr = "ℌ";
var HilbertSpace = "ℋ";
var Hopf = "ℍ";
var HorizontalLine = "─";
var Hscr = "ℋ";
var Hstrok = "Ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var IEcy = "Е";
var IJlig = "Ĳ";
var IOcy = "Ё";
var Iacut = "Í";
var Iacute = "Í";
var Icir = "Î";
var Icirc = "Î";
var Icy = "И";
var Idot = "İ";
var Ifr = "ℑ";
var Igrav = "Ì";
var Igrave = "Ì";
var Im = "ℑ";
var Imacr = "Ī";
var ImaginaryI = "ⅈ";
var Implies = "⇒";
var Int = "∬";
var Integral = "∫";
var Intersection = "⋂";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var Iogon = "Į";
var Iopf = "𝕀";
var Iota = "Ι";
var Iscr = "ℐ";
var Itilde = "Ĩ";
var Iukcy = "І";
var Ium = "Ï";
var Iuml = "Ï";
var Jcirc = "Ĵ";
var Jcy = "Й";
var Jfr = "𝔍";
var Jopf = "𝕁";
var Jscr = "𝒥";
var Jsercy = "Ј";
var Jukcy = "Є";
var KHcy = "Х";
var KJcy = "Ќ";
var Kappa = "Κ";
var Kcedil = "Ķ";
var Kcy = "К";
var Kfr = "𝔎";
var Kopf = "𝕂";
var Kscr = "𝒦";
var LJcy = "Љ";
var L = "<";
var LT = "<";
var Lacute = "Ĺ";
var Lambda = "Λ";
var Lang = "⟪";
var Laplacetrf = "ℒ";
var Larr = "↞";
var Lcaron = "Ľ";
var Lcedil = "Ļ";
var Lcy = "Л";
var LeftAngleBracket = "⟨";
var LeftArrow = "←";
var LeftArrowBar = "⇤";
var LeftArrowRightArrow = "⇆";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVector = "⇃";
var LeftDownVectorBar = "⥙";
var LeftFloor = "⌊";
var LeftRightArrow = "↔";
var LeftRightVector = "⥎";
var LeftTee = "⊣";
var LeftTeeArrow = "↤";
var LeftTeeVector = "⥚";
var LeftTriangle = "⊲";
var LeftTriangleBar = "⧏";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVector = "↿";
var LeftUpVectorBar = "⥘";
var LeftVector = "↼";
var LeftVectorBar = "⥒";
var Leftarrow = "⇐";
var Leftrightarrow = "⇔";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var LessLess = "⪡";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var Lfr = "𝔏";
var Ll = "⋘";
var Lleftarrow = "⇚";
var Lmidot = "Ŀ";
var LongLeftArrow = "⟵";
var LongLeftRightArrow = "⟷";
var LongRightArrow = "⟶";
var Longleftarrow = "⟸";
var Longleftrightarrow = "⟺";
var Longrightarrow = "⟹";
var Lopf = "𝕃";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var Lscr = "ℒ";
var Lsh = "↰";
var Lstrok = "Ł";
var Lt = "≪";
var Mcy = "М";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var MinusPlus = "∓";
var Mopf = "𝕄";
var Mscr = "ℳ";
var Mu = "Μ";
var NJcy = "Њ";
var Nacute = "Ń";
var Ncaron = "Ň";
var Ncedil = "Ņ";
var Ncy = "Н";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var Nfr = "𝔑";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var Nopf = "ℕ";
var Not = "⫬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var NotLeftTriangle = "⋪";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangle = "⋫";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var Nscr = "𝒩";
var Ntild = "Ñ";
var Ntilde = "Ñ";
var Nu = "Ν";
var OElig = "Œ";
var Oacut = "Ó";
var Oacute = "Ó";
var Ocir = "Ô";
var Ocirc = "Ô";
var Ocy = "О";
var Odblac = "Ő";
var Ofr = "𝔒";
var Ograv = "Ò";
var Ograve = "Ò";
var Omacr = "Ō";
var Omega = "Ω";
var Omicron = "Ο";
var Oopf = "𝕆";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var Or = "⩔";
var Oscr = "𝒪";
var Oslas = "Ø";
var Oslash = "Ø";
var Otild = "Õ";
var Otilde = "Õ";
var Otimes = "⨷";
var Oum = "Ö";
var Ouml = "Ö";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var PartialD = "∂";
var Pcy = "П";
var Pfr = "𝔓";
var Phi = "Φ";
var Pi = "Π";
var PlusMinus = "±";
var Poincareplane = "ℌ";
var Popf = "ℙ";
var Pr = "⪻";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var Prime = "″";
var Product = "∏";
var Proportion = "∷";
var Proportional = "∝";
var Pscr = "𝒫";
var Psi = "Ψ";
var QUO = "\"";
var QUOT = "\"";
var Qfr = "𝔔";
var Qopf = "ℚ";
var Qscr = "𝒬";
var RBarr = "⤐";
var RE = "®";
var REG = "®";
var Racute = "Ŕ";
var Rang = "⟫";
var Rarr = "↠";
var Rarrtl = "⤖";
var Rcaron = "Ř";
var Rcedil = "Ŗ";
var Rcy = "Р";
var Re = "ℜ";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var Rfr = "ℜ";
var Rho = "Ρ";
var RightAngleBracket = "⟩";
var RightArrow = "→";
var RightArrowBar = "⇥";
var RightArrowLeftArrow = "⇄";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVector = "⇂";
var RightDownVectorBar = "⥕";
var RightFloor = "⌋";
var RightTee = "⊢";
var RightTeeArrow = "↦";
var RightTeeVector = "⥛";
var RightTriangle = "⊳";
var RightTriangleBar = "⧐";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVector = "↾";
var RightUpVectorBar = "⥔";
var RightVector = "⇀";
var RightVectorBar = "⥓";
var Rightarrow = "⇒";
var Ropf = "ℝ";
var RoundImplies = "⥰";
var Rrightarrow = "⇛";
var Rscr = "ℛ";
var Rsh = "↱";
var RuleDelayed = "⧴";
var SHCHcy = "Щ";
var SHcy = "Ш";
var SOFTcy = "Ь";
var Sacute = "Ś";
var Sc = "⪼";
var Scaron = "Š";
var Scedil = "Ş";
var Scirc = "Ŝ";
var Scy = "С";
var Sfr = "𝔖";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var Sigma = "Σ";
var SmallCircle = "∘";
var Sopf = "𝕊";
var Sqrt = "√";
var Square = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var Sscr = "𝒮";
var Star = "⋆";
var Sub = "⋐";
var Subset = "⋐";
var SubsetEqual = "⊆";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var SuchThat = "∋";
var Sum = "∑";
var Sup = "⋑";
var Superset = "⊃";
var SupersetEqual = "⊇";
var Supset = "⋑";
var THOR = "Þ";
var THORN = "Þ";
var TRADE = "™";
var TSHcy = "Ћ";
var TScy = "Ц";
var Tab = "\t";
var Tau = "Τ";
var Tcaron = "Ť";
var Tcedil = "Ţ";
var Tcy = "Т";
var Tfr = "𝔗";
var Therefore = "∴";
var Theta = "Θ";
var ThickSpace = "  ";
var ThinSpace = " ";
var Tilde = "∼";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var Topf = "𝕋";
var TripleDot = "⃛";
var Tscr = "𝒯";
var Tstrok = "Ŧ";
var Uacut = "Ú";
var Uacute = "Ú";
var Uarr = "↟";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var Ubreve = "Ŭ";
var Ucir = "Û";
var Ucirc = "Û";
var Ucy = "У";
var Udblac = "Ű";
var Ufr = "𝔘";
var Ugrav = "Ù";
var Ugrave = "Ù";
var Umacr = "Ū";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var Uopf = "𝕌";
var UpArrow = "↑";
var UpArrowBar = "⤒";
var UpArrowDownArrow = "⇅";
var UpDownArrow = "↕";
var UpEquilibrium = "⥮";
var UpTee = "⊥";
var UpTeeArrow = "↥";
var Uparrow = "⇑";
var Updownarrow = "⇕";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var Upsi = "ϒ";
var Upsilon = "Υ";
var Uring = "Ů";
var Uscr = "𝒰";
var Utilde = "Ũ";
var Uum = "Ü";
var Uuml = "Ü";
var VDash = "⊫";
var Vbar = "⫫";
var Vcy = "В";
var Vdash = "⊩";
var Vdashl = "⫦";
var Vee = "⋁";
var Verbar = "‖";
var Vert = "‖";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var Vopf = "𝕍";
var Vscr = "𝒱";
var Vvdash = "⊪";
var Wcirc = "Ŵ";
var Wedge = "⋀";
var Wfr = "𝔚";
var Wopf = "𝕎";
var Wscr = "𝒲";
var Xfr = "𝔛";
var Xi = "Ξ";
var Xopf = "𝕏";
var Xscr = "𝒳";
var YAcy = "Я";
var YIcy = "Ї";
var YUcy = "Ю";
var Yacut = "Ý";
var Yacute = "Ý";
var Ycirc = "Ŷ";
var Ycy = "Ы";
var Yfr = "𝔜";
var Yopf = "𝕐";
var Yscr = "𝒴";
var Yuml = "Ÿ";
var ZHcy = "Ж";
var Zacute = "Ź";
var Zcaron = "Ž";
var Zcy = "З";
var Zdot = "Ż";
var ZeroWidthSpace = "​";
var Zeta = "Ζ";
var Zfr = "ℨ";
var Zopf = "ℤ";
var Zscr = "𝒵";
var aacut = "á";
var aacute = "á";
var abreve = "ă";
var ac = "∾";
var acE = "∾̳";
var acd = "∿";
var acir = "â";
var acirc = "â";
var acut = "´";
var acute = "´";
var acy = "а";
var aeli = "æ";
var aelig = "æ";
var af = "⁡";
var afr = "𝔞";
var agrav = "à";
var agrave = "à";
var alefsym = "ℵ";
var aleph = "ℵ";
var alpha = "α";
var amacr = "ā";
var amalg = "⨿";
var am = "&";
var amp = "&";
var and = "∧";
var andand = "⩕";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang = "∠";
var ange = "⦤";
var angle = "∠";
var angmsd = "∡";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst = "Å";
var angzarr = "⍼";
var aogon = "ą";
var aopf = "𝕒";
var ap = "≈";
var apE = "⩰";
var apacir = "⩯";
var ape = "≊";
var apid = "≋";
var apos = "'";
var approx = "≈";
var approxeq = "≊";
var arin = "å";
var aring = "å";
var ascr = "𝒶";
var ast = "*";
var asymp = "≈";
var asympeq = "≍";
var atild = "ã";
var atilde = "ã";
var aum = "ä";
var auml = "ä";
var awconint = "∳";
var awint = "⨑";
var bNot = "⫭";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var barvee = "⊽";
var barwed = "⌅";
var barwedge = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var bcy = "б";
var bdquo = "„";
var becaus = "∵";
var because = "∵";
var bemptyv = "⦰";
var bepsi = "϶";
var bernou = "ℬ";
var beta = "β";
var beth = "ℶ";
var between = "≬";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bnot = "⌐";
var bopf = "𝕓";
var bot = "⊥";
var bottom = "⊥";
var bowtie = "⋈";
var boxDL = "╗";
var boxDR = "╔";
var boxDl = "╖";
var boxDr = "╓";
var boxH = "═";
var boxHD = "╦";
var boxHU = "╩";
var boxHd = "╤";
var boxHu = "╧";
var boxUL = "╝";
var boxUR = "╚";
var boxUl = "╜";
var boxUr = "╙";
var boxV = "║";
var boxVH = "╬";
var boxVL = "╣";
var boxVR = "╠";
var boxVh = "╫";
var boxVl = "╢";
var boxVr = "╟";
var boxbox = "⧉";
var boxdL = "╕";
var boxdR = "╒";
var boxdl = "┐";
var boxdr = "┌";
var boxh = "─";
var boxhD = "╥";
var boxhU = "╨";
var boxhd = "┬";
var boxhu = "┴";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxuL = "╛";
var boxuR = "╘";
var boxul = "┘";
var boxur = "└";
var boxv = "│";
var boxvH = "╪";
var boxvL = "╡";
var boxvR = "╞";
var boxvh = "┼";
var boxvl = "┤";
var boxvr = "├";
var bprime = "‵";
var breve = "˘";
var brvba = "¦";
var brvbar = "¦";
var bscr = "𝒷";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsol = "\\";
var bsolb = "⧅";
var bsolhsub = "⟈";
var bull = "•";
var bullet = "•";
var bump = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var bumpeq = "≏";
var cacute = "ć";
var cap = "∩";
var capand = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var capcup = "⩇";
var capdot = "⩀";
var caps = "∩︀";
var caret = "⁁";
var caron = "ˇ";
var ccaps = "⩍";
var ccaron = "č";
var ccedi = "ç";
var ccedil = "ç";
var ccirc = "ĉ";
var ccups = "⩌";
var ccupssm = "⩐";
var cdot = "ċ";
var cedi = "¸";
var cedil = "¸";
var cemptyv = "⦲";
var cen = "¢";
var cent = "¢";
var centerdot = "·";
var cfr = "𝔠";
var chcy = "ч";
var check = "✓";
var checkmark = "✓";
var chi = "χ";
var cir = "○";
var cirE = "⧃";
var circ = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledR = "®";
var circledS = "Ⓢ";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var clubs = "♣";
var clubsuit = "♣";
var colon = ":";
var colone = "≔";
var coloneq = "≔";
var comma = ",";
var commat = "@";
var comp = "∁";
var compfn = "∘";
var complement = "∁";
var complexes = "ℂ";
var cong = "≅";
var congdot = "⩭";
var conint = "∮";
var copf = "𝕔";
var coprod = "∐";
var cop = "©";
var copy$2 = "©";
var copysr = "℗";
var crarr = "↵";
var cross = "✗";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var cup = "∪";
var cupbrcap = "⩈";
var cupcap = "⩆";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curre = "¤";
var curren = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var dArr = "⇓";
var dHar = "⥥";
var dagger = "†";
var daleth = "ℸ";
var darr = "↓";
var dash = "‐";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var dcaron = "ď";
var dcy = "д";
var dd = "ⅆ";
var ddagger = "‡";
var ddarr = "⇊";
var ddotseq = "⩷";
var de = "°";
var deg = "°";
var delta = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var dfr = "𝔡";
var dharl = "⇃";
var dharr = "⇂";
var diam = "⋄";
var diamond = "⋄";
var diamondsuit = "♦";
var diams = "♦";
var die = "¨";
var digamma = "ϝ";
var disin = "⋲";
var div$1 = "÷";
var divid = "÷";
var divide = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar = "$";
var dopf = "𝕕";
var dot$1 = "˙";
var doteq = "≐";
var doteqdot = "≑";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var downarrow = "↓";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var dscr = "𝒹";
var dscy = "ѕ";
var dsol = "⧶";
var dstrok = "đ";
var dtdot = "⋱";
var dtri = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var dzcy = "џ";
var dzigrarr = "⟿";
var eDDot = "⩷";
var eDot = "≑";
var eacut = "é";
var eacute = "é";
var easter = "⩮";
var ecaron = "ě";
var ecir = "ê";
var ecirc = "ê";
var ecolon = "≕";
var ecy = "э";
var edot = "ė";
var ee = "ⅇ";
var efDot = "≒";
var efr = "𝔢";
var eg = "⪚";
var egrav = "è";
var egrave = "è";
var egs = "⪖";
var egsdot = "⪘";
var el = "⪙";
var elinters = "⏧";
var ell = "ℓ";
var els = "⪕";
var elsdot = "⪗";
var emacr = "ē";
var empty = "∅";
var emptyset = "∅";
var emptyv = "∅";
var emsp13 = " ";
var emsp14 = " ";
var emsp = " ";
var eng = "ŋ";
var ensp = " ";
var eogon = "ę";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi = "ε";
var epsilon = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var equals = "=";
var equest = "≟";
var equiv = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erDot = "≓";
var erarr = "⥱";
var escr = "ℯ";
var esdot = "≐";
var esim = "≂";
var eta = "η";
var et = "ð";
var eth = "ð";
var eum = "ë";
var euml = "ë";
var euro = "€";
var excl = "!";
var exist = "∃";
var expectation = "ℰ";
var exponentiale = "ⅇ";
var fallingdotseq = "≒";
var fcy = "ф";
var female = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var ffr = "𝔣";
var filig = "ﬁ";
var fjlig = "fj";
var flat = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof = "ƒ";
var fopf = "𝕗";
var forall = "∀";
var fork = "⋔";
var forkv = "⫙";
var fpartint = "⨍";
var frac1 = "¼";
var frac12 = "½";
var frac13 = "⅓";
var frac14 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac3 = "¾";
var frac34 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl = "⁄";
var frown = "⌢";
var fscr = "𝒻";
var gE = "≧";
var gEl = "⪌";
var gacute = "ǵ";
var gamma = "γ";
var gammad = "ϝ";
var gap = "⪆";
var gbreve = "ğ";
var gcirc = "ĝ";
var gcy = "г";
var gdot = "ġ";
var ge = "≥";
var gel = "⋛";
var geq = "≥";
var geqq = "≧";
var geqslant = "⩾";
var ges = "⩾";
var gescc = "⪩";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl = "⋛︀";
var gesles = "⪔";
var gfr = "𝔤";
var gg = "≫";
var ggg = "⋙";
var gimel = "ℷ";
var gjcy = "ѓ";
var gl = "≷";
var glE = "⪒";
var gla = "⪥";
var glj = "⪤";
var gnE = "≩";
var gnap = "⪊";
var gnapprox = "⪊";
var gne = "⪈";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var gopf = "𝕘";
var grave = "`";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var g = ">";
var gt = ">";
var gtcc = "⪧";
var gtcir = "⩺";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var hArr = "⇔";
var hairsp = " ";
var half = "½";
var hamilt = "ℋ";
var hardcy = "ъ";
var harr = "↔";
var harrcir = "⥈";
var harrw = "↭";
var hbar = "ℏ";
var hcirc = "ĥ";
var hearts = "♥";
var heartsuit = "♥";
var hellip = "…";
var hercon = "⊹";
var hfr = "𝔥";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var hopf = "𝕙";
var horbar = "―";
var hscr = "𝒽";
var hslash = "ℏ";
var hstrok = "ħ";
var hybull = "⁃";
var hyphen = "‐";
var iacut = "í";
var iacute = "í";
var ic = "⁣";
var icir = "î";
var icirc = "î";
var icy = "и";
var iecy = "е";
var iexc = "¡";
var iexcl = "¡";
var iff = "⇔";
var ifr = "𝔦";
var igrav = "ì";
var igrave = "ì";
var ii = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var ijlig = "ĳ";
var imacr = "ī";
var image = "ℑ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var imof = "⊷";
var imped = "Ƶ";
var incare = "℅";
var infin = "∞";
var infintie = "⧝";
var inodot = "ı";
var int = "∫";
var intcal = "⊺";
var integers = "ℤ";
var intercal = "⊺";
var intlarhk = "⨗";
var intprod = "⨼";
var iocy = "ё";
var iogon = "į";
var iopf = "𝕚";
var iota = "ι";
var iprod = "⨼";
var iques = "¿";
var iquest = "¿";
var iscr = "𝒾";
var isin = "∈";
var isinE = "⋹";
var isindot = "⋵";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it = "⁢";
var itilde = "ĩ";
var iukcy = "і";
var ium = "ï";
var iuml = "ï";
var jcirc = "ĵ";
var jcy = "й";
var jfr = "𝔧";
var jmath = "ȷ";
var jopf = "𝕛";
var jscr = "𝒿";
var jsercy = "ј";
var jukcy = "є";
var kappa = "κ";
var kappav = "ϰ";
var kcedil = "ķ";
var kcy = "к";
var kfr = "𝔨";
var kgreen = "ĸ";
var khcy = "х";
var kjcy = "ќ";
var kopf = "𝕜";
var kscr = "𝓀";
var lAarr = "⇚";
var lArr = "⇐";
var lAtail = "⤛";
var lBarr = "⤎";
var lE = "≦";
var lEg = "⪋";
var lHar = "⥢";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var lambda = "λ";
var lang = "⟨";
var langd = "⦑";
var langle = "⟨";
var lap = "⪅";
var laqu = "«";
var laquo = "«";
var larr = "←";
var larrb = "⇤";
var larrbfs = "⤟";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var lat = "⪫";
var latail = "⤙";
var late = "⪭";
var lates = "⪭︀";
var lbarr = "⤌";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var lcaron = "ľ";
var lcedil = "ļ";
var lceil = "⌈";
var lcub = "{";
var lcy = "л";
var ldca = "⤶";
var ldquo = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var le = "≤";
var leftarrow = "←";
var leftarrowtail = "↢";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var leftrightarrow = "↔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var leftthreetimes = "⋋";
var leg = "⋚";
var leq = "≤";
var leqq = "≦";
var leqslant = "⩽";
var les = "⩽";
var lescc = "⪨";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var lessgtr = "≶";
var lesssim = "≲";
var lfisht = "⥼";
var lfloor = "⌊";
var lfr = "𝔩";
var lg = "≶";
var lgE = "⪑";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var ljcy = "љ";
var ll = "≪";
var llarr = "⇇";
var llcorner = "⌞";
var llhard = "⥫";
var lltri = "◺";
var lmidot = "ŀ";
var lmoust = "⎰";
var lmoustache = "⎰";
var lnE = "≨";
var lnap = "⪉";
var lnapprox = "⪉";
var lne = "⪇";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var longleftarrow = "⟵";
var longleftrightarrow = "⟷";
var longmapsto = "⟼";
var longrightarrow = "⟶";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast = "∗";
var lowbar = "_";
var loz = "◊";
var lozenge = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm = "‎";
var lrtri = "⊿";
var lsaquo = "‹";
var lscr = "𝓁";
var lsh = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo = "‘";
var lsquor = "‚";
var lstrok = "ł";
var l = "<";
var lt$1 = "<";
var ltcc = "⪦";
var ltcir = "⩹";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltrPar = "⦖";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var mDDot = "∺";
var mac = "¯";
var macr = "¯";
var male = "♂";
var malt = "✠";
var maltese = "✠";
var map$2 = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker = "▮";
var mcomma = "⨩";
var mcy = "м";
var mdash = "—";
var measuredangle = "∡";
var mfr = "𝔪";
var mho = "℧";
var micr = "µ";
var micro = "µ";
var mid = "∣";
var midast = "*";
var midcir = "⫰";
var middo = "·";
var middot = "·";
var minus = "−";
var minusb = "⊟";
var minusd = "∸";
var minusdu = "⨪";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models = "⊧";
var mopf = "𝕞";
var mp = "∓";
var mscr = "𝓂";
var mstpos = "∾";
var mu = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nGg = "⋙̸";
var nGt = "≫⃒";
var nGtv = "≫̸";
var nLeftarrow = "⇍";
var nLeftrightarrow = "⇎";
var nLl = "⋘̸";
var nLt = "≪⃒";
var nLtv = "≪̸";
var nRightarrow = "⇏";
var nVDash = "⊯";
var nVdash = "⊮";
var nabla = "∇";
var nacute = "ń";
var nang = "∠⃒";
var nap = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natur = "♮";
var natural = "♮";
var naturals = "ℕ";
var nbs = " ";
var nbsp = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var ncaron = "ň";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var ncy = "н";
var ndash = "–";
var ne = "≠";
var neArr = "⇗";
var nearhk = "⤤";
var nearr = "↗";
var nearrow = "↗";
var nedot = "≐̸";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var nexist = "∄";
var nexists = "∄";
var nfr = "𝔫";
var ngE = "≧̸";
var nge = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var ngsim = "≵";
var ngt = "≯";
var ngtr = "≯";
var nhArr = "⇎";
var nharr = "↮";
var nhpar = "⫲";
var ni = "∋";
var nis = "⋼";
var nisd = "⋺";
var niv = "∋";
var njcy = "њ";
var nlArr = "⇍";
var nlE = "≦̸";
var nlarr = "↚";
var nldr = "‥";
var nle = "≰";
var nleftarrow = "↚";
var nleftrightarrow = "↮";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles = "⩽̸";
var nless = "≮";
var nlsim = "≴";
var nlt = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nmid = "∤";
var nopf = "𝕟";
var no = "¬";
var not = "¬";
var notin = "∉";
var notinE = "⋹̸";
var notindot = "⋵̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var npar = "∦";
var nparallel = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var npre = "⪯̸";
var nprec = "⊀";
var npreceq = "⪯̸";
var nrArr = "⇏";
var nrarr = "↛";
var nrarrc = "⤳̸";
var nrarrw = "↝̸";
var nrightarrow = "↛";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc = "⊁";
var nsccue = "⋡";
var nsce = "⪰̸";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var ntild = "ñ";
var ntilde = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var nu = "ν";
var num = "#";
var numero = "№";
var numsp = " ";
var nvDash = "⊭";
var nvHarr = "⤄";
var nvap = "≍⃒";
var nvdash = "⊬";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwArr = "⇖";
var nwarhk = "⤣";
var nwarr = "↖";
var nwarrow = "↖";
var nwnear = "⤧";
var oS = "Ⓢ";
var oacut = "ó";
var oacute = "ó";
var oast = "⊛";
var ocir = "ô";
var ocirc = "ô";
var ocy = "о";
var odash = "⊝";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var oelig = "œ";
var ofcir = "⦿";
var ofr = "𝔬";
var ogon = "˛";
var ograv = "ò";
var ograve = "ò";
var ogt = "⧁";
var ohbar = "⦵";
var ohm = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline = "‾";
var olt = "⧀";
var omacr = "ō";
var omega = "ω";
var omicron = "ο";
var omid = "⦶";
var ominus = "⊖";
var oopf = "𝕠";
var opar = "⦷";
var operp = "⦹";
var oplus = "⊕";
var or = "∨";
var orarr = "↻";
var ord = "º";
var order = "ℴ";
var orderof = "ℴ";
var ordf = "ª";
var ordm = "º";
var origof = "⊶";
var oror = "⩖";
var orslope = "⩗";
var orv = "⩛";
var oscr = "ℴ";
var oslas = "ø";
var oslash = "ø";
var osol = "⊘";
var otild = "õ";
var otilde = "õ";
var otimes = "⊗";
var otimesas = "⨶";
var oum = "ö";
var ouml = "ö";
var ovbar = "⌽";
var par = "¶";
var para = "¶";
var parallel = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part = "∂";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil = "‰";
var perp = "⊥";
var pertenk = "‱";
var pfr = "𝔭";
var phi = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone = "☎";
var pi = "π";
var pitchfork = "⋔";
var piv = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plus = "+";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var plusm = "±";
var plusmn = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm = "±";
var pointint = "⨕";
var popf = "𝕡";
var poun = "£";
var pound = "£";
var pr = "≺";
var prE = "⪳";
var prap = "⪷";
var prcue = "≼";
var pre = "⪯";
var prec = "≺";
var precapprox = "⪷";
var preccurlyeq = "≼";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var precsim = "≾";
var prime = "′";
var primes = "ℙ";
var prnE = "⪵";
var prnap = "⪹";
var prnsim = "⋨";
var prod = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop = "∝";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var pscr = "𝓅";
var psi = "ψ";
var puncsp = " ";
var qfr = "𝔮";
var qint = "⨌";
var qopf = "𝕢";
var qprime = "⁗";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest = "?";
var questeq = "≟";
var quo = "\"";
var quot = "\"";
var rAarr = "⇛";
var rArr = "⇒";
var rAtail = "⤜";
var rBarr = "⤏";
var rHar = "⥤";
var race = "∽̱";
var racute = "ŕ";
var radic = "√";
var raemptyv = "⦳";
var rang = "⟩";
var rangd = "⦒";
var range$1 = "⦥";
var rangle = "⟩";
var raqu = "»";
var raquo = "»";
var rarr = "→";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var rarrtl = "↣";
var rarrw = "↝";
var ratail = "⤚";
var ratio = "∶";
var rationals = "ℚ";
var rbarr = "⤍";
var rbbrk = "❳";
var rbrace = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var rcaron = "ř";
var rcedil = "ŗ";
var rceil = "⌉";
var rcub = "}";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo = "”";
var rdquor = "”";
var rdsh = "↳";
var real = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals = "ℝ";
var rect = "▭";
var re = "®";
var reg = "®";
var rfisht = "⥽";
var rfloor = "⌋";
var rfr = "𝔯";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var rho = "ρ";
var rhov = "ϱ";
var rightarrow = "→";
var rightarrowtail = "↣";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var rightthreetimes = "⋌";
var ring = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm = "‏";
var rmoust = "⎱";
var rmoustache = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var ropf = "𝕣";
var roplus = "⨮";
var rotimes = "⨵";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var rsaquo = "›";
var rscr = "𝓇";
var rsh = "↱";
var rsqb = "]";
var rsquo = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var ruluhar = "⥨";
var rx = "℞";
var sacute = "ś";
var sbquo = "‚";
var sc = "≻";
var scE = "⪴";
var scap = "⪸";
var scaron = "š";
var sccue = "≽";
var sce = "⪰";
var scedil = "ş";
var scirc = "ŝ";
var scnE = "⪶";
var scnap = "⪺";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var scy = "с";
var sdot = "⋅";
var sdotb = "⊡";
var sdote = "⩦";
var seArr = "⇘";
var searhk = "⤥";
var searr = "↘";
var searrow = "↘";
var sec = "§";
var sect = "§";
var semi = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp = "♯";
var shchcy = "щ";
var shcy = "ш";
var shortmid = "∣";
var shortparallel = "∥";
var sh = "­";
var shy = "­";
var sigma = "σ";
var sigmaf = "ς";
var sigmav = "ς";
var sim = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var softcy = "ь";
var sol = "/";
var solb = "⧄";
var solbar = "⌿";
var sopf = "𝕤";
var spades = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var squ = "□";
var square = "□";
var squarf = "▪";
var squf = "▪";
var srarr = "→";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var star = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var sub$1 = "⊂";
var subE = "⫅";
var subdot = "⪽";
var sube = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var subset = "⊂";
var subseteq = "⊆";
var subseteqq = "⫅";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succ = "≻";
var succapprox = "⪸";
var succcurlyeq = "≽";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var sum = "∑";
var sung = "♪";
var sup = "⊃";
var sup1 = "¹";
var sup2 = "²";
var sup3 = "³";
var supE = "⫆";
var supdot = "⪾";
var supdsub = "⫘";
var supe = "⊇";
var supedot = "⫄";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var supset = "⊃";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swArr = "⇙";
var swarhk = "⤦";
var swarr = "↙";
var swarrow = "↙";
var swnwar = "⤪";
var szli = "ß";
var szlig = "ß";
var target = "⌖";
var tau = "τ";
var tbrk = "⎴";
var tcaron = "ť";
var tcedil = "ţ";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var tfr = "𝔱";
var there4 = "∴";
var therefore = "∴";
var theta = "θ";
var thetasym = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var thinsp = " ";
var thkap = "≈";
var thksim = "∼";
var thor = "þ";
var thorn = "þ";
var tilde = "˜";
var time$1 = "×";
var times = "×";
var timesb = "⊠";
var timesbar = "⨱";
var timesd = "⨰";
var tint = "∭";
var toea = "⤨";
var top = "⊤";
var topbot = "⌶";
var topcir = "⫱";
var topf = "𝕥";
var topfork = "⫚";
var tosa = "⤩";
var tprime = "‴";
var trade = "™";
var triangle = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie = "≜";
var triminus = "⨺";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var tscr = "𝓉";
var tscy = "ц";
var tshcy = "ћ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var uArr = "⇑";
var uHar = "⥣";
var uacut = "ú";
var uacute = "ú";
var uarr = "↑";
var ubrcy = "ў";
var ubreve = "ŭ";
var ucir = "û";
var ucirc = "û";
var ucy = "у";
var udarr = "⇅";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var ufr = "𝔲";
var ugrav = "ù";
var ugrave = "ù";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var umacr = "ū";
var um = "¨";
var uml = "¨";
var uogon = "ų";
var uopf = "𝕦";
var uparrow = "↑";
var updownarrow = "↕";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus = "⊎";
var upsi = "υ";
var upsih = "ϒ";
var upsilon = "υ";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var uring = "ů";
var urtri = "◹";
var uscr = "𝓊";
var utdot = "⋰";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var uum = "ü";
var uuml = "ü";
var uwangle = "⦧";
var vArr = "⇕";
var vBar = "⫨";
var vBarv = "⫩";
var vDash = "⊨";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var varr = "↕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var vcy = "в";
var vdash = "⊢";
var vee = "∨";
var veebar = "⊻";
var veeeq = "≚";
var vellip = "⋮";
var verbar = "|";
var vert = "|";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var vzigzag = "⦚";
var wcirc = "ŵ";
var wedbar = "⩟";
var wedge = "∧";
var wedgeq = "≙";
var weierp = "℘";
var wfr = "𝔴";
var wopf = "𝕨";
var wp = "℘";
var wr = "≀";
var wreath = "≀";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var xfr = "𝔵";
var xhArr = "⟺";
var xharr = "⟷";
var xi = "ξ";
var xlArr = "⟸";
var xlarr = "⟵";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrArr = "⟹";
var xrarr = "⟶";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var yacut = "ý";
var yacute = "ý";
var yacy = "я";
var ycirc = "ŷ";
var ycy = "ы";
var ye = "¥";
var yen = "¥";
var yfr = "𝔶";
var yicy = "ї";
var yopf = "𝕪";
var yscr = "𝓎";
var yucy = "ю";
var yum = "ÿ";
var yuml = "ÿ";
var zacute = "ź";
var zcaron = "ž";
var zcy = "з";
var zdot = "ż";
var zeetrf = "ℨ";
var zeta = "ζ";
var zfr = "𝔷";
var zhcy = "ж";
var zigrarr = "⇝";
var zopf = "𝕫";
var zscr = "𝓏";
var zwj = "‍";
var zwnj = "‌";
var require$$0$1 = {
	AEli: AEli,
	AElig: AElig,
	AM: AM,
	AMP: AMP,
	Aacut: Aacut,
	Aacute: Aacute,
	Abreve: Abreve,
	Acir: Acir,
	Acirc: Acirc,
	Acy: Acy,
	Afr: Afr,
	Agrav: Agrav,
	Agrave: Agrave,
	Alpha: Alpha,
	Amacr: Amacr,
	And: And,
	Aogon: Aogon,
	Aopf: Aopf,
	ApplyFunction: ApplyFunction,
	Arin: Arin,
	Aring: Aring,
	Ascr: Ascr,
	Assign: Assign,
	Atild: Atild,
	Atilde: Atilde,
	Aum: Aum,
	Auml: Auml,
	Backslash: Backslash,
	Barv: Barv,
	Barwed: Barwed,
	Bcy: Bcy,
	Because: Because,
	Bernoullis: Bernoullis,
	Beta: Beta,
	Bfr: Bfr,
	Bopf: Bopf,
	Breve: Breve,
	Bscr: Bscr,
	Bumpeq: Bumpeq,
	CHcy: CHcy,
	COP: COP,
	COPY: COPY,
	Cacute: Cacute,
	Cap: Cap,
	CapitalDifferentialD: CapitalDifferentialD,
	Cayleys: Cayleys,
	Ccaron: Ccaron,
	Ccedi: Ccedi,
	Ccedil: Ccedil,
	Ccirc: Ccirc,
	Cconint: Cconint,
	Cdot: Cdot,
	Cedilla: Cedilla,
	CenterDot: CenterDot,
	Cfr: Cfr,
	Chi: Chi,
	CircleDot: CircleDot,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	Colon: Colon,
	Colone: Colone,
	Congruent: Congruent,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	Copf: Copf,
	Coproduct: Coproduct,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	Cross: Cross,
	Cscr: Cscr,
	Cup: Cup,
	CupCap: CupCap,
	DD: DD,
	DDotrahd: DDotrahd,
	DJcy: DJcy,
	DScy: DScy,
	DZcy: DZcy,
	Dagger: Dagger,
	Darr: Darr,
	Dashv: Dashv,
	Dcaron: Dcaron,
	Dcy: Dcy,
	Del: Del,
	Delta: Delta,
	Dfr: Dfr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	Diamond: Diamond$1,
	DifferentialD: DifferentialD,
	Dopf: Dopf,
	Dot: Dot,
	DotDot: DotDot,
	DotEqual: DotEqual,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrow: DownArrow,
	DownArrowBar: DownArrowBar,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVector: DownLeftVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVector: DownRightVector,
	DownRightVectorBar: DownRightVectorBar,
	DownTee: DownTee,
	DownTeeArrow: DownTeeArrow,
	Downarrow: Downarrow,
	Dscr: Dscr,
	Dstrok: Dstrok,
	ENG: ENG,
	ET: ET,
	ETH: ETH,
	Eacut: Eacut,
	Eacute: Eacute,
	Ecaron: Ecaron,
	Ecir: Ecir,
	Ecirc: Ecirc,
	Ecy: Ecy,
	Edot: Edot,
	Efr: Efr,
	Egrav: Egrav,
	Egrave: Egrave,
	Element: Element$2,
	Emacr: Emacr,
	EmptySmallSquare: EmptySmallSquare,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	Eogon: Eogon,
	Eopf: Eopf,
	Epsilon: Epsilon,
	Equal: Equal,
	EqualTilde: EqualTilde,
	Equilibrium: Equilibrium,
	Escr: Escr,
	Esim: Esim,
	Eta: Eta,
	Eum: Eum,
	Euml: Euml,
	Exists: Exists,
	ExponentialE: ExponentialE,
	Fcy: Fcy,
	Ffr: Ffr,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	Fopf: Fopf,
	ForAll: ForAll,
	Fouriertrf: Fouriertrf,
	Fscr: Fscr,
	GJcy: GJcy,
	G: G,
	GT: GT,
	Gamma: Gamma,
	Gammad: Gammad,
	Gbreve: Gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	Gcy: Gcy,
	Gdot: Gdot,
	Gfr: Gfr,
	Gg: Gg,
	Gopf: Gopf,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	Gt: Gt,
	HARDcy: HARDcy,
	Hacek: Hacek,
	Hat: Hat,
	Hcirc: Hcirc,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	Hopf: Hopf,
	HorizontalLine: HorizontalLine,
	Hscr: Hscr,
	Hstrok: Hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	IEcy: IEcy,
	IJlig: IJlig,
	IOcy: IOcy,
	Iacut: Iacut,
	Iacute: Iacute,
	Icir: Icir,
	Icirc: Icirc,
	Icy: Icy,
	Idot: Idot,
	Ifr: Ifr,
	Igrav: Igrav,
	Igrave: Igrave,
	Im: Im,
	Imacr: Imacr,
	ImaginaryI: ImaginaryI,
	Implies: Implies,
	Int: Int,
	Integral: Integral,
	Intersection: Intersection,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	Iogon: Iogon,
	Iopf: Iopf,
	Iota: Iota,
	Iscr: Iscr,
	Itilde: Itilde,
	Iukcy: Iukcy,
	Ium: Ium,
	Iuml: Iuml,
	Jcirc: Jcirc,
	Jcy: Jcy,
	Jfr: Jfr,
	Jopf: Jopf,
	Jscr: Jscr,
	Jsercy: Jsercy,
	Jukcy: Jukcy,
	KHcy: KHcy,
	KJcy: KJcy,
	Kappa: Kappa,
	Kcedil: Kcedil,
	Kcy: Kcy,
	Kfr: Kfr,
	Kopf: Kopf,
	Kscr: Kscr,
	LJcy: LJcy,
	L: L,
	LT: LT,
	Lacute: Lacute,
	Lambda: Lambda,
	Lang: Lang,
	Laplacetrf: Laplacetrf,
	Larr: Larr,
	Lcaron: Lcaron,
	Lcedil: Lcedil,
	Lcy: Lcy,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrow: LeftArrow,
	LeftArrowBar: LeftArrowBar,
	LeftArrowRightArrow: LeftArrowRightArrow,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVector: LeftDownVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftFloor: LeftFloor,
	LeftRightArrow: LeftRightArrow,
	LeftRightVector: LeftRightVector,
	LeftTee: LeftTee,
	LeftTeeArrow: LeftTeeArrow,
	LeftTeeVector: LeftTeeVector,
	LeftTriangle: LeftTriangle,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVector: LeftUpVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftVector: LeftVector,
	LeftVectorBar: LeftVectorBar,
	Leftarrow: Leftarrow,
	Leftrightarrow: Leftrightarrow,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	LessLess: LessLess,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	Lfr: Lfr,
	Ll: Ll,
	Lleftarrow: Lleftarrow,
	Lmidot: Lmidot,
	LongLeftArrow: LongLeftArrow,
	LongLeftRightArrow: LongLeftRightArrow,
	LongRightArrow: LongRightArrow,
	Longleftarrow: Longleftarrow,
	Longleftrightarrow: Longleftrightarrow,
	Longrightarrow: Longrightarrow,
	Lopf: Lopf,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	Lscr: Lscr,
	Lsh: Lsh,
	Lstrok: Lstrok,
	Lt: Lt,
	"Map": "⤅",
	Mcy: Mcy,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	MinusPlus: MinusPlus,
	Mopf: Mopf,
	Mscr: Mscr,
	Mu: Mu,
	NJcy: NJcy,
	Nacute: Nacute,
	Ncaron: Ncaron,
	Ncedil: Ncedil,
	Ncy: Ncy,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	Nfr: Nfr,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	Nopf: Nopf,
	Not: Not,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	Nscr: Nscr,
	Ntild: Ntild,
	Ntilde: Ntilde,
	Nu: Nu,
	OElig: OElig,
	Oacut: Oacut,
	Oacute: Oacute,
	Ocir: Ocir,
	Ocirc: Ocirc,
	Ocy: Ocy,
	Odblac: Odblac,
	Ofr: Ofr,
	Ograv: Ograv,
	Ograve: Ograve,
	Omacr: Omacr,
	Omega: Omega,
	Omicron: Omicron,
	Oopf: Oopf,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	Or: Or,
	Oscr: Oscr,
	Oslas: Oslas,
	Oslash: Oslash,
	Otild: Otild,
	Otilde: Otilde,
	Otimes: Otimes,
	Oum: Oum,
	Ouml: Ouml,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	PartialD: PartialD,
	Pcy: Pcy,
	Pfr: Pfr,
	Phi: Phi,
	Pi: Pi,
	PlusMinus: PlusMinus,
	Poincareplane: Poincareplane,
	Popf: Popf,
	Pr: Pr,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	Prime: Prime,
	Product: Product,
	Proportion: Proportion,
	Proportional: Proportional,
	Pscr: Pscr,
	Psi: Psi,
	QUO: QUO,
	QUOT: QUOT,
	Qfr: Qfr,
	Qopf: Qopf,
	Qscr: Qscr,
	RBarr: RBarr,
	RE: RE,
	REG: REG,
	Racute: Racute,
	Rang: Rang,
	Rarr: Rarr,
	Rarrtl: Rarrtl,
	Rcaron: Rcaron,
	Rcedil: Rcedil,
	Rcy: Rcy,
	Re: Re,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	Rfr: Rfr,
	Rho: Rho,
	RightAngleBracket: RightAngleBracket,
	RightArrow: RightArrow,
	RightArrowBar: RightArrowBar,
	RightArrowLeftArrow: RightArrowLeftArrow,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVector: RightDownVector,
	RightDownVectorBar: RightDownVectorBar,
	RightFloor: RightFloor,
	RightTee: RightTee,
	RightTeeArrow: RightTeeArrow,
	RightTeeVector: RightTeeVector,
	RightTriangle: RightTriangle,
	RightTriangleBar: RightTriangleBar,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVector: RightUpVector,
	RightUpVectorBar: RightUpVectorBar,
	RightVector: RightVector,
	RightVectorBar: RightVectorBar,
	Rightarrow: Rightarrow,
	Ropf: Ropf,
	RoundImplies: RoundImplies,
	Rrightarrow: Rrightarrow,
	Rscr: Rscr,
	Rsh: Rsh,
	RuleDelayed: RuleDelayed,
	SHCHcy: SHCHcy,
	SHcy: SHcy,
	SOFTcy: SOFTcy,
	Sacute: Sacute,
	Sc: Sc,
	Scaron: Scaron,
	Scedil: Scedil,
	Scirc: Scirc,
	Scy: Scy,
	Sfr: Sfr,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	Sigma: Sigma,
	SmallCircle: SmallCircle,
	Sopf: Sopf,
	Sqrt: Sqrt,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	Sscr: Sscr,
	Star: Star,
	Sub: Sub,
	Subset: Subset,
	SubsetEqual: SubsetEqual,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	SuchThat: SuchThat,
	Sum: Sum,
	Sup: Sup,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	Supset: Supset,
	THOR: THOR,
	THORN: THORN,
	TRADE: TRADE,
	TSHcy: TSHcy,
	TScy: TScy,
	Tab: Tab,
	Tau: Tau,
	Tcaron: Tcaron,
	Tcedil: Tcedil,
	Tcy: Tcy,
	Tfr: Tfr,
	Therefore: Therefore,
	Theta: Theta,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	Topf: Topf,
	TripleDot: TripleDot,
	Tscr: Tscr,
	Tstrok: Tstrok,
	Uacut: Uacut,
	Uacute: Uacute,
	Uarr: Uarr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	Ubreve: Ubreve,
	Ucir: Ucir,
	Ucirc: Ucirc,
	Ucy: Ucy,
	Udblac: Udblac,
	Ufr: Ufr,
	Ugrav: Ugrav,
	Ugrave: Ugrave,
	Umacr: Umacr,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	Uopf: Uopf,
	UpArrow: UpArrow,
	UpArrowBar: UpArrowBar,
	UpArrowDownArrow: UpArrowDownArrow,
	UpDownArrow: UpDownArrow,
	UpEquilibrium: UpEquilibrium,
	UpTee: UpTee,
	UpTeeArrow: UpTeeArrow,
	Uparrow: Uparrow,
	Updownarrow: Updownarrow,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	Upsi: Upsi,
	Upsilon: Upsilon,
	Uring: Uring,
	Uscr: Uscr,
	Utilde: Utilde,
	Uum: Uum,
	Uuml: Uuml,
	VDash: VDash,
	Vbar: Vbar,
	Vcy: Vcy,
	Vdash: Vdash,
	Vdashl: Vdashl,
	Vee: Vee,
	Verbar: Verbar,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	Vopf: Vopf,
	Vscr: Vscr,
	Vvdash: Vvdash,
	Wcirc: Wcirc,
	Wedge: Wedge,
	Wfr: Wfr,
	Wopf: Wopf,
	Wscr: Wscr,
	Xfr: Xfr,
	Xi: Xi,
	Xopf: Xopf,
	Xscr: Xscr,
	YAcy: YAcy,
	YIcy: YIcy,
	YUcy: YUcy,
	Yacut: Yacut,
	Yacute: Yacute,
	Ycirc: Ycirc,
	Ycy: Ycy,
	Yfr: Yfr,
	Yopf: Yopf,
	Yscr: Yscr,
	Yuml: Yuml,
	ZHcy: ZHcy,
	Zacute: Zacute,
	Zcaron: Zcaron,
	Zcy: Zcy,
	Zdot: Zdot,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	Zfr: Zfr,
	Zopf: Zopf,
	Zscr: Zscr,
	aacut: aacut,
	aacute: aacute,
	abreve: abreve,
	ac: ac,
	acE: acE,
	acd: acd,
	acir: acir,
	acirc: acirc,
	acut: acut,
	acute: acute,
	acy: acy,
	aeli: aeli,
	aelig: aelig,
	af: af,
	afr: afr,
	agrav: agrav,
	agrave: agrave,
	alefsym: alefsym,
	aleph: aleph,
	alpha: alpha,
	amacr: amacr,
	amalg: amalg,
	am: am,
	amp: amp,
	and: and,
	andand: andand,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsd: angmsd,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	aogon: aogon,
	aopf: aopf,
	ap: ap,
	apE: apE,
	apacir: apacir,
	ape: ape,
	apid: apid,
	apos: apos,
	approx: approx,
	approxeq: approxeq,
	arin: arin,
	aring: aring,
	ascr: ascr,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	atild: atild,
	atilde: atilde,
	aum: aum,
	auml: auml,
	awconint: awconint,
	awint: awint,
	bNot: bNot,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	barvee: barvee,
	barwed: barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	beta: beta,
	beth: beth,
	between: between,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bnot: bnot,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxDL: boxDL,
	boxDR: boxDR,
	boxDl: boxDl,
	boxDr: boxDr,
	boxH: boxH,
	boxHD: boxHD,
	boxHU: boxHU,
	boxHd: boxHd,
	boxHu: boxHu,
	boxUL: boxUL,
	boxUR: boxUR,
	boxUl: boxUl,
	boxUr: boxUr,
	boxV: boxV,
	boxVH: boxVH,
	boxVL: boxVL,
	boxVR: boxVR,
	boxVh: boxVh,
	boxVl: boxVl,
	boxVr: boxVr,
	boxbox: boxbox,
	boxdL: boxdL,
	boxdR: boxdR,
	boxdl: boxdl,
	boxdr: boxdr,
	boxh: boxh,
	boxhD: boxhD,
	boxhU: boxhU,
	boxhd: boxhd,
	boxhu: boxhu,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxuL: boxuL,
	boxuR: boxuR,
	boxul: boxul,
	boxur: boxur,
	boxv: boxv,
	boxvH: boxvH,
	boxvL: boxvL,
	boxvR: boxvR,
	boxvh: boxvh,
	boxvl: boxvl,
	boxvr: boxvr,
	bprime: bprime,
	breve: breve,
	brvba: brvba,
	brvbar: brvbar,
	bscr: bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsol: bsol,
	bsolb: bsolb,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	bumpeq: bumpeq,
	cacute: cacute,
	cap: cap,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	capcup: capcup,
	capdot: capdot,
	caps: caps,
	caret: caret,
	caron: caron,
	ccaps: ccaps,
	ccaron: ccaron,
	ccedi: ccedi,
	ccedil: ccedil,
	ccirc: ccirc,
	ccups: ccups,
	ccupssm: ccupssm,
	cdot: cdot,
	cedi: cedi,
	cedil: cedil,
	cemptyv: cemptyv,
	cen: cen,
	cent: cent,
	centerdot: centerdot,
	cfr: cfr,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	chi: chi,
	cir: cir,
	cirE: cirE,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledR: circledR,
	circledS: circledS,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	conint: conint,
	copf: copf,
	coprod: coprod,
	cop: cop,
	copy: copy$2,
	copysr: copysr,
	crarr: crarr,
	cross: cross,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cup: cup,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curre: curre,
	curren: curren,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dArr: dArr,
	dHar: dHar,
	dagger: dagger,
	daleth: daleth,
	darr: darr,
	dash: dash,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	dcaron: dcaron,
	dcy: dcy,
	dd: dd,
	ddagger: ddagger,
	ddarr: ddarr,
	ddotseq: ddotseq,
	de: de,
	deg: deg,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	dfr: dfr,
	dharl: dharl,
	dharr: dharr,
	diam: diam,
	diamond: diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	digamma: digamma,
	disin: disin,
	div: div$1,
	divid: divid,
	divide: divide,
	divideontimes: divideontimes,
	divonx: divonx,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	dopf: dopf,
	dot: dot$1,
	doteq: doteq,
	doteqdot: doteqdot,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	downarrow: downarrow,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	dscr: dscr,
	dscy: dscy,
	dsol: dsol,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	eDDot: eDDot,
	eDot: eDot,
	eacut: eacut,
	eacute: eacute,
	easter: easter,
	ecaron: ecaron,
	ecir: ecir,
	ecirc: ecirc,
	ecolon: ecolon,
	ecy: ecy,
	edot: edot,
	ee: ee,
	efDot: efDot,
	efr: efr,
	eg: eg,
	egrav: egrav,
	egrave: egrave,
	egs: egs,
	egsdot: egsdot,
	el: el,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	emacr: emacr,
	empty: empty,
	emptyset: emptyset,
	emptyv: emptyv,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	eng: eng,
	ensp: ensp,
	eogon: eogon,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	equals: equals,
	equest: equest,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erDot: erDot,
	erarr: erarr,
	escr: escr,
	esdot: esdot,
	esim: esim,
	eta: eta,
	et: et,
	eth: eth,
	eum: eum,
	euml: euml,
	euro: euro,
	excl: excl,
	exist: exist,
	expectation: expectation,
	exponentiale: exponentiale,
	fallingdotseq: fallingdotseq,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	ffr: ffr,
	filig: filig,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	fopf: fopf,
	forall: forall,
	fork: fork,
	forkv: forkv,
	fpartint: fpartint,
	frac1: frac1,
	frac12: frac12,
	frac13: frac13,
	frac14: frac14,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac3: frac3,
	frac34: frac34,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	gE: gE,
	gEl: gEl,
	gacute: gacute,
	gamma: gamma,
	gammad: gammad,
	gap: gap,
	gbreve: gbreve,
	gcirc: gcirc,
	gcy: gcy,
	gdot: gdot,
	ge: ge,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	ges: ges,
	gescc: gescc,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	gfr: gfr,
	gg: gg,
	ggg: ggg,
	gimel: gimel,
	gjcy: gjcy,
	gl: gl,
	glE: glE,
	gla: gla,
	glj: glj,
	gnE: gnE,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	gopf: gopf,
	grave: grave,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	g: g,
	gt: gt,
	gtcc: gtcc,
	gtcir: gtcir,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	hArr: hArr,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	hardcy: hardcy,
	harr: harr,
	harrcir: harrcir,
	harrw: harrw,
	hbar: hbar,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	horbar: horbar,
	hscr: hscr,
	hslash: hslash,
	hstrok: hstrok,
	hybull: hybull,
	hyphen: hyphen,
	iacut: iacut,
	iacute: iacute,
	ic: ic,
	icir: icir,
	icirc: icirc,
	icy: icy,
	iecy: iecy,
	iexc: iexc,
	iexcl: iexcl,
	iff: iff,
	ifr: ifr,
	igrav: igrav,
	igrave: igrave,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	ijlig: ijlig,
	imacr: imacr,
	image: image,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	imof: imof,
	imped: imped,
	"in": "∈",
	incare: incare,
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	int: int,
	intcal: intcal,
	integers: integers,
	intercal: intercal,
	intlarhk: intlarhk,
	intprod: intprod,
	iocy: iocy,
	iogon: iogon,
	iopf: iopf,
	iota: iota,
	iprod: iprod,
	iques: iques,
	iquest: iquest,
	iscr: iscr,
	isin: isin,
	isinE: isinE,
	isindot: isindot,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	itilde: itilde,
	iukcy: iukcy,
	ium: ium,
	iuml: iuml,
	jcirc: jcirc,
	jcy: jcy,
	jfr: jfr,
	jmath: jmath,
	jopf: jopf,
	jscr: jscr,
	jsercy: jsercy,
	jukcy: jukcy,
	kappa: kappa,
	kappav: kappav,
	kcedil: kcedil,
	kcy: kcy,
	kfr: kfr,
	kgreen: kgreen,
	khcy: khcy,
	kjcy: kjcy,
	kopf: kopf,
	kscr: kscr,
	lAarr: lAarr,
	lArr: lArr,
	lAtail: lAtail,
	lBarr: lBarr,
	lE: lE,
	lEg: lEg,
	lHar: lHar,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	lambda: lambda,
	lang: lang,
	langd: langd,
	langle: langle,
	lap: lap,
	laqu: laqu,
	laquo: laquo,
	larr: larr,
	larrb: larrb,
	larrbfs: larrbfs,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	lat: lat,
	latail: latail,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	lcaron: lcaron,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	leftarrow: leftarrow,
	leftarrowtail: leftarrowtail,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	leftthreetimes: leftthreetimes,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	les: les,
	lescc: lescc,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	lessgtr: lessgtr,
	lesssim: lesssim,
	lfisht: lfisht,
	lfloor: lfloor,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	ljcy: ljcy,
	ll: ll,
	llarr: llarr,
	llcorner: llcorner,
	llhard: llhard,
	lltri: lltri,
	lmidot: lmidot,
	lmoust: lmoust,
	lmoustache: lmoustache,
	lnE: lnE,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	longleftrightarrow: longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	lsh: lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	lstrok: lstrok,
	l: l,
	lt: lt$1,
	ltcc: ltcc,
	ltcir: ltcir,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltrPar: ltrPar,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	mDDot: mDDot,
	mac: mac,
	macr: macr,
	male: male,
	malt: malt,
	maltese: maltese,
	map: map$2,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	mcy: mcy,
	mdash: mdash,
	measuredangle: measuredangle,
	mfr: mfr,
	mho: mho,
	micr: micr,
	micro: micro,
	mid: mid,
	midast: midast,
	midcir: midcir,
	middo: middo,
	middot: middot,
	minus: minus,
	minusb: minusb,
	minusd: minusd,
	minusdu: minusdu,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	mstpos: mstpos,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nGg: nGg,
	nGt: nGt,
	nGtv: nGtv,
	nLeftarrow: nLeftarrow,
	nLeftrightarrow: nLeftrightarrow,
	nLl: nLl,
	nLt: nLt,
	nLtv: nLtv,
	nRightarrow: nRightarrow,
	nVDash: nVDash,
	nVdash: nVdash,
	nabla: nabla,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natur: natur,
	natural: natural,
	naturals: naturals,
	nbs: nbs,
	nbsp: nbsp,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	ncaron: ncaron,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	ncy: ncy,
	ndash: ndash,
	ne: ne,
	neArr: neArr,
	nearhk: nearhk,
	nearr: nearr,
	nearrow: nearrow,
	nedot: nedot,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	nexist: nexist,
	nexists: nexists,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	ngsim: ngsim,
	ngt: ngt,
	ngtr: ngtr,
	nhArr: nhArr,
	nharr: nharr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	njcy: njcy,
	nlArr: nlArr,
	nlE: nlE,
	nlarr: nlarr,
	nldr: nldr,
	nle: nle,
	nleftarrow: nleftarrow,
	nleftrightarrow: nleftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nlsim: nlsim,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nmid: nmid,
	nopf: nopf,
	no: no,
	not: not,
	notin: notin,
	notinE: notinE,
	notindot: notindot,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	npar: npar,
	nparallel: nparallel,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	npre: npre,
	nprec: nprec,
	npreceq: npreceq,
	nrArr: nrArr,
	nrarr: nrarr,
	nrarrc: nrarrc,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	ntild: ntild,
	ntilde: ntilde,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvDash: nvDash,
	nvHarr: nvHarr,
	nvap: nvap,
	nvdash: nvdash,
	nvge: nvge,
	nvgt: nvgt,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwArr: nwArr,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	oS: oS,
	oacut: oacut,
	oacute: oacute,
	oast: oast,
	ocir: ocir,
	ocirc: ocirc,
	ocy: ocy,
	odash: odash,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	oelig: oelig,
	ofcir: ofcir,
	ofr: ofr,
	ogon: ogon,
	ograv: ograv,
	ograve: ograve,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	omacr: omacr,
	omega: omega,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	oopf: oopf,
	opar: opar,
	operp: operp,
	oplus: oplus,
	or: or,
	orarr: orarr,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf,
	ordm: ordm,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oscr: oscr,
	oslas: oslas,
	oslash: oslash,
	osol: osol,
	otild: otild,
	otilde: otilde,
	otimes: otimes,
	otimesas: otimesas,
	oum: oum,
	ouml: ouml,
	ovbar: ovbar,
	par: par,
	para: para,
	parallel: parallel,
	parsim: parsim,
	parsl: parsl,
	part: part,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	pfr: pfr,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plus: plus,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	plusm: plusm,
	plusmn: plusmn,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	pointint: pointint,
	popf: popf,
	poun: poun,
	pound: pound,
	pr: pr,
	prE: prE,
	prap: prap,
	prcue: prcue,
	pre: pre,
	prec: prec,
	precapprox: precapprox,
	preccurlyeq: preccurlyeq,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	precsim: precsim,
	prime: prime,
	primes: primes,
	prnE: prnE,
	prnap: prnap,
	prnsim: prnsim,
	prod: prod,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	pscr: pscr,
	psi: psi,
	puncsp: puncsp,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	qprime: qprime,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quo: quo,
	quot: quot,
	rAarr: rAarr,
	rArr: rArr,
	rAtail: rAtail,
	rBarr: rBarr,
	rHar: rHar,
	race: race,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	rangd: rangd,
	range: range$1,
	rangle: rangle,
	raqu: raqu,
	raquo: raquo,
	rarr: rarr,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	rcaron: rcaron,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	rect: rect,
	re: re,
	reg: reg,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	rho: rho,
	rhov: rhov,
	rightarrow: rightarrow,
	rightarrowtail: rightarrowtail,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	rightthreetimes: rightthreetimes,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoust: rmoust,
	rmoustache: rmoustache,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	roplus: roplus,
	rotimes: rotimes,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	rsaquo: rsaquo,
	rscr: rscr,
	rsh: rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	ruluhar: ruluhar,
	rx: rx,
	sacute: sacute,
	sbquo: sbquo,
	sc: sc,
	scE: scE,
	scap: scap,
	scaron: scaron,
	sccue: sccue,
	sce: sce,
	scedil: scedil,
	scirc: scirc,
	scnE: scnE,
	scnap: scnap,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	scy: scy,
	sdot: sdot,
	sdotb: sdotb,
	sdote: sdote,
	seArr: seArr,
	searhk: searhk,
	searr: searr,
	searrow: searrow,
	sec: sec,
	sect: sect,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	shchcy: shchcy,
	shcy: shcy,
	shortmid: shortmid,
	shortparallel: shortparallel,
	sh: sh,
	shy: shy,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	softcy: softcy,
	sol: sol,
	solb: solb,
	solbar: solbar,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	squ: squ,
	square: square,
	squarf: squarf,
	squf: squf,
	srarr: srarr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub$1,
	subE: subE,
	subdot: subdot,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succ: succ,
	succapprox: succapprox,
	succcurlyeq: succcurlyeq,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	sum: sum,
	sung: sung,
	sup: sup,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	supE: supE,
	supdot: supdot,
	supdsub: supdsub,
	supe: supe,
	supedot: supedot,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swArr: swArr,
	swarhk: swarhk,
	swarr: swarr,
	swarrow: swarrow,
	swnwar: swnwar,
	szli: szli,
	szlig: szlig,
	target: target,
	tau: tau,
	tbrk: tbrk,
	tcaron: tcaron,
	tcedil: tcedil,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	thor: thor,
	thorn: thorn,
	tilde: tilde,
	time: time$1,
	times: times,
	timesb: timesb,
	timesbar: timesbar,
	timesd: timesd,
	tint: tint,
	toea: toea,
	top: top,
	topbot: topbot,
	topcir: topcir,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	tscr: tscr,
	tscy: tscy,
	tshcy: tshcy,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	uArr: uArr,
	uHar: uHar,
	uacut: uacut,
	uacute: uacute,
	uarr: uarr,
	ubrcy: ubrcy,
	ubreve: ubreve,
	ucir: ucir,
	ucirc: ucirc,
	ucy: ucy,
	udarr: udarr,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	ufr: ufr,
	ugrav: ugrav,
	ugrave: ugrave,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	umacr: umacr,
	um: um,
	uml: uml,
	uogon: uogon,
	uopf: uopf,
	uparrow: uparrow,
	updownarrow: updownarrow,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	upsi: upsi,
	upsih: upsih,
	upsilon: upsilon,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	uring: uring,
	urtri: urtri,
	uscr: uscr,
	utdot: utdot,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	uum: uum,
	uuml: uuml,
	uwangle: uwangle,
	vArr: vArr,
	vBar: vBar,
	vBarv: vBarv,
	vDash: vDash,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vcy: vcy,
	vdash: vdash,
	vee: vee,
	veebar: veebar,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	vert: vert,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	vzigzag: vzigzag,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	wfr: wfr,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	xfr: xfr,
	xhArr: xhArr,
	xharr: xharr,
	xi: xi,
	xlArr: xlArr,
	xlarr: xlarr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrArr: xrArr,
	xrarr: xrarr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	yacut: yacut,
	yacute: yacute,
	yacy: yacy,
	ycirc: ycirc,
	ycy: ycy,
	ye: ye,
	yen: yen,
	yfr: yfr,
	yicy: yicy,
	yopf: yopf,
	yscr: yscr,
	yucy: yucy,
	yum: yum,
	yuml: yuml,
	zacute: zacute,
	zcaron: zcaron,
	zcy: zcy,
	zdot: zdot,
	zeetrf: zeetrf,
	zeta: zeta,
	zfr: zfr,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj
};

var characterEntities = require$$0$1;

var decodeEntity_1 = decodeEntity$1;

var own$2 = {}.hasOwnProperty;

function decodeEntity$1(characters) {
  return own$2.call(characterEntities, characters)
    ? characterEntities[characters]
    : false
}

var legacy = require$$0$2;
var invalid = require$$1;
var decimal = isDecimal;
var hexadecimal = isHexadecimal;
var alphanumerical = isAlphanumerical;
var decodeEntity = decodeEntity_1;

var parseEntities_1 = parseEntities;

var own$1 = {}.hasOwnProperty;
var fromCharCode = String.fromCharCode;
var noop$2 = Function.prototype;

// Default settings.
var defaults$1 = {
  warning: null,
  reference: null,
  text: null,
  warningContext: null,
  referenceContext: null,
  textContext: null,
  position: {},
  additional: null,
  attribute: false,
  nonTerminated: true
};

// Characters.
var tab = 9; // '\t'
var lineFeed = 10; // '\n'
var formFeed = 12; // '\f'
var space = 32; // ' '
var ampersand = 38; // '&'
var semicolon = 59; // ';'
var lessThan = 60; // '<'
var equalsTo = 61; // '='
var numberSign = 35; // '#'
var uppercaseX = 88; // 'X'
var lowercaseX = 120; // 'x'
var replacementCharacter = 65533; // '�'

// Reference types.
var name = 'named';
var hexa = 'hexadecimal';
var deci = 'decimal';

// Map of bases.
var bases = {};

bases[hexa] = 16;
bases[deci] = 10;

// Map of types to tests.
// Each type of character reference accepts different characters.
// This test is used to detect whether a reference has ended (as the semicolon
// is not strictly needed).
var tests = {};

tests[name] = alphanumerical;
tests[deci] = decimal;
tests[hexa] = hexadecimal;

// Warning types.
var namedNotTerminated = 1;
var numericNotTerminated = 2;
var namedEmpty = 3;
var numericEmpty = 4;
var namedUnknown = 5;
var numericDisallowed = 6;
var numericProhibited = 7;

// Warning messages.
var messages = {};

messages[namedNotTerminated] =
  'Named character references must be terminated by a semicolon';
messages[numericNotTerminated] =
  'Numeric character references must be terminated by a semicolon';
messages[namedEmpty] = 'Named character references cannot be empty';
messages[numericEmpty] = 'Numeric character references cannot be empty';
messages[namedUnknown] = 'Named character references must be known';
messages[numericDisallowed] =
  'Numeric character references cannot be disallowed';
messages[numericProhibited] =
  'Numeric character references cannot be outside the permissible Unicode range';

// Wrap to ensure clean parameters are given to `parse`.
function parseEntities(value, options) {
  var settings = {};
  var option;
  var key;

  if (!options) {
    options = {};
  }

  for (key in defaults$1) {
    option = options[key];
    settings[key] =
      option === null || option === undefined ? defaults$1[key] : option;
  }

  if (settings.position.indent || settings.position.start) {
    settings.indent = settings.position.indent || [];
    settings.position = settings.position.start;
  }

  return parse$1(value, settings)
}

// Parse entities.
// eslint-disable-next-line complexity
function parse$1(value, settings) {
  var additional = settings.additional;
  var nonTerminated = settings.nonTerminated;
  var handleText = settings.text;
  var handleReference = settings.reference;
  var handleWarning = settings.warning;
  var textContext = settings.textContext;
  var referenceContext = settings.referenceContext;
  var warningContext = settings.warningContext;
  var pos = settings.position;
  var indent = settings.indent || [];
  var length = value.length;
  var index = 0;
  var lines = -1;
  var column = pos.column || 1;
  var line = pos.line || 1;
  var queue = '';
  var result = [];
  var entityCharacters;
  var namedEntity;
  var terminated;
  var characters;
  var character;
  var reference;
  var following;
  var warning;
  var reason;
  var output;
  var entity;
  var begin;
  var start;
  var type;
  var test;
  var prev;
  var next;
  var diff;
  var end;

  if (typeof additional === 'string') {
    additional = additional.charCodeAt(0);
  }

  // Cache the current point.
  prev = now();

  // Wrap `handleWarning`.
  warning = handleWarning ? parseError : noop$2;

  // Ensure the algorithm walks over the first character and the end
  // (inclusive).
  index--;
  length++;

  while (++index < length) {
    // If the previous character was a newline.
    if (character === lineFeed) {
      column = indent[lines] || 1;
    }

    character = value.charCodeAt(index);

    if (character === ampersand) {
      following = value.charCodeAt(index + 1);

      // The behaviour depends on the identity of the next character.
      if (
        following === tab ||
        following === lineFeed ||
        following === formFeed ||
        following === space ||
        following === ampersand ||
        following === lessThan ||
        following !== following ||
        (additional && following === additional)
      ) {
        // Not a character reference.
        // No characters are consumed, and nothing is returned.
        // This is not an error, either.
        queue += fromCharCode(character);
        column++;

        continue
      }

      start = index + 1;
      begin = start;
      end = start;

      if (following === numberSign) {
        // Numerical entity.
        end = ++begin;

        // The behaviour further depends on the next character.
        following = value.charCodeAt(end);

        if (following === uppercaseX || following === lowercaseX) {
          // ASCII hex digits.
          type = hexa;
          end = ++begin;
        } else {
          // ASCII digits.
          type = deci;
        }
      } else {
        // Named entity.
        type = name;
      }

      entityCharacters = '';
      entity = '';
      characters = '';
      test = tests[type];
      end--;

      while (++end < length) {
        following = value.charCodeAt(end);

        if (!test(following)) {
          break
        }

        characters += fromCharCode(following);

        // Check if we can match a legacy named reference.
        // If so, we cache that as the last viable named reference.
        // This ensures we do not need to walk backwards later.
        if (type === name && own$1.call(legacy, characters)) {
          entityCharacters = characters;
          entity = legacy[characters];
        }
      }

      terminated = value.charCodeAt(end) === semicolon;

      if (terminated) {
        end++;

        namedEntity = type === name ? decodeEntity(characters) : false;

        if (namedEntity) {
          entityCharacters = characters;
          entity = namedEntity;
        }
      }

      diff = 1 + end - start;

      if (!terminated && !nonTerminated) ; else if (!characters) {
        // An empty (possible) entity is valid, unless it’s numeric (thus an
        // ampersand followed by an octothorp).
        if (type !== name) {
          warning(numericEmpty, diff);
        }
      } else if (type === name) {
        // An ampersand followed by anything unknown, and not terminated, is
        // invalid.
        if (terminated && !entity) {
          warning(namedUnknown, 1);
        } else {
          // If theres something after an entity name which is not known, cap
          // the reference.
          if (entityCharacters !== characters) {
            end = begin + entityCharacters.length;
            diff = 1 + end - begin;
            terminated = false;
          }

          // If the reference is not terminated, warn.
          if (!terminated) {
            reason = entityCharacters ? namedNotTerminated : namedEmpty;

            if (settings.attribute) {
              following = value.charCodeAt(end);

              if (following === equalsTo) {
                warning(reason, diff);
                entity = null;
              } else if (alphanumerical(following)) {
                entity = null;
              } else {
                warning(reason, diff);
              }
            } else {
              warning(reason, diff);
            }
          }
        }

        reference = entity;
      } else {
        if (!terminated) {
          // All non-terminated numeric entities are not rendered, and trigger a
          // warning.
          warning(numericNotTerminated, diff);
        }

        // When terminated and number, parse as either hexadecimal or decimal.
        reference = parseInt(characters, bases[type]);

        // Trigger a warning when the parsed number is prohibited, and replace
        // with replacement character.
        if (prohibited(reference)) {
          warning(numericProhibited, diff);
          reference = fromCharCode(replacementCharacter);
        } else if (reference in invalid) {
          // Trigger a warning when the parsed number is disallowed, and replace
          // by an alternative.
          warning(numericDisallowed, diff);
          reference = invalid[reference];
        } else {
          // Parse the number.
          output = '';

          // Trigger a warning when the parsed number should not be used.
          if (disallowed(reference)) {
            warning(numericDisallowed, diff);
          }

          // Stringify the number.
          if (reference > 0xffff) {
            reference -= 0x10000;
            output += fromCharCode((reference >>> (10 & 0x3ff)) | 0xd800);
            reference = 0xdc00 | (reference & 0x3ff);
          }

          reference = output + fromCharCode(reference);
        }
      }

      // Found it!
      // First eat the queued characters as normal text, then eat an entity.
      if (reference) {
        flush();

        prev = now();
        index = end - 1;
        column += end - start + 1;
        result.push(reference);
        next = now();
        next.offset++;

        if (handleReference) {
          handleReference.call(
            referenceContext,
            reference,
            {start: prev, end: next},
            value.slice(start - 1, end)
          );
        }

        prev = next;
      } else {
        // If we could not find a reference, queue the checked characters (as
        // normal characters), and move the pointer to their end.
        // This is possible because we can be certain neither newlines nor
        // ampersands are included.
        characters = value.slice(start - 1, end);
        queue += characters;
        column += characters.length;
        index = end - 1;
      }
    } else {
      // Handle anything other than an ampersand, including newlines and EOF.
      if (
        character === 10 // Line feed
      ) {
        line++;
        lines++;
        column = 0;
      }

      if (character === character) {
        queue += fromCharCode(character);
        column++;
      } else {
        flush();
      }
    }
  }

  // Return the reduced nodes.
  return result.join('')

  // Get current position.
  function now() {
    return {
      line: line,
      column: column,
      offset: index + (pos.offset || 0)
    }
  }

  // “Throw” a parse-error: a warning.
  function parseError(code, offset) {
    var position = now();

    position.column += offset;
    position.offset += offset;

    handleWarning.call(warningContext, messages[code], position, code);
  }

  // Flush `queue` (normal text).
  // Macro invoked before each entity and at the end of `value`.
  // Does nothing when `queue` is empty.
  function flush() {
    if (queue) {
      result.push(queue);

      if (handleText) {
        handleText.call(textContext, queue, {start: prev, end: now()});
      }

      queue = '';
    }
  }
}

// Check if `character` is outside the permissible unicode range.
function prohibited(code) {
  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff
}

// Check if `character` is disallowed.
function disallowed(code) {
  return (
    (code >= 0x0001 && code <= 0x0008) ||
    code === 0x000b ||
    (code >= 0x000d && code <= 0x001f) ||
    (code >= 0x007f && code <= 0x009f) ||
    (code >= 0xfdd0 && code <= 0xfdef) ||
    (code & 0xffff) === 0xffff ||
    (code & 0xffff) === 0xfffe
  )
}

var prismCore = {exports: {}};

(function (module) {
	/// <reference lib="WebWorker"/>

	var _self = (typeof window !== 'undefined')
		? window   // if in browser
		: (
			(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
				? self // if in worker
				: {}   // if in node js
		);

	/**
	 * Prism: Lightweight, robust, elegant syntax highlighting
	 *
	 * @license MIT <https://opensource.org/licenses/MIT>
	 * @author Lea Verou <https://lea.verou.me>
	 * @namespace
	 * @public
	 */
	var Prism = (function (_self) {

		// Private helper vars
		var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
		var uniqueId = 0;

		// The grammar object for plaintext
		var plainTextGrammar = {};


		var _ = {
			/**
			 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
			 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
			 * additional languages or plugins yourself.
			 *
			 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
			 *
			 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
			 * empty Prism object into the global scope before loading the Prism script like this:
			 *
			 * ```js
			 * window.Prism = window.Prism || {};
			 * Prism.manual = true;
			 * // add a new <script> to load Prism's script
			 * ```
			 *
			 * @default false
			 * @type {boolean}
			 * @memberof Prism
			 * @public
			 */
			manual: _self.Prism && _self.Prism.manual,
			/**
			 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
			 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
			 * own worker, you don't want it to do this.
			 *
			 * By setting this value to `true`, Prism will not add its own listeners to the worker.
			 *
			 * You obviously have to change this value before Prism executes. To do this, you can add an
			 * empty Prism object into the global scope before loading the Prism script like this:
			 *
			 * ```js
			 * window.Prism = window.Prism || {};
			 * Prism.disableWorkerMessageHandler = true;
			 * // Load Prism's script
			 * ```
			 *
			 * @default false
			 * @type {boolean}
			 * @memberof Prism
			 * @public
			 */
			disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

			/**
			 * A namespace for utility methods.
			 *
			 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
			 * change or disappear at any time.
			 *
			 * @namespace
			 * @memberof Prism
			 */
			util: {
				encode: function encode(tokens) {
					if (tokens instanceof Token) {
						return new Token(tokens.type, encode(tokens.content), tokens.alias);
					} else if (Array.isArray(tokens)) {
						return tokens.map(encode);
					} else {
						return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
					}
				},

				/**
				 * Returns the name of the type of the given value.
				 *
				 * @param {any} o
				 * @returns {string}
				 * @example
				 * type(null)      === 'Null'
				 * type(undefined) === 'Undefined'
				 * type(123)       === 'Number'
				 * type('foo')     === 'String'
				 * type(true)      === 'Boolean'
				 * type([1, 2])    === 'Array'
				 * type({})        === 'Object'
				 * type(String)    === 'Function'
				 * type(/abc+/)    === 'RegExp'
				 */
				type: function (o) {
					return Object.prototype.toString.call(o).slice(8, -1);
				},

				/**
				 * Returns a unique number for the given object. Later calls will still return the same number.
				 *
				 * @param {Object} obj
				 * @returns {number}
				 */
				objId: function (obj) {
					if (!obj['__id']) {
						Object.defineProperty(obj, '__id', { value: ++uniqueId });
					}
					return obj['__id'];
				},

				/**
				 * Creates a deep clone of the given object.
				 *
				 * The main intended use of this function is to clone language definitions.
				 *
				 * @param {T} o
				 * @param {Record<number, any>} [visited]
				 * @returns {T}
				 * @template T
				 */
				clone: function deepClone(o, visited) {
					visited = visited || {};

					var clone; var id;
					switch (_.util.type(o)) {
						case 'Object':
							id = _.util.objId(o);
							if (visited[id]) {
								return visited[id];
							}
							clone = /** @type {Record<string, any>} */ ({});
							visited[id] = clone;

							for (var key in o) {
								if (o.hasOwnProperty(key)) {
									clone[key] = deepClone(o[key], visited);
								}
							}

							return /** @type {any} */ (clone);

						case 'Array':
							id = _.util.objId(o);
							if (visited[id]) {
								return visited[id];
							}
							clone = [];
							visited[id] = clone;

							(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
								clone[i] = deepClone(v, visited);
							});

							return /** @type {any} */ (clone);

						default:
							return o;
					}
				},

				/**
				 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
				 *
				 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
				 *
				 * @param {Element} element
				 * @returns {string}
				 */
				getLanguage: function (element) {
					while (element) {
						var m = lang.exec(element.className);
						if (m) {
							return m[1].toLowerCase();
						}
						element = element.parentElement;
					}
					return 'none';
				},

				/**
				 * Sets the Prism `language-xxxx` class of the given element.
				 *
				 * @param {Element} element
				 * @param {string} language
				 * @returns {void}
				 */
				setLanguage: function (element, language) {
					// remove all `language-xxxx` classes
					// (this might leave behind a leading space)
					element.className = element.className.replace(RegExp(lang, 'gi'), '');

					// add the new `language-xxxx` class
					// (using `classList` will automatically clean up spaces for us)
					element.classList.add('language-' + language);
				},

				/**
				 * Returns the script element that is currently executing.
				 *
				 * This does __not__ work for line script element.
				 *
				 * @returns {HTMLScriptElement | null}
				 */
				currentScript: function () {
					if (typeof document === 'undefined') {
						return null;
					}
					if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
						return /** @type {any} */ (document.currentScript);
					}

					// IE11 workaround
					// we'll get the src of the current script by parsing IE11's error stack trace
					// this will not work for inline scripts

					try {
						throw new Error();
					} catch (err) {
						// Get file src url from stack. Specifically works with the format of stack traces in IE.
						// A stack will look like this:
						//
						// Error
						//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
						//    at Global code (http://localhost/components/prism-core.js:606:1)

						var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
						if (src) {
							var scripts = document.getElementsByTagName('script');
							for (var i in scripts) {
								if (scripts[i].src == src) {
									return scripts[i];
								}
							}
						}
						return null;
					}
				},

				/**
				 * Returns whether a given class is active for `element`.
				 *
				 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
				 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
				 * given class is just the given class with a `no-` prefix.
				 *
				 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
				 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
				 * ancestors have the given class or the negated version of it, then the default activation will be returned.
				 *
				 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
				 * version of it, the class is considered active.
				 *
				 * @param {Element} element
				 * @param {string} className
				 * @param {boolean} [defaultActivation=false]
				 * @returns {boolean}
				 */
				isActive: function (element, className, defaultActivation) {
					var no = 'no-' + className;

					while (element) {
						var classList = element.classList;
						if (classList.contains(className)) {
							return true;
						}
						if (classList.contains(no)) {
							return false;
						}
						element = element.parentElement;
					}
					return !!defaultActivation;
				}
			},

			/**
			 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
			 *
			 * @namespace
			 * @memberof Prism
			 * @public
			 */
			languages: {
				/**
				 * The grammar for plain, unformatted text.
				 */
				plain: plainTextGrammar,
				plaintext: plainTextGrammar,
				text: plainTextGrammar,
				txt: plainTextGrammar,

				/**
				 * Creates a deep copy of the language with the given id and appends the given tokens.
				 *
				 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
				 * will be overwritten at its original position.
				 *
				 * ## Best practices
				 *
				 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
				 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
				 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
				 *
				 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
				 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
				 *
				 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
				 * @param {Grammar} redef The new tokens to append.
				 * @returns {Grammar} The new language created.
				 * @public
				 * @example
				 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
				 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
				 *     // at its original position
				 *     'comment': { ... },
				 *     // CSS doesn't have a 'color' token, so this token will be appended
				 *     'color': /\b(?:red|green|blue)\b/
				 * });
				 */
				extend: function (id, redef) {
					var lang = _.util.clone(_.languages[id]);

					for (var key in redef) {
						lang[key] = redef[key];
					}

					return lang;
				},

				/**
				 * Inserts tokens _before_ another token in a language definition or any other grammar.
				 *
				 * ## Usage
				 *
				 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
				 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
				 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
				 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
				 * this:
				 *
				 * ```js
				 * Prism.languages.markup.style = {
				 *     // token
				 * };
				 * ```
				 *
				 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
				 * before existing tokens. For the CSS example above, you would use it like this:
				 *
				 * ```js
				 * Prism.languages.insertBefore('markup', 'cdata', {
				 *     'style': {
				 *         // token
				 *     }
				 * });
				 * ```
				 *
				 * ## Special cases
				 *
				 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
				 * will be ignored.
				 *
				 * This behavior can be used to insert tokens after `before`:
				 *
				 * ```js
				 * Prism.languages.insertBefore('markup', 'comment', {
				 *     'comment': Prism.languages.markup.comment,
				 *     // tokens after 'comment'
				 * });
				 * ```
				 *
				 * ## Limitations
				 *
				 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
				 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
				 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
				 * deleting properties which is necessary to insert at arbitrary positions.
				 *
				 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
				 * Instead, it will create a new object and replace all references to the target object with the new one. This
				 * can be done without temporarily deleting properties, so the iteration order is well-defined.
				 *
				 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
				 * you hold the target object in a variable, then the value of the variable will not change.
				 *
				 * ```js
				 * var oldMarkup = Prism.languages.markup;
				 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
				 *
				 * assert(oldMarkup !== Prism.languages.markup);
				 * assert(newMarkup === Prism.languages.markup);
				 * ```
				 *
				 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
				 * object to be modified.
				 * @param {string} before The key to insert before.
				 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
				 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
				 * object to be modified.
				 *
				 * Defaults to `Prism.languages`.
				 * @returns {Grammar} The new grammar object.
				 * @public
				 */
				insertBefore: function (inside, before, insert, root) {
					root = root || /** @type {any} */ (_.languages);
					var grammar = root[inside];
					/** @type {Grammar} */
					var ret = {};

					for (var token in grammar) {
						if (grammar.hasOwnProperty(token)) {

							if (token == before) {
								for (var newToken in insert) {
									if (insert.hasOwnProperty(newToken)) {
										ret[newToken] = insert[newToken];
									}
								}
							}

							// Do not insert token which also occur in insert. See #1525
							if (!insert.hasOwnProperty(token)) {
								ret[token] = grammar[token];
							}
						}
					}

					var old = root[inside];
					root[inside] = ret;

					// Update references in other language definitions
					_.languages.DFS(_.languages, function (key, value) {
						if (value === old && key != inside) {
							this[key] = ret;
						}
					});

					return ret;
				},

				// Traverse a language definition with Depth First Search
				DFS: function DFS(o, callback, type, visited) {
					visited = visited || {};

					var objId = _.util.objId;

					for (var i in o) {
						if (o.hasOwnProperty(i)) {
							callback.call(o, i, o[i], type || i);

							var property = o[i];
							var propertyType = _.util.type(property);

							if (propertyType === 'Object' && !visited[objId(property)]) {
								visited[objId(property)] = true;
								DFS(property, callback, null, visited);
							} else if (propertyType === 'Array' && !visited[objId(property)]) {
								visited[objId(property)] = true;
								DFS(property, callback, i, visited);
							}
						}
					}
				}
			},

			plugins: {},

			/**
			 * This is the most high-level function in Prism’s API.
			 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
			 * each one of them.
			 *
			 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
			 *
			 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
			 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
			 * @memberof Prism
			 * @public
			 */
			highlightAll: function (async, callback) {
				_.highlightAllUnder(document, async, callback);
			},

			/**
			 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
			 * {@link Prism.highlightElement} on each one of them.
			 *
			 * The following hooks will be run:
			 * 1. `before-highlightall`
			 * 2. `before-all-elements-highlight`
			 * 3. All hooks of {@link Prism.highlightElement} for each element.
			 *
			 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
			 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
			 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
			 * @memberof Prism
			 * @public
			 */
			highlightAllUnder: function (container, async, callback) {
				var env = {
					callback: callback,
					container: container,
					selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
				};

				_.hooks.run('before-highlightall', env);

				env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

				_.hooks.run('before-all-elements-highlight', env);

				for (var i = 0, element; (element = env.elements[i++]);) {
					_.highlightElement(element, async === true, env.callback);
				}
			},

			/**
			 * Highlights the code inside a single element.
			 *
			 * The following hooks will be run:
			 * 1. `before-sanity-check`
			 * 2. `before-highlight`
			 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
			 * 4. `before-insert`
			 * 5. `after-highlight`
			 * 6. `complete`
			 *
			 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
			 * the element's language.
			 *
			 * @param {Element} element The element containing the code.
			 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
			 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
			 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
			 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
			 *
			 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
			 * asynchronous highlighting to work. You can build your own bundle on the
			 * [Download page](https://prismjs.com/download.html).
			 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
			 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
			 * @memberof Prism
			 * @public
			 */
			highlightElement: function (element, async, callback) {
				// Find language
				var language = _.util.getLanguage(element);
				var grammar = _.languages[language];

				// Set language on the element, if not present
				_.util.setLanguage(element, language);

				// Set language on the parent, for styling
				var parent = element.parentElement;
				if (parent && parent.nodeName.toLowerCase() === 'pre') {
					_.util.setLanguage(parent, language);
				}

				var code = element.textContent;

				var env = {
					element: element,
					language: language,
					grammar: grammar,
					code: code
				};

				function insertHighlightedCode(highlightedCode) {
					env.highlightedCode = highlightedCode;

					_.hooks.run('before-insert', env);

					env.element.innerHTML = env.highlightedCode;

					_.hooks.run('after-highlight', env);
					_.hooks.run('complete', env);
					callback && callback.call(env.element);
				}

				_.hooks.run('before-sanity-check', env);

				// plugins may change/add the parent/element
				parent = env.element.parentElement;
				if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
					parent.setAttribute('tabindex', '0');
				}

				if (!env.code) {
					_.hooks.run('complete', env);
					callback && callback.call(env.element);
					return;
				}

				_.hooks.run('before-highlight', env);

				if (!env.grammar) {
					insertHighlightedCode(_.util.encode(env.code));
					return;
				}

				if (async && _self.Worker) {
					var worker = new Worker(_.filename);

					worker.onmessage = function (evt) {
						insertHighlightedCode(evt.data);
					};

					worker.postMessage(JSON.stringify({
						language: env.language,
						code: env.code,
						immediateClose: true
					}));
				} else {
					insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
				}
			},

			/**
			 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
			 * and the language definitions to use, and returns a string with the HTML produced.
			 *
			 * The following hooks will be run:
			 * 1. `before-tokenize`
			 * 2. `after-tokenize`
			 * 3. `wrap`: On each {@link Token}.
			 *
			 * @param {string} text A string with the code to be highlighted.
			 * @param {Grammar} grammar An object containing the tokens to use.
			 *
			 * Usually a language definition like `Prism.languages.markup`.
			 * @param {string} language The name of the language definition passed to `grammar`.
			 * @returns {string} The highlighted HTML.
			 * @memberof Prism
			 * @public
			 * @example
			 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
			 */
			highlight: function (text, grammar, language) {
				var env = {
					code: text,
					grammar: grammar,
					language: language
				};
				_.hooks.run('before-tokenize', env);
				if (!env.grammar) {
					throw new Error('The language "' + env.language + '" has no grammar.');
				}
				env.tokens = _.tokenize(env.code, env.grammar);
				_.hooks.run('after-tokenize', env);
				return Token.stringify(_.util.encode(env.tokens), env.language);
			},

			/**
			 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
			 * and the language definitions to use, and returns an array with the tokenized code.
			 *
			 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
			 *
			 * This method could be useful in other contexts as well, as a very crude parser.
			 *
			 * @param {string} text A string with the code to be highlighted.
			 * @param {Grammar} grammar An object containing the tokens to use.
			 *
			 * Usually a language definition like `Prism.languages.markup`.
			 * @returns {TokenStream} An array of strings and tokens, a token stream.
			 * @memberof Prism
			 * @public
			 * @example
			 * let code = `var foo = 0;`;
			 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
			 * tokens.forEach(token => {
			 *     if (token instanceof Prism.Token && token.type === 'number') {
			 *         console.log(`Found numeric literal: ${token.content}`);
			 *     }
			 * });
			 */
			tokenize: function (text, grammar) {
				var rest = grammar.rest;
				if (rest) {
					for (var token in rest) {
						grammar[token] = rest[token];
					}

					delete grammar.rest;
				}

				var tokenList = new LinkedList();
				addAfter(tokenList, tokenList.head, text);

				matchGrammar(text, tokenList, grammar, tokenList.head, 0);

				return toArray(tokenList);
			},

			/**
			 * @namespace
			 * @memberof Prism
			 * @public
			 */
			hooks: {
				all: {},

				/**
				 * Adds the given callback to the list of callbacks for the given hook.
				 *
				 * The callback will be invoked when the hook it is registered for is run.
				 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
				 *
				 * One callback function can be registered to multiple hooks and the same hook multiple times.
				 *
				 * @param {string} name The name of the hook.
				 * @param {HookCallback} callback The callback function which is given environment variables.
				 * @public
				 */
				add: function (name, callback) {
					var hooks = _.hooks.all;

					hooks[name] = hooks[name] || [];

					hooks[name].push(callback);
				},

				/**
				 * Runs a hook invoking all registered callbacks with the given environment variables.
				 *
				 * Callbacks will be invoked synchronously and in the order in which they were registered.
				 *
				 * @param {string} name The name of the hook.
				 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
				 * @public
				 */
				run: function (name, env) {
					var callbacks = _.hooks.all[name];

					if (!callbacks || !callbacks.length) {
						return;
					}

					for (var i = 0, callback; (callback = callbacks[i++]);) {
						callback(env);
					}
				}
			},

			Token: Token
		};
		_self.Prism = _;


		// Typescript note:
		// The following can be used to import the Token type in JSDoc:
		//
		//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

		/**
		 * Creates a new token.
		 *
		 * @param {string} type See {@link Token#type type}
		 * @param {string | TokenStream} content See {@link Token#content content}
		 * @param {string|string[]} [alias] The alias(es) of the token.
		 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
		 * @class
		 * @global
		 * @public
		 */
		function Token(type, content, alias, matchedStr) {
			/**
			 * The type of the token.
			 *
			 * This is usually the key of a pattern in a {@link Grammar}.
			 *
			 * @type {string}
			 * @see GrammarToken
			 * @public
			 */
			this.type = type;
			/**
			 * The strings or tokens contained by this token.
			 *
			 * This will be a token stream if the pattern matched also defined an `inside` grammar.
			 *
			 * @type {string | TokenStream}
			 * @public
			 */
			this.content = content;
			/**
			 * The alias(es) of the token.
			 *
			 * @type {string|string[]}
			 * @see GrammarToken
			 * @public
			 */
			this.alias = alias;
			// Copy of the full string this token was created from
			this.length = (matchedStr || '').length | 0;
		}

		/**
		 * A token stream is an array of strings and {@link Token Token} objects.
		 *
		 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
		 * them.
		 *
		 * 1. No adjacent strings.
		 * 2. No empty strings.
		 *
		 *    The only exception here is the token stream that only contains the empty string and nothing else.
		 *
		 * @typedef {Array<string | Token>} TokenStream
		 * @global
		 * @public
		 */

		/**
		 * Converts the given token or token stream to an HTML representation.
		 *
		 * The following hooks will be run:
		 * 1. `wrap`: On each {@link Token}.
		 *
		 * @param {string | Token | TokenStream} o The token or token stream to be converted.
		 * @param {string} language The name of current language.
		 * @returns {string} The HTML representation of the token or token stream.
		 * @memberof Token
		 * @static
		 */
		Token.stringify = function stringify(o, language) {
			if (typeof o == 'string') {
				return o;
			}
			if (Array.isArray(o)) {
				var s = '';
				o.forEach(function (e) {
					s += stringify(e, language);
				});
				return s;
			}

			var env = {
				type: o.type,
				content: stringify(o.content, language),
				tag: 'span',
				classes: ['token', o.type],
				attributes: {},
				language: language
			};

			var aliases = o.alias;
			if (aliases) {
				if (Array.isArray(aliases)) {
					Array.prototype.push.apply(env.classes, aliases);
				} else {
					env.classes.push(aliases);
				}
			}

			_.hooks.run('wrap', env);

			var attributes = '';
			for (var name in env.attributes) {
				attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
			}

			return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
		};

		/**
		 * @param {RegExp} pattern
		 * @param {number} pos
		 * @param {string} text
		 * @param {boolean} lookbehind
		 * @returns {RegExpExecArray | null}
		 */
		function matchPattern(pattern, pos, text, lookbehind) {
			pattern.lastIndex = pos;
			var match = pattern.exec(text);
			if (match && lookbehind && match[1]) {
				// change the match to remove the text matched by the Prism lookbehind group
				var lookbehindLength = match[1].length;
				match.index += lookbehindLength;
				match[0] = match[0].slice(lookbehindLength);
			}
			return match;
		}

		/**
		 * @param {string} text
		 * @param {LinkedList<string | Token>} tokenList
		 * @param {any} grammar
		 * @param {LinkedListNode<string | Token>} startNode
		 * @param {number} startPos
		 * @param {RematchOptions} [rematch]
		 * @returns {void}
		 * @private
		 *
		 * @typedef RematchOptions
		 * @property {string} cause
		 * @property {number} reach
		 */
		function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
			for (var token in grammar) {
				if (!grammar.hasOwnProperty(token) || !grammar[token]) {
					continue;
				}

				var patterns = grammar[token];
				patterns = Array.isArray(patterns) ? patterns : [patterns];

				for (var j = 0; j < patterns.length; ++j) {
					if (rematch && rematch.cause == token + ',' + j) {
						return;
					}

					var patternObj = patterns[j];
					var inside = patternObj.inside;
					var lookbehind = !!patternObj.lookbehind;
					var greedy = !!patternObj.greedy;
					var alias = patternObj.alias;

					if (greedy && !patternObj.pattern.global) {
						// Without the global flag, lastIndex won't work
						var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
						patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
					}

					/** @type {RegExp} */
					var pattern = patternObj.pattern || patternObj;

					for ( // iterate the token list and keep track of the current token/string position
						var currentNode = startNode.next, pos = startPos;
						currentNode !== tokenList.tail;
						pos += currentNode.value.length, currentNode = currentNode.next
					) {

						if (rematch && pos >= rematch.reach) {
							break;
						}

						var str = currentNode.value;

						if (tokenList.length > text.length) {
							// Something went terribly wrong, ABORT, ABORT!
							return;
						}

						if (str instanceof Token) {
							continue;
						}

						var removeCount = 1; // this is the to parameter of removeBetween
						var match;

						if (greedy) {
							match = matchPattern(pattern, pos, text, lookbehind);
							if (!match || match.index >= text.length) {
								break;
							}

							var from = match.index;
							var to = match.index + match[0].length;
							var p = pos;

							// find the node that contains the match
							p += currentNode.value.length;
							while (from >= p) {
								currentNode = currentNode.next;
								p += currentNode.value.length;
							}
							// adjust pos (and p)
							p -= currentNode.value.length;
							pos = p;

							// the current node is a Token, then the match starts inside another Token, which is invalid
							if (currentNode.value instanceof Token) {
								continue;
							}

							// find the last node which is affected by this match
							for (
								var k = currentNode;
								k !== tokenList.tail && (p < to || typeof k.value === 'string');
								k = k.next
							) {
								removeCount++;
								p += k.value.length;
							}
							removeCount--;

							// replace with the new match
							str = text.slice(pos, p);
							match.index -= pos;
						} else {
							match = matchPattern(pattern, 0, str, lookbehind);
							if (!match) {
								continue;
							}
						}

						// eslint-disable-next-line no-redeclare
						var from = match.index;
						var matchStr = match[0];
						var before = str.slice(0, from);
						var after = str.slice(from + matchStr.length);

						var reach = pos + str.length;
						if (rematch && reach > rematch.reach) {
							rematch.reach = reach;
						}

						var removeFrom = currentNode.prev;

						if (before) {
							removeFrom = addAfter(tokenList, removeFrom, before);
							pos += before.length;
						}

						removeRange(tokenList, removeFrom, removeCount);

						var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
						currentNode = addAfter(tokenList, removeFrom, wrapped);

						if (after) {
							addAfter(tokenList, currentNode, after);
						}

						if (removeCount > 1) {
							// at least one Token object was removed, so we have to do some rematching
							// this can only happen if the current pattern is greedy

							/** @type {RematchOptions} */
							var nestedRematch = {
								cause: token + ',' + j,
								reach: reach
							};
							matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

							// the reach might have been extended because of the rematching
							if (rematch && nestedRematch.reach > rematch.reach) {
								rematch.reach = nestedRematch.reach;
							}
						}
					}
				}
			}
		}

		/**
		 * @typedef LinkedListNode
		 * @property {T} value
		 * @property {LinkedListNode<T> | null} prev The previous node.
		 * @property {LinkedListNode<T> | null} next The next node.
		 * @template T
		 * @private
		 */

		/**
		 * @template T
		 * @private
		 */
		function LinkedList() {
			/** @type {LinkedListNode<T>} */
			var head = { value: null, prev: null, next: null };
			/** @type {LinkedListNode<T>} */
			var tail = { value: null, prev: head, next: null };
			head.next = tail;

			/** @type {LinkedListNode<T>} */
			this.head = head;
			/** @type {LinkedListNode<T>} */
			this.tail = tail;
			this.length = 0;
		}

		/**
		 * Adds a new node with the given value to the list.
		 *
		 * @param {LinkedList<T>} list
		 * @param {LinkedListNode<T>} node
		 * @param {T} value
		 * @returns {LinkedListNode<T>} The added node.
		 * @template T
		 */
		function addAfter(list, node, value) {
			// assumes that node != list.tail && values.length >= 0
			var next = node.next;

			var newNode = { value: value, prev: node, next: next };
			node.next = newNode;
			next.prev = newNode;
			list.length++;

			return newNode;
		}
		/**
		 * Removes `count` nodes after the given node. The given node will not be removed.
		 *
		 * @param {LinkedList<T>} list
		 * @param {LinkedListNode<T>} node
		 * @param {number} count
		 * @template T
		 */
		function removeRange(list, node, count) {
			var next = node.next;
			for (var i = 0; i < count && next !== list.tail; i++) {
				next = next.next;
			}
			node.next = next;
			next.prev = node;
			list.length -= i;
		}
		/**
		 * @param {LinkedList<T>} list
		 * @returns {T[]}
		 * @template T
		 */
		function toArray(list) {
			var array = [];
			var node = list.head.next;
			while (node !== list.tail) {
				array.push(node.value);
				node = node.next;
			}
			return array;
		}


		if (!_self.document) {
			if (!_self.addEventListener) {
				// in Node.js
				return _;
			}

			if (!_.disableWorkerMessageHandler) {
				// In worker
				_self.addEventListener('message', function (evt) {
					var message = JSON.parse(evt.data);
					var lang = message.language;
					var code = message.code;
					var immediateClose = message.immediateClose;

					_self.postMessage(_.highlight(code, _.languages[lang], lang));
					if (immediateClose) {
						_self.close();
					}
				}, false);
			}

			return _;
		}

		// Get current script and highlight
		var script = _.util.currentScript();

		if (script) {
			_.filename = script.src;

			if (script.hasAttribute('data-manual')) {
				_.manual = true;
			}
		}

		function highlightAutomaticallyCallback() {
			if (!_.manual) {
				_.highlightAll();
			}
		}

		if (!_.manual) {
			// If the document state is "loading", then we'll use DOMContentLoaded.
			// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
			// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
			// might take longer one animation frame to execute which can create a race condition where only some plugins have
			// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
			// See https://github.com/PrismJS/prism/issues/2102
			var readyState = document.readyState;
			if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
				document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
			} else {
				if (window.requestAnimationFrame) {
					window.requestAnimationFrame(highlightAutomaticallyCallback);
				} else {
					window.setTimeout(highlightAutomaticallyCallback, 16);
				}
			}
		}

		return _;

	}(_self));

	if (module.exports) {
		module.exports = Prism;
	}

	// hack for components to work correctly in node.js
	if (typeof commonjsGlobal !== 'undefined') {
		commonjsGlobal.Prism = Prism;
	}

	// some additional documentation/types

	/**
	 * The expansion of a simple `RegExp` literal to support additional properties.
	 *
	 * @typedef GrammarToken
	 * @property {RegExp} pattern The regular expression of the token.
	 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
	 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
	 * @property {boolean} [greedy=false] Whether the token is greedy.
	 * @property {string|string[]} [alias] An optional alias or list of aliases.
	 * @property {Grammar} [inside] The nested grammar of this token.
	 *
	 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
	 *
	 * This can be used to make nested and even recursive language definitions.
	 *
	 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
	 * each another.
	 * @global
	 * @public
	 */

	/**
	 * @typedef Grammar
	 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
	 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
	 * @global
	 * @public
	 */

	/**
	 * A function which will invoked after an element was successfully highlighted.
	 *
	 * @callback HighlightCallback
	 * @param {Element} element The element successfully highlighted.
	 * @returns {void}
	 * @global
	 * @public
	 */

	/**
	 * @callback HookCallback
	 * @param {Object<string, any>} env The environment variables of the hook.
	 * @returns {void}
	 * @global
	 * @public
	 */
} (prismCore));

var markup_1 = markup$1;
markup$1.displayName = 'markup';
markup$1.aliases = ['html', 'mathml', 'svg', 'xml', 'ssml', 'atom', 'rss'];
function markup$1(Prism) {
  Prism.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: true
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: true
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern:
        /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: true,
      inside: {
        'internal-subset': {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: true,
          greedy: true,
          inside: null // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        punctuation: /^<!|>$|[[\]]/,
        'doctype-tag': /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: true
    },
    tag: {
      pattern:
        /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: true,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        'special-attr': [],
        'attr-value': {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: 'attr-equals'
              },
              /"|'/
            ]
          }
        },
        punctuation: /\/?>/,
        'attr-name': {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: 'named-entity'
      },
      /&#x?[\da-f]{1,8};/i
    ]
  };
  Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
    Prism.languages.markup['entity'];
  Prism.languages.markup['doctype'].inside['internal-subset'].inside =
    Prism.languages.markup; // Plugin to make entity title show the real entity, idea by Roman Komarov
  Prism.hooks.add('wrap', function (env) {
    if (env.type === 'entity') {
      env.attributes['title'] = env.content.value.replace(/&amp;/, '&');
    }
  });
  Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function addInlined(tagName, lang) {
      var includedCdataInside = {};
      includedCdataInside['language-' + lang] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: true,
        inside: Prism.languages[lang]
      };
      includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;
      var inside = {
        'included-cdata': {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: includedCdataInside
        }
      };
      inside['language-' + lang] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[lang]
      };
      var def = {};
      def[tagName] = {
        pattern: RegExp(
          /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
            /__/g,
            function () {
              return tagName
            }
          ),
          'i'
        ),
        lookbehind: true,
        greedy: true,
        inside: inside
      };
      Prism.languages.insertBefore('markup', 'cdata', def);
    }
  });
  Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function (attrName, lang) {
      Prism.languages.markup.tag.inside['special-attr'].push({
        pattern: RegExp(
          /(^|["'\s])/.source +
            '(?:' +
            attrName +
            ')' +
            /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          'i'
        ),
        lookbehind: true,
        inside: {
          'attr-name': /^[^\s=]+/,
          'attr-value': {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: true,
                alias: [lang, 'language-' + lang],
                inside: Prism.languages[lang]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: 'attr-equals'
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  });
  Prism.languages.html = Prism.languages.markup;
  Prism.languages.mathml = Prism.languages.markup;
  Prism.languages.svg = Prism.languages.markup;
  Prism.languages.xml = Prism.languages.extend('markup', {});
  Prism.languages.ssml = Prism.languages.xml;
  Prism.languages.atom = Prism.languages.xml;
  Prism.languages.rss = Prism.languages.xml;
}

var css_1 = css$X;
css$X.displayName = 'css';
css$X.aliases = [];
function css$X(Prism) {
(function (Prism) {
    var string =
      /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
        inside: {
          rule: /^@[\w-]+/,
          'selector-function-argument': {
            pattern:
              /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: true,
            alias: 'selector'
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: true
          } // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp(
          '\\burl\\((?:' +
            string.source +
            '|' +
            /(?:[^\\\r\n()"']|\\[\s\S])*/.source +
            ')\\)',
          'i'
        ),
        greedy: true,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp('^' + string.source + '$'),
            alias: 'url'
          }
        }
      },
      selector: {
        pattern: RegExp(
          '(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' +
            string.source +
            ')*(?=\\s*\\{)'
        ),
        lookbehind: true
      },
      string: {
        pattern: string,
        greedy: true
      },
      property: {
        pattern:
          /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: true
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: true
      },
      punctuation: /[(){};:,]/
    };
    Prism.languages.css['atrule'].inside.rest = Prism.languages.css;
    var markup = Prism.languages.markup;
    if (markup) {
      markup.tag.addInlined('style', 'css');
      markup.tag.addAttribute('style', 'css');
    }
  })(Prism);
}

var clike_1 = clike$1;
clike$1.displayName = 'clike';
clike$1.aliases = [];
function clike$1(Prism) {
  Prism.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    'class-name': {
      pattern:
        /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: true,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword:
      /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  };
}

var javascript_1 = javascript;
javascript.displayName = 'javascript';
javascript.aliases = ['js'];
function javascript(Prism) {
  Prism.languages.javascript = Prism.languages.extend('clike', {
    'class-name': [
      Prism.languages.clike['class-name'],
      {
        pattern:
          /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: true
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: true
      },
      {
        pattern:
          /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function:
      /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source +
          '(?:' + // constant
          (/NaN|Infinity/.source +
            '|' + // binary integer
            /0[bB][01]+(?:_[01]+)*n?/.source +
            '|' + // octal integer
            /0[oO][0-7]+(?:_[0-7]+)*n?/.source +
            '|' + // hexadecimal integer
            /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
            '|' + // decimal bigint
            /\d+(?:_\d+)*n/.source +
            '|' + // decimal number (integer or float) but no bigint
            /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/
              .source) +
          ')' +
          /(?![\w$])/.source
      ),
      lookbehind: true
    },
    operator:
      /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  });
  Prism.languages.javascript['class-name'][0].pattern =
    /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
  Prism.languages.insertBefore('javascript', 'keyword', {
    regex: {
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      pattern:
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
      lookbehind: true,
      greedy: true,
      inside: {
        'regex-source': {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: true,
          alias: 'language-regex',
          inside: Prism.languages.regex
        },
        'regex-delimiter': /^\/|\/$/,
        'regex-flags': /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    'function-variable': {
      pattern:
        /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: 'function'
    },
    parameter: [
      {
        pattern:
          /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern:
          /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern:
          /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern:
          /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: true,
        inside: Prism.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  });
  Prism.languages.insertBefore('javascript', 'string', {
    hashbang: {
      pattern: /^#!.*/,
      greedy: true,
      alias: 'comment'
    },
    'template-string': {
      pattern:
        /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: true,
      inside: {
        'template-punctuation': {
          pattern: /^`|`$/,
          alias: 'string'
        },
        interpolation: {
          pattern:
            /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: true,
          inside: {
            'interpolation-punctuation': {
              pattern: /^\$\{|\}$/,
              alias: 'punctuation'
            },
            rest: Prism.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    'string-property': {
      pattern:
        /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: true,
      greedy: true,
      alias: 'property'
    }
  });
  Prism.languages.insertBefore('javascript', 'operator', {
    'literal-property': {
      pattern:
        /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: true,
      alias: 'property'
    }
  });
  if (Prism.languages.markup) {
    Prism.languages.markup.tag.addInlined('script', 'javascript'); // add attribute support for all DOM events.
    // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
    Prism.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/
        .source,
      'javascript'
    );
  }
  Prism.languages.js = Prism.languages.javascript;
}

/* global window, self */

// istanbul ignore next - Don't allow Prism to run on page load in browser or
// to start messaging from workers.
var ctx =
  typeof globalThis === 'object'
    ? globalThis
    : typeof self === 'object'
    ? self
    : typeof window === 'object'
    ? window
    : typeof commonjsGlobal === 'object'
    ? commonjsGlobal
    : {};

var restore = capture();

ctx.Prism = {manual: true, disableWorkerMessageHandler: true};

// Load all stuff in `prism.js` itself, except for `prism-file-highlight.js`.
// The wrapped non-leaky grammars are loaded instead of Prism’s originals.
var h = hastscript.exports;
var decode$1 = parseEntities_1;
var Prism = prismCore.exports;
var markup = markup_1;
var css$W = css_1;
var clike = clike_1;
var js = javascript_1;

restore();

var own = {}.hasOwnProperty;

// Inherit.
function Refractor() {}

Refractor.prototype = Prism;

// Construct.
var refract = new Refractor();

// Expose.
var core$1 = refract;

// Create.
refract.highlight = highlight;
refract.register = register$1;
refract.alias = alias;
refract.registered = registered;
refract.listLanguages = listLanguages;

// Register bundled grammars.
register$1(markup);
register$1(css$W);
register$1(clike);
register$1(js);

refract.util.encode = encode;
refract.Token.stringify = stringify$1;

function register$1(grammar) {
  if (typeof grammar !== 'function' || !grammar.displayName) {
    throw new Error('Expected `function` for `grammar`, got `' + grammar + '`')
  }

  // Do not duplicate registrations.
  if (refract.languages[grammar.displayName] === undefined) {
    grammar(refract);
  }
}

function alias(name, alias) {
  var languages = refract.languages;
  var map = name;
  var key;
  var list;
  var length;
  var index;

  if (alias) {
    map = {};
    map[name] = alias;
  }

  for (key in map) {
    list = map[key];
    list = typeof list === 'string' ? [list] : list;
    length = list.length;
    index = -1;

    while (++index < length) {
      languages[list[index]] = languages[key];
    }
  }
}

function highlight(value, name) {
  var sup = Prism.highlight;
  var grammar;

  if (typeof value !== 'string') {
    throw new Error('Expected `string` for `value`, got `' + value + '`')
  }

  // `name` is a grammar object.
  if (refract.util.type(name) === 'Object') {
    grammar = name;
    name = null;
  } else {
    if (typeof name !== 'string') {
      throw new Error('Expected `string` for `name`, got `' + name + '`')
    }

    if (own.call(refract.languages, name)) {
      grammar = refract.languages[name];
    } else {
      throw new Error('Unknown language: `' + name + '` is not registered')
    }
  }

  return sup.call(this, value, grammar, name)
}

function registered(language) {
  if (typeof language !== 'string') {
    throw new Error('Expected `string` for `language`, got `' + language + '`')
  }

  return own.call(refract.languages, language)
}

function listLanguages() {
  var languages = refract.languages;
  var list = [];
  var language;

  for (language in languages) {
    if (
      own.call(languages, language) &&
      typeof languages[language] === 'object'
    ) {
      list.push(language);
    }
  }

  return list
}

function stringify$1(value, language, parent) {
  var env;

  if (typeof value === 'string') {
    return {type: 'text', value: value}
  }

  if (refract.util.type(value) === 'Array') {
    return stringifyAll(value, language)
  }

  env = {
    type: value.type,
    content: refract.Token.stringify(value.content, language, parent),
    tag: 'span',
    classes: ['token', value.type],
    attributes: {},
    language: language,
    parent: parent
  };

  if (value.alias) {
    env.classes = env.classes.concat(value.alias);
  }

  refract.hooks.run('wrap', env);

  return h(
    env.tag + '.' + env.classes.join('.'),
    attributes(env.attributes),
    env.content
  )
}

function stringifyAll(values, language) {
  var result = [];
  var length = values.length;
  var index = -1;
  var value;

  while (++index < length) {
    value = values[index];

    if (value !== '' && value !== null && value !== undefined) {
      result.push(value);
    }
  }

  index = -1;
  length = result.length;

  while (++index < length) {
    value = result[index];
    result[index] = refract.Token.stringify(value, language, result);
  }

  return result
}

function encode(tokens) {
  return tokens
}

function attributes(attrs) {
  var key;

  for (key in attrs) {
    attrs[key] = decode$1(attrs[key]);
  }

  return attrs
}

function capture() {
  var defined = 'Prism' in ctx;
  /* istanbul ignore next */
  var current = defined ? ctx.Prism : undefined;

  return restore

  function restore() {
    /* istanbul ignore else - Clean leaks after Prism. */
    if (defined) {
      ctx.Prism = current;
    } else {
      delete ctx.Prism;
    }

    defined = undefined;
    current = undefined;
  }
}

var defaultStyle = {
  "code[class*=\"language-\"]": {
    "color": "black",
    "background": "none",
    "textShadow": "0 1px white",
    "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    "fontSize": "1em",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "wordWrap": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "4",
    "OTabSize": "4",
    "tabSize": "4",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none"
  },
  "pre[class*=\"language-\"]": {
    "color": "black",
    "background": "#f5f2f0",
    "textShadow": "0 1px white",
    "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    "fontSize": "1em",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "wordWrap": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "4",
    "OTabSize": "4",
    "tabSize": "4",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none",
    "padding": "1em",
    "margin": ".5em 0",
    "overflow": "auto"
  },
  "pre[class*=\"language-\"]::-moz-selection": {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  "pre[class*=\"language-\"] ::-moz-selection": {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  "code[class*=\"language-\"]::-moz-selection": {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  "code[class*=\"language-\"] ::-moz-selection": {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  "pre[class*=\"language-\"]::selection": {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  "pre[class*=\"language-\"] ::selection": {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  "code[class*=\"language-\"]::selection": {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  "code[class*=\"language-\"] ::selection": {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  ":not(pre) > code[class*=\"language-\"]": {
    "background": "#f5f2f0",
    "padding": ".1em",
    "borderRadius": ".3em",
    "whiteSpace": "normal"
  },
  "comment": {
    "color": "slategray"
  },
  "prolog": {
    "color": "slategray"
  },
  "doctype": {
    "color": "slategray"
  },
  "cdata": {
    "color": "slategray"
  },
  "punctuation": {
    "color": "#999"
  },
  "namespace": {
    "Opacity": ".7"
  },
  "property": {
    "color": "#905"
  },
  "tag": {
    "color": "#905"
  },
  "boolean": {
    "color": "#905"
  },
  "number": {
    "color": "#905"
  },
  "constant": {
    "color": "#905"
  },
  "symbol": {
    "color": "#905"
  },
  "deleted": {
    "color": "#905"
  },
  "selector": {
    "color": "#690"
  },
  "attr-name": {
    "color": "#690"
  },
  "string": {
    "color": "#690"
  },
  "char": {
    "color": "#690"
  },
  "builtin": {
    "color": "#690"
  },
  "inserted": {
    "color": "#690"
  },
  "operator": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  "entity": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)",
    "cursor": "help"
  },
  "url": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  ".language-css .token.string": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  ".style .token.string": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  "atrule": {
    "color": "#07a"
  },
  "attr-value": {
    "color": "#07a"
  },
  "keyword": {
    "color": "#07a"
  },
  "function": {
    "color": "#DD4A68"
  },
  "class-name": {
    "color": "#DD4A68"
  },
  "regex": {
    "color": "#e90"
  },
  "important": {
    "color": "#e90",
    "fontWeight": "bold"
  },
  "variable": {
    "color": "#e90"
  },
  "bold": {
    "fontWeight": "bold"
  },
  "italic": {
    "fontStyle": "italic"
  }
};

var abap_1 = abap;
abap.displayName = 'abap';
abap.aliases = [];
function abap(Prism) {
  Prism.languages.abap = {
    comment: /^\*.*/m,
    string: /(`|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
    'string-template': {
      pattern: /([|}])(?:\\.|[^\\|{\r\n])*(?=[|{])/,
      lookbehind: true,
      alias: 'string'
    },
    /* End Of Line comments should not interfere with strings when the
quote character occurs within them. We assume a string being highlighted
inside an EOL comment is more acceptable than the opposite.
*/
    'eol-comment': {
      pattern: /(^|\s)".*/m,
      lookbehind: true,
      alias: 'comment'
    },
    keyword: {
      pattern:
        /(\s|\.|^)(?:SCIENTIFIC_WITH_LEADING_ZERO|SCALE_PRESERVING_SCIENTIFIC|RMC_COMMUNICATION_FAILURE|END-ENHANCEMENT-SECTION|MULTIPLY-CORRESPONDING|SUBTRACT-CORRESPONDING|VERIFICATION-MESSAGE|DIVIDE-CORRESPONDING|ENHANCEMENT-SECTION|CURRENCY_CONVERSION|RMC_SYSTEM_FAILURE|START-OF-SELECTION|MOVE-CORRESPONDING|RMC_INVALID_STATUS|CUSTOMER-FUNCTION|END-OF-DEFINITION|ENHANCEMENT-POINT|SYSTEM-EXCEPTIONS|ADD-CORRESPONDING|SCALE_PRESERVING|SELECTION-SCREEN|CURSOR-SELECTION|END-OF-SELECTION|LOAD-OF-PROGRAM|SCROLL-BOUNDARY|SELECTION-TABLE|EXCEPTION-TABLE|IMPLEMENTATIONS|PARAMETER-TABLE|RIGHT-JUSTIFIED|UNIT_CONVERSION|AUTHORITY-CHECK|LIST-PROCESSING|SIGN_AS_POSTFIX|COL_BACKGROUND|IMPLEMENTATION|INTERFACE-POOL|TRANSFORMATION|IDENTIFICATION|ENDENHANCEMENT|LINE-SELECTION|INITIALIZATION|LEFT-JUSTIFIED|SELECT-OPTIONS|SELECTION-SETS|COMMUNICATION|CORRESPONDING|DECIMAL_SHIFT|PRINT-CONTROL|VALUE-REQUEST|CHAIN-REQUEST|FUNCTION-POOL|FIELD-SYMBOLS|FUNCTIONALITY|INVERTED-DATE|SELECTION-SET|CLASS-METHODS|OUTPUT-LENGTH|CLASS-CODING|COL_NEGATIVE|ERRORMESSAGE|FIELD-GROUPS|HELP-REQUEST|NO-EXTENSION|NO-TOPOFPAGE|REDEFINITION|DISPLAY-MODE|ENDINTERFACE|EXIT-COMMAND|FIELD-SYMBOL|NO-SCROLLING|SHORTDUMP-ID|ACCESSPOLICY|CLASS-EVENTS|COL_POSITIVE|DECLARATIONS|ENHANCEMENTS|FILTER-TABLE|SWITCHSTATES|SYNTAX-CHECK|TRANSPORTING|ASYNCHRONOUS|SYNTAX-TRACE|TOKENIZATION|USER-COMMAND|WITH-HEADING|ABAP-SOURCE|BREAK-POINT|CHAIN-INPUT|COMPRESSION|FIXED-POINT|NEW-SECTION|NON-UNICODE|OCCURRENCES|RESPONSIBLE|SYSTEM-CALL|TRACE-TABLE|ABBREVIATED|CHAR-TO-HEX|END-OF-FILE|ENDFUNCTION|ENVIRONMENT|ASSOCIATION|COL_HEADING|EDITOR-CALL|END-OF-PAGE|ENGINEERING|IMPLEMENTED|INTENSIFIED|RADIOBUTTON|SYSTEM-EXIT|TOP-OF-PAGE|TRANSACTION|APPLICATION|CONCATENATE|DESTINATION|ENHANCEMENT|IMMEDIATELY|NO-GROUPING|PRECOMPILED|REPLACEMENT|TITLE-LINES|ACTIVATION|BYTE-ORDER|CLASS-POOL|CONNECTION|CONVERSION|DEFINITION|DEPARTMENT|EXPIRATION|INHERITING|MESSAGE-ID|NO-HEADING|PERFORMING|QUEUE-ONLY|RIGHTSPACE|SCIENTIFIC|STATUSINFO|STRUCTURES|SYNCPOINTS|WITH-TITLE|ATTRIBUTES|BOUNDARIES|CLASS-DATA|COL_NORMAL|DD\/MM\/YYYY|DESCENDING|INTERFACES|LINE-COUNT|MM\/DD\/YYYY|NON-UNIQUE|PRESERVING|SELECTIONS|STATEMENTS|SUBROUTINE|TRUNCATION|TYPE-POOLS|ARITHMETIC|BACKGROUND|ENDPROVIDE|EXCEPTIONS|IDENTIFIER|INDEX-LINE|OBLIGATORY|PARAMETERS|PERCENTAGE|PUSHBUTTON|RESOLUTION|COMPONENTS|DEALLOCATE|DISCONNECT|DUPLICATES|FIRST-LINE|HEAD-LINES|NO-DISPLAY|OCCURRENCE|RESPECTING|RETURNCODE|SUBMATCHES|TRACE-FILE|ASCENDING|BYPASSING|ENDMODULE|EXCEPTION|EXCLUDING|EXPORTING|INCREMENT|MATCHCODE|PARAMETER|PARTIALLY|PREFERRED|REFERENCE|REPLACING|RETURNING|SELECTION|SEPARATED|SPECIFIED|STATEMENT|TIMESTAMP|TYPE-POOL|ACCEPTING|APPENDAGE|ASSIGNING|COL_GROUP|COMPARING|CONSTANTS|DANGEROUS|IMPORTING|INSTANCES|LEFTSPACE|LOG-POINT|QUICKINFO|READ-ONLY|SCROLLING|SQLSCRIPT|STEP-LOOP|TOP-LINES|TRANSLATE|APPENDING|AUTHORITY|CHARACTER|COMPONENT|CONDITION|DIRECTORY|DUPLICATE|MESSAGING|RECEIVING|SUBSCREEN|ACCORDING|COL_TOTAL|END-LINES|ENDMETHOD|ENDSELECT|EXPANDING|EXTENSION|INCLUDING|INFOTYPES|INTERFACE|INTERVALS|LINE-SIZE|PF-STATUS|PROCEDURE|PROTECTED|REQUESTED|RESUMABLE|RIGHTPLUS|SAP-SPOOL|SECONDARY|STRUCTURE|SUBSTRING|TABLEVIEW|NUMOFCHAR|ADJACENT|ANALYSIS|ASSIGNED|BACKWARD|CHANNELS|CHECKBOX|CONTINUE|CRITICAL|DATAINFO|DD\/MM\/YY|DURATION|ENCODING|ENDCLASS|FUNCTION|LEFTPLUS|LINEFEED|MM\/DD\/YY|OVERFLOW|RECEIVED|SKIPPING|SORTABLE|STANDARD|SUBTRACT|SUPPRESS|TABSTRIP|TITLEBAR|TRUNCATE|UNASSIGN|WHENEVER|ANALYZER|COALESCE|COMMENTS|CONDENSE|DECIMALS|DEFERRED|ENDWHILE|EXPLICIT|KEYWORDS|MESSAGES|POSITION|PRIORITY|RECEIVER|RENAMING|TIMEZONE|TRAILING|ALLOCATE|CENTERED|CIRCULAR|CONTROLS|CURRENCY|DELETING|DESCRIBE|DISTANCE|ENDCATCH|EXPONENT|EXTENDED|GENERATE|IGNORING|INCLUDES|INTERNAL|MAJOR-ID|MODIFIER|NEW-LINE|OPTIONAL|PROPERTY|ROLLBACK|STARTING|SUPPLIED|ABSTRACT|CHANGING|CONTEXTS|CREATING|CUSTOMER|DATABASE|DAYLIGHT|DEFINING|DISTINCT|DIVISION|ENABLING|ENDCHAIN|ESCAPING|HARMLESS|IMPLICIT|INACTIVE|LANGUAGE|MINOR-ID|MULTIPLY|NEW-PAGE|NO-TITLE|POS_HIGH|SEPARATE|TEXTPOOL|TRANSFER|SELECTOR|DBMAXLEN|ITERATOR|ARCHIVE|BIT-XOR|BYTE-CO|COLLECT|COMMENT|CURRENT|DEFAULT|DISPLAY|ENDFORM|EXTRACT|LEADING|LISTBOX|LOCATOR|MEMBERS|METHODS|NESTING|POS_LOW|PROCESS|PROVIDE|RAISING|RESERVE|SECONDS|SUMMARY|VISIBLE|BETWEEN|BIT-AND|BYTE-CS|CLEANUP|COMPUTE|CONTROL|CONVERT|DATASET|ENDCASE|FORWARD|HEADERS|HOTSPOT|INCLUDE|INVERSE|KEEPING|NO-ZERO|OBJECTS|OVERLAY|PADDING|PATTERN|PROGRAM|REFRESH|SECTION|SUMMING|TESTING|VERSION|WINDOWS|WITHOUT|BIT-NOT|BYTE-CA|BYTE-NA|CASTING|CONTEXT|COUNTRY|DYNAMIC|ENABLED|ENDLOOP|EXECUTE|FRIENDS|HANDLER|HEADING|INITIAL|\*-INPUT|LOGFILE|MAXIMUM|MINIMUM|NO-GAPS|NO-SIGN|PRAGMAS|PRIMARY|PRIVATE|REDUCED|REPLACE|REQUEST|RESULTS|UNICODE|WARNING|ALIASES|BYTE-CN|BYTE-NS|CALLING|COL_KEY|COLUMNS|CONNECT|ENDEXEC|ENTRIES|EXCLUDE|FILTERS|FURTHER|HELP-ID|LOGICAL|MAPPING|MESSAGE|NAMETAB|OPTIONS|PACKAGE|PERFORM|RECEIVE|STATICS|VARYING|BINDING|CHARLEN|GREATER|XSTRLEN|ACCEPT|APPEND|DETAIL|ELSEIF|ENDING|ENDTRY|FORMAT|FRAMES|GIVING|HASHED|HEADER|IMPORT|INSERT|MARGIN|MODULE|NATIVE|OBJECT|OFFSET|REMOTE|RESUME|SAVING|SIMPLE|SUBMIT|TABBED|TOKENS|UNIQUE|UNPACK|UPDATE|WINDOW|YELLOW|ACTUAL|ASPECT|CENTER|CURSOR|DELETE|DIALOG|DIVIDE|DURING|ERRORS|EVENTS|EXTEND|FILTER|HANDLE|HAVING|IGNORE|LITTLE|MEMORY|NO-GAP|OCCURS|OPTION|PERSON|PLACES|PUBLIC|REDUCE|REPORT|RESULT|SINGLE|SORTED|SWITCH|SYNTAX|TARGET|VALUES|WRITER|ASSERT|BLOCKS|BOUNDS|BUFFER|CHANGE|COLUMN|COMMIT|CONCAT|COPIES|CREATE|DDMMYY|DEFINE|ENDIAN|ESCAPE|EXPAND|KERNEL|LAYOUT|LEGACY|LEVELS|MMDDYY|NUMBER|OUTPUT|RANGES|READER|RETURN|SCREEN|SEARCH|SELECT|SHARED|SOURCE|STABLE|STATIC|SUBKEY|SUFFIX|TABLES|UNWIND|YYMMDD|ASSIGN|BACKUP|BEFORE|BINARY|BIT-OR|BLANKS|CLIENT|CODING|COMMON|DEMAND|DYNPRO|EXCEPT|EXISTS|EXPORT|FIELDS|GLOBAL|GROUPS|LENGTH|LOCALE|MEDIUM|METHOD|MODIFY|NESTED|OTHERS|REJECT|SCROLL|SUPPLY|SYMBOL|ENDFOR|STRLEN|ALIGN|BEGIN|BOUND|ENDAT|ENTRY|EVENT|FINAL|FLUSH|GRANT|INNER|SHORT|USING|WRITE|AFTER|BLACK|BLOCK|CLOCK|COLOR|COUNT|DUMMY|EMPTY|ENDDO|ENDON|GREEN|INDEX|INOUT|LEAVE|LEVEL|LINES|MODIF|ORDER|OUTER|RANGE|RESET|RETRY|RIGHT|SMART|SPLIT|STYLE|TABLE|THROW|UNDER|UNTIL|UPPER|UTF-8|WHERE|ALIAS|BLANK|CLEAR|CLOSE|EXACT|FETCH|FIRST|FOUND|GROUP|LLANG|LOCAL|OTHER|REGEX|SPOOL|TITLE|TYPES|VALID|WHILE|ALPHA|BOXED|CATCH|CHAIN|CHECK|CLASS|COVER|ENDIF|EQUIV|FIELD|FLOOR|FRAME|INPUT|LOWER|MATCH|NODES|PAGES|PRINT|RAISE|ROUND|SHIFT|SPACE|SPOTS|STAMP|STATE|TASKS|TIMES|TRMAC|ULINE|UNION|VALUE|WIDTH|EQUAL|LOG10|TRUNC|BLOB|CASE|CEIL|CLOB|COND|EXIT|FILE|GAPS|HOLD|INCL|INTO|KEEP|KEYS|LAST|LINE|LONG|LPAD|MAIL|MODE|OPEN|PINK|READ|ROWS|TEST|THEN|ZERO|AREA|BACK|BADI|BYTE|CAST|EDIT|EXEC|FAIL|FIND|FKEQ|FONT|FREE|GKEQ|HIDE|INIT|ITNO|LATE|LOOP|MAIN|MARK|MOVE|NEXT|NULL|RISK|ROLE|UNIT|WAIT|ZONE|BASE|CALL|CODE|DATA|DATE|FKGE|GKGE|HIGH|KIND|LEFT|LIST|MASK|MESH|NAME|NODE|PACK|PAGE|POOL|SEND|SIGN|SIZE|SOME|STOP|TASK|TEXT|TIME|USER|VARY|WITH|WORD|BLUE|CONV|COPY|DEEP|ELSE|FORM|FROM|HINT|ICON|JOIN|LIKE|LOAD|ONLY|PART|SCAN|SKIP|SORT|TYPE|UNIX|VIEW|WHEN|WORK|ACOS|ASIN|ATAN|COSH|EACH|FRAC|LESS|RTTI|SINH|SQRT|TANH|AVG|BIT|DIV|ISO|LET|OUT|PAD|SQL|ALL|CI_|CPI|END|LOB|LPI|MAX|MIN|NEW|OLE|RUN|SET|\?TO|YES|ABS|ADD|AND|BIG|FOR|HDB|JOB|LOW|NOT|SAP|TRY|VIA|XML|ANY|GET|IDS|KEY|MOD|OFF|PUT|RAW|RED|REF|SUM|TAB|XSD|CNT|COS|EXP|LOG|SIN|TAN|XOR|AT|CO|CP|DO|GT|ID|IF|NS|OR|BT|CA|CS|GE|NA|NB|EQ|IN|LT|NE|NO|OF|ON|PF|TO|AS|BY|CN|IS|LE|NP|UP|E|I|M|O|Z|C|X)\b/i,
      lookbehind: true
    },
    /* Numbers can be only integers. Decimal or Hex appear only as strings */
    number: /\b\d+\b/,
    /* Operators must always be surrounded by whitespace, they cannot be put
adjacent to operands.
*/
    operator: {
      pattern: /(\s)(?:\*\*?|<[=>]?|>=?|\?=|[-+\/=])(?=\s)/,
      lookbehind: true
    },
    'string-operator': {
      pattern: /(\s)&&?(?=\s)/,
      lookbehind: true,
      /* The official editor highlights */
      alias: 'keyword'
    },
    'token-operator': [
      {
        /* Special operators used to access structure components, class methods/attributes, etc. */
        pattern: /(\w)(?:->?|=>|[~|{}])(?=\w)/,
        lookbehind: true,
        alias: 'punctuation'
      },
      {
        /* Special tokens used do delimit string templates */
        pattern: /[|{}]/,
        alias: 'punctuation'
      }
    ],
    punctuation: /[,.:()]/
  };
}

var abnf_1 = abnf;
abnf.displayName = 'abnf';
abnf.aliases = [];
function abnf(Prism) {
(function (Prism) {
    var coreRules =
      '(?:ALPHA|BIT|CHAR|CR|CRLF|CTL|DIGIT|DQUOTE|HEXDIG|HTAB|LF|LWSP|OCTET|SP|VCHAR|WSP)';
    Prism.languages.abnf = {
      comment: /;.*/,
      string: {
        pattern: /(?:%[is])?"[^"\n\r]*"/,
        greedy: true,
        inside: {
          punctuation: /^%[is]/
        }
      },
      range: {
        pattern: /%(?:b[01]+-[01]+|d\d+-\d+|x[A-F\d]+-[A-F\d]+)/i,
        alias: 'number'
      },
      terminal: {
        pattern:
          /%(?:b[01]+(?:\.[01]+)*|d\d+(?:\.\d+)*|x[A-F\d]+(?:\.[A-F\d]+)*)/i,
        alias: 'number'
      },
      repetition: {
        pattern: /(^|[^\w-])(?:\d*\*\d*|\d+)/,
        lookbehind: true,
        alias: 'operator'
      },
      definition: {
        pattern: /(^[ \t]*)(?:[a-z][\w-]*|<[^<>\r\n]*>)(?=\s*=)/m,
        lookbehind: true,
        alias: 'keyword',
        inside: {
          punctuation: /<|>/
        }
      },
      'core-rule': {
        pattern: RegExp(
          '(?:(^|[^<\\w-])' + coreRules + '|<' + coreRules + '>)(?![\\w-])',
          'i'
        ),
        lookbehind: true,
        alias: ['rule', 'constant'],
        inside: {
          punctuation: /<|>/
        }
      },
      rule: {
        pattern: /(^|[^<\w-])[a-z][\w-]*|<[^<>\r\n]*>/i,
        lookbehind: true,
        inside: {
          punctuation: /<|>/
        }
      },
      operator: /=\/?|\//,
      punctuation: /[()\[\]]/
    };
  })(Prism);
}

var actionscript_1 = actionscript;
actionscript.displayName = 'actionscript';
actionscript.aliases = [];
function actionscript(Prism) {
  Prism.languages.actionscript = Prism.languages.extend('javascript', {
    keyword:
      /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/,
    operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/
  });
  Prism.languages.actionscript['class-name'].alias = 'function'; // doesn't work with AS because AS is too complex
  delete Prism.languages.actionscript['parameter'];
  delete Prism.languages.actionscript['literal-property'];
  if (Prism.languages.markup) {
    Prism.languages.insertBefore('actionscript', 'string', {
      xml: {
        pattern:
          /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
        lookbehind: true,
        inside: Prism.languages.markup
      }
    });
  }
}

var ada_1 = ada;
ada.displayName = 'ada';
ada.aliases = [];
function ada(Prism) {
  Prism.languages.ada = {
    comment: /--.*/,
    string: /"(?:""|[^"\r\f\n])*"/,
    number: [
      {
        pattern:
          /\b\d(?:_?\d)*#[\dA-F](?:_?[\dA-F])*(?:\.[\dA-F](?:_?[\dA-F])*)?#(?:E[+-]?\d(?:_?\d)*)?/i
      },
      {
        pattern: /\b\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:E[+-]?\d(?:_?\d)*)?\b/i
      }
    ],
    'attr-name': /\b'\w+/,
    keyword:
      /\b(?:abort|abs|abstract|accept|access|aliased|all|and|array|at|begin|body|case|constant|declare|delay|delta|digits|do|else|elsif|end|entry|exception|exit|for|function|generic|goto|if|in|interface|is|limited|loop|mod|new|not|null|of|others|out|overriding|package|pragma|private|procedure|protected|raise|range|record|rem|renames|requeue|return|reverse|select|separate|some|subtype|synchronized|tagged|task|terminate|then|type|until|use|when|while|with|xor)\b/i,
    boolean: /\b(?:false|true)\b/i,
    operator: /<[=>]?|>=?|=>?|:=|\/=?|\*\*?|[&+-]/,
    punctuation: /\.\.?|[,;():]/,
    char: /'.'/,
    variable: /\b[a-z](?:\w)*\b/i
  };
}

var agda_1 = agda;
agda.displayName = 'agda';
agda.aliases = [];
function agda(Prism) {
(function (Prism) {
    Prism.languages.agda = {
      comment: /\{-[\s\S]*?(?:-\}|$)|--.*/,
      string: {
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
        greedy: true
      },
      punctuation: /[(){}⦃⦄.;@]/,
      'class-name': {
        pattern: /((?:data|record) +)\S+/,
        lookbehind: true
      },
      function: {
        pattern: /(^[ \t]*)(?!\s)[^:\r\n]+(?=:)/m,
        lookbehind: true
      },
      operator: {
        pattern: /(^\s*|\s)(?:[=|:∀→λ\\?_]|->)(?=\s)/,
        lookbehind: true
      },
      keyword:
        /\b(?:Set|abstract|constructor|data|eta-equality|field|forall|hiding|import|in|inductive|infix|infixl|infixr|instance|let|macro|module|mutual|no-eta-equality|open|overlap|pattern|postulate|primitive|private|public|quote|quoteContext|quoteGoal|quoteTerm|record|renaming|rewrite|syntax|tactic|unquote|unquoteDecl|unquoteDef|using|variable|where|with)\b/
    };
  })(Prism);
}

var al_1 = al;
al.displayName = 'al';
al.aliases = [];
function al(Prism) {
  // based on https://github.com/microsoft/AL/blob/master/grammar/alsyntax.tmlanguage
  Prism.languages.al = {
    comment: /\/\/.*|\/\*[\s\S]*?\*\//,
    string: {
      pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
      greedy: true
    },
    function: {
      pattern:
        /(\b(?:event|procedure|trigger)\s+|(?:^|[^.])\.\s*)[a-z_]\w*(?=\s*\()/i,
      lookbehind: true
    },
    keyword: [
      // keywords
      /\b(?:array|asserterror|begin|break|case|do|downto|else|end|event|exit|for|foreach|function|if|implements|in|indataset|interface|internal|local|of|procedure|program|protected|repeat|runonclient|securityfiltering|suppressdispose|temporary|then|to|trigger|until|var|while|with|withevents)\b/i, // objects and metadata that are used like keywords
      /\b(?:action|actions|addafter|addbefore|addfirst|addlast|area|assembly|chartpart|codeunit|column|controladdin|cuegroup|customizes|dataitem|dataset|dotnet|elements|enum|enumextension|extends|field|fieldattribute|fieldelement|fieldgroup|fieldgroups|fields|filter|fixed|grid|group|key|keys|label|labels|layout|modify|moveafter|movebefore|movefirst|movelast|page|pagecustomization|pageextension|part|profile|query|repeater|report|requestpage|schema|separator|systempart|table|tableelement|tableextension|textattribute|textelement|type|usercontrol|value|xmlport)\b/i
    ],
    number:
      /\b(?:0x[\da-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)(?:F|LL?|U(?:LL?)?)?\b/i,
    boolean: /\b(?:false|true)\b/i,
    variable: /\b(?:Curr(?:FieldNo|Page|Report)|x?Rec|RequestOptionsPage)\b/,
    'class-name':
      /\b(?:automation|biginteger|bigtext|blob|boolean|byte|char|clienttype|code|completiontriggererrorlevel|connectiontype|database|dataclassification|datascope|date|dateformula|datetime|decimal|defaultlayout|dialog|dictionary|dotnetassembly|dotnettypedeclaration|duration|errorinfo|errortype|executioncontext|executionmode|fieldclass|fieldref|fieldtype|file|filterpagebuilder|guid|httpclient|httpcontent|httpheaders|httprequestmessage|httpresponsemessage|instream|integer|joker|jsonarray|jsonobject|jsontoken|jsonvalue|keyref|list|moduledependencyinfo|moduleinfo|none|notification|notificationscope|objecttype|option|outstream|pageresult|record|recordid|recordref|reportformat|securityfilter|sessionsettings|tableconnectiontype|tablefilter|testaction|testfield|testfilterfield|testpage|testpermissions|testrequestpage|text|textbuilder|textconst|textencoding|time|transactionmodel|transactiontype|variant|verbosity|version|view|views|webserviceactioncontext|webserviceactionresultcode|xmlattribute|xmlattributecollection|xmlcdata|xmlcomment|xmldeclaration|xmldocument|xmldocumenttype|xmlelement|xmlnamespacemanager|xmlnametable|xmlnode|xmlnodelist|xmlprocessinginstruction|xmlreadoptions|xmltext|xmlwriteoptions)\b/i,
    operator: /\.\.|:[=:]|[-+*/]=?|<>|[<>]=?|=|\b(?:and|div|mod|not|or|xor)\b/i,
    punctuation: /[()\[\]{}:.;,]/
  };
}

var antlr4_1 = antlr4;
antlr4.displayName = 'antlr4';
antlr4.aliases = ['g4'];
function antlr4(Prism) {
  Prism.languages.antlr4 = {
    comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    string: {
      pattern: /'(?:\\.|[^\\'\r\n])*'/,
      greedy: true
    },
    'character-class': {
      pattern: /\[(?:\\.|[^\\\]\r\n])*\]/,
      greedy: true,
      alias: 'regex',
      inside: {
        range: {
          pattern: /([^[]|(?:^|[^\\])(?:\\\\)*\\\[)-(?!\])/,
          lookbehind: true,
          alias: 'punctuation'
        },
        escape:
          /\\(?:u(?:[a-fA-F\d]{4}|\{[a-fA-F\d]+\})|[pP]\{[=\w-]+\}|[^\r\nupP])/,
        punctuation: /[\[\]]/
      }
    },
    action: {
      pattern: /\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}/,
      greedy: true,
      inside: {
        content: {
          // this might be C, C++, Python, Java, C#, or any other language ANTLR4 compiles to
          pattern: /(\{)[\s\S]+(?=\})/,
          lookbehind: true
        },
        punctuation: /[{}]/
      }
    },
    command: {
      pattern:
        /(->\s*(?!\s))(?:\s*(?:,\s*)?\b[a-z]\w*(?:\s*\([^()\r\n]*\))?)+(?=\s*;)/i,
      lookbehind: true,
      inside: {
        function: /\b\w+(?=\s*(?:[,(]|$))/,
        punctuation: /[,()]/
      }
    },
    annotation: {
      pattern: /@\w+(?:::\w+)*/,
      alias: 'keyword'
    },
    label: {
      pattern: /#[ \t]*\w+/,
      alias: 'punctuation'
    },
    keyword:
      /\b(?:catch|channels|finally|fragment|grammar|import|lexer|locals|mode|options|parser|returns|throws|tokens)\b/,
    definition: [
      {
        pattern: /\b[a-z]\w*(?=\s*:)/,
        alias: ['rule', 'class-name']
      },
      {
        pattern: /\b[A-Z]\w*(?=\s*:)/,
        alias: ['token', 'constant']
      }
    ],
    constant: /\b[A-Z][A-Z_]*\b/,
    operator: /\.\.|->|[|~]|[*+?]\??/,
    punctuation: /[;:()=]/
  };
  Prism.languages.g4 = Prism.languages.antlr4;
}

var apacheconf_1 = apacheconf;
apacheconf.displayName = 'apacheconf';
apacheconf.aliases = [];
function apacheconf(Prism) {
  Prism.languages.apacheconf = {
    comment: /#.*/,
    'directive-inline': {
      pattern:
        /(^[\t ]*)\b(?:AcceptFilter|AcceptPathInfo|AccessFileName|Action|Add(?:Alt|AltByEncoding|AltByType|Charset|DefaultCharset|Description|Encoding|Handler|Icon|IconByEncoding|IconByType|InputFilter|Language|ModuleInfo|OutputFilter|OutputFilterByType|Type)|Alias|AliasMatch|Allow(?:CONNECT|EncodedSlashes|Methods|Override|OverrideList)?|Anonymous(?:_LogEmail|_MustGiveEmail|_NoUserID|_VerifyEmail)?|AsyncRequestWorkerFactor|Auth(?:BasicAuthoritative|BasicFake|BasicProvider|BasicUseDigestAlgorithm|DBDUserPWQuery|DBDUserRealmQuery|DBMGroupFile|DBMType|DBMUserFile|Digest(?:Algorithm|Domain|NonceLifetime|Provider|Qop|ShmemSize)|Form(?:Authoritative|Body|DisableNoStore|FakeBasicAuth|Location|LoginRequiredLocation|LoginSuccessLocation|LogoutLocation|Method|Mimetype|Password|Provider|SitePassphrase|Size|Username)|GroupFile|LDAP(?:AuthorizePrefix|BindAuthoritative|BindDN|BindPassword|CharsetConfig|CompareAsUser|CompareDNOnServer|DereferenceAliases|GroupAttribute|GroupAttributeIsDN|InitialBindAsUser|InitialBindPattern|MaxSubGroupDepth|RemoteUserAttribute|RemoteUserIsDN|SearchAsUser|SubGroupAttribute|SubGroupClass|Url)|Merging|Name|nCache(?:Context|Enable|ProvideFor|SOCache|Timeout)|nzFcgiCheckAuthnProvider|nzFcgiDefineProvider|Type|UserFile|zDBDLoginToReferer|zDBDQuery|zDBDRedirectQuery|zDBMType|zSendForbiddenOnFailure)|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|Cache(?:DefaultExpire|DetailHeader|DirLength|DirLevels|Disable|Enable|File|Header|IgnoreCacheControl|IgnoreHeaders|IgnoreNoLastMod|IgnoreQueryString|IgnoreURLSessionIdentifiers|KeyBaseURL|LastModifiedFactor|Lock|LockMaxAge|LockPath|MaxExpire|MaxFileSize|MinExpire|MinFileSize|NegotiatedDocs|QuickHandler|ReadSize|ReadTime|Root|Socache(?:MaxSize|MaxTime|MinTime|ReadSize|ReadTime)?|StaleOnError|StoreExpired|StoreNoStore|StorePrivate)|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|Deflate(?:BufferSize|CompressionLevel|FilterNote|InflateLimitRequestBody|InflateRatio(?:Burst|Limit)|MemLevel|WindowSize)|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|Heartbeat(?:Address|Listen|MaxServers|Storage)|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|Index(?:HeadInsert|Ignore|IgnoreReset|Options|OrderDefault|StyleSheet)|InputSed|ISAPI(?:AppendLogToErrors|AppendLogToQuery|CacheFile|FakeAsync|LogNotSupported|ReadAheadBuffer)|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAP(?:CacheEntries|CacheTTL|ConnectionPoolTTL|ConnectionTimeout|LibraryDebug|OpCacheEntries|OpCacheTTL|ReferralHopLimit|Referrals|Retries|RetryDelay|SharedCacheFile|SharedCacheSize|Timeout|TrustedClientCert|TrustedGlobalCert|TrustedMode|VerifyServerCert)|Limit(?:InternalRecursion|Request(?:Body|Fields|FieldSize|Line)|XMLRequestBody)|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|Lua(?:Hook(?:AccessChecker|AuthChecker|CheckUserID|Fixups|InsertFilter|Log|MapToStorage|TranslateName|TypeChecker)|Inherit|InputFilter|MapHandler|OutputFilter|PackageCPath|PackagePath|QuickHandler|Root|Scope)|Max(?:ConnectionsPerChild|KeepAliveRequests|MemFree|RangeOverlaps|RangeReversals|Ranges|RequestWorkers|SpareServers|SpareThreads|Threads)|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|Proxy(?:AddHeaders|BadHeader|Block|Domain|ErrorOverride|ExpressDBMFile|ExpressDBMType|ExpressEnable|FtpDirCharset|FtpEscapeWildcards|FtpListOnWildcard|HTML(?:BufSize|CharsetOut|DocType|Enable|Events|Extended|Fixups|Interp|Links|Meta|StripComments|URLMap)|IOBufferSize|MaxForwards|Pass(?:Inherit|InterpolateEnv|Match|Reverse|ReverseCookieDomain|ReverseCookiePath)?|PreserveHost|ReceiveBufferSize|Remote|RemoteMatch|Requests|SCGIInternalRedirect|SCGISendfile|Set|SourceAddress|Status|Timeout|Via)|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIP(?:Header|InternalProxy|InternalProxyList|ProxiesHeader|TrustedProxy|TrustedProxyList)|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|Rewrite(?:Base|Cond|Engine|Map|Options|Rule)|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script(?:Alias|AliasMatch|InterpreterSource|Log|LogBuffer|LogLength|Sock)?|SecureListen|SeeRequestTail|SendBufferSize|Server(?:Admin|Alias|Limit|Name|Path|Root|Signature|Tokens)|Session(?:Cookie(?:Name|Name2|Remove)|Crypto(?:Cipher|Driver|Passphrase|PassphraseFile)|DBD(?:CookieName|CookieName2|CookieRemove|DeleteLabel|InsertLabel|PerUser|SelectLabel|UpdateLabel)|Env|Exclude|Header|Include|MaxAge)?|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSL(?:CACertificateFile|CACertificatePath|CADNRequestFile|CADNRequestPath|CARevocationCheck|CARevocationFile|CARevocationPath|CertificateChainFile|CertificateFile|CertificateKeyFile|CipherSuite|Compression|CryptoDevice|Engine|FIPS|HonorCipherOrder|InsecureRenegotiation|OCSP(?:DefaultResponder|Enable|OverrideResponder|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|UseRequestNonce)|OpenSSLConfCmd|Options|PassPhraseDialog|Protocol|Proxy(?:CACertificateFile|CACertificatePath|CARevocation(?:Check|File|Path)|CheckPeer(?:CN|Expire|Name)|CipherSuite|Engine|MachineCertificate(?:ChainFile|File|Path)|Protocol|Verify|VerifyDepth)|RandomSeed|RenegBufferSize|Require|RequireSSL|Session(?:Cache|CacheTimeout|TicketKeyFile|Tickets)|SRPUnknownUserSeed|SRPVerifierFile|Stapling(?:Cache|ErrorCacheTimeout|FakeTryLater|ForceURL|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|ReturnResponderErrors|StandardCacheTimeout)|StrictSNIVHostCheck|UserName|UseStapling|VerifyClient|VerifyDepth)|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|Virtual(?:DocumentRoot|ScriptAlias)(?:IP)?|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\b/im,
      lookbehind: true,
      alias: 'property'
    },
    'directive-block': {
      pattern:
        /<\/?\b(?:Auth[nz]ProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|Require(?:All|Any|None)|VirtualHost)\b.*>/i,
      inside: {
        'directive-block': {
          pattern: /^<\/?\w+/,
          inside: {
            punctuation: /^<\/?/
          },
          alias: 'tag'
        },
        'directive-block-parameter': {
          pattern: /.*[^>]/,
          inside: {
            punctuation: /:/,
            string: {
              pattern: /("|').*\1/,
              inside: {
                variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
              }
            }
          },
          alias: 'attr-value'
        },
        punctuation: />/
      },
      alias: 'tag'
    },
    'directive-flags': {
      pattern: /\[(?:[\w=],?)+\]/,
      alias: 'keyword'
    },
    string: {
      pattern: /("|').*\1/,
      inside: {
        variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
      }
    },
    variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/,
    regex: /\^?.*\$|\^.*\$?/
  };
}

var sql_1 = sql;
sql.displayName = 'sql';
sql.aliases = [];
function sql(Prism) {
  Prism.languages.sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: true
    },
    variable: [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: true
      },
      /@[\w.$]+/
    ],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: true,
      lookbehind: true
    },
    identifier: {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: true,
      lookbehind: true,
      inside: {
        punctuation: /^`|`$/
      }
    },
    function:
      /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    keyword:
      /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator:
      /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  };
}

var refractorSql = sql_1;
var apex_1 = apex;
apex.displayName = 'apex';
apex.aliases = [];
function apex(Prism) {
  Prism.register(refractorSql)
  ;(function (Prism) {
    var keywords =
      /\b(?:(?:after|before)(?=\s+[a-z])|abstract|activate|and|any|array|as|asc|autonomous|begin|bigdecimal|blob|boolean|break|bulk|by|byte|case|cast|catch|char|class|collect|commit|const|continue|currency|date|datetime|decimal|default|delete|desc|do|double|else|end|enum|exception|exit|export|extends|final|finally|float|for|from|get(?=\s*[{};])|global|goto|group|having|hint|if|implements|import|in|inner|insert|instanceof|int|integer|interface|into|join|like|limit|list|long|loop|map|merge|new|not|null|nulls|number|object|of|on|or|outer|override|package|parallel|pragma|private|protected|public|retrieve|return|rollback|select|set|short|sObject|sort|static|string|super|switch|synchronized|system|testmethod|then|this|throw|time|transaction|transient|trigger|try|undelete|update|upsert|using|virtual|void|webservice|when|where|while|(?:inherited|with|without)\s+sharing)\b/i;
    var className =
      /\b(?:(?=[a-z_]\w*\s*[<\[])|(?!<keyword>))[A-Z_]\w*(?:\s*\.\s*[A-Z_]\w*)*\b(?:\s*(?:\[\s*\]|<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>))*/.source.replace(
        /<keyword>/g,
        function () {
          return keywords.source
        }
      );
    /** @param {string} pattern */
    function insertClassName(pattern) {
      return RegExp(
        pattern.replace(/<CLASS-NAME>/g, function () {
          return className
        }),
        'i'
      )
    }
    var classNameInside = {
      keyword: keywords,
      punctuation: /[()\[\]{};,:.<>]/
    };
    Prism.languages.apex = {
      comment: Prism.languages.clike.comment,
      string: Prism.languages.clike.string,
      sql: {
        pattern: /((?:[=,({:]|\breturn)\s*)\[[^\[\]]*\]/i,
        lookbehind: true,
        greedy: true,
        alias: 'language-sql',
        inside: Prism.languages.sql
      },
      annotation: {
        pattern: /@\w+\b/,
        alias: 'punctuation'
      },
      'class-name': [
        {
          pattern: insertClassName(
            /(\b(?:class|enum|extends|implements|instanceof|interface|new|trigger\s+\w+\s+on)\s+)<CLASS-NAME>/
              .source
          ),
          lookbehind: true,
          inside: classNameInside
        },
        {
          // cast
          pattern: insertClassName(
            /(\(\s*)<CLASS-NAME>(?=\s*\)\s*[\w(])/.source
          ),
          lookbehind: true,
          inside: classNameInside
        },
        {
          // variable/parameter declaration and return types
          pattern: insertClassName(/<CLASS-NAME>(?=\s*\w+\s*[;=,(){:])/.source),
          inside: classNameInside
        }
      ],
      trigger: {
        pattern: /(\btrigger\s+)\w+\b/i,
        lookbehind: true,
        alias: 'class-name'
      },
      keyword: keywords,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      boolean: /\b(?:false|true)\b/i,
      number: /(?:\B\.\d+|\b\d+(?:\.\d+|L)?)\b/i,
      operator:
        /[!=](?:==?)?|\?\.?|&&|\|\||--|\+\+|[-+*/^&|]=?|:|<<?=?|>{1,3}=?/,
      punctuation: /[()\[\]{};,.]/
    };
  })(Prism);
}

var apl_1 = apl;
apl.displayName = 'apl';
apl.aliases = [];
function apl(Prism) {
  Prism.languages.apl = {
    comment: /(?:⍝|#[! ]).*$/m,
    string: {
      pattern: /'(?:[^'\r\n]|'')*'/,
      greedy: true
    },
    number:
      /¯?(?:\d*\.?\b\d+(?:e[+¯]?\d+)?|¯|∞)(?:j¯?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+¯]?\d+)?|¯|∞))?/i,
    statement: /:[A-Z][a-z][A-Za-z]*\b/,
    'system-function': {
      pattern: /⎕[A-Z]+/i,
      alias: 'function'
    },
    constant: /[⍬⌾#⎕⍞]/,
    function: /[-+×÷⌈⌊∣|⍳⍸?*⍟○!⌹<≤=>≥≠≡≢∊⍷∪∩~∨∧⍱⍲⍴,⍪⌽⊖⍉↑↓⊂⊃⊆⊇⌷⍋⍒⊤⊥⍕⍎⊣⊢⍁⍂≈⍯↗¤→]/,
    'monadic-operator': {
      pattern: /[\\\/⌿⍀¨⍨⌶&∥]/,
      alias: 'operator'
    },
    'dyadic-operator': {
      pattern: /[.⍣⍠⍤∘⌸@⌺⍥]/,
      alias: 'operator'
    },
    assignment: {
      pattern: /←/,
      alias: 'keyword'
    },
    punctuation: /[\[;\]()◇⋄]/,
    dfn: {
      pattern: /[{}⍺⍵⍶⍹∇⍫:]/,
      alias: 'builtin'
    }
  };
}

var applescript_1 = applescript;
applescript.displayName = 'applescript';
applescript.aliases = [];
function applescript(Prism) {
  Prism.languages.applescript = {
    comment: [
      // Allow one level of nesting
      /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
      /--.+/,
      /#.+/
    ],
    string: /"(?:\\.|[^"\\\r\n])*"/,
    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?\b/i,
    operator: [
      /[&=≠≤≥*+\-\/÷^]|[<>]=?/,
      /\b(?:(?:begin|end|start)s? with|(?:contains?|(?:does not|doesn't) contain)|(?:is|isn't|is not) (?:contained by|in)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:comes|(?:does not|doesn't) come) (?:after|before)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equal to|equals|is not|isn't)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|as|div|mod|not|or))\b/
    ],
    keyword:
      /\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\b/,
    'class-name':
      /\b(?:POSIX file|RGB color|alias|application|boolean|centimeters|centimetres|class|constant|cubic centimeters|cubic centimetres|cubic feet|cubic inches|cubic meters|cubic metres|cubic yards|date|degrees Celsius|degrees Fahrenheit|degrees Kelvin|feet|file|gallons|grams|inches|integer|kilograms|kilometers|kilometres|list|liters|litres|meters|metres|miles|number|ounces|pounds|quarts|real|record|reference|script|square feet|square kilometers|square kilometres|square meters|square metres|square miles|square yards|text|yards)\b/,
    punctuation: /[{}():,¬«»《》]/
  };
}

var aql_1 = aql;
aql.displayName = 'aql';
aql.aliases = [];
function aql(Prism) {
  Prism.languages.aql = {
    comment: /\/\/.*|\/\*[\s\S]*?\*\//,
    property: {
      pattern:
        /([{,]\s*)(?:(?!\d)\w+|(["'´`])(?:(?!\2)[^\\\r\n]|\\.)*\2)(?=\s*:)/,
      lookbehind: true,
      greedy: true
    },
    string: {
      pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
      greedy: true
    },
    identifier: {
      pattern: /([´`])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
      greedy: true
    },
    variable: /@@?\w+/,
    keyword: [
      {
        pattern: /(\bWITH\s+)COUNT(?=\s+INTO\b)/i,
        lookbehind: true
      },
      /\b(?:AGGREGATE|ALL|AND|ANY|ASC|COLLECT|DESC|DISTINCT|FILTER|FOR|GRAPH|IN|INBOUND|INSERT|INTO|K_PATHS|K_SHORTEST_PATHS|LET|LIKE|LIMIT|NONE|NOT|NULL|OR|OUTBOUND|REMOVE|REPLACE|RETURN|SHORTEST_PATH|SORT|UPDATE|UPSERT|WINDOW|WITH)\b/i, // pseudo keywords get a lookbehind to avoid false positives
      {
        pattern: /(^|[^\w.[])(?:KEEP|PRUNE|SEARCH|TO)\b/i,
        lookbehind: true
      },
      {
        pattern: /(^|[^\w.[])(?:CURRENT|NEW|OLD)\b/,
        lookbehind: true
      },
      {
        pattern: /\bOPTIONS(?=\s*\{)/i
      }
    ],
    function: /\b(?!\d)\w+(?=\s*\()/,
    boolean: /\b(?:false|true)\b/i,
    range: {
      pattern: /\.\./,
      alias: 'operator'
    },
    number: [
      /\b0b[01]+/i,
      /\b0x[0-9a-f]+/i,
      /(?:\B\.\d+|\b(?:0|[1-9]\d*)(?:\.\d+)?)(?:e[+-]?\d+)?/i
    ],
    operator: /\*{2,}|[=!]~|[!=<>]=?|&&|\|\||[-+*/%]/,
    punctuation: /::|[?.:,;()[\]{}]/
  };
}

var c_1 = c;
c.displayName = 'c';
c.aliases = [];
function c(Prism) {
  Prism.languages.c = Prism.languages.extend('clike', {
    comment: {
      pattern:
        /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: true
    },
    string: {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: true
    },
    'class-name': {
      pattern:
        /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: true
    },
    keyword:
      /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number:
      /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  });
  Prism.languages.insertBefore('c', 'string', {
    char: {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: true
    }
  });
  Prism.languages.insertBefore('c', 'string', {
    macro: {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern:
        /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: true,
      greedy: true,
      alias: 'property',
      inside: {
        string: [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: true
          },
          Prism.languages.c['string']
        ],
        char: Prism.languages.c['char'],
        comment: Prism.languages.c['comment'],
        'macro-name': [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: true
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: true,
            alias: 'function'
          }
        ],
        // highlight macro directives as keywords
        directive: {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: true,
          alias: 'keyword'
        },
        'directive-hash': /^#/,
        punctuation: /##|\\(?=[\r\n])/,
        expression: {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    }
  });
  Prism.languages.insertBefore('c', 'function', {
    // highlight predefined macros as constants
    constant:
      /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  });
  delete Prism.languages.c['boolean'];
}

var cpp_1;
var hasRequiredCpp;

function requireCpp () {
	if (hasRequiredCpp) return cpp_1;
	hasRequiredCpp = 1;
	var refractorC = c_1;
	cpp_1 = cpp;
	cpp.displayName = 'cpp';
	cpp.aliases = [];
	function cpp(Prism) {
	  Prism.register(refractorC)
	  ;(function (Prism) {
	    var keyword =
	      /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
	    var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(
	      /<keyword>/g,
	      function () {
	        return keyword.source
	      }
	    );
	    Prism.languages.cpp = Prism.languages.extend('c', {
	      'class-name': [
	        {
	          pattern: RegExp(
	            /(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(
	              /<keyword>/g,
	              function () {
	                return keyword.source
	              }
	            )
	          ),
	          lookbehind: true
	        }, // This is intended to capture the class name of method implementations like:
	        //   void foo::bar() const {}
	        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
	        // it starts with an uppercase letter. This approximation should give decent results.
	        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/, // This will capture the class name before destructors like:
	        //   Foo::~Foo() {}
	        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i, // This also intends to capture the class name of method implementations but here the class has template
	        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
	        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
	      ],
	      keyword: keyword,
	      number: {
	        pattern:
	          /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
	        greedy: true
	      },
	      operator:
	        />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
	      boolean: /\b(?:false|true)\b/
	    });
	    Prism.languages.insertBefore('cpp', 'string', {
	      module: {
	        // https://en.cppreference.com/w/cpp/language/modules
	        pattern: RegExp(
	          /(\b(?:import|module)\s+)/.source +
	            '(?:' + // header-name
	            /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source +
	            '|' + // module name or partition or both
	            /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(
	              /<mod-name>/g,
	              function () {
	                return modName
	              }
	            ) +
	            ')'
	        ),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          string: /^[<"][\s\S]+/,
	          operator: /:/,
	          punctuation: /\./
	        }
	      },
	      'raw-string': {
	        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
	        alias: 'string',
	        greedy: true
	      }
	    });
	    Prism.languages.insertBefore('cpp', 'keyword', {
	      'generic-function': {
	        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
	        inside: {
	          function: /^\w+/,
	          generic: {
	            pattern: /<[\s\S]+/,
	            alias: 'class-name',
	            inside: Prism.languages.cpp
	          }
	        }
	      }
	    });
	    Prism.languages.insertBefore('cpp', 'operator', {
	      'double-colon': {
	        pattern: /::/,
	        alias: 'punctuation'
	      }
	    });
	    Prism.languages.insertBefore('cpp', 'class-name', {
	      // the base clause is an optional list of parent classes
	      // https://en.cppreference.com/w/cpp/language/class
	      'base-clause': {
	        pattern:
	          /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
	        lookbehind: true,
	        greedy: true,
	        inside: Prism.languages.extend('cpp', {})
	      }
	    });
	    Prism.languages.insertBefore(
	      'inside',
	      'double-colon',
	      {
	        // All untokenized words that are not namespaces should be class names
	        'class-name': /\b[a-z_]\w*\b(?!\s*::)/i
	      },
	      Prism.languages.cpp['base-clause']
	    );
	  })(Prism);
	}
	return cpp_1;
}

var refractorCpp$1 = requireCpp();
var arduino_1 = arduino;
arduino.displayName = 'arduino';
arduino.aliases = ['ino'];
function arduino(Prism) {
  Prism.register(refractorCpp$1);
  Prism.languages.arduino = Prism.languages.extend('cpp', {
    keyword:
      /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
    constant:
      /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
    builtin:
      /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
  });
  Prism.languages.ino = Prism.languages.arduino;
}

var arff_1 = arff;
arff.displayName = 'arff';
arff.aliases = [];
function arff(Prism) {
  Prism.languages.arff = {
    comment: /%.*/,
    string: {
      pattern: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    keyword: /@(?:attribute|data|end|relation)\b/i,
    number: /\b\d+(?:\.\d+)?\b/,
    punctuation: /[{},]/
  };
}

var asciidoc_1 = asciidoc;
asciidoc.displayName = 'asciidoc';
asciidoc.aliases = ['adoc'];
function asciidoc(Prism) {
(function (Prism) {
    var attributes = {
      pattern:
        /(^[ \t]*)\[(?!\[)(?:(["'$`])(?:(?!\2)[^\\]|\\.)*\2|\[(?:[^\[\]\\]|\\.)*\]|[^\[\]\\"'$`]|\\.)*\]/m,
      lookbehind: true,
      inside: {
        quoted: {
          pattern: /([$`])(?:(?!\1)[^\\]|\\.)*\1/,
          inside: {
            punctuation: /^[$`]|[$`]$/
          }
        },
        interpreted: {
          pattern: /'(?:[^'\\]|\\.)*'/,
          inside: {
            punctuation: /^'|'$/ // See rest below
          }
        },
        string: /"(?:[^"\\]|\\.)*"/,
        variable: /\w+(?==)/,
        punctuation: /^\[|\]$|,/,
        operator: /=/,
        // The negative look-ahead prevents blank matches
        'attr-value': /(?!^\s+$).+/
      }
    };
    var asciidoc = (Prism.languages.asciidoc = {
      'comment-block': {
        pattern: /^(\/{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1/m,
        alias: 'comment'
      },
      table: {
        pattern: /^\|={3,}(?:(?:\r?\n|\r(?!\n)).*)*?(?:\r?\n|\r)\|={3,}$/m,
        inside: {
          specifiers: {
            pattern:
              /(?:(?:(?:\d+(?:\.\d+)?|\.\d+)[+*](?:[<^>](?:\.[<^>])?|\.[<^>])?|[<^>](?:\.[<^>])?|\.[<^>])[a-z]*|[a-z]+)(?=\|)/,
            alias: 'attr-value'
          },
          punctuation: {
            pattern: /(^|[^\\])[|!]=*/,
            lookbehind: true
          } // See rest below
        }
      },
      'passthrough-block': {
        pattern: /^(\+{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
        inside: {
          punctuation: /^\++|\++$/ // See rest below
        }
      },
      // Literal blocks and listing blocks
      'literal-block': {
        pattern: /^(-{4,}|\.{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
        inside: {
          punctuation: /^(?:-+|\.+)|(?:-+|\.+)$/ // See rest below
        }
      },
      // Sidebar blocks, quote blocks, example blocks and open blocks
      'other-block': {
        pattern:
          /^(--|\*{4,}|_{4,}|={4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
        inside: {
          punctuation: /^(?:-+|\*+|_+|=+)|(?:-+|\*+|_+|=+)$/ // See rest below
        }
      },
      // list-punctuation and list-label must appear before indented-block
      'list-punctuation': {
        pattern:
          /(^[ \t]*)(?:-|\*{1,5}|\.{1,5}|(?:[a-z]|\d+)\.|[xvi]+\))(?= )/im,
        lookbehind: true,
        alias: 'punctuation'
      },
      'list-label': {
        pattern: /(^[ \t]*)[a-z\d].+(?::{2,4}|;;)(?=\s)/im,
        lookbehind: true,
        alias: 'symbol'
      },
      'indented-block': {
        pattern: /((\r?\n|\r)\2)([ \t]+)\S.*(?:(?:\r?\n|\r)\3.+)*(?=\2{2}|$)/,
        lookbehind: true
      },
      comment: /^\/\/.*/m,
      title: {
        pattern:
          /^.+(?:\r?\n|\r)(?:={3,}|-{3,}|~{3,}|\^{3,}|\+{3,})$|^={1,5} .+|^\.(?![\s.]).*/m,
        alias: 'important',
        inside: {
          punctuation: /^(?:\.|=+)|(?:=+|-+|~+|\^+|\++)$/ // See rest below
        }
      },
      'attribute-entry': {
        pattern: /^:[^:\r\n]+:(?: .*?(?: \+(?:\r?\n|\r).*?)*)?$/m,
        alias: 'tag'
      },
      attributes: attributes,
      hr: {
        pattern: /^'{3,}$/m,
        alias: 'punctuation'
      },
      'page-break': {
        pattern: /^<{3,}$/m,
        alias: 'punctuation'
      },
      admonition: {
        pattern: /^(?:CAUTION|IMPORTANT|NOTE|TIP|WARNING):/m,
        alias: 'keyword'
      },
      callout: [
        {
          pattern: /(^[ \t]*)<?\d*>/m,
          lookbehind: true,
          alias: 'symbol'
        },
        {
          pattern: /<\d+>/,
          alias: 'symbol'
        }
      ],
      macro: {
        pattern:
          /\b[a-z\d][a-z\d-]*::?(?:[^\s\[\]]*\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
        inside: {
          function: /^[a-z\d-]+(?=:)/,
          punctuation: /^::?/,
          attributes: {
            pattern: /(?:\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
            inside: attributes.inside
          }
        }
      },
      inline: {
        /*
The initial look-behind prevents the highlighting of escaped quoted text.
Quoted text can be multi-line but cannot span an empty line.
All quoted text can have attributes before [foobar, 'foobar', baz="bar"].
First, we handle the constrained quotes.
Those must be bounded by non-word chars and cannot have spaces between the delimiter and the first char.
They are, in order: _emphasis_, ``double quotes'', `single quotes', `monospace`, 'emphasis', *strong*, +monospace+ and #unquoted#
Then we handle the unconstrained quotes.
Those do not have the restrictions of the constrained quotes.
They are, in order: __emphasis__, **strong**, ++monospace++, +++passthrough+++, ##unquoted##, $$passthrough$$, ~subscript~, ^superscript^, {attribute-reference}, [[anchor]], [[[bibliography anchor]]], <<xref>>, (((indexes))) and ((indexes))
*/
        pattern:
          /(^|[^\\])(?:(?:\B\[(?:[^\]\\"']|(["'])(?:(?!\2)[^\\]|\\.)*\2|\\.)*\])?(?:\b_(?!\s)(?: _|[^_\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: _|[^_\\\r\n]|\\.)+)*_\b|\B``(?!\s).+?(?:(?:\r?\n|\r).+?)*''\B|\B`(?!\s)(?:[^`'\s]|\s+\S)+['`]\B|\B(['*+#])(?!\s)(?: \3|(?!\3)[^\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: \3|(?!\3)[^\\\r\n]|\\.)+)*\3\B)|(?:\[(?:[^\]\\"']|(["'])(?:(?!\4)[^\\]|\\.)*\4|\\.)*\])?(?:(__|\*\*|\+\+\+?|##|\$\$|[~^]).+?(?:(?:\r?\n|\r).+?)*\5|\{[^}\r\n]+\}|\[\[\[?.+?(?:(?:\r?\n|\r).+?)*\]?\]\]|<<.+?(?:(?:\r?\n|\r).+?)*>>|\(\(\(?.+?(?:(?:\r?\n|\r).+?)*\)?\)\)))/m,
        lookbehind: true,
        inside: {
          attributes: attributes,
          url: {
            pattern: /^(?:\[\[\[?.+?\]?\]\]|<<.+?>>)$/,
            inside: {
              punctuation: /^(?:\[\[\[?|<<)|(?:\]\]\]?|>>)$/
            }
          },
          'attribute-ref': {
            pattern: /^\{.+\}$/,
            inside: {
              variable: {
                pattern: /(^\{)[a-z\d,+_-]+/,
                lookbehind: true
              },
              operator: /^[=?!#%@$]|!(?=[:}])/,
              punctuation: /^\{|\}$|::?/
            }
          },
          italic: {
            pattern: /^(['_])[\s\S]+\1$/,
            inside: {
              punctuation: /^(?:''?|__?)|(?:''?|__?)$/
            }
          },
          bold: {
            pattern: /^\*[\s\S]+\*$/,
            inside: {
              punctuation: /^\*\*?|\*\*?$/
            }
          },
          punctuation:
            /^(?:``?|\+{1,3}|##?|\$\$|[~^]|\(\(\(?)|(?:''?|\+{1,3}|##?|\$\$|[~^`]|\)?\)\))$/
        }
      },
      replacement: {
        pattern: /\((?:C|R|TM)\)/,
        alias: 'builtin'
      },
      entity: /&#?[\da-z]{1,8};/i,
      'line-continuation': {
        pattern: /(^| )\+$/m,
        lookbehind: true,
        alias: 'punctuation'
      }
    }); // Allow some nesting. There is no recursion though, so cloning should not be needed.
    function copyFromAsciiDoc(keys) {
      keys = keys.split(' ');
      var o = {};
      for (var i = 0, l = keys.length; i < l; i++) {
        o[keys[i]] = asciidoc[keys[i]];
      }
      return o
    }
    attributes.inside['interpreted'].inside.rest = copyFromAsciiDoc(
      'macro inline replacement entity'
    );
    asciidoc['passthrough-block'].inside.rest = copyFromAsciiDoc('macro');
    asciidoc['literal-block'].inside.rest = copyFromAsciiDoc('callout');
    asciidoc['table'].inside.rest = copyFromAsciiDoc(
      'comment-block passthrough-block literal-block other-block list-punctuation indented-block comment title attribute-entry attributes hr page-break admonition list-label callout macro inline replacement entity line-continuation'
    );
    asciidoc['other-block'].inside.rest = copyFromAsciiDoc(
      'table list-punctuation indented-block comment attribute-entry attributes hr page-break admonition list-label macro inline replacement entity line-continuation'
    );
    asciidoc['title'].inside.rest = copyFromAsciiDoc(
      'macro inline replacement entity'
    ); // Plugin to make entity title show the real entity, idea by Roman Komarov
    Prism.hooks.add('wrap', function (env) {
      if (env.type === 'entity') {
        env.attributes['title'] = env.content.value.replace(/&amp;/, '&');
      }
    });
    Prism.languages.adoc = Prism.languages.asciidoc;
  })(Prism);
}

var asm6502_1 = asm6502;
asm6502.displayName = 'asm6502';
asm6502.aliases = [];
function asm6502(Prism) {
  Prism.languages.asm6502 = {
    comment: /;.*/,
    directive: {
      pattern: /\.\w+(?= )/,
      alias: 'property'
    },
    string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    'op-code': {
      pattern:
        /\b(?:ADC|AND|ASL|BCC|BCS|BEQ|BIT|BMI|BNE|BPL|BRK|BVC|BVS|CLC|CLD|CLI|CLV|CMP|CPX|CPY|DEC|DEX|DEY|EOR|INC|INX|INY|JMP|JSR|LDA|LDX|LDY|LSR|NOP|ORA|PHA|PHP|PLA|PLP|ROL|ROR|RTI|RTS|SBC|SEC|SED|SEI|STA|STX|STY|TAX|TAY|TSX|TXA|TXS|TYA|adc|and|asl|bcc|bcs|beq|bit|bmi|bne|bpl|brk|bvc|bvs|clc|cld|cli|clv|cmp|cpx|cpy|dec|dex|dey|eor|inc|inx|iny|jmp|jsr|lda|ldx|ldy|lsr|nop|ora|pha|php|pla|plp|rol|ror|rti|rts|sbc|sec|sed|sei|sta|stx|sty|tax|tay|tsx|txa|txs|tya)\b/,
      alias: 'keyword'
    },
    'hex-number': {
      pattern: /#?\$[\da-f]{1,4}\b/i,
      alias: 'number'
    },
    'binary-number': {
      pattern: /#?%[01]+\b/,
      alias: 'number'
    },
    'decimal-number': {
      pattern: /#?\b\d+\b/,
      alias: 'number'
    },
    register: {
      pattern: /\b[xya]\b/i,
      alias: 'variable'
    },
    punctuation: /[(),:]/
  };
}

var asmatmel_1 = asmatmel;
asmatmel.displayName = 'asmatmel';
asmatmel.aliases = [];
function asmatmel(Prism) {
  Prism.languages.asmatmel = {
    comment: {
      pattern: /;.*/,
      greedy: true
    },
    string: {
      pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    constant: /\b(?:PORT[A-Z]|DDR[A-Z]|(?:DD|P)[A-Z](?:\d|[0-2]\d|3[01]))\b/,
    directive: {
      pattern: /\.\w+(?= )/,
      alias: 'property'
    },
    'r-register': {
      pattern: /\br(?:\d|[12]\d|3[01])\b/,
      alias: 'variable'
    },
    'op-code': {
      pattern:
        /\b(?:ADC|ADD|ADIW|AND|ANDI|ASR|BCLR|BLD|BRBC|BRBS|BRCC|BRCS|BREAK|BREQ|BRGE|BRHC|BRHS|BRID|BRIE|BRLO|BRLT|BRMI|BRNE|BRPL|BRSH|BRTC|BRTS|BRVC|BRVS|BSET|BST|CALL|CBI|CBR|CLC|CLH|CLI|CLN|CLR|CLS|CLT|CLV|CLZ|COM|CP|CPC|CPI|CPSE|DEC|DES|EICALL|EIJMP|ELPM|EOR|FMUL|FMULS|FMULSU|ICALL|IJMP|IN|INC|JMP|LAC|LAS|LAT|LD|LD[A-Za-z0-9]|LPM|LSL|LSR|MOV|MOVW|MUL|MULS|MULSU|NEG|NOP|OR|ORI|OUT|POP|PUSH|RCALL|RET|RETI|RJMP|ROL|ROR|SBC|SBCI|SBI|SBIC|SBIS|SBIW|SBR|SBRC|SBRS|SEC|SEH|SEI|SEN|SER|SES|SET|SEV|SEZ|SLEEP|SPM|ST|ST[A-Z0-9]|SUB|SUBI|SWAP|TST|WDR|XCH|adc|add|adiw|and|andi|asr|bclr|bld|brbc|brbs|brcc|brcs|break|breq|brge|brhc|brhs|brid|brie|brlo|brlt|brmi|brne|brpl|brsh|brtc|brts|brvc|brvs|bset|bst|call|cbi|cbr|clc|clh|cli|cln|clr|cls|clt|clv|clz|com|cp|cpc|cpi|cpse|dec|des|eicall|eijmp|elpm|eor|fmul|fmuls|fmulsu|icall|ijmp|in|inc|jmp|lac|las|lat|ld|ld[a-z0-9]|lpm|lsl|lsr|mov|movw|mul|muls|mulsu|neg|nop|or|ori|out|pop|push|rcall|ret|reti|rjmp|rol|ror|sbc|sbci|sbi|sbic|sbis|sbiw|sbr|sbrc|sbrs|sec|seh|sei|sen|ser|ses|set|sev|sez|sleep|spm|st|st[a-zA-Z0-9]|sub|subi|swap|tst|wdr|xch)\b/,
      alias: 'keyword'
    },
    'hex-number': {
      pattern: /#?\$[\da-f]{2,4}\b/i,
      alias: 'number'
    },
    'binary-number': {
      pattern: /#?%[01]+\b/,
      alias: 'number'
    },
    'decimal-number': {
      pattern: /#?\b\d+\b/,
      alias: 'number'
    },
    register: {
      pattern: /\b[acznvshtixy]\b/i,
      alias: 'variable'
    },
    operator: />>=?|<<=?|&&?|\|\|?|[-+*/%&|^!=<>?]=?/,
    punctuation: /[(),:]/
  };
}

var csharp_1;
var hasRequiredCsharp;

function requireCsharp () {
	if (hasRequiredCsharp) return csharp_1;
	hasRequiredCsharp = 1;

	csharp_1 = csharp;
	csharp.displayName = 'csharp';
	csharp.aliases = ['dotnet', 'cs'];
	function csharp(Prism) {
(function (Prism) {
	    /**
	     * Replaces all placeholders "<<n>>" of given pattern with the n-th replacement (zero based).
	     *
	     * Note: This is a simple text based replacement. Be careful when using backreferences!
	     *
	     * @param {string} pattern the given pattern.
	     * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.
	     * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.
	     * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source
	     */
	    function replace(pattern, replacements) {
	      return pattern.replace(/<<(\d+)>>/g, function (m, index) {
	        return '(?:' + replacements[+index] + ')'
	      })
	    }
	    /**
	     * @param {string} pattern
	     * @param {string[]} replacements
	     * @param {string} [flags]
	     * @returns {RegExp}
	     */
	    function re(pattern, replacements, flags) {
	      return RegExp(replace(pattern, replacements), flags || '')
	    }
	    /**
	     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.
	     *
	     * @param {string} pattern
	     * @param {number} depthLog2
	     * @returns {string}
	     */
	    function nested(pattern, depthLog2) {
	      for (var i = 0; i < depthLog2; i++) {
	        pattern = pattern.replace(/<<self>>/g, function () {
	          return '(?:' + pattern + ')'
	        });
	      }
	      return pattern.replace(/<<self>>/g, '[^\\s\\S]')
	    } // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/
	    var keywordKinds = {
	      // keywords which represent a return or variable type
	      type: 'bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void',
	      // keywords which are used to declare a type
	      typeDeclaration: 'class enum interface record struct',
	      // contextual keywords
	      // ("var" and "dynamic" are missing because they are used like types)
	      contextual:
	        'add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)',
	      // all other keywords
	      other:
	        'abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield'
	    }; // keywords
	    function keywordsToPattern(words) {
	      return '\\b(?:' + words.trim().replace(/ /g, '|') + ')\\b'
	    }
	    var typeDeclarationKeywords = keywordsToPattern(
	      keywordKinds.typeDeclaration
	    );
	    var keywords = RegExp(
	      keywordsToPattern(
	        keywordKinds.type +
	          ' ' +
	          keywordKinds.typeDeclaration +
	          ' ' +
	          keywordKinds.contextual +
	          ' ' +
	          keywordKinds.other
	      )
	    );
	    var nonTypeKeywords = keywordsToPattern(
	      keywordKinds.typeDeclaration +
	        ' ' +
	        keywordKinds.contextual +
	        ' ' +
	        keywordKinds.other
	    );
	    var nonContextualKeywords = keywordsToPattern(
	      keywordKinds.type +
	        ' ' +
	        keywordKinds.typeDeclaration +
	        ' ' +
	        keywordKinds.other
	    ); // types
	    var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2); // the idea behind the other forbidden characters is to prevent false positives. Same for tupleElement.
	    var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
	    var name = /@?\b[A-Za-z_]\w*\b/.source;
	    var genericName = replace(/<<0>>(?:\s*<<1>>)?/.source, [name, generic]);
	    var identifier = replace(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [
	      nonTypeKeywords,
	      genericName
	    ]);
	    var array = /\[\s*(?:,\s*)*\]/.source;
	    var typeExpressionWithoutTuple = replace(
	      /<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source,
	      [identifier, array]
	    );
	    var tupleElement = replace(
	      /[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source,
	      [generic, nestedRound, array]
	    );
	    var tuple = replace(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
	    var typeExpression = replace(
	      /(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source,
	      [tuple, identifier, array]
	    );
	    var typeInside = {
	      keyword: keywords,
	      punctuation: /[<>()?,.:[\]]/
	    }; // strings & characters
	    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#character-literals
	    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#string-literals
	    var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source; // simplified pattern
	    var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
	    var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
	    Prism.languages.csharp = Prism.languages.extend('clike', {
	      string: [
	        {
	          pattern: re(/(^|[^$\\])<<0>>/.source, [verbatimString]),
	          lookbehind: true,
	          greedy: true
	        },
	        {
	          pattern: re(/(^|[^@$\\])<<0>>/.source, [regularString]),
	          lookbehind: true,
	          greedy: true
	        }
	      ],
	      'class-name': [
	        {
	          // Using static
	          // using static System.Math;
	          pattern: re(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [
	            identifier
	          ]),
	          lookbehind: true,
	          inside: typeInside
	        },
	        {
	          // Using alias (type)
	          // using Project = PC.MyCompany.Project;
	          pattern: re(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [
	            name,
	            typeExpression
	          ]),
	          lookbehind: true,
	          inside: typeInside
	        },
	        {
	          // Using alias (alias)
	          // using Project = PC.MyCompany.Project;
	          pattern: re(/(\busing\s+)<<0>>(?=\s*=)/.source, [name]),
	          lookbehind: true
	        },
	        {
	          // Type declarations
	          // class Foo<A, B>
	          // interface Foo<out A, B>
	          pattern: re(/(\b<<0>>\s+)<<1>>/.source, [
	            typeDeclarationKeywords,
	            genericName
	          ]),
	          lookbehind: true,
	          inside: typeInside
	        },
	        {
	          // Single catch exception declaration
	          // catch(Foo)
	          // (things like catch(Foo e) is covered by variable declaration)
	          pattern: re(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier]),
	          lookbehind: true,
	          inside: typeInside
	        },
	        {
	          // Name of the type parameter of generic constraints
	          // where Foo : class
	          pattern: re(/(\bwhere\s+)<<0>>/.source, [name]),
	          lookbehind: true
	        },
	        {
	          // Casts and checks via as and is.
	          // as Foo<A>, is Bar<B>
	          // (things like if(a is Foo b) is covered by variable declaration)
	          pattern: re(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [
	            typeExpressionWithoutTuple
	          ]),
	          lookbehind: true,
	          inside: typeInside
	        },
	        {
	          // Variable, field and parameter declaration
	          // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
	          pattern: re(
	            /\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/
	              .source,
	            [typeExpression, nonContextualKeywords, name]
	          ),
	          inside: typeInside
	        }
	      ],
	      keyword: keywords,
	      // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
	      number:
	        /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
	      operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
	      punctuation: /\?\.?|::|[{}[\];(),.:]/
	    });
	    Prism.languages.insertBefore('csharp', 'number', {
	      range: {
	        pattern: /\.\./,
	        alias: 'operator'
	      }
	    });
	    Prism.languages.insertBefore('csharp', 'punctuation', {
	      'named-parameter': {
	        pattern: re(/([(,]\s*)<<0>>(?=\s*:)/.source, [name]),
	        lookbehind: true,
	        alias: 'punctuation'
	      }
	    });
	    Prism.languages.insertBefore('csharp', 'class-name', {
	      namespace: {
	        // namespace Foo.Bar {}
	        // using Foo.Bar;
	        pattern: re(
	          /(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source,
	          [name]
	        ),
	        lookbehind: true,
	        inside: {
	          punctuation: /\./
	        }
	      },
	      'type-expression': {
	        // default(Foo), typeof(Foo<Bar>), sizeof(int)
	        pattern: re(
	          /(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/
	            .source,
	          [nestedRound]
	        ),
	        lookbehind: true,
	        alias: 'class-name',
	        inside: typeInside
	      },
	      'return-type': {
	        // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
	        // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
	        // int Foo => 0; int Foo { get; set } = 0;
	        pattern: re(
	          /<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source,
	          [typeExpression, identifier]
	        ),
	        inside: typeInside,
	        alias: 'class-name'
	      },
	      'constructor-invocation': {
	        // new List<Foo<Bar[]>> { }
	        pattern: re(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
	        lookbehind: true,
	        inside: typeInside,
	        alias: 'class-name'
	      },
	      /*'explicit-implementation': {
	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
	inside: classNameInside,
	alias: 'class-name'
	},*/
	      'generic-method': {
	        // foo<Bar>()
	        pattern: re(/<<0>>\s*<<1>>(?=\s*\()/.source, [name, generic]),
	        inside: {
	          function: re(/^<<0>>/.source, [name]),
	          generic: {
	            pattern: RegExp(generic),
	            alias: 'class-name',
	            inside: typeInside
	          }
	        }
	      },
	      'type-list': {
	        // The list of types inherited or of generic constraints
	        // class Foo<F> : Bar, IList<FooBar>
	        // where F : Bar, IList<int>
	        pattern: re(
	          /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/
	            .source,
	          [
	            typeDeclarationKeywords,
	            genericName,
	            name,
	            typeExpression,
	            keywords.source,
	            nestedRound,
	            /\bnew\s*\(\s*\)/.source
	          ]
	        ),
	        lookbehind: true,
	        inside: {
	          'record-arguments': {
	            pattern: re(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [
	              genericName,
	              nestedRound
	            ]),
	            lookbehind: true,
	            greedy: true,
	            inside: Prism.languages.csharp
	          },
	          keyword: keywords,
	          'class-name': {
	            pattern: RegExp(typeExpression),
	            greedy: true,
	            inside: typeInside
	          },
	          punctuation: /[,()]/
	        }
	      },
	      preprocessor: {
	        pattern: /(^[\t ]*)#.*/m,
	        lookbehind: true,
	        alias: 'property',
	        inside: {
	          // highlight preprocessor directives as keywords
	          directive: {
	            pattern:
	              /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
	            lookbehind: true,
	            alias: 'keyword'
	          }
	        }
	      }
	    }); // attributes
	    var regularStringOrCharacter = regularString + '|' + character;
	    var regularStringCharacterOrComment = replace(
	      /\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source,
	      [regularStringOrCharacter]
	    );
	    var roundExpression = nested(
	      replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
	        regularStringCharacterOrComment
	      ]),
	      2
	    ); // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/#attribute-targets
	    var attrTarget =
	      /\b(?:assembly|event|field|method|module|param|property|return|type)\b/
	        .source;
	    var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [
	      identifier,
	      roundExpression
	    ]);
	    Prism.languages.insertBefore('csharp', 'class-name', {
	      attribute: {
	        // Attributes
	        // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
	        pattern: re(
	          /((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/
	            .source,
	          [attrTarget, attr]
	        ),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          target: {
	            pattern: re(/^<<0>>(?=\s*:)/.source, [attrTarget]),
	            alias: 'keyword'
	          },
	          'attribute-arguments': {
	            pattern: re(/\(<<0>>*\)/.source, [roundExpression]),
	            inside: Prism.languages.csharp
	          },
	          'class-name': {
	            pattern: RegExp(identifier),
	            inside: {
	              punctuation: /\./
	            }
	          },
	          punctuation: /[:,]/
	        }
	      }
	    }); // string interpolation
	    var formatString = /:[^}\r\n]+/.source; // multi line
	    var mInterpolationRound = nested(
	      replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
	        regularStringCharacterOrComment
	      ]),
	      2
	    );
	    var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
	      mInterpolationRound,
	      formatString
	    ]); // single line
	    var sInterpolationRound = nested(
	      replace(
	        /[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/
	          .source,
	        [regularStringOrCharacter]
	      ),
	      2
	    );
	    var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
	      sInterpolationRound,
	      formatString
	    ]);
	    function createInterpolationInside(interpolation, interpolationRound) {
	      return {
	        interpolation: {
	          pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
	          lookbehind: true,
	          inside: {
	            'format-string': {
	              pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [
	                interpolationRound,
	                formatString
	              ]),
	              lookbehind: true,
	              inside: {
	                punctuation: /^:/
	              }
	            },
	            punctuation: /^\{|\}$/,
	            expression: {
	              pattern: /[\s\S]+/,
	              alias: 'language-csharp',
	              inside: Prism.languages.csharp
	            }
	          }
	        },
	        string: /[\s\S]+/
	      }
	    }
	    Prism.languages.insertBefore('csharp', 'string', {
	      'interpolation-string': [
	        {
	          pattern: re(
	            /(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source,
	            [mInterpolation]
	          ),
	          lookbehind: true,
	          greedy: true,
	          inside: createInterpolationInside(mInterpolation, mInterpolationRound)
	        },
	        {
	          pattern: re(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [
	            sInterpolation
	          ]),
	          lookbehind: true,
	          greedy: true,
	          inside: createInterpolationInside(sInterpolation, sInterpolationRound)
	        }
	      ],
	      char: {
	        pattern: RegExp(character),
	        greedy: true
	      }
	    });
	    Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp;
	  })(Prism);
	}
	return csharp_1;
}

var refractorCsharp = requireCsharp();
var aspnet_1 = aspnet;
aspnet.displayName = 'aspnet';
aspnet.aliases = [];
function aspnet(Prism) {
  Prism.register(refractorCsharp);
  Prism.languages.aspnet = Prism.languages.extend('markup', {
    'page-directive': {
      pattern: /<%\s*@.*%>/,
      alias: 'tag',
      inside: {
        'page-directive': {
          pattern:
            /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
          alias: 'tag'
        },
        rest: Prism.languages.markup.tag.inside
      }
    },
    directive: {
      pattern: /<%.*%>/,
      alias: 'tag',
      inside: {
        directive: {
          pattern: /<%\s*?[$=%#:]{0,2}|%>/,
          alias: 'tag'
        },
        rest: Prism.languages.csharp
      }
    }
  }); // Regexp copied from prism-markup, with a negative look-ahead added
  Prism.languages.aspnet.tag.pattern =
    /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/; // match directives of attribute value foo="<% Bar %>"
  Prism.languages.insertBefore(
    'inside',
    'punctuation',
    {
      directive: Prism.languages.aspnet['directive']
    },
    Prism.languages.aspnet.tag.inside['attr-value']
  );
  Prism.languages.insertBefore('aspnet', 'comment', {
    'asp-comment': {
      pattern: /<%--[\s\S]*?--%>/,
      alias: ['asp', 'comment']
    }
  }); // script runat="server" contains csharp, not javascript
  Prism.languages.insertBefore(
    'aspnet',
    Prism.languages.javascript ? 'script' : 'tag',
    {
      'asp-script': {
        pattern:
          /(<script(?=.*runat=['"]?server\b)[^>]*>)[\s\S]*?(?=<\/script>)/i,
        lookbehind: true,
        alias: ['asp', 'script'],
        inside: Prism.languages.csharp || {}
      }
    }
  );
}

var autohotkey_1 = autohotkey;
autohotkey.displayName = 'autohotkey';
autohotkey.aliases = [];
function autohotkey(Prism) {
  // NOTES - follows first-first highlight method, block is locked after highlight, different from SyntaxHl
  Prism.languages.autohotkey = {
    comment: [
      {
        pattern: /(^|\s);.*/,
        lookbehind: true
      },
      {
        pattern:
          /(^[\t ]*)\/\*(?:[\r\n](?![ \t]*\*\/)|[^\r\n])*(?:[\r\n][ \t]*\*\/)?/m,
        lookbehind: true,
        greedy: true
      }
    ],
    tag: {
      // labels
      pattern: /^([ \t]*)[^\s,`":]+(?=:[ \t]*$)/m,
      lookbehind: true
    },
    string: /"(?:[^"\n\r]|"")*"/,
    variable: /%\w+%/,
    number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
    operator:
      /\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,
    boolean: /\b(?:false|true)\b/,
    selector:
      /\b(?:AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetRegView|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,
    constant:
      /\b(?:a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_fileencoding|a_formatfloat|a_formatinteger|a_gui|a_guicontrol|a_guicontrolevent|a_guievent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_is64bitos|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|a_priorkey|a_programfiles|a_programs|a_programscommon|a_ptrsize|a_regview|a_screendpi|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scripthwnd|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel|programfiles)\b/i,
    builtin:
      /\b(?:abs|acos|asc|asin|atan|ceil|chr|class|comobjactive|comobjarray|comobjconnect|comobjcreate|comobjerror|comobjflags|comobjget|comobjquery|comobjtype|comobjvalue|cos|dllcall|exp|fileexist|Fileopen|floor|format|il_add|il_create|il_destroy|instr|isfunc|islabel|IsObject|ln|log|ltrim|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|numget|numput|onmessage|regexmatch|regexreplace|registercallback|round|rtrim|sb_seticon|sb_setparts|sb_settext|sin|sqrt|strlen|strreplace|strsplit|substr|tan|tv_add|tv_delete|tv_get|tv_getchild|tv_getcount|tv_getnext|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__Call|__Get|__New|__Set)\b/i,
    symbol:
      /\b(?:alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,
    important:
      /#\b(?:AllowSameLineComments|ClipboardTimeout|CommentFlag|DerefChar|ErrorStdOut|EscapeChar|HotkeyInterval|HotkeyModifierTimeout|Hotstring|If|IfTimeout|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Include|IncludeAgain|InputLevel|InstallKeybdHook|InstallMouseHook|KeyHistory|MaxHotkeysPerInterval|MaxMem|MaxThreads|MaxThreadsBuffer|MaxThreadsPerHotkey|MenuMaskKey|NoEnv|NoTrayIcon|Persistent|SingleInstance|UseHook|Warn|WinActivateForce)\b/i,
    keyword:
      /\b(?:Abort|AboveNormal|Add|ahk_class|ahk_exe|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Catch|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|Finally|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|Region|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Throw|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|Try|TryAgain|Type|UnCheck|underline|Unicode|Unlock|Until|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i,
    function: /[^(); \t,\n+*\-=?>:\\\/<&%\[\]]+(?=\()/,
    punctuation: /[{}[\]():,]/
  };
}

var autoit_1 = autoit;
autoit.displayName = 'autoit';
autoit.aliases = [];
function autoit(Prism) {
  Prism.languages.autoit = {
    comment: [
      /;.*/,
      {
        // The multi-line comments delimiters can actually be commented out with ";"
        pattern:
          /(^[\t ]*)#(?:comments-start|cs)[\s\S]*?^[ \t]*#(?:ce|comments-end)/m,
        lookbehind: true
      }
    ],
    url: {
      pattern: /(^[\t ]*#include\s+)(?:<[^\r\n>]+>|"[^\r\n"]+")/m,
      lookbehind: true
    },
    string: {
      pattern: /(["'])(?:\1\1|(?!\1)[^\r\n])*\1/,
      greedy: true,
      inside: {
        variable: /([%$@])\w+\1/
      }
    },
    directive: {
      pattern: /(^[\t ]*)#[\w-]+/m,
      lookbehind: true,
      alias: 'keyword'
    },
    function: /\b\w+(?=\()/,
    // Variables and macros
    variable: /[$@]\w+/,
    keyword:
      /\b(?:Case|Const|Continue(?:Case|Loop)|Default|Dim|Do|Else(?:If)?|End(?:Func|If|Select|Switch|With)|Enum|Exit(?:Loop)?|For|Func|Global|If|In|Local|Next|Null|ReDim|Select|Static|Step|Switch|Then|To|Until|Volatile|WEnd|While|With)\b/i,
    number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
    boolean: /\b(?:False|True)\b/i,
    operator: /<[=>]?|[-+*\/=&>]=?|[?^]|\b(?:And|Not|Or)\b/i,
    punctuation: /[\[\]().,:]/
  };
}

var avisynth_1 = avisynth;
avisynth.displayName = 'avisynth';
avisynth.aliases = ['avs'];
function avisynth(Prism) {
(function (Prism) {
    function replace(pattern, replacements) {
      return pattern.replace(/<<(\d+)>>/g, function (m, index) {
        return replacements[+index]
      })
    }
    function re(pattern, replacements, flags) {
      return RegExp(replace(pattern, replacements), flags || '')
    }
    var types = /bool|clip|float|int|string|val/.source;
    var internals = [
      // bools
      /is(?:bool|clip|float|int|string)|defined|(?:(?:internal)?function|var)?exists?/
        .source, // control
      /apply|assert|default|eval|import|nop|select|undefined/.source, // global
      /opt_(?:allowfloataudio|avipadscanlines|dwchannelmask|enable_(?:b64a|planartopackedrgb|v210|y3_10_10|y3_10_16)|usewaveextensible|vdubplanarhack)|set(?:cachemode|maxcpu|memorymax|planarlegacyalignment|workingdir)/
        .source, // conv
      /hex(?:value)?|value/.source, // numeric
      /abs|ceil|continued(?:denominator|numerator)?|exp|floor|fmod|frac|log(?:10)?|max|min|muldiv|pi|pow|rand|round|sign|spline|sqrt/
        .source, // trig
      /a?sinh?|a?cosh?|a?tan[2h]?/.source, // bit
      /(?:bit(?:and|not|x?or|[lr]?shift[aslu]?|sh[lr]|sa[lr]|[lr]rotatel?|ro[rl]|te?st|set(?:count)?|cl(?:ea)?r|ch(?:an)?ge?))/
        .source, // runtime
      /average(?:[bgr]|chroma[uv]|luma)|(?:[rgb]|chroma[uv]|luma|rgb|[yuv](?=difference(?:fromprevious|tonext)))difference(?:fromprevious|tonext)?|[yuvrgb]plane(?:median|min|max|minmaxdifference)/
        .source, // script
      /getprocessinfo|logmsg|script(?:dir(?:utf8)?|file(?:utf8)?|name(?:utf8)?)|setlogparams/
        .source, // string
      /chr|(?:fill|find|left|mid|replace|rev|right)str|format|[lu]case|ord|str(?:cmpi?|fromutf8|len|toutf8)|time|trim(?:all|left|right)/
        .source, // version
      /isversionorgreater|version(?:number|string)/.source, // helper
      /buildpixeltype|colorspacenametopixeltype/.source, // avsplus
      /addautoloaddir|on(?:cpu|cuda)|prefetch|setfiltermtmode/.source
    ].join('|');
    var properties = [
      // content
      /has(?:audio|video)/.source, // resolution
      /height|width/.source, // framerate
      /frame(?:count|rate)|framerate(?:denominator|numerator)/.source, // interlacing
      /getparity|is(?:field|frame)based/.source, // color format
      /bitspercomponent|componentsize|hasalpha|is(?:planar(?:rgba?)?|interleaved|rgb(?:24|32|48|64)?|y(?:8|u(?:va?|y2))?|yv(?:12|16|24|411)|420|422|444|packedrgb)|numcomponents|pixeltype/
        .source, // audio
      /audio(?:bits|channels|duration|length(?:[fs]|hi|lo)?|rate)|isaudio(?:float|int)/
        .source
    ].join('|');
    var filters = [
      // source
      /avi(?:file)?source|directshowsource|image(?:reader|source|sourceanim)|opendmlsource|segmented(?:avisource|directshowsource)|wavsource/
        .source, // color
      /coloryuv|convertbacktoyuy2|convertto(?:RGB(?:24|32|48|64)|(?:planar)?RGBA?|Y8?|YV(?:12|16|24|411)|YUVA?(?:411|420|422|444)|YUY2)|fixluminance|gr[ae]yscale|invert|levels|limiter|mergea?rgb|merge(?:chroma|luma)|rgbadjust|show(?:alpha|blue|green|red)|swapuv|tweak|[uv]toy8?|ytouv/
        .source, // overlay
      /(?:colorkey|reset)mask|layer|mask(?:hs)?|merge|overlay|subtract/.source, // geometry
      /addborders|(?:bicubic|bilinear|blackman|gauss|lanczos4|lanczos|point|sinc|spline(?:16|36|64))resize|crop(?:bottom)?|flip(?:horizontal|vertical)|(?:horizontal|vertical)?reduceby2|letterbox|skewrows|turn(?:180|left|right)/
        .source, // pixel
      /blur|fixbrokenchromaupsampling|generalconvolution|(?:spatial|temporal)soften|sharpen/
        .source, // timeline
      /trim|(?:un)?alignedsplice|(?:assume|assumescaled|change|convert)FPS|(?:delete|duplicate)frame|dissolve|fade(?:in|io|out)[02]?|freezeframe|interleave|loop|reverse|select(?:even|odd|(?:range)?every)/
        .source, // interlace
      /assume[bt]ff|assume(?:field|frame)based|bob|complementparity|doubleweave|peculiarblend|pulldown|separate(?:columns|fields|rows)|swapfields|weave(?:columns|rows)?/
        .source, // audio
      /amplify(?:db)?|assumesamplerate|audiodub(?:ex)?|audiotrim|convertaudioto(?:(?:8|16|24|32)bit|float)|converttomono|delayaudio|ensurevbrmp3sync|get(?:left|right)?channel|kill(?:audio|video)|mergechannels|mixaudio|monotostereo|normalize|resampleaudio|ssrc|supereq|timestretch/
        .source, // conditional
      /animate|applyrange|conditional(?:filter|reader|select)|frameevaluate|scriptclip|tcp(?:server|source)|writefile(?:end|if|start)?/
        .source, // export
      /imagewriter/.source, // debug
      /blackness|blankclip|colorbars(?:hd)?|compare|dumpfiltergraph|echo|histogram|info|messageclip|preroll|setgraphanalysis|show(?:framenumber|smpte|time)|showfiveversions|stack(?:horizontal|vertical)|subtitle|tone|version/
        .source
    ].join('|');
    var allinternals = [internals, properties, filters].join('|');
    Prism.languages.avisynth = {
      comment: [
        {
          // Matches [* *] nestable block comments, but only supports 1 level of nested comments
          // /\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|<self>)*\*\]/
          pattern:
            /(^|[^\\])\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|\[\*(?:[^\[*]|\[(?!\*)|\*(?!\]))*\*\])*\*\]/,
          lookbehind: true,
          greedy: true
        },
        {
          // Matches /* */ block comments
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          // Matches # comments
          pattern: /(^|[^\\$])#.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      // Handle before strings because optional arguments are surrounded by double quotes
      argument: {
        pattern: re(/\b(?:<<0>>)\s+("?)\w+\1/.source, [types], 'i'),
        inside: {
          keyword: /^\w+/
        }
      },
      // Optional argument assignment
      'argument-label': {
        pattern: /([,(][\s\\]*)\w+\s*=(?!=)/,
        lookbehind: true,
        inside: {
          'argument-name': {
            pattern: /^\w+/,
            alias: 'punctuation'
          },
          punctuation: /=$/
        }
      },
      string: [
        {
          // triple double-quoted
          pattern: /"""[\s\S]*?"""/,
          greedy: true
        },
        {
          // single double-quoted
          pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
          greedy: true,
          inside: {
            constant: {
              // These *are* case-sensitive!
              pattern:
                /\b(?:DEFAULT_MT_MODE|(?:MAINSCRIPT|PROGRAM|SCRIPT)DIR|(?:MACHINE|USER)_(?:CLASSIC|PLUS)_PLUGINS)\b/
            }
          }
        }
      ],
      // The special "last" variable that takes the value of the last implicitly returned clip
      variable: /\b(?:last)\b/i,
      boolean: /\b(?:false|no|true|yes)\b/i,
      keyword:
        /\b(?:catch|else|for|function|global|if|return|try|while|__END__)\b/i,
      constant: /\bMT_(?:MULTI_INSTANCE|NICE_FILTER|SERIALIZED|SPECIAL_MT)\b/,
      // AviSynth's internal functions, filters, and properties
      'builtin-function': {
        pattern: re(/\b(?:<<0>>)\b/.source, [allinternals], 'i'),
        alias: 'function'
      },
      'type-cast': {
        pattern: re(/\b(?:<<0>>)(?=\s*\()/.source, [types], 'i'),
        alias: 'keyword'
      },
      // External/user-defined filters
      function: {
        pattern: /\b[a-z_]\w*(?=\s*\()|(\.)[a-z_]\w*\b/i,
        lookbehind: true
      },
      // Matches a \ as the first or last character on a line
      'line-continuation': {
        pattern: /(^[ \t]*)\\|\\(?=[ \t]*$)/m,
        lookbehind: true,
        alias: 'punctuation'
      },
      number:
        /\B\$(?:[\da-f]{6}|[\da-f]{8})\b|(?:(?:\b|\B-)\d+(?:\.\d*)?\b|\B\.\d+\b)/i,
      operator: /\+\+?|[!=<>]=?|&&|\|\||[?:*/%-]/,
      punctuation: /[{}\[\]();,.]/
    };
    Prism.languages.avs = Prism.languages.avisynth;
  })(Prism);
}

var avroIdl_1 = avroIdl;
avroIdl.displayName = 'avroIdl';
avroIdl.aliases = [];
function avroIdl(Prism) {
  // GitHub: https://github.com/apache/avro
  // Docs: https://avro.apache.org/docs/current/idl.html
  Prism.languages['avro-idl'] = {
    comment: {
      pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
      greedy: true
    },
    string: {
      pattern: /(^|[^\\])"(?:[^\r\n"\\]|\\.)*"/,
      lookbehind: true,
      greedy: true
    },
    annotation: {
      pattern: /@(?:[$\w.-]|`[^\r\n`]+`)+/,
      greedy: true,
      alias: 'function'
    },
    'function-identifier': {
      pattern: /`[^\r\n`]+`(?=\s*\()/,
      greedy: true,
      alias: 'function'
    },
    identifier: {
      pattern: /`[^\r\n`]+`/,
      greedy: true
    },
    'class-name': {
      pattern: /(\b(?:enum|error|protocol|record|throws)\b\s+)[$\w]+/,
      lookbehind: true,
      greedy: true
    },
    keyword:
      /\b(?:array|boolean|bytes|date|decimal|double|enum|error|false|fixed|float|idl|import|int|local_timestamp_ms|long|map|null|oneway|protocol|record|schema|string|throws|time_ms|timestamp_ms|true|union|uuid|void)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: [
      {
        pattern:
          /(^|[^\w.])-?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|0x(?:[a-f0-9]+(?:\.[a-f0-9]*)?|\.[a-f0-9]+)(?:p[+-]?\d+)?)[dfl]?(?![\w.])/i,
        lookbehind: true
      },
      /-?\b(?:Infinity|NaN)\b/
    ],
    operator: /=/,
    punctuation: /[()\[\]{}<>.:,;-]/
  };
  Prism.languages.avdl = Prism.languages['avro-idl'];
}

var bash_1 = bash;
bash.displayName = 'bash';
bash.aliases = ['shell'];
function bash(Prism) {
(function (Prism) {
    // $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\n' '|'
    // + LC_ALL, RANDOM, REPLY, SECONDS.
    // + make sure PS1..4 are here as they are not always set,
    // - some useless things.
    var envVars =
      '\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b';
    var commandAfterHeredoc = {
      pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
      lookbehind: true,
      alias: 'punctuation',
      // this looks reasonably well in all themes
      inside: null // see below
    };
    var insideString = {
      bash: commandAfterHeredoc,
      environment: {
        pattern: RegExp('\\$' + envVars),
        alias: 'constant'
      },
      variable: [
        // [0]: Arithmetic Environment
        {
          pattern: /\$?\(\([\s\S]+?\)\)/,
          greedy: true,
          inside: {
            // If there is a $ sign at the beginning highlight $(( and )) as variable
            variable: [
              {
                pattern: /(^\$\(\([\s\S]+)\)\)/,
                lookbehind: true
              },
              /^\$\(\(/
            ],
            number:
              /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
            // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
            operator:
              /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
            // If there is no $ sign at the beginning highlight (( and )) as punctuation
            punctuation: /\(\(?|\)\)?|,|;/
          }
        }, // [1]: Command Substitution
        {
          pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
          greedy: true,
          inside: {
            variable: /^\$\(|^`|\)$|`$/
          }
        }, // [2]: Brace expansion
        {
          pattern: /\$\{[^}]+\}/,
          greedy: true,
          inside: {
            operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
            punctuation: /[\[\]]/,
            environment: {
              pattern: RegExp('(\\{)' + envVars),
              lookbehind: true,
              alias: 'constant'
            }
          }
        },
        /\$(?:\w+|[#?*!@$])/
      ],
      // Escape sequences from echo and printf's manuals, and escaped quotes.
      entity:
        /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
    };
    Prism.languages.bash = {
      shebang: {
        pattern: /^#!\s*\/.*/,
        alias: 'important'
      },
      comment: {
        pattern: /(^|[^"{\\$])#.*/,
        lookbehind: true
      },
      'function-name': [
        // a) function foo {
        // b) foo() {
        // c) function foo() {
        // but not “foo {”
        {
          // a) and c)
          pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
          lookbehind: true,
          alias: 'function'
        },
        {
          // b)
          pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
          alias: 'function'
        }
      ],
      // Highlight variable names as variables in for and select beginnings.
      'for-or-select': {
        pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
        alias: 'variable',
        lookbehind: true
      },
      // Highlight variable names as variables in the left-hand part
      // of assignments (“=” and “+=”).
      'assign-left': {
        pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
        inside: {
          environment: {
            pattern: RegExp('(^|[\\s;|&]|[<>]\\()' + envVars),
            lookbehind: true,
            alias: 'constant'
          }
        },
        alias: 'variable',
        lookbehind: true
      },
      string: [
        // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
        {
          pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
          lookbehind: true,
          greedy: true,
          inside: insideString
        }, // Here-document with quotes around the tag
        // → No expansion (so no “inside”).
        {
          pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
          lookbehind: true,
          greedy: true,
          inside: {
            bash: commandAfterHeredoc
          }
        }, // “Normal” string
        {
          // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
          pattern:
            /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
          lookbehind: true,
          greedy: true,
          inside: insideString
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
          pattern: /(^|[^$\\])'[^']*'/,
          lookbehind: true,
          greedy: true
        },
        {
          // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
          pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
          greedy: true,
          inside: {
            entity: insideString.entity
          }
        }
      ],
      environment: {
        pattern: RegExp('\\$?' + envVars),
        alias: 'constant'
      },
      variable: insideString.variable,
      function: {
        pattern:
          /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
        lookbehind: true
      },
      keyword: {
        pattern:
          /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
        lookbehind: true
      },
      // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
      builtin: {
        pattern:
          /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
        lookbehind: true,
        // Alias added to make those easier to distinguish from strings.
        alias: 'class-name'
      },
      boolean: {
        pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
        lookbehind: true
      },
      'file-descriptor': {
        pattern: /\B&\d\b/,
        alias: 'important'
      },
      operator: {
        // Lots of redirections here, but not just that.
        pattern:
          /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
        inside: {
          'file-descriptor': {
            pattern: /^\d/,
            alias: 'important'
          }
        }
      },
      punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
      number: {
        pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
        lookbehind: true
      }
    };
    commandAfterHeredoc.inside = Prism.languages.bash;
    /* Patterns in command substitution. */
    var toBeCopied = [
      'comment',
      'function-name',
      'for-or-select',
      'assign-left',
      'string',
      'environment',
      'function',
      'keyword',
      'builtin',
      'boolean',
      'file-descriptor',
      'operator',
      'punctuation',
      'number'
    ];
    var inside = insideString.variable[1].inside;
    for (var i = 0; i < toBeCopied.length; i++) {
      inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];
    }
    Prism.languages.shell = Prism.languages.bash;
  })(Prism);
}

var basic_1 = basic;
basic.displayName = 'basic';
basic.aliases = [];
function basic(Prism) {
  Prism.languages.basic = {
    comment: {
      pattern: /(?:!|REM\b).+/i,
      inside: {
        keyword: /^REM/i
      }
    },
    string: {
      pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
      greedy: true
    },
    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
    keyword:
      /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
    function:
      /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
    operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
    punctuation: /[,;:()]/
  };
}

var batch_1 = batch;
batch.displayName = 'batch';
batch.aliases = [];
function batch(Prism) {
(function (Prism) {
    var variable = /%%?[~:\w]+%?|!\S+!/;
    var parameter = {
      pattern: /\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im,
      alias: 'attr-name',
      inside: {
        punctuation: /:/
      }
    };
    var string = /"(?:[\\"]"|[^"])*"(?!")/;
    var number = /(?:\b|-)\d+\b/;
    Prism.languages.batch = {
      comment: [
        /^::.*/m,
        {
          pattern: /((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
          lookbehind: true
        }
      ],
      label: {
        pattern: /^:.*/m,
        alias: 'property'
      },
      command: [
        {
          // FOR command
          pattern:
            /((?:^|[&(])[ \t]*)for(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* \S+ in \([^)]+\) do/im,
          lookbehind: true,
          inside: {
            keyword: /\b(?:do|in)\b|^for\b/i,
            string: string,
            parameter: parameter,
            variable: variable,
            number: number,
            punctuation: /[()',]/
          }
        },
        {
          // IF command
          pattern:
            /((?:^|[&(])[ \t]*)if(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|(?!")(?:(?!==)\S)+)?(?:==| (?:equ|geq|gtr|leq|lss|neq) )(?:"[^"]*"|[^\s"]\S*))/im,
          lookbehind: true,
          inside: {
            keyword:
              /\b(?:cmdextversion|defined|errorlevel|exist|not)\b|^if\b/i,
            string: string,
            parameter: parameter,
            variable: variable,
            number: number,
            operator: /\^|==|\b(?:equ|geq|gtr|leq|lss|neq)\b/i
          }
        },
        {
          // ELSE command
          pattern: /((?:^|[&()])[ \t]*)else\b/im,
          lookbehind: true,
          inside: {
            keyword: /^else\b/i
          }
        },
        {
          // SET command
          pattern:
            /((?:^|[&(])[ \t]*)set(?: \/[a-z](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
          lookbehind: true,
          inside: {
            keyword: /^set\b/i,
            string: string,
            parameter: parameter,
            variable: [variable, /\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/],
            number: number,
            operator: /[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/,
            punctuation: /[()',]/
          }
        },
        {
          // Other commands
          pattern:
            /((?:^|[&(])[ \t]*@?)\w+\b(?:"(?:[\\"]"|[^"])*"(?!")|[^"^&)\r\n]|\^(?:\r\n|[\s\S]))*/m,
          lookbehind: true,
          inside: {
            keyword: /^\w+\b/,
            string: string,
            parameter: parameter,
            label: {
              pattern: /(^\s*):\S+/m,
              lookbehind: true,
              alias: 'property'
            },
            variable: variable,
            number: number,
            operator: /\^/
          }
        }
      ],
      operator: /[&@]/,
      punctuation: /[()']/
    };
  })(Prism);
}

var bbcode_1 = bbcode;
bbcode.displayName = 'bbcode';
bbcode.aliases = ['shortcode'];
function bbcode(Prism) {
  Prism.languages.bbcode = {
    tag: {
      pattern:
        /\[\/?[^\s=\]]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))?(?:\s+[^\s=\]]+\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))*\s*\]/,
      inside: {
        tag: {
          pattern: /^\[\/?[^\s=\]]+/,
          inside: {
            punctuation: /^\[\/?/
          }
        },
        'attr-value': {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+)/,
          inside: {
            punctuation: [
              /^=/,
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: true
              }
            ]
          }
        },
        punctuation: /\]/,
        'attr-name': /[^\s=\]]+/
      }
    }
  };
  Prism.languages.shortcode = Prism.languages.bbcode;
}

var bicep_1 = bicep;
bicep.displayName = 'bicep';
bicep.aliases = [];
function bicep(Prism) {
  // based loosely upon: https://github.com/Azure/bicep/blob/main/src/textmate/bicep.tmlanguage
  Prism.languages.bicep = {
    comment: [
      {
        // multiline comments eg /* ASDF */
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
      },
      {
        // singleline comments eg // ASDF
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    property: [
      {
        pattern: /([\r\n][ \t]*)[a-z_]\w*(?=[ \t]*:)/i,
        lookbehind: true
      },
      {
        pattern: /([\r\n][ \t]*)'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'(?=[ \t]*:)/,
        lookbehind: true,
        greedy: true
      }
    ],
    string: [
      {
        pattern: /'''[^'][\s\S]*?'''/,
        greedy: true
      },
      {
        pattern: /(^|[^\\'])'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'/,
        lookbehind: true,
        greedy: true
      }
    ],
    'interpolated-string': {
      pattern: /(^|[^\\'])'(?:\\.|\$(?:(?!\{)|\{[^{}\r\n]*\})|[^'\\\r\n$])*'/,
      lookbehind: true,
      greedy: true,
      inside: {
        interpolation: {
          pattern: /\$\{[^{}\r\n]*\}/,
          inside: {
            expression: {
              pattern: /(^\$\{)[\s\S]+(?=\}$)/,
              lookbehind: true
            },
            punctuation: /^\$\{|\}$/
          }
        },
        string: /[\s\S]+/
      }
    },
    datatype: {
      pattern: /(\b(?:output|param)\b[ \t]+\w+[ \t]+)\w+\b/,
      lookbehind: true,
      alias: 'class-name'
    },
    boolean: /\b(?:false|true)\b/,
    // https://github.com/Azure/bicep/blob/114a3251b4e6e30082a58729f19a8cc4e374ffa6/src/textmate/bicep.tmlanguage#L184
    keyword:
      /\b(?:existing|for|if|in|module|null|output|param|resource|targetScope|var)\b/,
    decorator: /@\w+\b/,
    function: /\b[a-z_]\w*(?=[ \t]*\()/i,
    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
    operator:
      /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
    punctuation: /[{}[\];(),.:]/
  };
  Prism.languages.bicep['interpolated-string'].inside['interpolation'].inside[
    'expression'
  ].inside = Prism.languages.bicep;
}

var birb_1 = birb;
birb.displayName = 'birb';
birb.aliases = [];
function birb(Prism) {
  Prism.languages.birb = Prism.languages.extend('clike', {
    string: {
      pattern: /r?("|')(?:\\.|(?!\1)[^\\])*\1/,
      greedy: true
    },
    'class-name': [
      /\b[A-Z](?:[\d_]*[a-zA-Z]\w*)?\b/, // matches variable and function return types (parameters as well).
      /\b(?:[A-Z]\w*|(?!(?:var|void)\b)[a-z]\w*)(?=\s+\w+\s*[;,=()])/
    ],
    keyword:
      /\b(?:assert|break|case|class|const|default|else|enum|final|follows|for|grab|if|nest|new|next|noSeeb|return|static|switch|throw|var|void|while)\b/,
    operator: /\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?|:/,
    variable: /\b[a-z_]\w*\b/
  });
  Prism.languages.insertBefore('birb', 'function', {
    metadata: {
      pattern: /<\w+>/,
      greedy: true,
      alias: 'symbol'
    }
  });
}

var refractorC = c_1;
var bison_1 = bison;
bison.displayName = 'bison';
bison.aliases = [];
function bison(Prism) {
  Prism.register(refractorC);
  Prism.languages.bison = Prism.languages.extend('c', {});
  Prism.languages.insertBefore('bison', 'comment', {
    bison: {
      // This should match all the beginning of the file
      // including the prologue(s), the bison declarations and
      // the grammar rules.
      pattern: /^(?:[^%]|%(?!%))*%%[\s\S]*?%%/,
      inside: {
        c: {
          // Allow for one level of nested braces
          pattern: /%\{[\s\S]*?%\}|\{(?:\{[^}]*\}|[^{}])*\}/,
          inside: {
            delimiter: {
              pattern: /^%?\{|%?\}$/,
              alias: 'punctuation'
            },
            'bison-variable': {
              pattern: /[$@](?:<[^\s>]+>)?[\w$]+/,
              alias: 'variable',
              inside: {
                punctuation: /<|>/
              }
            },
            rest: Prism.languages.c
          }
        },
        comment: Prism.languages.c.comment,
        string: Prism.languages.c.string,
        property: /\S+(?=:)/,
        keyword: /%\w+/,
        number: {
          pattern: /(^|[^@])\b(?:0x[\da-f]+|\d+)/i,
          lookbehind: true
        },
        punctuation: /%[%?]|[|:;\[\]<>]/
      }
    }
  });
}

var bnf_1 = bnf;
bnf.displayName = 'bnf';
bnf.aliases = ['rbnf'];
function bnf(Prism) {
  Prism.languages.bnf = {
    string: {
      pattern: /"[^\r\n"]*"|'[^\r\n']*'/
    },
    definition: {
      pattern: /<[^<>\r\n\t]+>(?=\s*::=)/,
      alias: ['rule', 'keyword'],
      inside: {
        punctuation: /^<|>$/
      }
    },
    rule: {
      pattern: /<[^<>\r\n\t]+>/,
      inside: {
        punctuation: /^<|>$/
      }
    },
    operator: /::=|[|()[\]{}*+?]|\.{3}/
  };
  Prism.languages.rbnf = Prism.languages.bnf;
}

var brainfuck_1 = brainfuck;
brainfuck.displayName = 'brainfuck';
brainfuck.aliases = [];
function brainfuck(Prism) {
  Prism.languages.brainfuck = {
    pointer: {
      pattern: /<|>/,
      alias: 'keyword'
    },
    increment: {
      pattern: /\+/,
      alias: 'inserted'
    },
    decrement: {
      pattern: /-/,
      alias: 'deleted'
    },
    branching: {
      pattern: /\[|\]/,
      alias: 'important'
    },
    operator: /[.,]/,
    comment: /\S+/
  };
}

var brightscript_1 = brightscript;
brightscript.displayName = 'brightscript';
brightscript.aliases = [];
function brightscript(Prism) {
  Prism.languages.brightscript = {
    comment: /(?:\brem|').*/i,
    'directive-statement': {
      pattern: /(^[\t ]*)#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if).*/im,
      lookbehind: true,
      alias: 'property',
      inside: {
        'error-message': {
          pattern: /(^#error).+/,
          lookbehind: true
        },
        directive: {
          pattern: /^#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if)/,
          alias: 'keyword'
        },
        expression: {
          pattern: /[\s\S]+/,
          inside: null // see below
        }
      }
    },
    property: {
      pattern:
        /([\r\n{,][\t ]*)(?:(?!\d)\w+|"(?:[^"\r\n]|"")*"(?!"))(?=[ \t]*:)/,
      lookbehind: true,
      greedy: true
    },
    string: {
      pattern: /"(?:[^"\r\n]|"")*"(?!")/,
      greedy: true
    },
    'class-name': {
      pattern: /(\bAs[\t ]+)\w+/i,
      lookbehind: true
    },
    keyword:
      /\b(?:As|Dim|Each|Else|Elseif|End|Exit|For|Function|Goto|If|In|Print|Return|Step|Stop|Sub|Then|To|While)\b/i,
    boolean: /\b(?:false|true)\b/i,
    function: /\b(?!\d)\w+(?=[\t ]*\()/,
    number: /(?:\b\d+(?:\.\d+)?(?:[ed][+-]\d+)?|&h[a-f\d]+)\b[%&!#]?/i,
    operator:
      /--|\+\+|>>=?|<<=?|<>|[-+*/\\<>]=?|[:^=?]|\b(?:and|mod|not|or)\b/i,
    punctuation: /[.,;()[\]{}]/,
    constant: /\b(?:LINE_NUM)\b/i
  };
  Prism.languages.brightscript['directive-statement'].inside.expression.inside =
    Prism.languages.brightscript;
}

var bro_1 = bro;
bro.displayName = 'bro';
bro.aliases = [];
function bro(Prism) {
  Prism.languages.bro = {
    comment: {
      pattern: /(^|[^\\$])#.*/,
      lookbehind: true,
      inside: {
        italic: /\b(?:FIXME|TODO|XXX)\b/
      }
    },
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    boolean: /\b[TF]\b/,
    function: {
      pattern: /(\b(?:event|function|hook)[ \t]+)\w+(?:::\w+)?/,
      lookbehind: true
    },
    builtin:
      /(?:@(?:load(?:-(?:plugin|sigs))?|unload|prefixes|ifn?def|else|(?:end)?if|DIR|FILENAME))|(?:&?(?:add_func|create_expire|default|delete_func|encrypt|error_handler|expire_func|group|log|mergeable|optional|persistent|priority|raw_output|read_expire|redef|rotate_interval|rotate_size|synchronized|type_column|write_expire))/,
    constant: {
      pattern: /(\bconst[ \t]+)\w+/i,
      lookbehind: true
    },
    keyword:
      /\b(?:add|addr|alarm|any|bool|break|const|continue|count|delete|double|else|enum|event|export|file|for|function|global|hook|if|in|int|interval|local|module|next|of|opaque|pattern|port|print|record|return|schedule|set|string|subnet|table|time|timeout|using|vector|when)\b/,
    operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&|\|\|?|\?|\*|\/|~|\^|%/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    punctuation: /[{}[\];(),.:]/
  };
}

var bsl_1 = bsl;
bsl.displayName = 'bsl';
bsl.aliases = [];
function bsl(Prism) {
  /* eslint-disable no-misleading-character-class */
  // 1C:Enterprise
  // https://github.com/Diversus23/
  //
  Prism.languages.bsl = {
    comment: /\/\/.*/,
    string: [
      // Строки
      // Strings
      {
        pattern: /"(?:[^"]|"")*"(?!")/,
        greedy: true
      }, // Дата и время
      // Date & time
      {
        pattern: /'(?:[^'\r\n\\]|\\.)*'/
      }
    ],
    keyword: [
      {
        // RU
        pattern:
          /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:пока|для|новый|прервать|попытка|исключение|вызватьисключение|иначе|конецпопытки|неопределено|функция|перем|возврат|конецфункции|если|иначеесли|процедура|конецпроцедуры|тогда|знач|экспорт|конецесли|из|каждого|истина|ложь|по|цикл|конеццикла|выполнить)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
        lookbehind: true
      },
      {
        // EN
        pattern:
          /\b(?:break|do|each|else|elseif|enddo|endfunction|endif|endprocedure|endtry|except|execute|export|false|for|function|if|in|new|null|procedure|raise|return|then|to|true|try|undefined|val|var|while)\b/i
      }
    ],
    number: {
      pattern:
        /(^(?=\d)|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:\d+(?:\.\d*)?|\.\d+)(?:E[+-]?\d+)?/i,
      lookbehind: true
    },
    operator: [
      /[<>+\-*/]=?|[%=]/, // RU
      {
        pattern:
          /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:и|или|не)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
        lookbehind: true
      }, // EN
      {
        pattern: /\b(?:and|not|or)\b/i
      }
    ],
    punctuation: /\(\.|\.\)|[()\[\]:;,.]/,
    directive: [
      // Теги препроцессора вида &Клиент, &Сервер, ...
      // Preprocessor tags of the type &Client, &Server, ...
      {
        pattern: /^([ \t]*)&.*/m,
        lookbehind: true,
        greedy: true,
        alias: 'important'
      }, // Инструкции препроцессора вида:
      // #Если Сервер Тогда
      // ...
      // #КонецЕсли
      // Preprocessor instructions of the form:
      // #If Server Then
      // ...
      // #EndIf
      {
        pattern: /^([ \t]*)#.*/gm,
        lookbehind: true,
        greedy: true,
        alias: 'important'
      }
    ]
  };
  Prism.languages.oscript = Prism.languages['bsl'];
}

var cfscript_1 = cfscript;
cfscript.displayName = 'cfscript';
cfscript.aliases = [];
function cfscript(Prism) {
  // https://cfdocs.org/script
  Prism.languages.cfscript = Prism.languages.extend('clike', {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        inside: {
          annotation: {
            pattern: /(?:^|[^.])@[\w\.]+/,
            alias: 'punctuation'
          }
        }
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    keyword:
      /\b(?:abstract|break|catch|component|continue|default|do|else|extends|final|finally|for|function|if|in|include|package|private|property|public|remote|required|rethrow|return|static|switch|throw|try|var|while|xml)\b(?!\s*=)/,
    operator: [
      /\+\+|--|&&|\|\||::|=>|[!=]==|<=?|>=?|[-+*/%&|^!=<>]=?|\?(?:\.|:)?|[?:]/,
      /\b(?:and|contains|eq|equal|eqv|gt|gte|imp|is|lt|lte|mod|not|or|xor)\b/
    ],
    scope: {
      pattern:
        /\b(?:application|arguments|cgi|client|cookie|local|session|super|this|variables)\b/,
      alias: 'global'
    },
    type: {
      pattern:
        /\b(?:any|array|binary|boolean|date|guid|numeric|query|string|struct|uuid|void|xml)\b/,
      alias: 'builtin'
    }
  });
  Prism.languages.insertBefore('cfscript', 'keyword', {
    // This must be declared before keyword because we use "function" inside the lookahead
    'function-variable': {
      pattern:
        /[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: 'function'
    }
  });
  delete Prism.languages.cfscript['class-name'];
  Prism.languages.cfc = Prism.languages['cfscript'];
}

var refractorCpp = requireCpp();
var chaiscript_1 = chaiscript;
chaiscript.displayName = 'chaiscript';
chaiscript.aliases = [];
function chaiscript(Prism) {
  Prism.register(refractorCpp);
  Prism.languages.chaiscript = Prism.languages.extend('clike', {
    string: {
      pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'/,
      lookbehind: true,
      greedy: true
    },
    'class-name': [
      {
        // e.g. class Rectangle { ... }
        pattern: /(\bclass\s+)\w+/,
        lookbehind: true
      },
      {
        // e.g. attr Rectangle::height, def Rectangle::area() { ... }
        pattern: /(\b(?:attr|def)\s+)\w+(?=\s*::)/,
        lookbehind: true
      }
    ],
    keyword:
      /\b(?:attr|auto|break|case|catch|class|continue|def|default|else|finally|for|fun|global|if|return|switch|this|try|var|while)\b/,
    number: [Prism.languages.cpp.number, /\b(?:Infinity|NaN)\b/],
    operator:
      />>=?|<<=?|\|\||&&|:[:=]?|--|\+\+|[=!<>+\-*/%|&^]=?|[?~]|`[^`\r\n]{1,4}`/
  });
  Prism.languages.insertBefore('chaiscript', 'operator', {
    'parameter-type': {
      // e.g. def foo(int x, Vector y) {...}
      pattern: /([,(]\s*)\w+(?=\s+\w)/,
      lookbehind: true,
      alias: 'class-name'
    }
  });
  Prism.languages.insertBefore('chaiscript', 'string', {
    'string-interpolation': {
      pattern:
        /(^|[^\\])"(?:[^"$\\]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*"/,
      lookbehind: true,
      greedy: true,
      inside: {
        interpolation: {
          pattern:
            /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\}/,
          lookbehind: true,
          inside: {
            'interpolation-expression': {
              pattern: /(^\$\{)[\s\S]+(?=\}$)/,
              lookbehind: true,
              inside: Prism.languages.chaiscript
            },
            'interpolation-punctuation': {
              pattern: /^\$\{|\}$/,
              alias: 'punctuation'
            }
          }
        },
        string: /[\s\S]+/
      }
    }
  });
}

var cil_1 = cil;
cil.displayName = 'cil';
cil.aliases = [];
function cil(Prism) {
  Prism.languages.cil = {
    comment: /\/\/.*/,
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    directive: {
      pattern: /(^|\W)\.[a-z]+(?=\s)/,
      lookbehind: true,
      alias: 'class-name'
    },
    // Actually an assembly reference
    variable: /\[[\w\.]+\]/,
    keyword:
      /\b(?:abstract|ansi|assembly|auto|autochar|beforefieldinit|bool|bstr|byvalstr|catch|char|cil|class|currency|date|decimal|default|enum|error|explicit|extends|extern|famandassem|family|famorassem|final(?:ly)?|float32|float64|hidebysig|u?int(?:8|16|32|64)?|iant|idispatch|implements|import|initonly|instance|interface|iunknown|literal|lpstr|lpstruct|lptstr|lpwstr|managed|method|native(?:Type)?|nested|newslot|object(?:ref)?|pinvokeimpl|private|privatescope|public|reqsecobj|rtspecialname|runtime|sealed|sequential|serializable|specialname|static|string|struct|syschar|tbstr|unicode|unmanagedexp|unsigned|value(?:type)?|variant|virtual|void)\b/,
    function:
      /\b(?:(?:constrained|no|readonly|tail|unaligned|volatile)\.)?(?:conv\.(?:[iu][1248]?|ovf\.[iu][1248]?(?:\.un)?|r\.un|r4|r8)|ldc\.(?:i4(?:\.\d+|\.[mM]1|\.s)?|i8|r4|r8)|ldelem(?:\.[iu][1248]?|\.r[48]|\.ref|a)?|ldind\.(?:[iu][1248]?|r[48]|ref)|stelem\.?(?:i[1248]?|r[48]|ref)?|stind\.(?:i[1248]?|r[48]|ref)?|end(?:fault|filter|finally)|ldarg(?:\.[0-3s]|a(?:\.s)?)?|ldloc(?:\.\d+|\.s)?|sub(?:\.ovf(?:\.un)?)?|mul(?:\.ovf(?:\.un)?)?|add(?:\.ovf(?:\.un)?)?|stloc(?:\.[0-3s])?|refany(?:type|val)|blt(?:\.un)?(?:\.s)?|ble(?:\.un)?(?:\.s)?|bgt(?:\.un)?(?:\.s)?|bge(?:\.un)?(?:\.s)?|unbox(?:\.any)?|init(?:blk|obj)|call(?:i|virt)?|brfalse(?:\.s)?|bne\.un(?:\.s)?|ldloca(?:\.s)?|brzero(?:\.s)?|brtrue(?:\.s)?|brnull(?:\.s)?|brinst(?:\.s)?|starg(?:\.s)?|leave(?:\.s)?|shr(?:\.un)?|rem(?:\.un)?|div(?:\.un)?|clt(?:\.un)?|alignment|castclass|ldvirtftn|beq(?:\.s)?|ckfinite|ldsflda|ldtoken|localloc|mkrefany|rethrow|cgt\.un|arglist|switch|stsfld|sizeof|newobj|newarr|ldsfld|ldnull|ldflda|isinst|throw|stobj|stfld|ldstr|ldobj|ldlen|ldftn|ldfld|cpobj|cpblk|break|br\.s|xor|shl|ret|pop|not|nop|neg|jmp|dup|cgt|ceq|box|and|or|br)\b/,
    boolean: /\b(?:false|true)\b/,
    number: /\b-?(?:0x[0-9a-f]+|\d+)(?:\.[0-9a-f]+)?\b/i,
    punctuation: /[{}[\];(),:=]|IL_[0-9A-Za-z]+/
  };
}

var clojure_1 = clojure;
clojure.displayName = 'clojure';
clojure.aliases = [];
function clojure(Prism) {
  // Copied from https://github.com/jeluard/prism-clojure
  Prism.languages.clojure = {
    comment: {
      pattern: /;.*/,
      greedy: true
    },
    string: {
      pattern: /"(?:[^"\\]|\\.)*"/,
      greedy: true
    },
    char: /\\\w+/,
    symbol: {
      pattern: /(^|[\s()\[\]{},])::?[\w*+!?'<>=/.-]+/,
      lookbehind: true
    },
    keyword: {
      pattern:
        /(\()(?:-|->|->>|\.|\.\.|\*|\/|\+|<|<=|=|==|>|>=|accessor|agent|agent-errors|aget|alength|all-ns|alter|and|append-child|apply|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assoc|await|await-for|bean|binding|bit-and|bit-not|bit-or|bit-shift-left|bit-shift-right|bit-xor|boolean|branch\?|butlast|byte|cast|char|children|class|clear-agent-errors|comment|commute|comp|comparator|complement|concat|cond|conj|cons|constantly|construct-proxy|contains\?|count|create-ns|create-struct|cycle|dec|declare|def|def-|definline|definterface|defmacro|defmethod|defmulti|defn|defn-|defonce|defproject|defprotocol|defrecord|defstruct|deftype|deref|difference|disj|dissoc|distinct|do|doall|doc|dorun|doseq|dosync|dotimes|doto|double|down|drop|drop-while|edit|end\?|ensure|eval|every\?|false\?|ffirst|file-seq|filter|find|find-doc|find-ns|find-var|first|float|flush|fn|fnseq|for|frest|gensym|get|get-proxy-class|hash-map|hash-set|identical\?|identity|if|if-let|if-not|import|in-ns|inc|index|insert-child|insert-left|insert-right|inspect-table|inspect-tree|instance\?|int|interleave|intersection|into|into-array|iterate|join|key|keys|keyword|keyword\?|last|lazy-cat|lazy-cons|left|lefts|let|line-seq|list|list\*|load|load-file|locking|long|loop|macroexpand|macroexpand-1|make-array|make-node|map|map-invert|map\?|mapcat|max|max-key|memfn|merge|merge-with|meta|min|min-key|monitor-enter|name|namespace|neg\?|new|newline|next|nil\?|node|not|not-any\?|not-every\?|not=|ns|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unmap|nth|nthrest|or|parse|partial|path|peek|pop|pos\?|pr|pr-str|print|print-str|println|println-str|prn|prn-str|project|proxy|proxy-mappings|quot|quote|rand|rand-int|range|re-find|re-groups|re-matcher|re-matches|re-pattern|re-seq|read|read-line|recur|reduce|ref|ref-set|refer|rem|remove|remove-method|remove-ns|rename|rename-keys|repeat|replace|replicate|resolve|rest|resultset-seq|reverse|rfirst|right|rights|root|rrest|rseq|second|select|select-keys|send|send-off|seq|seq-zip|seq\?|set|set!|short|slurp|some|sort|sort-by|sorted-map|sorted-map-by|sorted-set|special-symbol\?|split-at|split-with|str|string\?|struct|struct-map|subs|subvec|symbol|symbol\?|sync|take|take-nth|take-while|test|throw|time|to-array|to-array-2d|tree-seq|true\?|try|union|up|update-proxy|val|vals|var|var-get|var-set|var\?|vector|vector-zip|vector\?|when|when-first|when-let|when-not|with-local-vars|with-meta|with-open|with-out-str|xml-seq|xml-zip|zero\?|zipmap|zipper)(?=[\s)]|$)/,
      lookbehind: true
    },
    boolean: /\b(?:false|nil|true)\b/,
    number: {
      pattern:
        /(^|[^\w$@])(?:\d+(?:[/.]\d+)?(?:e[+-]?\d+)?|0x[a-f0-9]+|[1-9]\d?r[a-z0-9]+)[lmn]?(?![\w$@])/i,
      lookbehind: true
    },
    function: {
      pattern: /((?:^|[^'])\()[\w*+!?'<>=/.-]+(?=[\s)]|$)/,
      lookbehind: true
    },
    operator: /[#@^`~]/,
    punctuation: /[{}\[\](),]/
  };
}

var cmake_1 = cmake;
cmake.displayName = 'cmake';
cmake.aliases = [];
function cmake(Prism) {
  Prism.languages.cmake = {
    comment: /#.*/,
    string: {
      pattern: /"(?:[^\\"]|\\.)*"/,
      greedy: true,
      inside: {
        interpolation: {
          pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
          inside: {
            punctuation: /\$\{|\}/,
            variable: /\w+/
          }
        }
      }
    },
    variable:
      /\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_(?:BINARY_DIR|DESCRIPTION|HOMEPAGE_URL|NAME|SOURCE_DIR|VERSION|VERSION_(?:MAJOR|MINOR|PATCH|TWEAK))|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE|XCODE_VERSION))\b/,
    property:
      /\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|GLOBAL_KEYWORD|GLOBAL_PROJECT_TYPES|GLOBAL_ROOTNAMESPACE|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
    keyword:
      /\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
    boolean: /\b(?:FALSE|OFF|ON|TRUE)\b/,
    namespace:
      /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
    operator:
      /\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
    inserted: {
      pattern: /\b\w+::\w+\b/,
      alias: 'class-name'
    },
    number: /\b\d+(?:\.\d+)*\b/,
    function: /\b[a-z_]\w*(?=\s*\()\b/i,
    punctuation: /[()>}]|\$[<{]/
  };
}

var cobol_1;
var hasRequiredCobol;

function requireCobol () {
	if (hasRequiredCobol) return cobol_1;
	hasRequiredCobol = 1;

	cobol_1 = cobol;
	cobol.displayName = 'cobol';
	cobol.aliases = [];
	function cobol(Prism) {
	  Prism.languages.cobol = {
	    comment: {
	      pattern: /\*>.*|(^[ \t]*)\*.*/m,
	      lookbehind: true,
	      greedy: true
	    },
	    string: {
	      pattern: /[xzgn]?(?:"(?:[^\r\n"]|"")*"(?!")|'(?:[^\r\n']|'')*'(?!'))/i,
	      greedy: true
	    },
	    level: {
	      pattern: /(^[ \t]*)\d+\b/m,
	      lookbehind: true,
	      greedy: true,
	      alias: 'number'
	    },
	    'class-name': {
	      // https://github.com/antlr/grammars-v4/blob/42edd5b687d183b5fa679e858a82297bd27141e7/cobol85/Cobol85.g4#L1015
	      pattern:
	        /(\bpic(?:ture)?\s+)(?:(?:[-\w$/,:*+<>]|\.(?!\s|$))(?:\(\d+\))?)+/i,
	      lookbehind: true,
	      inside: {
	        number: {
	          pattern: /(\()\d+/,
	          lookbehind: true
	        },
	        punctuation: /[()]/
	      }
	    },
	    keyword: {
	      pattern:
	        /(^|[^\w-])(?:ABORT|ACCEPT|ACCESS|ADD|ADDRESS|ADVANCING|AFTER|ALIGNED|ALL|ALPHABET|ALPHABETIC|ALPHABETIC-LOWER|ALPHABETIC-UPPER|ALPHANUMERIC|ALPHANUMERIC-EDITED|ALSO|ALTER|ALTERNATE|ANY|ARE|AREA|AREAS|AS|ASCENDING|ASCII|ASSIGN|ASSOCIATED-DATA|ASSOCIATED-DATA-LENGTH|AT|ATTRIBUTE|AUTHOR|AUTO|AUTO-SKIP|BACKGROUND-COLOR|BACKGROUND-COLOUR|BASIS|BEEP|BEFORE|BEGINNING|BELL|BINARY|BIT|BLANK|BLINK|BLOCK|BOTTOM|BOUNDS|BY|BYFUNCTION|BYTITLE|CALL|CANCEL|CAPABLE|CCSVERSION|CD|CF|CH|CHAINING|CHANGED|CHANNEL|CHARACTER|CHARACTERS|CLASS|CLASS-ID|CLOCK-UNITS|CLOSE|CLOSE-DISPOSITION|COBOL|CODE|CODE-SET|COL|COLLATING|COLUMN|COM-REG|COMMA|COMMITMENT|COMMON|COMMUNICATION|COMP|COMP-1|COMP-2|COMP-3|COMP-4|COMP-5|COMPUTATIONAL|COMPUTATIONAL-1|COMPUTATIONAL-2|COMPUTATIONAL-3|COMPUTATIONAL-4|COMPUTATIONAL-5|COMPUTE|CONFIGURATION|CONTAINS|CONTENT|CONTINUE|CONTROL|CONTROL-POINT|CONTROLS|CONVENTION|CONVERTING|COPY|CORR|CORRESPONDING|COUNT|CRUNCH|CURRENCY|CURSOR|DATA|DATA-BASE|DATE|DATE-COMPILED|DATE-WRITTEN|DAY|DAY-OF-WEEK|DBCS|DE|DEBUG-CONTENTS|DEBUG-ITEM|DEBUG-LINE|DEBUG-NAME|DEBUG-SUB-1|DEBUG-SUB-2|DEBUG-SUB-3|DEBUGGING|DECIMAL-POINT|DECLARATIVES|DEFAULT|DEFAULT-DISPLAY|DEFINITION|DELETE|DELIMITED|DELIMITER|DEPENDING|DESCENDING|DESTINATION|DETAIL|DFHRESP|DFHVALUE|DISABLE|DISK|DISPLAY|DISPLAY-1|DIVIDE|DIVISION|DONTCARE|DOUBLE|DOWN|DUPLICATES|DYNAMIC|EBCDIC|EGCS|EGI|ELSE|EMI|EMPTY-CHECK|ENABLE|END|END-ACCEPT|END-ADD|END-CALL|END-COMPUTE|END-DELETE|END-DIVIDE|END-EVALUATE|END-IF|END-MULTIPLY|END-OF-PAGE|END-PERFORM|END-READ|END-RECEIVE|END-RETURN|END-REWRITE|END-SEARCH|END-START|END-STRING|END-SUBTRACT|END-UNSTRING|END-WRITE|ENDING|ENTER|ENTRY|ENTRY-PROCEDURE|ENVIRONMENT|EOL|EOP|EOS|ERASE|ERROR|ESCAPE|ESI|EVALUATE|EVENT|EVERY|EXCEPTION|EXCLUSIVE|EXHIBIT|EXIT|EXPORT|EXTEND|EXTENDED|EXTERNAL|FD|FILE|FILE-CONTROL|FILLER|FINAL|FIRST|FOOTING|FOR|FOREGROUND-COLOR|FOREGROUND-COLOUR|FROM|FULL|FUNCTION|FUNCTION-POINTER|FUNCTIONNAME|GENERATE|GIVING|GLOBAL|GO|GOBACK|GRID|GROUP|HEADING|HIGH-VALUE|HIGH-VALUES|HIGHLIGHT|I-O|I-O-CONTROL|ID|IDENTIFICATION|IF|IMPLICIT|IMPORT|IN|INDEX|INDEXED|INDICATE|INITIAL|INITIALIZE|INITIATE|INPUT|INPUT-OUTPUT|INSPECT|INSTALLATION|INTEGER|INTO|INVALID|INVOKE|IS|JUST|JUSTIFIED|KANJI|KEPT|KEY|KEYBOARD|LABEL|LANGUAGE|LAST|LB|LD|LEADING|LEFT|LEFTLINE|LENGTH|LENGTH-CHECK|LIBACCESS|LIBPARAMETER|LIBRARY|LIMIT|LIMITS|LINAGE|LINAGE-COUNTER|LINE|LINE-COUNTER|LINES|LINKAGE|LIST|LOCAL|LOCAL-STORAGE|LOCK|LONG-DATE|LONG-TIME|LOW-VALUE|LOW-VALUES|LOWER|LOWLIGHT|MEMORY|MERGE|MESSAGE|MMDDYYYY|MODE|MODULES|MORE-LABELS|MOVE|MULTIPLE|MULTIPLY|NAMED|NATIONAL|NATIONAL-EDITED|NATIVE|NEGATIVE|NETWORK|NEXT|NO|NO-ECHO|NULL|NULLS|NUMBER|NUMERIC|NUMERIC-DATE|NUMERIC-EDITED|NUMERIC-TIME|OBJECT-COMPUTER|OCCURS|ODT|OF|OFF|OMITTED|ON|OPEN|OPTIONAL|ORDER|ORDERLY|ORGANIZATION|OTHER|OUTPUT|OVERFLOW|OVERLINE|OWN|PACKED-DECIMAL|PADDING|PAGE|PAGE-COUNTER|PASSWORD|PERFORM|PF|PH|PIC|PICTURE|PLUS|POINTER|PORT|POSITION|POSITIVE|PRINTER|PRINTING|PRIVATE|PROCEDURE|PROCEDURE-POINTER|PROCEDURES|PROCEED|PROCESS|PROGRAM|PROGRAM-ID|PROGRAM-LIBRARY|PROMPT|PURGE|QUEUE|QUOTE|QUOTES|RANDOM|RD|READ|READER|REAL|RECEIVE|RECEIVED|RECORD|RECORDING|RECORDS|RECURSIVE|REDEFINES|REEL|REF|REFERENCE|REFERENCES|RELATIVE|RELEASE|REMAINDER|REMARKS|REMOTE|REMOVAL|REMOVE|RENAMES|REPLACE|REPLACING|REPORT|REPORTING|REPORTS|REQUIRED|RERUN|RESERVE|RESET|RETURN|RETURN-CODE|RETURNING|REVERSE-VIDEO|REVERSED|REWIND|REWRITE|RF|RH|RIGHT|ROUNDED|RUN|SAME|SAVE|SCREEN|SD|SEARCH|SECTION|SECURE|SECURITY|SEGMENT|SEGMENT-LIMIT|SELECT|SEND|SENTENCE|SEPARATE|SEQUENCE|SEQUENTIAL|SET|SHARED|SHAREDBYALL|SHAREDBYRUNUNIT|SHARING|SHIFT-IN|SHIFT-OUT|SHORT-DATE|SIGN|SIZE|SORT|SORT-CONTROL|SORT-CORE-SIZE|SORT-FILE-SIZE|SORT-MERGE|SORT-MESSAGE|SORT-MODE-SIZE|SORT-RETURN|SOURCE|SOURCE-COMPUTER|SPACE|SPACES|SPECIAL-NAMES|STANDARD|STANDARD-1|STANDARD-2|START|STATUS|STOP|STRING|SUB-QUEUE-1|SUB-QUEUE-2|SUB-QUEUE-3|SUBTRACT|SUM|SUPPRESS|SYMBOL|SYMBOLIC|SYNC|SYNCHRONIZED|TABLE|TALLY|TALLYING|TAPE|TASK|TERMINAL|TERMINATE|TEST|TEXT|THEN|THREAD|THREAD-LOCAL|THROUGH|THRU|TIME|TIMER|TIMES|TITLE|TO|TODAYS-DATE|TODAYS-NAME|TOP|TRAILING|TRUNCATED|TYPE|TYPEDEF|UNDERLINE|UNIT|UNSTRING|UNTIL|UP|UPON|USAGE|USE|USING|VALUE|VALUES|VARYING|VIRTUAL|WAIT|WHEN|WHEN-COMPILED|WITH|WORDS|WORKING-STORAGE|WRITE|YEAR|YYYYDDD|YYYYMMDD|ZERO-FILL|ZEROES|ZEROS)(?![\w-])/i,
	      lookbehind: true
	    },
	    boolean: {
	      pattern: /(^|[^\w-])(?:false|true)(?![\w-])/i,
	      lookbehind: true
	    },
	    number: {
	      pattern:
	        /(^|[^\w-])(?:[+-]?(?:(?:\d+(?:[.,]\d+)?|[.,]\d+)(?:e[+-]?\d+)?|zero))(?![\w-])/i,
	      lookbehind: true
	    },
	    operator: [
	      /<>|[<>]=?|[=+*/&]/,
	      {
	        pattern: /(^|[^\w-])(?:-|and|equal|greater|less|not|or|than)(?![\w-])/i,
	        lookbehind: true
	      }
	    ],
	    punctuation: /[.:,()]/
	  };
	}
	return cobol_1;
}

var coffeescript_1;
var hasRequiredCoffeescript;

function requireCoffeescript () {
	if (hasRequiredCoffeescript) return coffeescript_1;
	hasRequiredCoffeescript = 1;

	coffeescript_1 = coffeescript;
	coffeescript.displayName = 'coffeescript';
	coffeescript.aliases = ['coffee'];
	function coffeescript(Prism) {
(function (Prism) {
	    // Ignore comments starting with { to privilege string interpolation highlighting
	    var comment = /#(?!\{).+/;
	    var interpolation = {
	      pattern: /#\{[^}]+\}/,
	      alias: 'variable'
	    };
	    Prism.languages.coffeescript = Prism.languages.extend('javascript', {
	      comment: comment,
	      string: [
	        // Strings are multiline
	        {
	          pattern: /'(?:\\[\s\S]|[^\\'])*'/,
	          greedy: true
	        },
	        {
	          // Strings are multiline
	          pattern: /"(?:\\[\s\S]|[^\\"])*"/,
	          greedy: true,
	          inside: {
	            interpolation: interpolation
	          }
	        }
	      ],
	      keyword:
	        /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
	      'class-member': {
	        pattern: /@(?!\d)\w+/,
	        alias: 'variable'
	      }
	    });
	    Prism.languages.insertBefore('coffeescript', 'comment', {
	      'multiline-comment': {
	        pattern: /###[\s\S]+?###/,
	        alias: 'comment'
	      },
	      // Block regexp can contain comments and interpolation
	      'block-regex': {
	        pattern: /\/{3}[\s\S]*?\/{3}/,
	        alias: 'regex',
	        inside: {
	          comment: comment,
	          interpolation: interpolation
	        }
	      }
	    });
	    Prism.languages.insertBefore('coffeescript', 'string', {
	      'inline-javascript': {
	        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
	        inside: {
	          delimiter: {
	            pattern: /^`|`$/,
	            alias: 'punctuation'
	          },
	          script: {
	            pattern: /[\s\S]+/,
	            alias: 'language-javascript',
	            inside: Prism.languages.javascript
	          }
	        }
	      },
	      // Block strings
	      'multiline-string': [
	        {
	          pattern: /'''[\s\S]*?'''/,
	          greedy: true,
	          alias: 'string'
	        },
	        {
	          pattern: /"""[\s\S]*?"""/,
	          greedy: true,
	          alias: 'string',
	          inside: {
	            interpolation: interpolation
	          }
	        }
	      ]
	    });
	    Prism.languages.insertBefore('coffeescript', 'keyword', {
	      // Object property
	      property: /(?!\d)\w+(?=\s*:(?!:))/
	    });
	    delete Prism.languages.coffeescript['template-string'];
	    Prism.languages.coffee = Prism.languages.coffeescript;
	  })(Prism);
	}
	return coffeescript_1;
}

var concurnas_1;
var hasRequiredConcurnas;

function requireConcurnas () {
	if (hasRequiredConcurnas) return concurnas_1;
	hasRequiredConcurnas = 1;

	concurnas_1 = concurnas;
	concurnas.displayName = 'concurnas';
	concurnas.aliases = ['conc'];
	function concurnas(Prism) {
	  Prism.languages.concurnas = {
	    comment: {
	      pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*)/,
	      lookbehind: true,
	      greedy: true
	    },
	    langext: {
	      pattern: /\b\w+\s*\|\|[\s\S]+?\|\|/,
	      greedy: true,
	      inside: {
	        'class-name': /^\w+/,
	        string: {
	          pattern: /(^\s*\|\|)[\s\S]+(?=\|\|$)/,
	          lookbehind: true
	        },
	        punctuation: /\|\|/
	      }
	    },
	    function: {
	      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/,
	      lookbehind: true
	    },
	    keyword:
	      /\b(?:abstract|actor|also|annotation|assert|async|await|bool|boolean|break|byte|case|catch|changed|char|class|closed|constant|continue|def|default|del|double|elif|else|enum|every|extends|false|finally|float|for|from|global|gpudef|gpukernel|if|import|in|init|inject|int|lambda|local|long|loop|match|new|nodefault|null|of|onchange|open|out|override|package|parfor|parforsync|post|pre|private|protected|provide|provider|public|return|shared|short|single|size_t|sizeof|super|sync|this|throw|trait|trans|transient|true|try|typedef|unchecked|using|val|var|void|while|with)\b/,
	    boolean: /\b(?:false|true)\b/,
	    number:
	      /\b0b[01][01_]*L?\b|\b0x(?:[\da-f_]*\.)?[\da-f_p+-]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfls]?/i,
	    punctuation: /[{}[\];(),.:]/,
	    operator:
	      /<==|>==|=>|->|<-|<>|&==|&<>|\?:?|\.\?|\+\+|--|[-+*/=<>]=?|[!^~]|\b(?:and|as|band|bor|bxor|comp|is|isnot|mod|or)\b=?/,
	    annotation: {
	      pattern: /@(?:\w+:)?(?:\w+|\[[^\]]+\])?/,
	      alias: 'builtin'
	    }
	  };
	  Prism.languages.insertBefore('concurnas', 'langext', {
	    'regex-literal': {
	      pattern: /\br("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      greedy: true,
	      inside: {
	        interpolation: {
	          pattern:
	            /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
	          lookbehind: true,
	          inside: Prism.languages.concurnas
	        },
	        regex: /[\s\S]+/
	      }
	    },
	    'string-literal': {
	      pattern: /(?:\B|\bs)("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      greedy: true,
	      inside: {
	        interpolation: {
	          pattern:
	            /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
	          lookbehind: true,
	          inside: Prism.languages.concurnas
	        },
	        string: /[\s\S]+/
	      }
	    }
	  });
	  Prism.languages.conc = Prism.languages.concurnas;
	}
	return concurnas_1;
}

var coq_1;
var hasRequiredCoq;

function requireCoq () {
	if (hasRequiredCoq) return coq_1;
	hasRequiredCoq = 1;

	coq_1 = coq;
	coq.displayName = 'coq';
	coq.aliases = [];
	function coq(Prism) {
(function (Prism) {
	    // https://github.com/coq/coq
	    var commentSource = /\(\*(?:[^(*]|\((?!\*)|\*(?!\))|<self>)*\*\)/.source;
	    for (var i = 0; i < 2; i++) {
	      commentSource = commentSource.replace(/<self>/g, function () {
	        return commentSource
	      });
	    }
	    commentSource = commentSource.replace(/<self>/g, '[]');
	    Prism.languages.coq = {
	      comment: RegExp(commentSource),
	      string: {
	        pattern: /"(?:[^"]|"")*"(?!")/,
	        greedy: true
	      },
	      attribute: [
	        {
	          pattern: RegExp(
	            /#\[(?:[^\[\]("]|"(?:[^"]|"")*"(?!")|\((?!\*)|<comment>)*\]/.source.replace(
	              /<comment>/g,
	              function () {
	                return commentSource
	              }
	            )
	          ),
	          greedy: true,
	          alias: 'attr-name',
	          inside: {
	            comment: RegExp(commentSource),
	            string: {
	              pattern: /"(?:[^"]|"")*"(?!")/,
	              greedy: true
	            },
	            operator: /=/,
	            punctuation: /^#\[|\]$|[,()]/
	          }
	        },
	        {
	          pattern:
	            /\b(?:Cumulative|Global|Local|Monomorphic|NonCumulative|Polymorphic|Private|Program)\b/,
	          alias: 'attr-name'
	        }
	      ],
	      keyword:
	        /\b(?:Abort|About|Add|Admit|Admitted|All|Arguments|As|Assumptions|Axiom|Axioms|Back|BackTo|Backtrace|BinOp|BinOpSpec|BinRel|Bind|Blacklist|Canonical|Case|Cd|Check|Class|Classes|Close|CoFixpoint|CoInductive|Coercion|Coercions|Collection|Combined|Compute|Conjecture|Conjectures|Constant|Constants|Constraint|Constructors|Context|Corollary|Create|CstOp|Custom|Cut|Debug|Declare|Defined|Definition|Delimit|Dependencies|Dependent|Derive|Diffs|Drop|Elimination|End|Entry|Equality|Eval|Example|Existential|Existentials|Existing|Export|Extern|Extraction|Fact|Fail|Field|File|Firstorder|Fixpoint|Flags|Focus|From|Funclass|Function|Functional|GC|Generalizable|Goal|Grab|Grammar|Graph|Guarded|Haskell|Heap|Hide|Hint|HintDb|Hints|Hypotheses|Hypothesis|IF|Identity|Immediate|Implicit|Implicits|Import|Include|Induction|Inductive|Infix|Info|Initial|InjTyp|Inline|Inspect|Instance|Instances|Intro|Intros|Inversion|Inversion_clear|JSON|Language|Left|Lemma|Let|Lia|Libraries|Library|Load|LoadPath|Locate|Ltac|Ltac2|ML|Match|Method|Minimality|Module|Modules|Morphism|Next|NoInline|Notation|Number|OCaml|Obligation|Obligations|Opaque|Open|Optimize|Parameter|Parameters|Parametric|Path|Paths|Prenex|Preterm|Primitive|Print|Profile|Projections|Proof|Prop|PropBinOp|PropOp|PropUOp|Property|Proposition|Pwd|Qed|Quit|Rec|Record|Recursive|Redirect|Reduction|Register|Relation|Remark|Remove|Require|Reserved|Reset|Resolve|Restart|Rewrite|Right|Ring|Rings|SProp|Saturate|Save|Scheme|Scope|Scopes|Search|SearchHead|SearchPattern|SearchRewrite|Section|Separate|Set|Setoid|Show|Signatures|Solve|Solver|Sort|Sortclass|Sorted|Spec|Step|Strategies|Strategy|String|Structure|SubClass|Subgraph|SuchThat|Tactic|Term|TestCompile|Theorem|Time|Timeout|To|Transparent|Type|Typeclasses|Types|Typing|UnOp|UnOpSpec|Undelimit|Undo|Unfocus|Unfocused|Unfold|Universe|Universes|Unshelve|Variable|Variables|Variant|Verbose|View|Visibility|Zify|_|apply|as|at|by|cofix|else|end|exists|exists2|fix|for|forall|fun|if|in|let|match|measure|move|removed|return|struct|then|using|wf|where|with)\b/,
	      number:
	        /\b(?:0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]+)?(?:p[+-]?\d[\d_]*)?|\d[\d_]*(?:\.[\d_]+)?(?:e[+-]?\d[\d_]*)?)\b/i,
	      punct: {
	        pattern: /@\{|\{\||\[=|:>/,
	        alias: 'punctuation'
	      },
	      operator:
	        /\/\\|\\\/|\.{2,3}|:{1,2}=|\*\*|[-=]>|<(?:->?|[+:=>]|<:)|>(?:=|->)|\|[-|]?|[-!%&*+/<=>?@^~']/,
	      punctuation: /\.\(|`\(|@\{|`\{|\{\||\[=|:>|[:.,;(){}\[\]]/
	    };
	  })(Prism);
	}
	return coq_1;
}

var ruby_1;
var hasRequiredRuby;

function requireRuby () {
	if (hasRequiredRuby) return ruby_1;
	hasRequiredRuby = 1;

	ruby_1 = ruby;
	ruby.displayName = 'ruby';
	ruby.aliases = ['rb'];
	function ruby(Prism) {
(function (Prism) {
	    Prism.languages.ruby = Prism.languages.extend('clike', {
	      comment: {
	        pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
	        greedy: true
	      },
	      'class-name': {
	        pattern:
	          /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
	        lookbehind: true,
	        inside: {
	          punctuation: /[.\\]/
	        }
	      },
	      keyword:
	        /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
	      operator:
	        /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
	      punctuation: /[(){}[\].,;]/
	    });
	    Prism.languages.insertBefore('ruby', 'operator', {
	      'double-colon': {
	        pattern: /::/,
	        alias: 'punctuation'
	      }
	    });
	    var interpolation = {
	      pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
	      lookbehind: true,
	      inside: {
	        content: {
	          pattern: /^(#\{)[\s\S]+(?=\}$)/,
	          lookbehind: true,
	          inside: Prism.languages.ruby
	        },
	        delimiter: {
	          pattern: /^#\{|\}$/,
	          alias: 'punctuation'
	        }
	      }
	    };
	    delete Prism.languages.ruby.function;
	    var percentExpression =
	      '(?:' +
	      [
	        /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
	        /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
	        /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
	        /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
	        /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
	      ].join('|') +
	      ')';
	    var symbolName =
	      /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/
	        .source;
	    Prism.languages.insertBefore('ruby', 'keyword', {
	      'regex-literal': [
	        {
	          pattern: RegExp(
	            /%r/.source + percentExpression + /[egimnosux]{0,6}/.source
	          ),
	          greedy: true,
	          inside: {
	            interpolation: interpolation,
	            regex: /[\s\S]+/
	          }
	        },
	        {
	          pattern:
	            /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
	          lookbehind: true,
	          greedy: true,
	          inside: {
	            interpolation: interpolation,
	            regex: /[\s\S]+/
	          }
	        }
	      ],
	      variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
	      symbol: [
	        {
	          pattern: RegExp(/(^|[^:]):/.source + symbolName),
	          lookbehind: true,
	          greedy: true
	        },
	        {
	          pattern: RegExp(
	            /([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source
	          ),
	          lookbehind: true,
	          greedy: true
	        }
	      ],
	      'method-definition': {
	        pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
	        lookbehind: true,
	        inside: {
	          function: /\b\w+$/,
	          keyword: /^self\b/,
	          'class-name': /^\w+/,
	          punctuation: /\./
	        }
	      }
	    });
	    Prism.languages.insertBefore('ruby', 'string', {
	      'string-literal': [
	        {
	          pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
	          greedy: true,
	          inside: {
	            interpolation: interpolation,
	            string: /[\s\S]+/
	          }
	        },
	        {
	          pattern:
	            /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
	          greedy: true,
	          inside: {
	            interpolation: interpolation,
	            string: /[\s\S]+/
	          }
	        },
	        {
	          pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
	          alias: 'heredoc-string',
	          greedy: true,
	          inside: {
	            delimiter: {
	              pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
	              inside: {
	                symbol: /\b\w+/,
	                punctuation: /^<<[-~]?/
	              }
	            },
	            interpolation: interpolation,
	            string: /[\s\S]+/
	          }
	        },
	        {
	          pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
	          alias: 'heredoc-string',
	          greedy: true,
	          inside: {
	            delimiter: {
	              pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
	              inside: {
	                symbol: /\b\w+/,
	                punctuation: /^<<[-~]?'|'$/
	              }
	            },
	            string: /[\s\S]+/
	          }
	        }
	      ],
	      'command-literal': [
	        {
	          pattern: RegExp(/%x/.source + percentExpression),
	          greedy: true,
	          inside: {
	            interpolation: interpolation,
	            command: {
	              pattern: /[\s\S]+/,
	              alias: 'string'
	            }
	          }
	        },
	        {
	          pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
	          greedy: true,
	          inside: {
	            interpolation: interpolation,
	            command: {
	              pattern: /[\s\S]+/,
	              alias: 'string'
	            }
	          }
	        }
	      ]
	    });
	    delete Prism.languages.ruby.string;
	    Prism.languages.insertBefore('ruby', 'number', {
	      builtin:
	        /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
	      constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
	    });
	    Prism.languages.rb = Prism.languages.ruby;
	  })(Prism);
	}
	return ruby_1;
}

var crystal_1;
var hasRequiredCrystal;

function requireCrystal () {
	if (hasRequiredCrystal) return crystal_1;
	hasRequiredCrystal = 1;
	var refractorRuby = requireRuby();
	crystal_1 = crystal;
	crystal.displayName = 'crystal';
	crystal.aliases = [];
	function crystal(Prism) {
	  Prism.register(refractorRuby)
	  ;(function (Prism) {
	    Prism.languages.crystal = Prism.languages.extend('ruby', {
	      keyword: [
	        /\b(?:__DIR__|__END_LINE__|__FILE__|__LINE__|abstract|alias|annotation|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|ifdef|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|ptr|require|rescue|return|select|self|sizeof|struct|super|then|type|typeof|undef|uninitialized|union|unless|until|when|while|with|yield)\b/,
	        {
	          pattern: /(\.\s*)(?:is_a|responds_to)\?/,
	          lookbehind: true
	        }
	      ],
	      number:
	        /\b(?:0b[01_]*[01]|0o[0-7_]*[0-7]|0x[\da-fA-F_]*[\da-fA-F]|(?:\d(?:[\d_]*\d)?)(?:\.[\d_]*\d)?(?:[eE][+-]?[\d_]*\d)?)(?:_(?:[uif](?:8|16|32|64))?)?\b/,
	      operator: [/->/, Prism.languages.ruby.operator],
	      punctuation: /[(){}[\].,;\\]/
	    });
	    Prism.languages.insertBefore('crystal', 'string-literal', {
	      attribute: {
	        pattern: /@\[.*?\]/,
	        inside: {
	          delimiter: {
	            pattern: /^@\[|\]$/,
	            alias: 'punctuation'
	          },
	          attribute: {
	            pattern: /^(\s*)\w+/,
	            lookbehind: true,
	            alias: 'class-name'
	          },
	          args: {
	            pattern: /\S(?:[\s\S]*\S)?/,
	            inside: Prism.languages.crystal
	          }
	        }
	      },
	      expansion: {
	        pattern: /\{(?:\{.*?\}|%.*?%)\}/,
	        inside: {
	          content: {
	            pattern: /^(\{.)[\s\S]+(?=.\}$)/,
	            lookbehind: true,
	            inside: Prism.languages.crystal
	          },
	          delimiter: {
	            pattern: /^\{[\{%]|[\}%]\}$/,
	            alias: 'operator'
	          }
	        }
	      },
	      char: {
	        pattern:
	          /'(?:[^\\\r\n]{1,2}|\\(?:.|u(?:[A-Fa-f0-9]{1,4}|\{[A-Fa-f0-9]{1,6}\})))'/,
	        greedy: true
	      }
	    });
	  })(Prism);
	}
	return crystal_1;
}

var cshtml_1;
var hasRequiredCshtml;

function requireCshtml () {
	if (hasRequiredCshtml) return cshtml_1;
	hasRequiredCshtml = 1;
	var refractorCsharp = requireCsharp();
	cshtml_1 = cshtml;
	cshtml.displayName = 'cshtml';
	cshtml.aliases = ['razor'];
	function cshtml(Prism) {
	  Prism.register(refractorCsharp)
	  // Docs:
	  // https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-5.0&tabs=visual-studio
	  // https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-5.0
	  ;(function (Prism) {
	    var commentLike = /\/(?![/*])|\/\/.*[\r\n]|\/\*[^*]*(?:\*(?!\/)[^*]*)*\*\//
	      .source;
	    var stringLike =
	      /@(?!")|"(?:[^\r\n\\"]|\\.)*"|@"(?:[^\\"]|""|\\[\s\S])*"(?!")/.source +
	      '|' +
	      /'(?:(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'|(?=[^\\](?!')))/.source;
	    /**
	     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.
	     *
	     * @param {string} pattern
	     * @param {number} depthLog2
	     * @returns {string}
	     */
	    function nested(pattern, depthLog2) {
	      for (var i = 0; i < depthLog2; i++) {
	        pattern = pattern.replace(/<self>/g, function () {
	          return '(?:' + pattern + ')'
	        });
	      }
	      return pattern
	        .replace(/<self>/g, '[^\\s\\S]')
	        .replace(/<str>/g, '(?:' + stringLike + ')')
	        .replace(/<comment>/g, '(?:' + commentLike + ')')
	    }
	    var round = nested(/\((?:[^()'"@/]|<str>|<comment>|<self>)*\)/.source, 2);
	    var square = nested(/\[(?:[^\[\]'"@/]|<str>|<comment>|<self>)*\]/.source, 2);
	    var curly = nested(/\{(?:[^{}'"@/]|<str>|<comment>|<self>)*\}/.source, 2);
	    var angle = nested(/<(?:[^<>'"@/]|<str>|<comment>|<self>)*>/.source, 2); // Note about the above bracket patterns:
	    // They all ignore HTML expressions that might be in the C# code. This is a problem because HTML (like strings and
	    // comments) is parsed differently. This is a huge problem because HTML might contain brackets and quotes which
	    // messes up the bracket and string counting implemented by the above patterns.
	    //
	    // This problem is not fixable because 1) HTML expression are highly context sensitive and very difficult to detect
	    // and 2) they require one capturing group at every nested level. See the `tagRegion` pattern to admire the
	    // complexity of an HTML expression.
	    //
	    // To somewhat alleviate the problem a bit, the patterns for characters (e.g. 'a') is very permissive, it also
	    // allows invalid characters to support HTML expressions like this: <p>That's it!</p>.
	    var tagAttrs =
	      /(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?/
	        .source;
	    var tagContent = /(?!\d)[^\s>\/=$<%]+/.source + tagAttrs + /\s*\/?>/.source;
	    var tagRegion =
	      /\B@?/.source +
	      '(?:' +
	      /<([a-zA-Z][\w:]*)/.source +
	      tagAttrs +
	      /\s*>/.source +
	      '(?:' +
	      (/[^<]/.source +
	        '|' + // all tags that are not the start tag
	        // eslint-disable-next-line regexp/strict
	        /<\/?(?!\1\b)/.source +
	        tagContent +
	        '|' + // nested start tag
	        nested(
	          // eslint-disable-next-line regexp/strict
	          /<\1/.source +
	            tagAttrs +
	            /\s*>/.source +
	            '(?:' +
	            (/[^<]/.source +
	              '|' + // all tags that are not the start tag
	              // eslint-disable-next-line regexp/strict
	              /<\/?(?!\1\b)/.source +
	              tagContent +
	              '|' +
	              '<self>') +
	            ')*' + // eslint-disable-next-line regexp/strict
	            /<\/\1\s*>/.source,
	          2
	        )) +
	      ')*' + // eslint-disable-next-line regexp/strict
	      /<\/\1\s*>/.source +
	      '|' +
	      /</.source +
	      tagContent +
	      ')'; // Now for the actual language definition(s):
	    //
	    // Razor as a language has 2 parts:
	    //  1) CSHTML: A markup-like language that has been extended with inline C# code expressions and blocks.
	    //  2) C#+HTML: A variant of C# that can contain CSHTML tags as expressions.
	    //
	    // In the below code, both CSHTML and C#+HTML will be create as separate language definitions that reference each
	    // other. However, only CSHTML will be exported via `Prism.languages`.
	    Prism.languages.cshtml = Prism.languages.extend('markup', {});
	    var csharpWithHtml = Prism.languages.insertBefore(
	      'csharp',
	      'string',
	      {
	        html: {
	          pattern: RegExp(tagRegion),
	          greedy: true,
	          inside: Prism.languages.cshtml
	        }
	      },
	      {
	        csharp: Prism.languages.extend('csharp', {})
	      }
	    );
	    var cs = {
	      pattern: /\S[\s\S]*/,
	      alias: 'language-csharp',
	      inside: csharpWithHtml
	    };
	    Prism.languages.insertBefore('cshtml', 'prolog', {
	      'razor-comment': {
	        pattern: /@\*[\s\S]*?\*@/,
	        greedy: true,
	        alias: 'comment'
	      },
	      block: {
	        pattern: RegExp(
	          /(^|[^@])@/.source +
	            '(?:' +
	            [
	              // @{ ... }
	              curly, // @code{ ... }
	              /(?:code|functions)\s*/.source + curly, // @for (...) { ... }
	              /(?:for|foreach|lock|switch|using|while)\s*/.source +
	                round +
	                /\s*/.source +
	                curly, // @do { ... } while (...);
	              /do\s*/.source +
	                curly +
	                /\s*while\s*/.source +
	                round +
	                /(?:\s*;)?/.source, // @try { ... } catch (...) { ... } finally { ... }
	              /try\s*/.source +
	                curly +
	                /\s*catch\s*/.source +
	                round +
	                /\s*/.source +
	                curly +
	                /\s*finally\s*/.source +
	                curly, // @if (...) {...} else if (...) {...} else {...}
	              /if\s*/.source +
	                round +
	                /\s*/.source +
	                curly +
	                '(?:' +
	                /\s*else/.source +
	                '(?:' +
	                /\s+if\s*/.source +
	                round +
	                ')?' +
	                /\s*/.source +
	                curly +
	                ')*'
	            ].join('|') +
	            ')'
	        ),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          keyword: /^@\w*/,
	          csharp: cs
	        }
	      },
	      directive: {
	        pattern:
	          /^([ \t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\s).*/m,
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          keyword: /^@\w+/,
	          csharp: cs
	        }
	      },
	      value: {
	        pattern: RegExp(
	          /(^|[^@])@/.source +
	            /(?:await\b\s*)?/.source +
	            '(?:' +
	            /\w+\b/.source +
	            '|' +
	            round +
	            ')' +
	            '(?:' +
	            /[?!]?\.\w+\b/.source +
	            '|' +
	            round +
	            '|' +
	            square +
	            '|' +
	            angle +
	            round +
	            ')*'
	        ),
	        lookbehind: true,
	        greedy: true,
	        alias: 'variable',
	        inside: {
	          keyword: /^@/,
	          csharp: cs
	        }
	      },
	      'delegate-operator': {
	        pattern: /(^|[^@])@(?=<)/,
	        lookbehind: true,
	        alias: 'operator'
	      }
	    });
	    Prism.languages.razor = Prism.languages.cshtml;
	  })(Prism);
	}
	return cshtml_1;
}

var csp_1;
var hasRequiredCsp;

function requireCsp () {
	if (hasRequiredCsp) return csp_1;
	hasRequiredCsp = 1;

	csp_1 = csp;
	csp.displayName = 'csp';
	csp.aliases = [];
	function csp(Prism) {
(function (Prism) {
	    /**
	     * @param {string} source
	     * @returns {RegExp}
	     */
	    function value(source) {
	      return RegExp(
	        /([ \t])/.source + '(?:' + source + ')' + /(?=[\s;]|$)/.source,
	        'i'
	      )
	    }
	    Prism.languages.csp = {
	      directive: {
	        pattern:
	          /(^|[\s;])(?:base-uri|block-all-mixed-content|(?:child|connect|default|font|frame|img|manifest|media|object|prefetch|script|style|worker)-src|disown-opener|form-action|frame-(?:ancestors|options)|input-protection(?:-(?:clip|selectors))?|navigate-to|plugin-types|policy-uri|referrer|reflected-xss|report-(?:to|uri)|require-sri-for|sandbox|(?:script|style)-src-(?:attr|elem)|upgrade-insecure-requests)(?=[\s;]|$)/i,
	        lookbehind: true,
	        alias: 'property'
	      },
	      scheme: {
	        pattern: value(/[a-z][a-z0-9.+-]*:/.source),
	        lookbehind: true
	      },
	      none: {
	        pattern: value(/'none'/.source),
	        lookbehind: true,
	        alias: 'keyword'
	      },
	      nonce: {
	        pattern: value(/'nonce-[-+/\w=]+'/.source),
	        lookbehind: true,
	        alias: 'number'
	      },
	      hash: {
	        pattern: value(/'sha(?:256|384|512)-[-+/\w=]+'/.source),
	        lookbehind: true,
	        alias: 'number'
	      },
	      host: {
	        pattern: value(
	          /[a-z][a-z0-9.+-]*:\/\/[^\s;,']*/.source +
	            '|' +
	            /\*[^\s;,']*/.source +
	            '|' +
	            /[a-z0-9-]+(?:\.[a-z0-9-]+)+(?::[\d*]+)?(?:\/[^\s;,']*)?/.source
	        ),
	        lookbehind: true,
	        alias: 'url',
	        inside: {
	          important: /\*/
	        }
	      },
	      keyword: [
	        {
	          pattern: value(/'unsafe-[a-z-]+'/.source),
	          lookbehind: true,
	          alias: 'unsafe'
	        },
	        {
	          pattern: value(/'[a-z-]+'/.source),
	          lookbehind: true,
	          alias: 'safe'
	        }
	      ],
	      punctuation: /;/
	    };
	  })(Prism);
	}
	return csp_1;
}

var cssExtras_1;
var hasRequiredCssExtras;

function requireCssExtras () {
	if (hasRequiredCssExtras) return cssExtras_1;
	hasRequiredCssExtras = 1;

	cssExtras_1 = cssExtras;
	cssExtras.displayName = 'cssExtras';
	cssExtras.aliases = [];
	function cssExtras(Prism) {
(function (Prism) {
	    var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
	    var selectorInside;
	    Prism.languages.css.selector = {
	      pattern: Prism.languages.css.selector.pattern,
	      lookbehind: true,
	      inside: (selectorInside = {
	        'pseudo-element':
	          /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
	        'pseudo-class': /:[-\w]+/,
	        class: /\.[-\w]+/,
	        id: /#[-\w]+/,
	        attribute: {
	          pattern: RegExp('\\[(?:[^[\\]"\']|' + string.source + ')*\\]'),
	          greedy: true,
	          inside: {
	            punctuation: /^\[|\]$/,
	            'case-sensitivity': {
	              pattern: /(\s)[si]$/i,
	              lookbehind: true,
	              alias: 'keyword'
	            },
	            namespace: {
	              pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
	              lookbehind: true,
	              inside: {
	                punctuation: /\|$/
	              }
	            },
	            'attr-name': {
	              pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
	              lookbehind: true
	            },
	            'attr-value': [
	              string,
	              {
	                pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
	                lookbehind: true
	              }
	            ],
	            operator: /[|~*^$]?=/
	          }
	        },
	        'n-th': [
	          {
	            pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
	            lookbehind: true,
	            inside: {
	              number: /[\dn]+/,
	              operator: /[+-]/
	            }
	          },
	          {
	            pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
	            lookbehind: true
	          }
	        ],
	        combinator: />|\+|~|\|\|/,
	        // the `tag` token has been existed and removed.
	        // because we can't find a perfect tokenize to match it.
	        // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.
	        punctuation: /[(),]/
	      })
	    };
	    Prism.languages.css['atrule'].inside['selector-function-argument'].inside =
	      selectorInside;
	    Prism.languages.insertBefore('css', 'property', {
	      variable: {
	        pattern:
	          /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
	        lookbehind: true
	      }
	    });
	    var unit = {
	      pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
	      lookbehind: true
	    }; // 123 -123 .123 -.123 12.3 -12.3
	    var number = {
	      pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
	      lookbehind: true
	    };
	    Prism.languages.insertBefore('css', 'function', {
	      operator: {
	        pattern: /(\s)[+\-*\/](?=\s)/,
	        lookbehind: true
	      },
	      // CAREFUL!
	      // Previewers and Inline color use hexcode and color.
	      hexcode: {
	        pattern: /\B#[\da-f]{3,8}\b/i,
	        alias: 'color'
	      },
	      color: [
	        {
	          pattern:
	            /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
	          lookbehind: true
	        },
	        {
	          pattern:
	            /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
	          inside: {
	            unit: unit,
	            number: number,
	            function: /[\w-]+(?=\()/,
	            punctuation: /[(),]/
	          }
	        }
	      ],
	      // it's important that there is no boundary assertion after the hex digits
	      entity: /\\[\da-f]{1,8}/i,
	      unit: unit,
	      number: number
	    });
	  })(Prism);
	}
	return cssExtras_1;
}

var csv_1;
var hasRequiredCsv;

function requireCsv () {
	if (hasRequiredCsv) return csv_1;
	hasRequiredCsv = 1;

	csv_1 = csv;
	csv.displayName = 'csv';
	csv.aliases = [];
	function csv(Prism) {
	  // https://tools.ietf.org/html/rfc4180
	  Prism.languages.csv = {
	    value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
	    punctuation: /,/
	  };
	}
	return csv_1;
}

var cypher_1;
var hasRequiredCypher;

function requireCypher () {
	if (hasRequiredCypher) return cypher_1;
	hasRequiredCypher = 1;

	cypher_1 = cypher;
	cypher.displayName = 'cypher';
	cypher.aliases = [];
	function cypher(Prism) {
	  Prism.languages.cypher = {
	    // https://neo4j.com/docs/cypher-manual/current/syntax/comments/
	    comment: /\/\/.*/,
	    string: {
	      pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/,
	      greedy: true
	    },
	    'class-name': {
	      pattern: /(:\s*)(?:\w+|`(?:[^`\\\r\n])*`)(?=\s*[{):])/,
	      lookbehind: true,
	      greedy: true
	    },
	    relationship: {
	      pattern:
	        /(-\[\s*(?:\w+\s*|`(?:[^`\\\r\n])*`\s*)?:\s*|\|\s*:\s*)(?:\w+|`(?:[^`\\\r\n])*`)/,
	      lookbehind: true,
	      greedy: true,
	      alias: 'property'
	    },
	    identifier: {
	      pattern: /`(?:[^`\\\r\n])*`/,
	      greedy: true
	    },
	    variable: /\$\w+/,
	    // https://neo4j.com/docs/cypher-manual/current/syntax/reserved/
	    keyword:
	      /\b(?:ADD|ALL|AND|AS|ASC|ASCENDING|ASSERT|BY|CALL|CASE|COMMIT|CONSTRAINT|CONTAINS|CREATE|CSV|DELETE|DESC|DESCENDING|DETACH|DISTINCT|DO|DROP|ELSE|END|ENDS|EXISTS|FOR|FOREACH|IN|INDEX|IS|JOIN|KEY|LIMIT|LOAD|MANDATORY|MATCH|MERGE|NODE|NOT|OF|ON|OPTIONAL|OR|ORDER(?=\s+BY)|PERIODIC|REMOVE|REQUIRE|RETURN|SCALAR|SCAN|SET|SKIP|START|STARTS|THEN|UNION|UNIQUE|UNWIND|USING|WHEN|WHERE|WITH|XOR|YIELD)\b/i,
	    function: /\b\w+\b(?=\s*\()/,
	    boolean: /\b(?:false|null|true)\b/i,
	    number: /\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/,
	    // https://neo4j.com/docs/cypher-manual/current/syntax/operators/
	    operator: /:|<--?|--?>?|<>|=~?|[<>]=?|[+*/%^|]|\.\.\.?/,
	    punctuation: /[()[\]{},;.]/
	  };
	}
	return cypher_1;
}

var d_1;
var hasRequiredD;

function requireD () {
	if (hasRequiredD) return d_1;
	hasRequiredD = 1;

	d_1 = d;
	d.displayName = 'd';
	d.aliases = [];
	function d(Prism) {
	  Prism.languages.d = Prism.languages.extend('clike', {
	    comment: [
	      {
	        // Shebang
	        pattern: /^\s*#!.+/,
	        greedy: true
	      },
	      {
	        pattern: RegExp(
	          /(^|[^\\])/.source +
	            '(?:' +
	            [
	              // /+ comment +/
	              // Allow one level of nesting
	              /\/\+(?:\/\+(?:[^+]|\+(?!\/))*\+\/|(?!\/\+)[\s\S])*?\+\//.source, // // comment
	              /\/\/.*/.source, // /* comment */
	              /\/\*[\s\S]*?\*\//.source
	            ].join('|') +
	            ')'
	        ),
	        lookbehind: true,
	        greedy: true
	      }
	    ],
	    string: [
	      {
	        pattern: RegExp(
	          [
	            // r"", x""
	            /\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?/.source, // q"[]", q"()", q"<>", q"{}"
	            /\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/.source, // q"IDENT
	            // ...
	            // IDENT"
	            /\bq"((?!\d)\w+)$[\s\S]*?^\1"/.source, // q"//", q"||", etc.
	            // eslint-disable-next-line regexp/strict
	            /\bq"(.)[\s\S]*?\2"/.source, // eslint-disable-next-line regexp/strict
	            /(["`])(?:\\[\s\S]|(?!\3)[^\\])*\3[cwd]?/.source
	          ].join('|'),
	          'm'
	        ),
	        greedy: true
	      },
	      {
	        pattern: /\bq\{(?:\{[^{}]*\}|[^{}])*\}/,
	        greedy: true,
	        alias: 'token-string'
	      }
	    ],
	    // In order: $, keywords and special tokens, globally defined symbols
	    keyword:
	      /\$|\b(?:__(?:(?:DATE|EOF|FILE|FUNCTION|LINE|MODULE|PRETTY_FUNCTION|TIMESTAMP|TIME|VENDOR|VERSION)__|gshared|parameters|traits|vector)|abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|dstring|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|inout|int|interface|invariant|ireal|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|ptrdiff_t|public|pure|real|ref|return|scope|shared|short|size_t|static|string|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|wstring)\b/,
	    number: [
	      // The lookbehind and the negative look-ahead try to prevent bad highlighting of the .. operator
	      // Hexadecimal numbers must be handled separately to avoid problems with exponent "e"
	      /\b0x\.?[a-f\d_]+(?:(?!\.\.)\.[a-f\d_]*)?(?:p[+-]?[a-f\d_]+)?[ulfi]{0,4}/i,
	      {
	        pattern:
	          /((?:\.\.)?)(?:\b0b\.?|\b|\.)\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:e[+-]?\d[\d_]*)?[ulfi]{0,4}/i,
	        lookbehind: true
	      }
	    ],
	    operator:
	      /\|[|=]?|&[&=]?|\+[+=]?|-[-=]?|\.?\.\.|=[>=]?|!(?:i[ns]\b|<>?=?|>=?|=)?|\bi[ns]\b|(?:<[<>]?|>>?>?|\^\^|[*\/%^~])=?/
	  });
	  Prism.languages.insertBefore('d', 'string', {
	    // Characters
	    // 'a', '\\', '\n', '\xFF', '\377', '\uFFFF', '\U0010FFFF', '\quot'
	    char: /'(?:\\(?:\W|\w+)|[^\\])'/
	  });
	  Prism.languages.insertBefore('d', 'keyword', {
	    property: /\B@\w*/
	  });
	  Prism.languages.insertBefore('d', 'function', {
	    register: {
	      // Iasm registers
	      pattern:
	        /\b(?:[ABCD][LHX]|E?(?:BP|DI|SI|SP)|[BS]PL|[ECSDGF]S|CR[0234]|[DS]IL|DR[012367]|E[ABCD]X|X?MM[0-7]|R(?:1[0-5]|[89])[BWD]?|R[ABCD]X|R[BS]P|R[DS]I|TR[3-7]|XMM(?:1[0-5]|[89])|YMM(?:1[0-5]|\d))\b|\bST(?:\([0-7]\)|\b)/,
	      alias: 'variable'
	    }
	  });
	}
	return d_1;
}

var dart_1;
var hasRequiredDart;

function requireDart () {
	if (hasRequiredDart) return dart_1;
	hasRequiredDart = 1;

	dart_1 = dart;
	dart.displayName = 'dart';
	dart.aliases = [];
	function dart(Prism) {
(function (Prism) {
	    var keywords = [
	      /\b(?:async|sync|yield)\*/,
	      /\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|covariant|default|deferred|do|dynamic|else|enum|export|extends|extension|external|factory|final|finally|for|get|hide|if|implements|import|in|interface|library|mixin|new|null|on|operator|part|rethrow|return|set|show|static|super|switch|sync|this|throw|try|typedef|var|void|while|with|yield)\b/
	    ]; // Handles named imports, such as http.Client
	    var packagePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/
	      .source; // based on the dart naming conventions
	    var className = {
	      pattern: RegExp(packagePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
	      lookbehind: true,
	      inside: {
	        namespace: {
	          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
	          inside: {
	            punctuation: /\./
	          }
	        }
	      }
	    };
	    Prism.languages.dart = Prism.languages.extend('clike', {
	      'class-name': [
	        className,
	        {
	          // variables and parameters
	          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
	          pattern: RegExp(
	            packagePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source
	          ),
	          lookbehind: true,
	          inside: className.inside
	        }
	      ],
	      keyword: keywords,
	      operator:
	        /\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/
	    });
	    Prism.languages.insertBefore('dart', 'string', {
	      'string-literal': {
	        pattern:
	          /r?(?:("""|''')[\s\S]*?\1|(["'])(?:\\.|(?!\2)[^\\\r\n])*\2(?!\2))/,
	        greedy: true,
	        inside: {
	          interpolation: {
	            pattern:
	              /((?:^|[^\\])(?:\\{2})*)\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
	            lookbehind: true,
	            inside: {
	              punctuation: /^\$\{?|\}$/,
	              expression: {
	                pattern: /[\s\S]+/,
	                inside: Prism.languages.dart
	              }
	            }
	          },
	          string: /[\s\S]+/
	        }
	      },
	      string: undefined
	    });
	    Prism.languages.insertBefore('dart', 'class-name', {
	      metadata: {
	        pattern: /@\w+/,
	        alias: 'function'
	      }
	    });
	    Prism.languages.insertBefore('dart', 'class-name', {
	      generics: {
	        pattern:
	          /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,
	        inside: {
	          'class-name': className,
	          keyword: keywords,
	          punctuation: /[<>(),.:]/,
	          operator: /[?&|]/
	        }
	      }
	    });
	  })(Prism);
	}
	return dart_1;
}

var dataweave_1;
var hasRequiredDataweave;

function requireDataweave () {
	if (hasRequiredDataweave) return dataweave_1;
	hasRequiredDataweave = 1;

	dataweave_1 = dataweave;
	dataweave.displayName = 'dataweave';
	dataweave.aliases = [];
	function dataweave(Prism) {
(function (Prism) {
	    Prism.languages.dataweave = {
	      url: /\b[A-Za-z]+:\/\/[\w/:.?=&-]+|\burn:[\w:.?=&-]+/,
	      property: {
	        pattern: /(?:\b\w+#)?(?:"(?:\\.|[^\\"\r\n])*"|\b\w+)(?=\s*[:@])/,
	        greedy: true
	      },
	      string: {
	        pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
	        greedy: true
	      },
	      'mime-type':
	        /\b(?:application|audio|image|multipart|text|video)\/[\w+-]+/,
	      date: {
	        pattern: /\|[\w:+-]+\|/,
	        greedy: true
	      },
	      comment: [
	        {
	          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
	          lookbehind: true,
	          greedy: true
	        },
	        {
	          pattern: /(^|[^\\:])\/\/.*/,
	          lookbehind: true,
	          greedy: true
	        }
	      ],
	      regex: {
	        pattern: /\/(?:[^\\\/\r\n]|\\[^\r\n])+\//,
	        greedy: true
	      },
	      keyword:
	        /\b(?:and|as|at|case|do|else|fun|if|input|is|match|not|ns|null|or|output|type|unless|update|using|var)\b/,
	      function: /\b[A-Z_]\w*(?=\s*\()/i,
	      number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
	      punctuation: /[{}[\];(),.:@]/,
	      operator: /<<|>>|->|[<>~=]=?|!=|--?-?|\+\+?|!|\?/,
	      boolean: /\b(?:false|true)\b/
	    };
	  })(Prism);
	}
	return dataweave_1;
}

var dax_1;
var hasRequiredDax;

function requireDax () {
	if (hasRequiredDax) return dax_1;
	hasRequiredDax = 1;

	dax_1 = dax;
	dax.displayName = 'dax';
	dax.aliases = [];
	function dax(Prism) {
	  Prism.languages.dax = {
	    comment: {
	      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/).*)/,
	      lookbehind: true
	    },
	    'data-field': {
	      pattern:
	        /'(?:[^']|'')*'(?!')(?:\[[ \w\xA0-\uFFFF]+\])?|\w+\[[ \w\xA0-\uFFFF]+\]/,
	      alias: 'symbol'
	    },
	    measure: {
	      pattern: /\[[ \w\xA0-\uFFFF]+\]/,
	      alias: 'constant'
	    },
	    string: {
	      pattern: /"(?:[^"]|"")*"(?!")/,
	      greedy: true
	    },
	    function:
	      /\b(?:ABS|ACOS|ACOSH|ACOT|ACOTH|ADDCOLUMNS|ADDMISSINGITEMS|ALL|ALLCROSSFILTERED|ALLEXCEPT|ALLNOBLANKROW|ALLSELECTED|AND|APPROXIMATEDISTINCTCOUNT|ASIN|ASINH|ATAN|ATANH|AVERAGE|AVERAGEA|AVERAGEX|BETA\.DIST|BETA\.INV|BLANK|CALCULATE|CALCULATETABLE|CALENDAR|CALENDARAUTO|CEILING|CHISQ\.DIST|CHISQ\.DIST\.RT|CHISQ\.INV|CHISQ\.INV\.RT|CLOSINGBALANCEMONTH|CLOSINGBALANCEQUARTER|CLOSINGBALANCEYEAR|COALESCE|COMBIN|COMBINA|COMBINEVALUES|CONCATENATE|CONCATENATEX|CONFIDENCE\.NORM|CONFIDENCE\.T|CONTAINS|CONTAINSROW|CONTAINSSTRING|CONTAINSSTRINGEXACT|CONVERT|COS|COSH|COT|COTH|COUNT|COUNTA|COUNTAX|COUNTBLANK|COUNTROWS|COUNTX|CROSSFILTER|CROSSJOIN|CURRENCY|CURRENTGROUP|CUSTOMDATA|DATATABLE|DATE|DATEADD|DATEDIFF|DATESBETWEEN|DATESINPERIOD|DATESMTD|DATESQTD|DATESYTD|DATEVALUE|DAY|DEGREES|DETAILROWS|DISTINCT|DISTINCTCOUNT|DISTINCTCOUNTNOBLANK|DIVIDE|EARLIER|EARLIEST|EDATE|ENDOFMONTH|ENDOFQUARTER|ENDOFYEAR|EOMONTH|ERROR|EVEN|EXACT|EXCEPT|EXP|EXPON\.DIST|FACT|FALSE|FILTER|FILTERS|FIND|FIRSTDATE|FIRSTNONBLANK|FIRSTNONBLANKVALUE|FIXED|FLOOR|FORMAT|GCD|GENERATE|GENERATEALL|GENERATESERIES|GEOMEAN|GEOMEANX|GROUPBY|HASONEFILTER|HASONEVALUE|HOUR|IF|IF\.EAGER|IFERROR|IGNORE|INT|INTERSECT|ISBLANK|ISCROSSFILTERED|ISEMPTY|ISERROR|ISEVEN|ISFILTERED|ISINSCOPE|ISLOGICAL|ISNONTEXT|ISNUMBER|ISO\.CEILING|ISODD|ISONORAFTER|ISSELECTEDMEASURE|ISSUBTOTAL|ISTEXT|KEEPFILTERS|KEYWORDMATCH|LASTDATE|LASTNONBLANK|LASTNONBLANKVALUE|LCM|LEFT|LEN|LN|LOG|LOG10|LOOKUPVALUE|LOWER|MAX|MAXA|MAXX|MEDIAN|MEDIANX|MID|MIN|MINA|MINUTE|MINX|MOD|MONTH|MROUND|NATURALINNERJOIN|NATURALLEFTOUTERJOIN|NEXTDAY|NEXTMONTH|NEXTQUARTER|NEXTYEAR|NONVISUAL|NORM\.DIST|NORM\.INV|NORM\.S\.DIST|NORM\.S\.INV|NOT|NOW|ODD|OPENINGBALANCEMONTH|OPENINGBALANCEQUARTER|OPENINGBALANCEYEAR|OR|PARALLELPERIOD|PATH|PATHCONTAINS|PATHITEM|PATHITEMREVERSE|PATHLENGTH|PERCENTILE\.EXC|PERCENTILE\.INC|PERCENTILEX\.EXC|PERCENTILEX\.INC|PERMUT|PI|POISSON\.DIST|POWER|PREVIOUSDAY|PREVIOUSMONTH|PREVIOUSQUARTER|PREVIOUSYEAR|PRODUCT|PRODUCTX|QUARTER|QUOTIENT|RADIANS|RAND|RANDBETWEEN|RANK\.EQ|RANKX|RELATED|RELATEDTABLE|REMOVEFILTERS|REPLACE|REPT|RIGHT|ROLLUP|ROLLUPADDISSUBTOTAL|ROLLUPGROUP|ROLLUPISSUBTOTAL|ROUND|ROUNDDOWN|ROUNDUP|ROW|SAMEPERIODLASTYEAR|SAMPLE|SEARCH|SECOND|SELECTCOLUMNS|SELECTEDMEASURE|SELECTEDMEASUREFORMATSTRING|SELECTEDMEASURENAME|SELECTEDVALUE|SIGN|SIN|SINH|SQRT|SQRTPI|STARTOFMONTH|STARTOFQUARTER|STARTOFYEAR|STDEV\.P|STDEV\.S|STDEVX\.P|STDEVX\.S|SUBSTITUTE|SUBSTITUTEWITHINDEX|SUM|SUMMARIZE|SUMMARIZECOLUMNS|SUMX|SWITCH|T\.DIST|T\.DIST\.2T|T\.DIST\.RT|T\.INV|T\.INV\.2T|TAN|TANH|TIME|TIMEVALUE|TODAY|TOPN|TOPNPERLEVEL|TOPNSKIP|TOTALMTD|TOTALQTD|TOTALYTD|TREATAS|TRIM|TRUE|TRUNC|UNICHAR|UNICODE|UNION|UPPER|USERELATIONSHIP|USERNAME|USEROBJECTID|USERPRINCIPALNAME|UTCNOW|UTCTODAY|VALUE|VALUES|VAR\.P|VAR\.S|VARX\.P|VARX\.S|WEEKDAY|WEEKNUM|XIRR|XNPV|YEAR|YEARFRAC)(?=\s*\()/i,
	    keyword:
	      /\b(?:DEFINE|EVALUATE|MEASURE|ORDER\s+BY|RETURN|VAR|START\s+AT|ASC|DESC)\b/i,
	    boolean: {
	      pattern: /\b(?:FALSE|NULL|TRUE)\b/i,
	      alias: 'constant'
	    },
	    number: /\b\d+(?:\.\d*)?|\B\.\d+\b/,
	    operator: /:=|[-+*\/=^]|&&?|\|\||<(?:=>?|<|>)?|>[>=]?|\b(?:IN|NOT)\b/i,
	    punctuation: /[;\[\](){}`,.]/
	  };
	}
	return dax_1;
}

var dhall_1;
var hasRequiredDhall;

function requireDhall () {
	if (hasRequiredDhall) return dhall_1;
	hasRequiredDhall = 1;

	dhall_1 = dhall;
	dhall.displayName = 'dhall';
	dhall.aliases = [];
	function dhall(Prism) {
	  // ABNF grammar:
	  // https://github.com/dhall-lang/dhall-lang/blob/master/standard/dhall.abnf
	  Prism.languages.dhall = {
	    // Multi-line comments can be nested. E.g. {- foo {- bar -} -}
	    // The multi-line pattern is essentially this:
	    //   \{-(?:[^-{]|-(?!\})|\{(?!-)|<SELF>)*-\}
	    comment:
	      /--.*|\{-(?:[^-{]|-(?!\})|\{(?!-)|\{-(?:[^-{]|-(?!\})|\{(?!-))*-\})*-\}/,
	    string: {
	      pattern: /"(?:[^"\\]|\\.)*"|''(?:[^']|'(?!')|'''|''\$\{)*''(?!'|\$)/,
	      greedy: true,
	      inside: {
	        interpolation: {
	          pattern: /\$\{[^{}]*\}/,
	          inside: {
	            expression: {
	              pattern: /(^\$\{)[\s\S]+(?=\}$)/,
	              lookbehind: true,
	              alias: 'language-dhall',
	              inside: null // see blow
	            },
	            punctuation: /\$\{|\}/
	          }
	        }
	      }
	    },
	    label: {
	      pattern: /`[^`]*`/,
	      greedy: true
	    },
	    url: {
	      // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L596
	      pattern:
	        /\bhttps?:\/\/[\w.:%!$&'*+;=@~-]+(?:\/[\w.:%!$&'*+;=@~-]*)*(?:\?[/?\w.:%!$&'*+;=@~-]*)?/,
	      greedy: true
	    },
	    env: {
	      // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L661
	      pattern: /\benv:(?:(?!\d)\w+|"(?:[^"\\=]|\\.)*")/,
	      greedy: true,
	      inside: {
	        function: /^env/,
	        operator: /^:/,
	        variable: /[\s\S]+/
	      }
	    },
	    hash: {
	      // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L725
	      pattern: /\bsha256:[\da-fA-F]{64}\b/,
	      inside: {
	        function: /sha256/,
	        operator: /:/,
	        number: /[\da-fA-F]{64}/
	      }
	    },
	    // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L359
	    keyword:
	      /\b(?:as|assert|else|forall|if|in|let|merge|missing|then|toMap|using|with)\b|\u2200/,
	    builtin: /\b(?:None|Some)\b/,
	    boolean: /\b(?:False|True)\b/,
	    number:
	      /\bNaN\b|-?\bInfinity\b|[+-]?\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/,
	    operator:
	      /\/\\|\/\/\\\\|&&|\|\||===|[!=]=|\/\/|->|\+\+|::|[+*#@=:?<>|\\\u2227\u2a53\u2261\u2afd\u03bb\u2192]/,
	    punctuation: /\.\.|[{}\[\](),./]/,
	    // we'll just assume that every capital word left is a type name
	    'class-name': /\b[A-Z]\w*\b/
	  };
	  Prism.languages.dhall.string.inside.interpolation.inside.expression.inside =
	    Prism.languages.dhall;
	}
	return dhall_1;
}

var diff_1;
var hasRequiredDiff;

function requireDiff () {
	if (hasRequiredDiff) return diff_1;
	hasRequiredDiff = 1;

	diff_1 = diff;
	diff.displayName = 'diff';
	diff.aliases = [];
	function diff(Prism) {
(function (Prism) {
	    Prism.languages.diff = {
	      coord: [
	        // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
	        /^(?:\*{3}|-{3}|\+{3}).*$/m, // Match "@@ ... @@" coord lines in unified diff.
	        /^@@.*@@$/m, // Match coord lines in normal diff (starts with a number).
	        /^\d.*$/m
	      ] // deleted, inserted, unchanged, diff
	    };
	    /**
	     * A map from the name of a block to its line prefix.
	     *
	     * @type {Object<string, string>}
	     */
	    var PREFIXES = {
	      'deleted-sign': '-',
	      'deleted-arrow': '<',
	      'inserted-sign': '+',
	      'inserted-arrow': '>',
	      unchanged: ' ',
	      diff: '!'
	    }; // add a token for each prefix
	    Object.keys(PREFIXES).forEach(function (name) {
	      var prefix = PREFIXES[name];
	      var alias = [];
	      if (!/^\w+$/.test(name)) {
	        // "deleted-sign" -> "deleted"
	        alias.push(/\w+/.exec(name)[0]);
	      }
	      if (name === 'diff') {
	        alias.push('bold');
	      }
	      Prism.languages.diff[name] = {
	        pattern: RegExp(
	          '^(?:[' + prefix + '].*(?:\r\n?|\n|(?![\\s\\S])))+',
	          'm'
	        ),
	        alias: alias,
	        inside: {
	          line: {
	            pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
	            lookbehind: true
	          },
	          prefix: {
	            pattern: /[\s\S]/,
	            alias: /\w+/.exec(name)[0]
	          }
	        }
	      };
	    }); // make prefixes available to Diff plugin
	    Object.defineProperty(Prism.languages.diff, 'PREFIXES', {
	      value: PREFIXES
	    });
	  })(Prism);
	}
	return diff_1;
}

var markupTemplating_1;
var hasRequiredMarkupTemplating;

function requireMarkupTemplating () {
	if (hasRequiredMarkupTemplating) return markupTemplating_1;
	hasRequiredMarkupTemplating = 1;

	markupTemplating_1 = markupTemplating;
	markupTemplating.displayName = 'markupTemplating';
	markupTemplating.aliases = [];
	function markupTemplating(Prism) {
(function (Prism) {
	    /**
	     * Returns the placeholder for the given language id and index.
	     *
	     * @param {string} language
	     * @param {string|number} index
	     * @returns {string}
	     */
	    function getPlaceholder(language, index) {
	      return '___' + language.toUpperCase() + index + '___'
	    }
	    Object.defineProperties((Prism.languages['markup-templating'] = {}), {
	      buildPlaceholders: {
	        /**
	         * Tokenize all inline templating expressions matching `placeholderPattern`.
	         *
	         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
	         * `true` will be replaced.
	         *
	         * @param {object} env The environment of the `before-tokenize` hook.
	         * @param {string} language The language id.
	         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
	         * @param {(match: string) => boolean} [replaceFilter]
	         */
	        value: function (env, language, placeholderPattern, replaceFilter) {
	          if (env.language !== language) {
	            return
	          }
	          var tokenStack = (env.tokenStack = []);
	          env.code = env.code.replace(placeholderPattern, function (match) {
	            if (typeof replaceFilter === 'function' && !replaceFilter(match)) {
	              return match
	            }
	            var i = tokenStack.length;
	            var placeholder; // Check for existing strings
	            while (
	              env.code.indexOf((placeholder = getPlaceholder(language, i))) !==
	              -1
	            ) {
	              ++i;
	            } // Create a sparse array
	            tokenStack[i] = match;
	            return placeholder
	          }); // Switch the grammar to markup
	          env.grammar = Prism.languages.markup;
	        }
	      },
	      tokenizePlaceholders: {
	        /**
	         * Replace placeholders with proper tokens after tokenizing.
	         *
	         * @param {object} env The environment of the `after-tokenize` hook.
	         * @param {string} language The language id.
	         */
	        value: function (env, language) {
	          if (env.language !== language || !env.tokenStack) {
	            return
	          } // Switch the grammar back
	          env.grammar = Prism.languages[language];
	          var j = 0;
	          var keys = Object.keys(env.tokenStack);
	          function walkTokens(tokens) {
	            for (var i = 0; i < tokens.length; i++) {
	              // all placeholders are replaced already
	              if (j >= keys.length) {
	                break
	              }
	              var token = tokens[i];
	              if (
	                typeof token === 'string' ||
	                (token.content && typeof token.content === 'string')
	              ) {
	                var k = keys[j];
	                var t = env.tokenStack[k];
	                var s = typeof token === 'string' ? token : token.content;
	                var placeholder = getPlaceholder(language, k);
	                var index = s.indexOf(placeholder);
	                if (index > -1) {
	                  ++j;
	                  var before = s.substring(0, index);
	                  var middle = new Prism.Token(
	                    language,
	                    Prism.tokenize(t, env.grammar),
	                    'language-' + language,
	                    t
	                  );
	                  var after = s.substring(index + placeholder.length);
	                  var replacement = [];
	                  if (before) {
	                    replacement.push.apply(replacement, walkTokens([before]));
	                  }
	                  replacement.push(middle);
	                  if (after) {
	                    replacement.push.apply(replacement, walkTokens([after]));
	                  }
	                  if (typeof token === 'string') {
	                    tokens.splice.apply(tokens, [i, 1].concat(replacement));
	                  } else {
	                    token.content = replacement;
	                  }
	                }
	              } else if (
	                token.content
	                /* && typeof token.content !== 'string' */
	              ) {
	                walkTokens(token.content);
	              }
	            }
	            return tokens
	          }
	          walkTokens(env.tokens);
	        }
	      }
	    });
	  })(Prism);
	}
	return markupTemplating_1;
}

var django_1;
var hasRequiredDjango;

function requireDjango () {
	if (hasRequiredDjango) return django_1;
	hasRequiredDjango = 1;
	var refractorMarkupTemplating = requireMarkupTemplating();
	django_1 = django;
	django.displayName = 'django';
	django.aliases = ['jinja2'];
	function django(Prism) {
	  Prism.register(refractorMarkupTemplating)
	  // Django/Jinja2 syntax definition for Prism.js <http://prismjs.com> syntax highlighter.
	  // Mostly it works OK but can paint code incorrectly on complex html/template tag combinations.
	  ;(function (Prism) {
	    Prism.languages.django = {
	      comment: /^\{#[\s\S]*?#\}$/,
	      tag: {
	        pattern: /(^\{%[+-]?\s*)\w+/,
	        lookbehind: true,
	        alias: 'keyword'
	      },
	      delimiter: {
	        pattern: /^\{[{%][+-]?|[+-]?[}%]\}$/,
	        alias: 'punctuation'
	      },
	      string: {
	        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	        greedy: true
	      },
	      filter: {
	        pattern: /(\|)\w+/,
	        lookbehind: true,
	        alias: 'function'
	      },
	      test: {
	        pattern: /(\bis\s+(?:not\s+)?)(?!not\b)\w+/,
	        lookbehind: true,
	        alias: 'function'
	      },
	      function: /\b[a-z_]\w+(?=\s*\()/i,
	      keyword:
	        /\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\b/,
	      operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
	      number: /\b\d+(?:\.\d+)?\b/,
	      boolean: /[Ff]alse|[Nn]one|[Tt]rue/,
	      variable: /\b\w+\b/,
	      punctuation: /[{}[\](),.:;]/
	    };
	    var pattern = /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}|\{#[\s\S]*?#\}/g;
	    var markupTemplating = Prism.languages['markup-templating'];
	    Prism.hooks.add('before-tokenize', function (env) {
	      markupTemplating.buildPlaceholders(env, 'django', pattern);
	    });
	    Prism.hooks.add('after-tokenize', function (env) {
	      markupTemplating.tokenizePlaceholders(env, 'django');
	    }); // Add an Jinja2 alias
	    Prism.languages.jinja2 = Prism.languages.django;
	    Prism.hooks.add('before-tokenize', function (env) {
	      markupTemplating.buildPlaceholders(env, 'jinja2', pattern);
	    });
	    Prism.hooks.add('after-tokenize', function (env) {
	      markupTemplating.tokenizePlaceholders(env, 'jinja2');
	    });
	  })(Prism);
	}
	return django_1;
}

var dnsZoneFile_1;
var hasRequiredDnsZoneFile;

function requireDnsZoneFile () {
	if (hasRequiredDnsZoneFile) return dnsZoneFile_1;
	hasRequiredDnsZoneFile = 1;

	dnsZoneFile_1 = dnsZoneFile;
	dnsZoneFile.displayName = 'dnsZoneFile';
	dnsZoneFile.aliases = [];
	function dnsZoneFile(Prism) {
	  Prism.languages['dns-zone-file'] = {
	    comment: /;.*/,
	    string: {
	      pattern: /"(?:\\.|[^"\\\r\n])*"/,
	      greedy: true
	    },
	    variable: [
	      {
	        pattern: /(^\$ORIGIN[ \t]+)\S+/m,
	        lookbehind: true
	      },
	      {
	        pattern: /(^|\s)@(?=\s|$)/,
	        lookbehind: true
	      }
	    ],
	    keyword: /^\$(?:INCLUDE|ORIGIN|TTL)(?=\s|$)/m,
	    class: {
	      // https://tools.ietf.org/html/rfc1035#page-13
	      pattern: /(^|\s)(?:CH|CS|HS|IN)(?=\s|$)/,
	      lookbehind: true,
	      alias: 'keyword'
	    },
	    type: {
	      // https://en.wikipedia.org/wiki/List_of_DNS_record_types
	      pattern:
	        /(^|\s)(?:A|A6|AAAA|AFSDB|APL|ATMA|CAA|CDNSKEY|CDS|CERT|CNAME|DHCID|DLV|DNAME|DNSKEY|DS|EID|GID|GPOS|HINFO|HIP|IPSECKEY|ISDN|KEY|KX|LOC|MAILA|MAILB|MB|MD|MF|MG|MINFO|MR|MX|NAPTR|NB|NBSTAT|NIMLOC|NINFO|NS|NSAP|NSAP-PTR|NSEC|NSEC3|NSEC3PARAM|NULL|NXT|OPENPGPKEY|PTR|PX|RKEY|RP|RRSIG|RT|SIG|SINK|SMIMEA|SOA|SPF|SRV|SSHFP|TA|TKEY|TLSA|TSIG|TXT|UID|UINFO|UNSPEC|URI|WKS|X25)(?=\s|$)/,
	      lookbehind: true,
	      alias: 'keyword'
	    },
	    punctuation: /[()]/
	  };
	  Prism.languages['dns-zone'] = Prism.languages['dns-zone-file'];
	}
	return dnsZoneFile_1;
}

var docker_1;
var hasRequiredDocker;

function requireDocker () {
	if (hasRequiredDocker) return docker_1;
	hasRequiredDocker = 1;

	docker_1 = docker;
	docker.displayName = 'docker';
	docker.aliases = ['dockerfile'];
	function docker(Prism) {
(function (Prism) {
	    // Many of the following regexes will contain negated lookaheads like `[ \t]+(?![ \t])`. This is a trick to ensure
	    // that quantifiers behave *atomically*. Atomic quantifiers are necessary to prevent exponential backtracking.
	    var spaceAfterBackSlash =
	      /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source; // At least one space, comment, or line break
	    var space = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source.replace(
	      /<SP_BS>/g,
	      function () {
	        return spaceAfterBackSlash
	      }
	    );
	    var string =
	      /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/
	        .source;
	    var option = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(
	      /<STR>/g,
	      function () {
	        return string
	      }
	    );
	    var stringRule = {
	      pattern: RegExp(string),
	      greedy: true
	    };
	    var commentRule = {
	      pattern: /(^[ \t]*)#.*/m,
	      lookbehind: true,
	      greedy: true
	    };
	    /**
	     * @param {string} source
	     * @param {string} flags
	     * @returns {RegExp}
	     */
	    function re(source, flags) {
	      source = source
	        .replace(/<OPT>/g, function () {
	          return option
	        })
	        .replace(/<SP>/g, function () {
	          return space
	        });
	      return RegExp(source, flags)
	    }
	    Prism.languages.docker = {
	      instruction: {
	        pattern:
	          /(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          options: {
	            pattern: re(
	              /(^(?:ONBUILD<SP>)?\w+<SP>)<OPT>(?:<SP><OPT>)*/.source,
	              'i'
	            ),
	            lookbehind: true,
	            greedy: true,
	            inside: {
	              property: {
	                pattern: /(^|\s)--[\w-]+/,
	                lookbehind: true
	              },
	              string: [
	                stringRule,
	                {
	                  pattern: /(=)(?!["'])(?:[^\s\\]|\\.)+/,
	                  lookbehind: true
	                }
	              ],
	              operator: /\\$/m,
	              punctuation: /=/
	            }
	          },
	          keyword: [
	            {
	              // https://docs.docker.com/engine/reference/builder/#healthcheck
	              pattern: re(
	                /(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\b/
	                  .source,
	                'i'
	              ),
	              lookbehind: true,
	              greedy: true
	            },
	            {
	              // https://docs.docker.com/engine/reference/builder/#from
	              pattern: re(
	                /(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \t\\]+<SP>)AS/
	                  .source,
	                'i'
	              ),
	              lookbehind: true,
	              greedy: true
	            },
	            {
	              // https://docs.docker.com/engine/reference/builder/#onbuild
	              pattern: re(/(^ONBUILD<SP>)\w+/.source, 'i'),
	              lookbehind: true,
	              greedy: true
	            },
	            {
	              pattern: /^\w+/,
	              greedy: true
	            }
	          ],
	          comment: commentRule,
	          string: stringRule,
	          variable: /\$(?:\w+|\{[^{}"'\\]*\})/,
	          operator: /\\$/m
	        }
	      },
	      comment: commentRule
	    };
	    Prism.languages.dockerfile = Prism.languages.docker;
	  })(Prism);
	}
	return docker_1;
}

var dot_1;
var hasRequiredDot;

function requireDot () {
	if (hasRequiredDot) return dot_1;
	hasRequiredDot = 1;

	dot_1 = dot;
	dot.displayName = 'dot';
	dot.aliases = ['gv'];
	function dot(Prism) {
(function (Prism) {
	    var ID =
	      '(?:' +
	      [
	        // an identifier
	        /[a-zA-Z_\x80-\uFFFF][\w\x80-\uFFFF]*/.source, // a number
	        /-?(?:\.\d+|\d+(?:\.\d*)?)/.source, // a double-quoted string
	        /"[^"\\]*(?:\\[\s\S][^"\\]*)*"/.source, // HTML-like string
	        /<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>/
	          .source
	      ].join('|') +
	      ')';
	    var IDInside = {
	      markup: {
	        pattern: /(^<)[\s\S]+(?=>$)/,
	        lookbehind: true,
	        alias: ['language-markup', 'language-html', 'language-xml'],
	        inside: Prism.languages.markup
	      }
	    };
	    /**
	     * @param {string} source
	     * @param {string} flags
	     * @returns {RegExp}
	     */
	    function withID(source, flags) {
	      return RegExp(
	        source.replace(/<ID>/g, function () {
	          return ID
	        }),
	        flags
	      )
	    }
	    Prism.languages.dot = {
	      comment: {
	        pattern: /\/\/.*|\/\*[\s\S]*?\*\/|^#.*/m,
	        greedy: true
	      },
	      'graph-name': {
	        pattern: withID(
	          /(\b(?:digraph|graph|subgraph)[ \t\r\n]+)<ID>/.source,
	          'i'
	        ),
	        lookbehind: true,
	        greedy: true,
	        alias: 'class-name',
	        inside: IDInside
	      },
	      'attr-value': {
	        pattern: withID(/(=[ \t\r\n]*)<ID>/.source),
	        lookbehind: true,
	        greedy: true,
	        inside: IDInside
	      },
	      'attr-name': {
	        pattern: withID(/([\[;, \t\r\n])<ID>(?=[ \t\r\n]*=)/.source),
	        lookbehind: true,
	        greedy: true,
	        inside: IDInside
	      },
	      keyword: /\b(?:digraph|edge|graph|node|strict|subgraph)\b/i,
	      'compass-point': {
	        pattern: /(:[ \t\r\n]*)(?:[ewc_]|[ns][ew]?)(?![\w\x80-\uFFFF])/,
	        lookbehind: true,
	        alias: 'builtin'
	      },
	      node: {
	        pattern: withID(/(^|[^-.\w\x80-\uFFFF\\])<ID>/.source),
	        lookbehind: true,
	        greedy: true,
	        inside: IDInside
	      },
	      operator: /[=:]|-[->]/,
	      punctuation: /[\[\]{};,]/
	    };
	    Prism.languages.gv = Prism.languages.dot;
	  })(Prism);
	}
	return dot_1;
}

var ebnf_1;
var hasRequiredEbnf;

function requireEbnf () {
	if (hasRequiredEbnf) return ebnf_1;
	hasRequiredEbnf = 1;

	ebnf_1 = ebnf;
	ebnf.displayName = 'ebnf';
	ebnf.aliases = [];
	function ebnf(Prism) {
	  Prism.languages.ebnf = {
	    comment: /\(\*[\s\S]*?\*\)/,
	    string: {
	      pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
	      greedy: true
	    },
	    special: {
	      pattern: /\?[^?\r\n]*\?/,
	      greedy: true,
	      alias: 'class-name'
	    },
	    definition: {
	      pattern: /^([\t ]*)[a-z]\w*(?:[ \t]+[a-z]\w*)*(?=\s*=)/im,
	      lookbehind: true,
	      alias: ['rule', 'keyword']
	    },
	    rule: /\b[a-z]\w*(?:[ \t]+[a-z]\w*)*\b/i,
	    punctuation: /\([:/]|[:/]\)|[.,;()[\]{}]/,
	    operator: /[-=|*/!]/
	  };
	}
	return ebnf_1;
}

var editorconfig_1;
var hasRequiredEditorconfig;

function requireEditorconfig () {
	if (hasRequiredEditorconfig) return editorconfig_1;
	hasRequiredEditorconfig = 1;

	editorconfig_1 = editorconfig;
	editorconfig.displayName = 'editorconfig';
	editorconfig.aliases = [];
	function editorconfig(Prism) {
	  Prism.languages.editorconfig = {
	    // https://editorconfig-specification.readthedocs.io
	    comment: /[;#].*/,
	    section: {
	      pattern: /(^[ \t]*)\[.+\]/m,
	      lookbehind: true,
	      alias: 'selector',
	      inside: {
	        regex: /\\\\[\[\]{},!?.*]/,
	        // Escape special characters with '\\'
	        operator: /[!?]|\.\.|\*{1,2}/,
	        punctuation: /[\[\]{},]/
	      }
	    },
	    key: {
	      pattern: /(^[ \t]*)[^\s=]+(?=[ \t]*=)/m,
	      lookbehind: true,
	      alias: 'attr-name'
	    },
	    value: {
	      pattern: /=.*/,
	      alias: 'attr-value',
	      inside: {
	        punctuation: /^=/
	      }
	    }
	  };
	}
	return editorconfig_1;
}

var eiffel_1;
var hasRequiredEiffel;

function requireEiffel () {
	if (hasRequiredEiffel) return eiffel_1;
	hasRequiredEiffel = 1;

	eiffel_1 = eiffel;
	eiffel.displayName = 'eiffel';
	eiffel.aliases = [];
	function eiffel(Prism) {
	  Prism.languages.eiffel = {
	    comment: /--.*/,
	    string: [
	      // Aligned-verbatim-strings
	      {
	        pattern: /"([^[]*)\[[\s\S]*?\]\1"/,
	        greedy: true
	      }, // Non-aligned-verbatim-strings
	      {
	        pattern: /"([^{]*)\{[\s\S]*?\}\1"/,
	        greedy: true
	      }, // Single-line string
	      {
	        pattern: /"(?:%(?:(?!\n)\s)*\n\s*%|%\S|[^%"\r\n])*"/,
	        greedy: true
	      }
	    ],
	    // normal char | special char | char code
	    char: /'(?:%.|[^%'\r\n])+'/,
	    keyword:
	      /\b(?:across|agent|alias|all|and|as|assign|attached|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\b/i,
	    boolean: /\b(?:False|True)\b/i,
	    // Convention: class-names are always all upper-case characters
	    'class-name': /\b[A-Z][\dA-Z_]*\b/,
	    number: [
	      // hexa | octal | bin
	      /\b0[xcb][\da-f](?:_*[\da-f])*\b/i, // Decimal
	      /(?:\b\d(?:_*\d)*)?\.(?:(?:\d(?:_*\d)*)?e[+-]?)?\d(?:_*\d)*\b|\b\d(?:_*\d)*\b\.?/i
	    ],
	    punctuation: /:=|<<|>>|\(\||\|\)|->|\.(?=\w)|[{}[\];(),:?]/,
	    operator: /\\\\|\|\.\.\||\.\.|\/[~\/=]?|[><]=?|[-+*^=~]/
	  };
	}
	return eiffel_1;
}

var ejs_1;
var hasRequiredEjs;

function requireEjs () {
	if (hasRequiredEjs) return ejs_1;
	hasRequiredEjs = 1;
	var refractorMarkupTemplating = requireMarkupTemplating();
	ejs_1 = ejs;
	ejs.displayName = 'ejs';
	ejs.aliases = ['eta'];
	function ejs(Prism) {
	  Prism.register(refractorMarkupTemplating)
	  ;(function (Prism) {
	    Prism.languages.ejs = {
	      delimiter: {
	        pattern: /^<%[-_=]?|[-_]?%>$/,
	        alias: 'punctuation'
	      },
	      comment: /^#[\s\S]*/,
	      'language-javascript': {
	        pattern: /[\s\S]+/,
	        inside: Prism.languages.javascript
	      }
	    };
	    Prism.hooks.add('before-tokenize', function (env) {
	      var ejsPattern = /<%(?!%)[\s\S]+?%>/g;
	      Prism.languages['markup-templating'].buildPlaceholders(
	        env,
	        'ejs',
	        ejsPattern
	      );
	    });
	    Prism.hooks.add('after-tokenize', function (env) {
	      Prism.languages['markup-templating'].tokenizePlaceholders(env, 'ejs');
	    });
	    Prism.languages.eta = Prism.languages.ejs;
	  })(Prism);
	}
	return ejs_1;
}

var elixir_1;
var hasRequiredElixir;

function requireElixir () {
	if (hasRequiredElixir) return elixir_1;
	hasRequiredElixir = 1;

	elixir_1 = elixir;
	elixir.displayName = 'elixir';
	elixir.aliases = [];
	function elixir(Prism) {
	  Prism.languages.elixir = {
	    doc: {
	      pattern:
	        /@(?:doc|moduledoc)\s+(?:("""|''')[\s\S]*?\1|("|')(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2)/,
	      inside: {
	        attribute: /^@\w+/,
	        string: /['"][\s\S]+/
	      }
	    },
	    comment: {
	      pattern: /#.*/,
	      greedy: true
	    },
	    // ~r"""foo""" (multi-line), ~r'''foo''' (multi-line), ~r/foo/, ~r|foo|, ~r"foo", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>
	    regex: {
	      pattern:
	        /~[rR](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|[^\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[uismxfr]*/,
	      greedy: true
	    },
	    string: [
	      {
	        // ~s"""foo""" (multi-line), ~s'''foo''' (multi-line), ~s/foo/, ~s|foo|, ~s"foo", ~s'foo', ~s(foo), ~s[foo], ~s{foo} (with interpolation care), ~s<foo>
	        pattern:
	          /~[cCsSwW](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|#\{[^}]+\}|#(?!\{)|[^#\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[csa]?/,
	        greedy: true,
	        inside: {
	          // See interpolation below
	        }
	      },
	      {
	        pattern: /("""|''')[\s\S]*?\1/,
	        greedy: true,
	        inside: {
	          // See interpolation below
	        }
	      },
	      {
	        // Multi-line strings are allowed
	        pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	        greedy: true,
	        inside: {
	          // See interpolation below
	        }
	      }
	    ],
	    atom: {
	      // Look-behind prevents bad highlighting of the :: operator
	      pattern: /(^|[^:]):\w+/,
	      lookbehind: true,
	      alias: 'symbol'
	    },
	    module: {
	      pattern: /\b[A-Z]\w*\b/,
	      alias: 'class-name'
	    },
	    // Look-ahead prevents bad highlighting of the :: operator
	    'attr-name': /\b\w+\??:(?!:)/,
	    argument: {
	      // Look-behind prevents bad highlighting of the && operator
	      pattern: /(^|[^&])&\d+/,
	      lookbehind: true,
	      alias: 'variable'
	    },
	    attribute: {
	      pattern: /@\w+/,
	      alias: 'variable'
	    },
	    function: /\b[_a-zA-Z]\w*[?!]?(?:(?=\s*(?:\.\s*)?\()|(?=\/\d))/,
	    number: /\b(?:0[box][a-f\d_]+|\d[\d_]*)(?:\.[\d_]+)?(?:e[+-]?[\d_]+)?\b/i,
	    keyword:
	      /\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\b/,
	    boolean: /\b(?:false|nil|true)\b/,
	    operator: [
	      /\bin\b|&&?|\|[|>]?|\\\\|::|\.\.\.?|\+\+?|-[->]?|<[-=>]|>=|!==?|\B!|=(?:==?|[>~])?|[*\/^]/,
	      {
	        // We don't want to match <<
	        pattern: /([^<])<(?!<)/,
	        lookbehind: true
	      },
	      {
	        // We don't want to match >>
	        pattern: /([^>])>(?!>)/,
	        lookbehind: true
	      }
	    ],
	    punctuation: /<<|>>|[.,%\[\]{}()]/
	  };
	  Prism.languages.elixir.string.forEach(function (o) {
	    o.inside = {
	      interpolation: {
	        pattern: /#\{[^}]+\}/,
	        inside: {
	          delimiter: {
	            pattern: /^#\{|\}$/,
	            alias: 'punctuation'
	          },
	          rest: Prism.languages.elixir
	        }
	      }
	    };
	  });
	}
	return elixir_1;
}

var elm_1;
var hasRequiredElm;

function requireElm () {
	if (hasRequiredElm) return elm_1;
	hasRequiredElm = 1;

	elm_1 = elm;
	elm.displayName = 'elm';
	elm.aliases = [];
	function elm(Prism) {
	  Prism.languages.elm = {
	    comment: /--.*|\{-[\s\S]*?-\}/,
	    char: {
	      pattern:
	        /'(?:[^\\'\r\n]|\\(?:[abfnrtv\\']|\d+|x[0-9a-fA-F]+|u\{[0-9a-fA-F]+\}))'/,
	      greedy: true
	    },
	    string: [
	      {
	        // Multiline strings are wrapped in triple ". Quotes may appear unescaped.
	        pattern: /"""[\s\S]*?"""/,
	        greedy: true
	      },
	      {
	        pattern: /"(?:[^\\"\r\n]|\\.)*"/,
	        greedy: true
	      }
	    ],
	    'import-statement': {
	      // The imported or hidden names are not included in this import
	      // statement. This is because we want to highlight those exactly like
	      // we do for the names in the program.
	      pattern:
	        /(^[\t ]*)import\s+[A-Z]\w*(?:\.[A-Z]\w*)*(?:\s+as\s+(?:[A-Z]\w*)(?:\.[A-Z]\w*)*)?(?:\s+exposing\s+)?/m,
	      lookbehind: true,
	      inside: {
	        keyword: /\b(?:as|exposing|import)\b/
	      }
	    },
	    keyword:
	      /\b(?:alias|as|case|else|exposing|if|in|infixl|infixr|let|module|of|then|type)\b/,
	    // These are builtin variables only. Constructors are highlighted later as a constant.
	    builtin:
	      /\b(?:abs|acos|always|asin|atan|atan2|ceiling|clamp|compare|cos|curry|degrees|e|flip|floor|fromPolar|identity|isInfinite|isNaN|logBase|max|min|negate|never|not|pi|radians|rem|round|sin|sqrt|tan|toFloat|toPolar|toString|truncate|turns|uncurry|xor)\b/,
	    // decimal integers and floating point numbers | hexadecimal integers
	    number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[0-9a-f]+)\b/i,
	    // Most of this is needed because of the meaning of a single '.'.
	    // If it stands alone freely, it is the function composition.
	    // It may also be a separator between a module name and an identifier => no
	    // operator. If it comes together with other special characters it is an
	    // operator too.
	    // Valid operator characters in 0.18: +-/*=.$<>:&|^?%#@~!
	    // Ref: https://groups.google.com/forum/#!msg/elm-dev/0AHSnDdkSkQ/E0SVU70JEQAJ
	    operator: /\s\.\s|[+\-/*=.$<>:&|^?%#@~!]{2,}|[+\-/*=$<>:&|^?%#@~!]/,
	    // In Elm, nearly everything is a variable, do not highlight these.
	    hvariable: /\b(?:[A-Z]\w*\.)*[a-z]\w*\b/,
	    constant: /\b(?:[A-Z]\w*\.)*[A-Z]\w*\b/,
	    punctuation: /[{}[\]|(),.:]/
	  };
	}
	return elm_1;
}

var erb_1;
var hasRequiredErb;

function requireErb () {
	if (hasRequiredErb) return erb_1;
	hasRequiredErb = 1;
	var refractorRuby = requireRuby();
	var refractorMarkupTemplating = requireMarkupTemplating();
	erb_1 = erb;
	erb.displayName = 'erb';
	erb.aliases = [];
	function erb(Prism) {
	  Prism.register(refractorRuby);
	  Prism.register(refractorMarkupTemplating)
	  ;(function (Prism) {
	    Prism.languages.erb = {
	      delimiter: {
	        pattern: /^(\s*)<%=?|%>(?=\s*$)/,
	        lookbehind: true,
	        alias: 'punctuation'
	      },
	      ruby: {
	        pattern: /\s*\S[\s\S]*/,
	        alias: 'language-ruby',
	        inside: Prism.languages.ruby
	      }
	    };
	    Prism.hooks.add('before-tokenize', function (env) {
	      var erbPattern =
	        /<%=?(?:[^\r\n]|[\r\n](?!=begin)|[\r\n]=begin\s(?:[^\r\n]|[\r\n](?!=end))*[\r\n]=end)+?%>/g;
	      Prism.languages['markup-templating'].buildPlaceholders(
	        env,
	        'erb',
	        erbPattern
	      );
	    });
	    Prism.hooks.add('after-tokenize', function (env) {
	      Prism.languages['markup-templating'].tokenizePlaceholders(env, 'erb');
	    });
	  })(Prism);
	}
	return erb_1;
}

var erlang_1;
var hasRequiredErlang;

function requireErlang () {
	if (hasRequiredErlang) return erlang_1;
	hasRequiredErlang = 1;

	erlang_1 = erlang;
	erlang.displayName = 'erlang';
	erlang.aliases = [];
	function erlang(Prism) {
	  Prism.languages.erlang = {
	    comment: /%.+/,
	    string: {
	      pattern: /"(?:\\.|[^\\"\r\n])*"/,
	      greedy: true
	    },
	    'quoted-function': {
	      pattern: /'(?:\\.|[^\\'\r\n])+'(?=\()/,
	      alias: 'function'
	    },
	    'quoted-atom': {
	      pattern: /'(?:\\.|[^\\'\r\n])+'/,
	      alias: 'atom'
	    },
	    boolean: /\b(?:false|true)\b/,
	    keyword: /\b(?:after|case|catch|end|fun|if|of|receive|try|when)\b/,
	    number: [
	      /\$\\?./,
	      /\b\d+#[a-z0-9]+/i,
	      /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i
	    ],
	    function: /\b[a-z][\w@]*(?=\()/,
	    variable: {
	      // Look-behind is used to prevent wrong highlighting of atoms containing "@"
	      pattern: /(^|[^@])(?:\b|\?)[A-Z_][\w@]*/,
	      lookbehind: true
	    },
	    operator: [
	      /[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:and|andalso|band|bnot|bor|bsl|bsr|bxor|div|not|or|orelse|rem|xor)\b/,
	      {
	        // We don't want to match <<
	        pattern: /(^|[^<])<(?!<)/,
	        lookbehind: true
	      },
	      {
	        // We don't want to match >>
	        pattern: /(^|[^>])>(?!>)/,
	        lookbehind: true
	      }
	    ],
	    atom: /\b[a-z][\w@]*/,
	    punctuation: /[()[\]{}:;,.#|]|<<|>>/
	  };
	}
	return erlang_1;
}

var lua_1;
var hasRequiredLua;

function requireLua () {
	if (hasRequiredLua) return lua_1;
	hasRequiredLua = 1;

	lua_1 = lua;
	lua.displayName = 'lua';
	lua.aliases = [];
	function lua(Prism) {
	  Prism.languages.lua = {
	    comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
	    // \z may be used to skip the following space
	    string: {
	      pattern:
	        /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
	      greedy: true
	    },
	    number:
	      /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
	    keyword:
	      /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
	    function: /(?!\d)\w+(?=\s*(?:[({]))/,
	    operator: [
	      /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
	      {
	        // Match ".." but don't break "..."
	        pattern: /(^|[^.])\.\.(?!\.)/,
	        lookbehind: true
	      }
	    ],
	    punctuation: /[\[\](){},;]|\.+|:+/
	  };
	}
	return lua_1;
}

var etlua_1;
var hasRequiredEtlua;

function requireEtlua () {
	if (hasRequiredEtlua) return etlua_1;
	hasRequiredEtlua = 1;
	var refractorLua = requireLua();
	var refractorMarkupTemplating = requireMarkupTemplating();
	etlua_1 = etlua;
	etlua.displayName = 'etlua';
	etlua.aliases = [];
	function etlua(Prism) {
	  Prism.register(refractorLua);
	  Prism.register(refractorMarkupTemplating)
	  ;(function (Prism) {
	    Prism.languages.etlua = {
	      delimiter: {
	        pattern: /^<%[-=]?|-?%>$/,
	        alias: 'punctuation'
	      },
	      'language-lua': {
	        pattern: /[\s\S]+/,
	        inside: Prism.languages.lua
	      }
	    };
	    Prism.hooks.add('before-tokenize', function (env) {
	      var pattern = /<%[\s\S]+?%>/g;
	      Prism.languages['markup-templating'].buildPlaceholders(
	        env,
	        'etlua',
	        pattern
	      );
	    });
	    Prism.hooks.add('after-tokenize', function (env) {
	      Prism.languages['markup-templating'].tokenizePlaceholders(env, 'etlua');
	    });
	  })(Prism);
	}
	return etlua_1;
}

var excelFormula_1;
var hasRequiredExcelFormula;

function requireExcelFormula () {
	if (hasRequiredExcelFormula) return excelFormula_1;
	hasRequiredExcelFormula = 1;

	excelFormula_1 = excelFormula;
	excelFormula.displayName = 'excelFormula';
	excelFormula.aliases = [];
	function excelFormula(Prism) {
	  Prism.languages['excel-formula'] = {
	    comment: {
	      pattern: /(\bN\(\s*)"(?:[^"]|"")*"(?=\s*\))/i,
	      lookbehind: true,
	      greedy: true
	    },
	    string: {
	      pattern: /"(?:[^"]|"")*"(?!")/,
	      greedy: true
	    },
	    reference: {
	      // https://www.ablebits.com/office-addins-blog/2015/12/08/excel-reference-another-sheet-workbook/
	      // Sales!B2
	      // 'Winter sales'!B2
	      // [Sales.xlsx]Jan!B2:B5
	      // D:\Reports\[Sales.xlsx]Jan!B2:B5
	      // '[Sales.xlsx]Jan sales'!B2:B5
	      // 'D:\Reports\[Sales.xlsx]Jan sales'!B2:B5
	      pattern:
	        /(?:'[^']*'|(?:[^\s()[\]{}<>*?"';,$&]*\[[^^\s()[\]{}<>*?"']+\])?\w+)!/,
	      greedy: true,
	      alias: 'string',
	      inside: {
	        operator: /!$/,
	        punctuation: /'/,
	        sheet: {
	          pattern: /[^[\]]+$/,
	          alias: 'function'
	        },
	        file: {
	          pattern: /\[[^[\]]+\]$/,
	          inside: {
	            punctuation: /[[\]]/
	          }
	        },
	        path: /[\s\S]+/
	      }
	    },
	    'function-name': {
	      pattern: /\b[A-Z]\w*(?=\()/i,
	      alias: 'keyword'
	    },
	    range: {
	      pattern:
	        /\$?\b(?:[A-Z]+\$?\d+:\$?[A-Z]+\$?\d+|[A-Z]+:\$?[A-Z]+|\d+:\$?\d+)\b/i,
	      alias: 'property',
	      inside: {
	        operator: /:/,
	        cell: /\$?[A-Z]+\$?\d+/i,
	        column: /\$?[A-Z]+/i,
	        row: /\$?\d+/
	      }
	    },
	    cell: {
	      // Excel is case insensitive, so the string "foo1" could be either a variable or a cell.
	      // To combat this, we match cells case insensitive, if the contain at least one "$", and case sensitive otherwise.
	      pattern: /\b[A-Z]+\d+\b|\$[A-Za-z]+\$?\d+\b|\b[A-Za-z]+\$\d+\b/,
	      alias: 'property'
	    },
	    number: /(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?\b/i,
	    boolean: /\b(?:FALSE|TRUE)\b/i,
	    operator: /[-+*/^%=&,]|<[=>]?|>=?/,
	    punctuation: /[[\]();{}|]/
	  };
	  Prism.languages['xlsx'] = Prism.languages['xls'] =
	    Prism.languages['excel-formula'];
	}
	return excelFormula_1;
}

var factor_1;
var hasRequiredFactor;

function requireFactor () {
	if (hasRequiredFactor) return factor_1;
	hasRequiredFactor = 1;

	factor_1 = factor;
	factor.displayName = 'factor';
	factor.aliases = [];
	function factor(Prism) {
(function (Prism) {
	    var comment_inside = {
	      function:
	        /\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\?{2,}|!{2,})\b/
	    };
	    var string_inside = {
	      number: /\\[^\s']|%\w/
	    };
	    var factor = {
	      comment: [
	        {
	          // ! single-line exclamation point comments with whitespace after/around the !
	          pattern: /(^|\s)(?:! .*|!$)/,
	          lookbehind: true,
	          inside: comment_inside
	        },
	        /* from basis/multiline: */
	        {
	          // /* comment */, /* comment*/
	          pattern: /(^|\s)\/\*\s[\s\S]*?\*\/(?=\s|$)/,
	          lookbehind: true,
	          greedy: true,
	          inside: comment_inside
	        },
	        {
	          // ![[ comment ]] , ![===[ comment]===]
	          pattern: /(^|\s)!\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
	          lookbehind: true,
	          greedy: true,
	          inside: comment_inside
	        }
	      ],
	      number: [
	        {
	          // basic base 10 integers 9, -9
	          pattern: /(^|\s)[+-]?\d+(?=\s|$)/,
	          lookbehind: true
	        },
	        {
	          // base prefix integers 0b010 0o70 0xad 0d10 0XAD -0xa9
	          pattern: /(^|\s)[+-]?0(?:b[01]+|o[0-7]+|d\d+|x[\dA-F]+)(?=\s|$)/i,
	          lookbehind: true
	        },
	        {
	          // fractional ratios 1/5 -1/5 and the literal float approximations 1/5. -1/5.
	          pattern: /(^|\s)[+-]?\d+\/\d+\.?(?=\s|$)/,
	          lookbehind: true
	        },
	        {
	          // positive mixed numbers 23+1/5 +23+1/5
	          pattern: /(^|\s)\+?\d+\+\d+\/\d+(?=\s|$)/,
	          lookbehind: true
	        },
	        {
	          // negative mixed numbers -23-1/5
	          pattern: /(^|\s)-\d+-\d+\/\d+(?=\s|$)/,
	          lookbehind: true
	        },
	        {
	          // basic decimal floats -0.01 0. .0 .1 -.1 -1. -12.13 +12.13
	          // and scientific notation with base 10 exponents 3e4 3e-4 .3e-4
	          pattern:
	            /(^|\s)[+-]?(?:\d*\.\d+|\d+\.\d*|\d+)(?:e[+-]?\d+)?(?=\s|$)/i,
	          lookbehind: true
	        },
	        {
	          // NAN literal syntax NAN: 80000deadbeef, NAN: a
	          pattern: /(^|\s)NAN:\s+[\da-fA-F]+(?=\s|$)/,
	          lookbehind: true
	        },
	        {
	          /*
	base prefix floats 0x1.0p3 (8.0) 0b1.010p2 (5.0) 0x1.p1 0b1.11111111p11111...
	"The normalized hex form ±0x1.MMMMMMMMMMMMM[pP]±EEEE allows any floating-point number to be specified precisely.
	The values of MMMMMMMMMMMMM and EEEE map directly to the mantissa and exponent fields of the binary IEEE 754 representation."
	<https://docs.factorcode.org/content/article-syntax-floats.html>
	*/
	          pattern:
	            /(^|\s)[+-]?0(?:b1\.[01]*|o1\.[0-7]*|d1\.\d*|x1\.[\dA-F]*)p\d+(?=\s|$)/i,
	          lookbehind: true
	        }
	      ],
	      // R/ regexp?\/\\/
	      regexp: {
	        pattern:
	          /(^|\s)R\/\s(?:\\\S|[^\\/])*\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\s|$)/,
	        lookbehind: true,
	        alias: 'number',
	        inside: {
	          variable: /\\\S/,
	          keyword: /[+?*\[\]^$(){}.|]/,
	          operator: {
	            pattern: /(\/)[idmsr]+(?:-[idmsr]+)?/,
	            lookbehind: true
	          }
	        }
	      },
	      boolean: {
	        pattern: /(^|\s)[tf](?=\s|$)/,
	        lookbehind: true
	      },
	      // SBUF" asd", URL" ://...", P" /etc/"
	      'custom-string': {
	        pattern: /(^|\s)[A-Z0-9\-]+"\s(?:\\\S|[^"\\])*"/,
	        lookbehind: true,
	        greedy: true,
	        alias: 'string',
	        inside: {
	          number: /\\\S|%\w|\//
	        }
	      },
	      'multiline-string': [
	        {
	          // STRING: name \n content \n ; -> CONSTANT: name "content" (symbol)
	          pattern: /(^|\s)STRING:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*;(?=\s|$)/,
	          lookbehind: true,
	          greedy: true,
	          alias: 'string',
	          inside: {
	            number: string_inside.number,
	            // trailing semicolon on its own line
	            'semicolon-or-setlocal': {
	              pattern: /([\r\n][ \t]*);(?=\s|$)/,
	              lookbehind: true,
	              alias: 'function'
	            }
	          }
	        },
	        {
	          // HEREDOC: marker \n content \n marker ; -> "content" (immediate)
	          pattern: /(^|\s)HEREDOC:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*\S+(?=\s|$)/,
	          lookbehind: true,
	          greedy: true,
	          alias: 'string',
	          inside: string_inside
	        },
	        {
	          // [[ string ]], [==[ string]==]
	          pattern: /(^|\s)\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
	          lookbehind: true,
	          greedy: true,
	          alias: 'string',
	          inside: string_inside
	        }
	      ],
	      'special-using': {
	        pattern: /(^|\s)USING:(?:\s\S+)*(?=\s+;(?:\s|$))/,
	        lookbehind: true,
	        alias: 'function',
	        inside: {
	          // this is essentially a regex for vocab names, which i don't want to specify
	          // but the USING: gets picked up as a vocab name
	          string: {
	            pattern: /(\s)[^:\s]+/,
	            lookbehind: true
	          }
	        }
	      },
	      /* this description of stack effect literal syntax is not complete and not as specific as theoretically possible
	trying to do better is more work and regex-computation-time than it's worth though.
	- we'd like to have the "delimiter" parts of the stack effect [ (, --, and ) ] be a different (less-important or comment-like) colour to the stack effect contents
	- we'd like if nested stack effects were treated as such rather than just appearing flat (with `inside`)
	- we'd like if the following variable name conventions were recognised specifically:
	special row variables = ..a b..
	type and stack effect annotations end with a colon = ( quot: ( a: ( -- ) -- b ) -- x ), ( x: number -- )
	word throws unconditional error = *
	any other word-like variable name = a ? q' etc
	https://docs.factorcode.org/content/article-effects.html
	these are pretty complicated to highlight properly without a real parser, and therefore out of scope
	the old pattern, which may be later useful, was: (^|\s)(?:call|execute|eval)?\((?:\s+[^"\r\n\t ]\S*)*?\s+--(?:\s+[^"\n\t ]\S*)*?\s+\)(?=\s|$)
	*/
	      // current solution is not great
	      'stack-effect-delimiter': [
	        {
	          // opening parenthesis
	          pattern: /(^|\s)(?:call|eval|execute)?\((?=\s)/,
	          lookbehind: true,
	          alias: 'operator'
	        },
	        {
	          // middle --
	          pattern: /(\s)--(?=\s)/,
	          lookbehind: true,
	          alias: 'operator'
	        },
	        {
	          // closing parenthesis
	          pattern: /(\s)\)(?=\s|$)/,
	          lookbehind: true,
	          alias: 'operator'
	        }
	      ],
	      combinators: {
	        pattern: null,
	        lookbehind: true,
	        alias: 'keyword'
	      },
	      'kernel-builtin': {
	        pattern: null,
	        lookbehind: true,
	        alias: 'variable'
	      },
	      'sequences-builtin': {
	        pattern: null,
	        lookbehind: true,
	        alias: 'variable'
	      },
	      'math-builtin': {
	        pattern: null,
	        lookbehind: true,
	        alias: 'variable'
	      },
	      'constructor-word': {
	        // <array> but not <=>
	        pattern: /(^|\s)<(?!=+>|-+>)\S+>(?=\s|$)/,
	        lookbehind: true,
	        alias: 'keyword'
	      },
	      'other-builtin-syntax': {
	        pattern: null,
	        lookbehind: true,
	        alias: 'operator'
	      },
	      /*
	full list of supported word naming conventions: (the convention appears outside of the [brackets])
	set-[x]
	change-[x]
	with-[x]
	new-[x]
	>[string]
	[base]>
	[string]>[number]
	+[symbol]+
	[boolean-word]?
	?[of]
	[slot-reader]>>
	>>[slot-setter]
	[slot-writer]<<
	([implementation-detail])
	[mutater]!
	[variant]*
	[prettyprint].
	$[help-markup]
	<constructors>, SYNTAX:, etc are supported by their own patterns.
	`with` and `new` from `kernel` are their own builtins.
	see <https://docs.factorcode.org/content/article-conventions.html>
	*/
	      'conventionally-named-word': {
	        pattern:
	          /(^|\s)(?!")(?:(?:change|new|set|with)-\S+|\$\S+|>[^>\s]+|[^:>\s]+>|[^>\s]+>[^>\s]+|\+[^+\s]+\+|[^?\s]+\?|\?[^?\s]+|[^>\s]+>>|>>[^>\s]+|[^<\s]+<<|\([^()\s]+\)|[^!\s]+!|[^*\s]\S*\*|[^.\s]\S*\.)(?=\s|$)/,
	        lookbehind: true,
	        alias: 'keyword'
	      },
	      'colon-syntax': {
	        pattern: /(^|\s)(?:[A-Z0-9\-]+#?)?:{1,2}\s+(?:;\S+|(?!;)\S+)(?=\s|$)/,
	        lookbehind: true,
	        greedy: true,
	        alias: 'function'
	      },
	      'semicolon-or-setlocal': {
	        pattern: /(\s)(?:;|:>)(?=\s|$)/,
	        lookbehind: true,
	        alias: 'function'
	      },
	      // do not highlight leading } or trailing X{ at the begin/end of the file as it's invalid syntax
	      'curly-brace-literal-delimiter': [
	        {
	          // opening
	          pattern: /(^|\s)[a-z]*\{(?=\s)/i,
	          lookbehind: true,
	          alias: 'operator'
	        },
	        {
	          // closing
	          pattern: /(\s)\}(?=\s|$)/,
	          lookbehind: true,
	          alias: 'operator'
	        }
	      ],
	      // do not highlight leading ] or trailing [ at the begin/end of the file as it's invalid syntax
	      'quotation-delimiter': [
	        {
	          // opening
	          pattern: /(^|\s)\[(?=\s)/,
	          lookbehind: true,
	          alias: 'operator'
	        },
	        {
	          // closing
	          pattern: /(\s)\](?=\s|$)/,
	          lookbehind: true,
	          alias: 'operator'
	        }
	      ],
	      'normal-word': {
	        pattern: /(^|\s)[^"\s]\S*(?=\s|$)/,
	        lookbehind: true
	      },
	      /*
	basic first-class string "a"
	with escaped double-quote "a\""
	escaped backslash "\\"
	and general escapes since Factor has so many "\N"
	syntax that works in the reference implementation that isn't fully
	supported because it's an implementation detail:
	"string 1""string 2" -> 2 strings (works anyway)
	"string"5 -> string, 5
	"string"[ ] -> string, quotation
	{ "a"} -> array<string>
	the rest of those examples all properly recognise the string, but not
	the other object (number, quotation, etc)
	this is fine for a regex-only implementation.
	*/
	      string: {
	        pattern: /"(?:\\\S|[^"\\])*"/,
	        greedy: true,
	        inside: string_inside
	      }
	    };
	    var escape = function (str) {
	      return (str + '').replace(/([.?*+\^$\[\]\\(){}|\-])/g, '\\$1')
	    };
	    var arrToWordsRegExp = function (arr) {
	      return new RegExp('(^|\\s)(?:' + arr.map(escape).join('|') + ')(?=\\s|$)')
	    };
	    var builtins = {
	      'kernel-builtin': [
	        'or',
	        '2nipd',
	        '4drop',
	        'tuck',
	        'wrapper',
	        'nip',
	        'wrapper?',
	        'callstack>array',
	        'die',
	        'dupd',
	        'callstack',
	        'callstack?',
	        '3dup',
	        'hashcode',
	        'pick',
	        '4nip',
	        'build',
	        '>boolean',
	        'nipd',
	        'clone',
	        '5nip',
	        'eq?',
	        '?',
	        '=',
	        'swapd',
	        '2over',
	        'clear',
	        '2dup',
	        'get-retainstack',
	        'not',
	        'tuple?',
	        'dup',
	        '3nipd',
	        'call',
	        '-rotd',
	        'object',
	        'drop',
	        'assert=',
	        'assert?',
	        '-rot',
	        'execute',
	        'boa',
	        'get-callstack',
	        'curried?',
	        '3drop',
	        'pickd',
	        'overd',
	        'over',
	        'roll',
	        '3nip',
	        'swap',
	        'and',
	        '2nip',
	        'rotd',
	        'throw',
	        '(clone)',
	        'hashcode*',
	        'spin',
	        'reach',
	        '4dup',
	        'equal?',
	        'get-datastack',
	        'assert',
	        '2drop',
	        '<wrapper>',
	        'boolean?',
	        'identity-hashcode',
	        'identity-tuple?',
	        'null',
	        'composed?',
	        'new',
	        '5drop',
	        'rot',
	        '-roll',
	        'xor',
	        'identity-tuple',
	        'boolean'
	      ],
	      'other-builtin-syntax': [
	        // syntax
	        '=======',
	        'recursive',
	        'flushable',
	        '>>',
	        '<<<<<<',
	        'M\\',
	        'B',
	        'PRIVATE>',
	        '\\',
	        '======',
	        'final',
	        'inline',
	        'delimiter',
	        'deprecated',
	        '<PRIVATE',
	        '>>>>>>',
	        '<<<<<<<',
	        'parse-complex',
	        'malformed-complex',
	        'read-only',
	        '>>>>>>>',
	        'call-next-method',
	        '<<',
	        'foldable', // literals
	        '$',
	        '$[',
	        '${'
	      ],
	      'sequences-builtin': [
	        'member-eq?',
	        'mismatch',
	        'append',
	        'assert-sequence=',
	        'longer',
	        'repetition',
	        'clone-like',
	        '3sequence',
	        'assert-sequence?',
	        'last-index-from',
	        'reversed',
	        'index-from',
	        'cut*',
	        'pad-tail',
	        'join-as',
	        'remove-eq!',
	        'concat-as',
	        'but-last',
	        'snip',
	        'nths',
	        'nth',
	        'sequence',
	        'longest',
	        'slice?',
	        '<slice>',
	        'remove-nth',
	        'tail-slice',
	        'empty?',
	        'tail*',
	        'member?',
	        'virtual-sequence?',
	        'set-length',
	        'drop-prefix',
	        'iota',
	        'unclip',
	        'bounds-error?',
	        'unclip-last-slice',
	        'non-negative-integer-expected',
	        'non-negative-integer-expected?',
	        'midpoint@',
	        'longer?',
	        '?set-nth',
	        '?first',
	        'rest-slice',
	        'prepend-as',
	        'prepend',
	        'fourth',
	        'sift',
	        'subseq-start',
	        'new-sequence',
	        '?last',
	        'like',
	        'first4',
	        '1sequence',
	        'reverse',
	        'slice',
	        'virtual@',
	        'repetition?',
	        'set-last',
	        'index',
	        '4sequence',
	        'max-length',
	        'set-second',
	        'immutable-sequence',
	        'first2',
	        'first3',
	        'supremum',
	        'unclip-slice',
	        'suffix!',
	        'insert-nth',
	        'tail',
	        '3append',
	        'short',
	        'suffix',
	        'concat',
	        'flip',
	        'immutable?',
	        'reverse!',
	        '2sequence',
	        'sum',
	        'delete-all',
	        'indices',
	        'snip-slice',
	        '<iota>',
	        'check-slice',
	        'sequence?',
	        'head',
	        'append-as',
	        'halves',
	        'sequence=',
	        'collapse-slice',
	        '?second',
	        'slice-error?',
	        'product',
	        'bounds-check?',
	        'bounds-check',
	        'immutable',
	        'virtual-exemplar',
	        'harvest',
	        'remove',
	        'pad-head',
	        'last',
	        'set-fourth',
	        'cartesian-product',
	        'remove-eq',
	        'shorten',
	        'shorter',
	        'reversed?',
	        'shorter?',
	        'shortest',
	        'head-slice',
	        'pop*',
	        'tail-slice*',
	        'but-last-slice',
	        'iota?',
	        'append!',
	        'cut-slice',
	        'new-resizable',
	        'head-slice*',
	        'sequence-hashcode',
	        'pop',
	        'set-nth',
	        '?nth',
	        'second',
	        'join',
	        'immutable-sequence?',
	        '<reversed>',
	        '3append-as',
	        'virtual-sequence',
	        'subseq?',
	        'remove-nth!',
	        'length',
	        'last-index',
	        'lengthen',
	        'assert-sequence',
	        'copy',
	        'move',
	        'third',
	        'first',
	        'tail?',
	        'set-first',
	        'prefix',
	        'bounds-error',
	        '<repetition>',
	        'exchange',
	        'surround',
	        'cut',
	        'min-length',
	        'set-third',
	        'push-all',
	        'head?',
	        'subseq-start-from',
	        'delete-slice',
	        'rest',
	        'sum-lengths',
	        'head*',
	        'infimum',
	        'remove!',
	        'glue',
	        'slice-error',
	        'subseq',
	        'push',
	        'replace-slice',
	        'subseq-as',
	        'unclip-last'
	      ],
	      'math-builtin': [
	        'number=',
	        'next-power-of-2',
	        '?1+',
	        'fp-special?',
	        'imaginary-part',
	        'float>bits',
	        'number?',
	        'fp-infinity?',
	        'bignum?',
	        'fp-snan?',
	        'denominator',
	        'gcd',
	        '*',
	        '+',
	        'fp-bitwise=',
	        '-',
	        'u>=',
	        '/',
	        '>=',
	        'bitand',
	        'power-of-2?',
	        'log2-expects-positive',
	        'neg?',
	        '<',
	        'log2',
	        '>',
	        'integer?',
	        'number',
	        'bits>double',
	        '2/',
	        'zero?',
	        'bits>float',
	        'float?',
	        'shift',
	        'ratio?',
	        'rect>',
	        'even?',
	        'ratio',
	        'fp-sign',
	        'bitnot',
	        '>fixnum',
	        'complex?',
	        '/i',
	        'integer>fixnum',
	        '/f',
	        'sgn',
	        '>bignum',
	        'next-float',
	        'u<',
	        'u>',
	        'mod',
	        'recip',
	        'rational',
	        '>float',
	        '2^',
	        'integer',
	        'fixnum?',
	        'neg',
	        'fixnum',
	        'sq',
	        'bignum',
	        '>rect',
	        'bit?',
	        'fp-qnan?',
	        'simple-gcd',
	        'complex',
	        '<fp-nan>',
	        'real',
	        '>fraction',
	        'double>bits',
	        'bitor',
	        'rem',
	        'fp-nan-payload',
	        'real-part',
	        'log2-expects-positive?',
	        'prev-float',
	        'align',
	        'unordered?',
	        'float',
	        'fp-nan?',
	        'abs',
	        'bitxor',
	        'integer>fixnum-strict',
	        'u<=',
	        'odd?',
	        '<=',
	        '/mod',
	        '>integer',
	        'real?',
	        'rational?',
	        'numerator'
	      ] // that's all for now
	    };
	    Object.keys(builtins).forEach(function (k) {
	      factor[k].pattern = arrToWordsRegExp(builtins[k]);
	    });
	    var combinators = [
	      // kernel
	      '2bi',
	      'while',
	      '2tri',
	      'bi*',
	      '4dip',
	      'both?',
	      'same?',
	      'tri@',
	      'curry',
	      'prepose',
	      '3bi',
	      '?if',
	      'tri*',
	      '2keep',
	      '3keep',
	      'curried',
	      '2keepd',
	      'when',
	      '2bi*',
	      '2tri*',
	      '4keep',
	      'bi@',
	      'keepdd',
	      'do',
	      'unless*',
	      'tri-curry',
	      'if*',
	      'loop',
	      'bi-curry*',
	      'when*',
	      '2bi@',
	      '2tri@',
	      'with',
	      '2with',
	      'either?',
	      'bi',
	      'until',
	      '3dip',
	      '3curry',
	      'tri-curry*',
	      'tri-curry@',
	      'bi-curry',
	      'keepd',
	      'compose',
	      '2dip',
	      'if',
	      '3tri',
	      'unless',
	      'tuple',
	      'keep',
	      '2curry',
	      'tri',
	      'most',
	      'while*',
	      'dip',
	      'composed',
	      'bi-curry@', // sequences
	      'find-last-from',
	      'trim-head-slice',
	      'map-as',
	      'each-from',
	      'none?',
	      'trim-tail',
	      'partition',
	      'if-empty',
	      'accumulate*',
	      'reject!',
	      'find-from',
	      'accumulate-as',
	      'collector-for-as',
	      'reject',
	      'map',
	      'map-sum',
	      'accumulate!',
	      '2each-from',
	      'follow',
	      'supremum-by',
	      'map!',
	      'unless-empty',
	      'collector',
	      'padding',
	      'reduce-index',
	      'replicate-as',
	      'infimum-by',
	      'trim-tail-slice',
	      'count',
	      'find-index',
	      'filter',
	      'accumulate*!',
	      'reject-as',
	      'map-integers',
	      'map-find',
	      'reduce',
	      'selector',
	      'interleave',
	      '2map',
	      'filter-as',
	      'binary-reduce',
	      'map-index-as',
	      'find',
	      'produce',
	      'filter!',
	      'replicate',
	      'cartesian-map',
	      'cartesian-each',
	      'find-index-from',
	      'map-find-last',
	      '3map-as',
	      '3map',
	      'find-last',
	      'selector-as',
	      '2map-as',
	      '2map-reduce',
	      'accumulate',
	      'each',
	      'each-index',
	      'accumulate*-as',
	      'when-empty',
	      'all?',
	      'collector-as',
	      'push-either',
	      'new-like',
	      'collector-for',
	      '2selector',
	      'push-if',
	      '2all?',
	      'map-reduce',
	      '3each',
	      'any?',
	      'trim-slice',
	      '2reduce',
	      'change-nth',
	      'produce-as',
	      '2each',
	      'trim',
	      'trim-head',
	      'cartesian-find',
	      'map-index', // math
	      'if-zero',
	      'each-integer',
	      'unless-zero',
	      '(find-integer)',
	      'when-zero',
	      'find-last-integer',
	      '(all-integers?)',
	      'times',
	      '(each-integer)',
	      'find-integer',
	      'all-integers?', // math.combinators
	      'unless-negative',
	      'if-positive',
	      'when-positive',
	      'when-negative',
	      'unless-positive',
	      'if-negative', // combinators
	      'case',
	      '2cleave',
	      'cond>quot',
	      'case>quot',
	      '3cleave',
	      'wrong-values',
	      'to-fixed-point',
	      'alist>quot',
	      'cond',
	      'cleave',
	      'call-effect',
	      'recursive-hashcode',
	      'spread',
	      'deep-spread>quot', // combinators.short-circuit
	      '2||',
	      '0||',
	      'n||',
	      '0&&',
	      '2&&',
	      '3||',
	      '1||',
	      '1&&',
	      'n&&',
	      '3&&', // combinators.smart
	      'smart-unless*',
	      'keep-inputs',
	      'reduce-outputs',
	      'smart-when*',
	      'cleave>array',
	      'smart-with',
	      'smart-apply',
	      'smart-if',
	      'inputs/outputs',
	      'output>sequence-n',
	      'map-outputs',
	      'map-reduce-outputs',
	      'dropping',
	      'output>array',
	      'smart-map-reduce',
	      'smart-2map-reduce',
	      'output>array-n',
	      'nullary',
	      'input<sequence',
	      'append-outputs',
	      'drop-inputs',
	      'inputs',
	      'smart-2reduce',
	      'drop-outputs',
	      'smart-reduce',
	      'preserving',
	      'smart-when',
	      'outputs',
	      'append-outputs-as',
	      'smart-unless',
	      'smart-if*',
	      'sum-outputs',
	      'input<sequence-unsafe',
	      'output>sequence' // tafn
	    ];
	    factor.combinators.pattern = arrToWordsRegExp(combinators);
	    Prism.languages.factor = factor;
	  })(Prism);
	}
	return factor_1;
}

var _false;
var hasRequired_false;

function require_false () {
	if (hasRequired_false) return _false;
	hasRequired_false = 1;

	_false = $false;
	$false.displayName = '$false';
	$false.aliases = [];
	function $false(Prism) {
(function (Prism) {
	    /**
	     * Based on the manual by Wouter van Oortmerssen.
	     *
	     * @see {@link https://github.com/PrismJS/prism/issues/2801#issue-829717504}
	     */
	    Prism.languages['false'] = {
	      comment: {
	        pattern: /\{[^}]*\}/
	      },
	      string: {
	        pattern: /"[^"]*"/,
	        greedy: true
	      },
	      'character-code': {
	        pattern: /'(?:[^\r]|\r\n?)/,
	        alias: 'number'
	      },
	      'assembler-code': {
	        pattern: /\d+`/,
	        alias: 'important'
	      },
	      number: /\d+/,
	      operator: /[-!#$%&'*+,./:;=>?@\\^_`|~ßø]/,
	      punctuation: /\[|\]/,
	      variable: /[a-z]/,
	      'non-standard': {
	        pattern: /[()<BDO®]/,
	        alias: 'bold'
	      }
	    };
	  })(Prism);
	}
	return _false;
}

var firestoreSecurityRules_1;
var hasRequiredFirestoreSecurityRules;

function requireFirestoreSecurityRules () {
	if (hasRequiredFirestoreSecurityRules) return firestoreSecurityRules_1;
	hasRequiredFirestoreSecurityRules = 1;

	firestoreSecurityRules_1 = firestoreSecurityRules;
	firestoreSecurityRules.displayName = 'firestoreSecurityRules';
	firestoreSecurityRules.aliases = [];
	function firestoreSecurityRules(Prism) {
	  Prism.languages['firestore-security-rules'] = Prism.languages.extend(
	    'clike',
	    {
	      comment: /\/\/.*/,
	      keyword:
	        /\b(?:allow|function|if|match|null|return|rules_version|service)\b/,
	      operator: /&&|\|\||[<>!=]=?|[-+*/%]|\b(?:in|is)\b/
	    }
	  );
	  delete Prism.languages['firestore-security-rules']['class-name'];
	  Prism.languages.insertBefore('firestore-security-rules', 'keyword', {
	    path: {
	      pattern:
	        /(^|[\s(),])(?:\/(?:[\w\xA0-\uFFFF]+|\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)))+/,
	      lookbehind: true,
	      greedy: true,
	      inside: {
	        variable: {
	          pattern: /\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)/,
	          inside: {
	            operator: /=/,
	            keyword: /\*\*/,
	            punctuation: /[.$(){}]/
	          }
	        },
	        punctuation: /\//
	      }
	    },
	    method: {
	      // to make the pattern shorter, the actual method names are omitted
	      pattern: /(\ballow\s+)[a-z]+(?:\s*,\s*[a-z]+)*(?=\s*[:;])/,
	      lookbehind: true,
	      alias: 'builtin',
	      inside: {
	        punctuation: /,/
	      }
	    }
	  });
	}
	return firestoreSecurityRules_1;
}

var flow_1;
var hasRequiredFlow;

function requireFlow () {
	if (hasRequiredFlow) return flow_1;
	hasRequiredFlow = 1;

	flow_1 = flow;
	flow.displayName = 'flow';
	flow.aliases = [];
	function flow(Prism) {
(function (Prism) {
	    Prism.languages.flow = Prism.languages.extend('javascript', {});
	    Prism.languages.insertBefore('flow', 'keyword', {
	      type: [
	        {
	          pattern:
	            /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|any|mixed|null|void)\b/,
	          alias: 'tag'
	        }
	      ]
	    });
	    Prism.languages.flow['function-variable'].pattern =
	      /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i;
	    delete Prism.languages.flow['parameter'];
	    Prism.languages.insertBefore('flow', 'operator', {
	      'flow-punctuation': {
	        pattern: /\{\||\|\}/,
	        alias: 'punctuation'
	      }
	    });
	    if (!Array.isArray(Prism.languages.flow.keyword)) {
	      Prism.languages.flow.keyword = [Prism.languages.flow.keyword];
	    }
	    Prism.languages.flow.keyword.unshift(
	      {
	        pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/,
	        lookbehind: true
	      },
	      {
	        pattern:
	          /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/,
	        lookbehind: true
	      }
	    );
	  })(Prism);
	}
	return flow_1;
}

var fortran_1;
var hasRequiredFortran;

function requireFortran () {
	if (hasRequiredFortran) return fortran_1;
	hasRequiredFortran = 1;

	fortran_1 = fortran;
	fortran.displayName = 'fortran';
	fortran.aliases = [];
	function fortran(Prism) {
	  Prism.languages.fortran = {
	    'quoted-number': {
	      pattern: /[BOZ](['"])[A-F0-9]+\1/i,
	      alias: 'number'
	    },
	    string: {
	      pattern:
	        /(?:\b\w+_)?(['"])(?:\1\1|&(?:\r\n?|\n)(?:[ \t]*!.*(?:\r\n?|\n)|(?![ \t]*!))|(?!\1).)*(?:\1|&)/,
	      inside: {
	        comment: {
	          pattern: /(&(?:\r\n?|\n)\s*)!.*/,
	          lookbehind: true
	        }
	      }
	    },
	    comment: {
	      pattern: /!.*/,
	      greedy: true
	    },
	    boolean: /\.(?:FALSE|TRUE)\.(?:_\w+)?/i,
	    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[ED][+-]?\d+)?(?:_\w+)?/i,
	    keyword: [
	      // Types
	      /\b(?:CHARACTER|COMPLEX|DOUBLE ?PRECISION|INTEGER|LOGICAL|REAL)\b/i, // END statements
	      /\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE(?! PROCEDURE)|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\b/i, // Statements
	      /\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\b/i, // Others
	      /\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEIF|ELSEWHERE|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\b/i
	    ],
	    operator: [
	      /\*\*|\/\/|=>|[=\/]=|[<>]=?|::|[+\-*=%]|\.[A-Z]+\./i,
	      {
	        // Use lookbehind to prevent confusion with (/ /)
	        pattern: /(^|(?!\().)\/(?!\))/,
	        lookbehind: true
	      }
	    ],
	    punctuation: /\(\/|\/\)|[(),;:&]/
	  };
	}
	return fortran_1;
}

var fsharp_1;
var hasRequiredFsharp;

function requireFsharp () {
	if (hasRequiredFsharp) return fsharp_1;
	hasRequiredFsharp = 1;

	fsharp_1 = fsharp;
	fsharp.displayName = 'fsharp';
	fsharp.aliases = [];
	function fsharp(Prism) {
	  Prism.languages.fsharp = Prism.languages.extend('clike', {
	    comment: [
	      {
	        pattern: /(^|[^\\])\(\*(?!\))[\s\S]*?\*\)/,
	        lookbehind: true,
	        greedy: true
	      },
	      {
	        pattern: /(^|[^\\:])\/\/.*/,
	        lookbehind: true,
	        greedy: true
	      }
	    ],
	    string: {
	      pattern: /(?:"""[\s\S]*?"""|@"(?:""|[^"])*"|"(?:\\[\s\S]|[^\\"])*")B?/,
	      greedy: true
	    },
	    'class-name': {
	      pattern:
	        /(\b(?:exception|inherit|interface|new|of|type)\s+|\w\s*:\s*|\s:\??>\s*)[.\w]+\b(?:\s*(?:->|\*)\s*[.\w]+\b)*(?!\s*[:.])/,
	      lookbehind: true,
	      inside: {
	        operator: /->|\*/,
	        punctuation: /\./
	      }
	    },
	    keyword:
	      /\b(?:let|return|use|yield)(?:!\B|\b)|\b(?:abstract|and|as|asr|assert|atomic|base|begin|break|checked|class|component|const|constraint|constructor|continue|default|delegate|do|done|downcast|downto|eager|elif|else|end|event|exception|extern|external|false|finally|fixed|for|fun|function|functor|global|if|in|include|inherit|inline|interface|internal|land|lazy|lor|lsl|lsr|lxor|match|member|method|mixin|mod|module|mutable|namespace|new|not|null|object|of|open|or|override|parallel|private|process|protected|public|pure|rec|sealed|select|sig|static|struct|tailcall|then|to|trait|true|try|type|upcast|val|virtual|void|volatile|when|while|with)\b/,
	    number: [
	      /\b0x[\da-fA-F]+(?:LF|lf|un)?\b/,
	      /\b0b[01]+(?:uy|y)?\b/,
	      /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[fm]|e[+-]?\d+)?\b/i,
	      /\b\d+(?:[IlLsy]|UL|u[lsy]?)?\b/
	    ],
	    operator:
	      /([<>~&^])\1\1|([*.:<>&])\2|<-|->|[!=:]=|<?\|{1,3}>?|\??(?:<=|>=|<>|[-+*/%=<>])\??|[!?^&]|~[+~-]|:>|:\?>?/
	  });
	  Prism.languages.insertBefore('fsharp', 'keyword', {
	    preprocessor: {
	      pattern: /(^[\t ]*)#.*/m,
	      lookbehind: true,
	      alias: 'property',
	      inside: {
	        directive: {
	          pattern: /(^#)\b(?:else|endif|if|light|line|nowarn)\b/,
	          lookbehind: true,
	          alias: 'keyword'
	        }
	      }
	    }
	  });
	  Prism.languages.insertBefore('fsharp', 'punctuation', {
	    'computation-expression': {
	      pattern: /\b[_a-z]\w*(?=\s*\{)/i,
	      alias: 'keyword'
	    }
	  });
	  Prism.languages.insertBefore('fsharp', 'string', {
	    annotation: {
	      pattern: /\[<.+?>\]/,
	      greedy: true,
	      inside: {
	        punctuation: /^\[<|>\]$/,
	        'class-name': {
	          pattern: /^\w+$|(^|;\s*)[A-Z]\w*(?=\()/,
	          lookbehind: true
	        },
	        'annotation-content': {
	          pattern: /[\s\S]+/,
	          inside: Prism.languages.fsharp
	        }
	      }
	    },
	    char: {
	      pattern:
	        /'(?:[^\\']|\\(?:.|\d{3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|U[a-fA-F\d]{8}))'B?/,
	      greedy: true
	    }
	  });
	}
	return fsharp_1;
}

var ftl_1;
var hasRequiredFtl;

function requireFtl () {
	if (hasRequiredFtl) return ftl_1;
	hasRequiredFtl = 1;
	var refractorMarkupTemplating = requireMarkupTemplating();
	ftl_1 = ftl;
	ftl.displayName = 'ftl';
	ftl.aliases = [];
	function ftl(Prism) {
	  Prism.register(refractorMarkupTemplating)
	  ;(function (Prism) {
	    // https://freemarker.apache.org/docs/dgui_template_exp.html
	    // FTL expression with 4 levels of nesting supported
	    var FTL_EXPR =
	      /[^<()"']|\((?:<expr>)*\)|<(?!#--)|<#--(?:[^-]|-(?!->))*-->|"(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*'/
	        .source;
	    for (var i = 0; i < 2; i++) {
	      FTL_EXPR = FTL_EXPR.replace(/<expr>/g, function () {
	        return FTL_EXPR
	      });
	    }
	    FTL_EXPR = FTL_EXPR.replace(/<expr>/g, /[^\s\S]/.source);
	    var ftl = {
	      comment: /<#--[\s\S]*?-->/,
	      string: [
	        {
	          // raw string
	          pattern: /\br("|')(?:(?!\1)[^\\]|\\.)*\1/,
	          greedy: true
	        },
	        {
	          pattern: RegExp(
	            /("|')(?:(?!\1|\$\{)[^\\]|\\.|\$\{(?:(?!\})(?:<expr>))*\})*\1/.source.replace(
	              /<expr>/g,
	              function () {
	                return FTL_EXPR
	              }
	            )
	          ),
	          greedy: true,
	          inside: {
	            interpolation: {
	              pattern: RegExp(
	                /((?:^|[^\\])(?:\\\\)*)\$\{(?:(?!\})(?:<expr>))*\}/.source.replace(
	                  /<expr>/g,
	                  function () {
	                    return FTL_EXPR
	                  }
	                )
	              ),
	              lookbehind: true,
	              inside: {
	                'interpolation-punctuation': {
	                  pattern: /^\$\{|\}$/,
	                  alias: 'punctuation'
	                },
	                rest: null
	              }
	            }
	          }
	        }
	      ],
	      keyword: /\b(?:as)\b/,
	      boolean: /\b(?:false|true)\b/,
	      'builtin-function': {
	        pattern: /((?:^|[^?])\?\s*)\w+/,
	        lookbehind: true,
	        alias: 'function'
	      },
	      function: /\b\w+(?=\s*\()/,
	      number: /\b\d+(?:\.\d+)?\b/,
	      operator:
	        /\.\.[<*!]?|->|--|\+\+|&&|\|\||\?{1,2}|[-+*/%!=<>]=?|\b(?:gt|gte|lt|lte)\b/,
	      punctuation: /[,;.:()[\]{}]/
	    };
	    ftl.string[1].inside.interpolation.inside.rest = ftl;
	    Prism.languages.ftl = {
	      'ftl-comment': {
	        // the pattern is shortened to be more efficient
	        pattern: /^<#--[\s\S]*/,
	        alias: 'comment'
	      },
	      'ftl-directive': {
	        pattern: /^<[\s\S]+>$/,
	        inside: {
	          directive: {
	            pattern: /(^<\/?)[#@][a-z]\w*/i,
	            lookbehind: true,
	            alias: 'keyword'
	          },
	          punctuation: /^<\/?|\/?>$/,
	          content: {
	            pattern: /\s*\S[\s\S]*/,
	            alias: 'ftl',
	            inside: ftl
	          }
	        }
	      },
	      'ftl-interpolation': {
	        pattern: /^\$\{[\s\S]*\}$/,
	        inside: {
	          punctuation: /^\$\{|\}$/,
	          content: {
	            pattern: /\s*\S[\s\S]*/,
	            alias: 'ftl',
	            inside: ftl
	          }
	        }
	      }
	    };
	    Prism.hooks.add('before-tokenize', function (env) {
	      // eslint-disable-next-line regexp/no-useless-lazy
	      var pattern = RegExp(
	        /<#--[\s\S]*?-->|<\/?[#@][a-zA-Z](?:<expr>)*?>|\$\{(?:<expr>)*?\}/.source.replace(
	          /<expr>/g,
	          function () {
	            return FTL_EXPR
	          }
	        ),
	        'gi'
	      );
	      Prism.languages['markup-templating'].buildPlaceholders(
	        env,
	        'ftl',
	        pattern
	      );
	    });
	    Prism.hooks.add('after-tokenize', function (env) {
	      Prism.languages['markup-templating'].tokenizePlaceholders(env, 'ftl');
	    });
	  })(Prism);
	}
	return ftl_1;
}

var gap_1;
var hasRequiredGap;

function requireGap () {
	if (hasRequiredGap) return gap_1;
	hasRequiredGap = 1;

	gap_1 = gap;
	gap.displayName = 'gap';
	gap.aliases = [];
	function gap(Prism) {
	  // https://www.gap-system.org/Manuals/doc/ref/chap4.html
	  // https://www.gap-system.org/Manuals/doc/ref/chap27.html
	  Prism.languages.gap = {
	    shell: {
	      pattern: /^gap>[\s\S]*?(?=^gap>|$(?![\s\S]))/m,
	      greedy: true,
	      inside: {
	        gap: {
	          pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
	          lookbehind: true,
	          inside: null // see below
	        },
	        punctuation: /^gap>/
	      }
	    },
	    comment: {
	      pattern: /#.*/,
	      greedy: true
	    },
	    string: {
	      pattern:
	        /(^|[^\\'"])(?:'(?:[^\r\n\\']|\\.){1,10}'|"(?:[^\r\n\\"]|\\.)*"(?!")|"""[\s\S]*?""")/,
	      lookbehind: true,
	      greedy: true,
	      inside: {
	        continuation: {
	          pattern: /([\r\n])>/,
	          lookbehind: true,
	          alias: 'punctuation'
	        }
	      }
	    },
	    keyword:
	      /\b(?:Assert|Info|IsBound|QUIT|TryNextMethod|Unbind|and|atomic|break|continue|do|elif|else|end|fi|for|function|if|in|local|mod|not|od|or|quit|readonly|readwrite|rec|repeat|return|then|until|while)\b/,
	    boolean: /\b(?:false|true)\b/,
	    function: /\b[a-z_]\w*(?=\s*\()/i,
	    number: {
	      pattern:
	        /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
	      lookbehind: true
	    },
	    continuation: {
	      pattern: /([\r\n])>/,
	      lookbehind: true,
	      alias: 'punctuation'
	    },
	    operator: /->|[-+*/^~=!]|<>|[<>]=?|:=|\.\./,
	    punctuation: /[()[\]{},;.:]/
	  };
	  Prism.languages.gap.shell.inside.gap.inside = Prism.languages.gap;
	}
	return gap_1;
}

var gcode_1;
var hasRequiredGcode;

function requireGcode () {
	if (hasRequiredGcode) return gcode_1;
	hasRequiredGcode = 1;

	gcode_1 = gcode;
	gcode.displayName = 'gcode';
	gcode.aliases = [];
	function gcode(Prism) {
	  Prism.languages.gcode = {
	    comment: /;.*|\B\(.*?\)\B/,
	    string: {
	      pattern: /"(?:""|[^"])*"/,
	      greedy: true
	    },
	    keyword: /\b[GM]\d+(?:\.\d+)?\b/,
	    property: /\b[A-Z]/,
	    checksum: {
	      pattern: /(\*)\d+/,
	      lookbehind: true,
	      alias: 'number'
	    },
	    // T0:0:0
	    punctuation: /[:*]/
	  };
	}
	return gcode_1;
}

var gdscript_1;
var hasRequiredGdscript;

function requireGdscript () {
	if (hasRequiredGdscript) return gdscript_1;
	hasRequiredGdscript = 1;

	gdscript_1 = gdscript;
	gdscript.displayName = 'gdscript';
	gdscript.aliases = [];
	function gdscript(Prism) {
	  Prism.languages.gdscript = {
	    comment: /#.*/,
	    string: {
	      pattern:
	        /@?(?:("|')(?:(?!\1)[^\n\\]|\\[\s\S])*\1(?!"|')|"""(?:[^\\]|\\[\s\S])*?""")/,
	      greedy: true
	    },
	    'class-name': {
	      // class_name Foo, extends Bar, class InnerClass
	      // export(int) var baz, export(int, 0) var i
	      // as Node
	      // const FOO: int = 9, var bar: bool = true
	      // func add(reference: Item, amount: int) -> Item:
	      pattern:
	        /(^(?:class|class_name|extends)[ \t]+|^export\([ \t]*|\bas[ \t]+|(?:\b(?:const|var)[ \t]|[,(])[ \t]*\w+[ \t]*:[ \t]*|->[ \t]*)[a-zA-Z_]\w*/m,
	      lookbehind: true
	    },
	    keyword:
	      /\b(?:and|as|assert|break|breakpoint|class|class_name|const|continue|elif|else|enum|export|extends|for|func|if|in|is|master|mastersync|match|not|null|onready|or|pass|preload|puppet|puppetsync|remote|remotesync|return|self|setget|signal|static|tool|var|while|yield)\b/,
	    function: /\b[a-z_]\w*(?=[ \t]*\()/i,
	    variable: /\$\w+/,
	    number: [
	      /\b0b[01_]+\b|\b0x[\da-fA-F_]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.[\d_]+)(?:e[+-]?[\d_]+)?\b/,
	      /\b(?:INF|NAN|PI|TAU)\b/
	    ],
	    constant: /\b[A-Z][A-Z_\d]*\b/,
	    boolean: /\b(?:false|true)\b/,
	    operator: /->|:=|&&|\|\||<<|>>|[-+*/%&|!<>=]=?|[~^]/,
	    punctuation: /[.:,;()[\]{}]/
	  };
	}
	return gdscript_1;
}

var gedcom_1;
var hasRequiredGedcom;

function requireGedcom () {
	if (hasRequiredGedcom) return gedcom_1;
	hasRequiredGedcom = 1;

	gedcom_1 = gedcom;
	gedcom.displayName = 'gedcom';
	gedcom.aliases = [];
	function gedcom(Prism) {
	  Prism.languages.gedcom = {
	    'line-value': {
	      // Preceded by level, optional pointer, and tag
	      pattern:
	        /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?\w+ ).+/m,
	      lookbehind: true,
	      inside: {
	        pointer: {
	          pattern: /^@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@$/,
	          alias: 'variable'
	        }
	      }
	    },
	    tag: {
	      // Preceded by level and optional pointer
	      pattern:
	        /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?)\w+/m,
	      lookbehind: true,
	      alias: 'string'
	    },
	    level: {
	      pattern: /(^[\t ]*)\d+/m,
	      lookbehind: true,
	      alias: 'number'
	    },
	    pointer: {
	      pattern: /@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@/,
	      alias: 'variable'
	    }
	  };
	}
	return gedcom_1;
}

var gherkin_1;
var hasRequiredGherkin;

function requireGherkin () {
	if (hasRequiredGherkin) return gherkin_1;
	hasRequiredGherkin = 1;

	gherkin_1 = gherkin;
	gherkin.displayName = 'gherkin';
	gherkin.aliases = [];
	function gherkin(Prism) {
(function (Prism) {
	    var tableRow = /(?:\r?\n|\r)[ \t]*\|.+\|(?:(?!\|).)*/.source;
	    Prism.languages.gherkin = {
	      pystring: {
	        pattern: /("""|''')[\s\S]+?\1/,
	        alias: 'string'
	      },
	      comment: {
	        pattern: /(^[ \t]*)#.*/m,
	        lookbehind: true
	      },
	      tag: {
	        pattern: /(^[ \t]*)@\S*/m,
	        lookbehind: true
	      },
	      feature: {
	        pattern:
	          /((?:^|\r?\n|\r)[ \t]*)(?:Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Característica|Egenskab|Egenskap|Eiginleiki|Feature|Fīča|Fitur|Fonctionnalité|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcţionalitate|Funcționalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitāte|Funkcionalnost|Funkcja|Funksie|Funktionalität|Funktionalitéit|Funzionalità|Hwaet|Hwæt|Jellemző|Karakteristik|Lastnost|Mak|Mogucnost|laH|Mogućnost|Moznosti|Možnosti|OH HAI|Omadus|Ominaisuus|Osobina|Özellik|Potrzeba biznesowa|perbogh|poQbogh malja'|Požadavek|Požiadavka|Pretty much|Qap|Qu'meH 'ut|Savybė|Tính năng|Trajto|Vermoë|Vlastnosť|Właściwość|Značilnost|Δυνατότητα|Λειτουργία|Могућност|Мөмкинлек|Особина|Свойство|Үзенчәлеклелек|Функционал|Функционалност|Функция|Функціонал|תכונה|خاصية|خصوصیت|صلاحیت|کاروبار کی ضرورت|وِیژگی|रूप लेख|ਖਾਸੀਅਤ|ਨਕਸ਼ ਨੁਹਾਰ|ਮੁਹਾਂਦਰਾ|గుణము|ಹೆಚ್ಚಳ|ความต้องการทางธุรกิจ|ความสามารถ|โครงหลัก|기능|フィーチャ|功能|機能):(?:[^:\r\n]+(?:\r?\n|\r|$))*/,
	        lookbehind: true,
	        inside: {
	          important: {
	            pattern: /(:)[^\r\n]+/,
	            lookbehind: true
	          },
	          keyword: /[^:\r\n]+:/
	        }
	      },
	      scenario: {
	        pattern:
	          /(^[ \t]*)(?:Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|Ær|Agtergrond|All y'all|Antecedentes|Antecedents|Atburðarás|Atburðarásir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bối cảnh|Cefndir|Cenario|Cenário|Cenario de Fundo|Cenário de Fundo|Cenarios|Cenários|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dæmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineação do Cenário|Dis is what went down|Dữ liệu|Dyagram Senaryo|Dyagram senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenário|EXAMPLZ|Examples|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatókönyv|Forgatókönyv vázlat|Fundo|Geçmiş|Grundlage|Hannergrond|ghantoH|Háttér|Heave to|Istorik|Juhtumid|Keadaan|Khung kịch bản|Khung tình huống|Kịch bản|Koncept|Konsep skenario|Kontèks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut chovnatlh|lut|lutmey|Lýsing Atburðarásar|Lýsing Dæma|MISHUN SRSLY|MISHUN|Menggariskan Senario|mo'|Náčrt Scenára|Náčrt Scénáře|Náčrt Scenáru|Oris scenarija|Örnekler|Osnova|Osnova Scenára|Osnova scénáře|Osnutek|Ozadje|Paraugs|Pavyzdžiai|Példák|Piemēri|Plan du scénario|Plan du Scénario|Plan Senaryo|Plan senaryo|Plang vum Szenario|Pozadí|Pozadie|Pozadina|Príklady|Příklady|Primer|Primeri|Primjeri|Przykłady|Raamstsenaarium|Reckon it's like|Rerefons|Scenár|Scénář|Scenarie|Scenarij|Scenarijai|Scenarijaus šablonas|Scenariji|Scenārijs|Scenārijs pēc parauga|Scenarijus|Scenario|Scénario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se ðe|Se the|Se þe|Senario|Senaryo Deskripsyon|Senaryo deskripsyon|Senaryo|Senaryo taslağı|Shiver me timbers|Situācija|Situai|Situasie Uiteensetting|Situasie|Skenario konsep|Skenario|Skica|Structura scenariu|Structură scenariu|Struktura scenarija|Stsenaarium|Swa hwaer swa|Swa|Swa hwær swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tình huống|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo-ho-ho|You'll wanna|Założenia|Παραδείγματα|Περιγραφή Σεναρίου|Σενάρια|Σενάριο|Υπόβαθρο|Кереш|Контекст|Концепт|Мисаллар|Мисоллар|Основа|Передумова|Позадина|Предистория|Предыстория|Приклади|Пример|Примери|Примеры|Рамка на сценарий|Скица|Структура сценарија|Структура сценария|Структура сценарію|Сценарий|Сценарий структураси|Сценарийның төзелеше|Сценарији|Сценарио|Сценарій|Тарих|Үрнәкләр|דוגמאות|רקע|תבנית תרחיש|תרחיש|الخلفية|الگوی سناریو|امثلة|پس منظر|زمینه|سناریو|سيناريو|سيناريو مخطط|مثالیں|منظر نامے کا خاکہ|منظرنامہ|نمونه ها|उदाहरण|परिदृश्य|परिदृश्य रूपरेखा|पृष्ठभूमि|ਉਦਾਹਰਨਾਂ|ਪਟਕਥਾ|ਪਟਕਥਾ ਢਾਂਚਾ|ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ|ਪਿਛੋਕੜ|ఉదాహరణలు|కథనం|నేపథ్యం|సన్నివేశం|ಉದಾಹರಣೆಗಳು|ಕಥಾಸಾರಾಂಶ|ವಿವರಣೆ|ಹಿನ್ನೆಲೆ|โครงสร้างของเหตุการณ์|ชุดของตัวอย่าง|ชุดของเหตุการณ์|แนวคิด|สรุปเหตุการณ์|เหตุการณ์|배경|시나리오|시나리오 개요|예|サンプル|シナリオ|シナリオアウトライン|シナリオテンプレ|シナリオテンプレート|テンプレ|例|例子|剧本|剧本大纲|劇本|劇本大綱|场景|场景大纲|場景|場景大綱|背景):[^:\r\n]*/m,
	        lookbehind: true,
	        inside: {
	          important: {
	            pattern: /(:)[^\r\n]*/,
	            lookbehind: true
	          },
	          keyword: /[^:\r\n]+:/
	        }
	      },
	      'table-body': {
	        // Look-behind is used to skip the table head, which has the same format as any table row
	        pattern: RegExp('(' + tableRow + ')(?:' + tableRow + ')+'),
	        lookbehind: true,
	        inside: {
	          outline: {
	            pattern: /<[^>]+>/,
	            alias: 'variable'
	          },
	          td: {
	            pattern: /\s*[^\s|][^|]*/,
	            alias: 'string'
	          },
	          punctuation: /\|/
	        }
	      },
	      'table-head': {
	        pattern: RegExp(tableRow),
	        inside: {
	          th: {
	            pattern: /\s*[^\s|][^|]*/,
	            alias: 'variable'
	          },
	          punctuation: /\|/
	        }
	      },
	      atrule: {
	        pattern:
	          /(^[ \t]+)(?:'a|'ach|'ej|7|a|A také|A taktiež|A tiež|A zároveň|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Atès|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Biết|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Când|Cand|Cando|Ce|Cuando|Če|Ða ðe|Ða|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Daţi fiind|Dați fiind|DEN|Dato|De|Den youse gotta|Dengan|Diberi|Diyelim ki|Donada|Donat|Donitaĵo|Do|Dun|Duota|Ðurh|Eeldades|Ef|Eğer ki|Entao|Então|Entón|E|En|Entonces|Epi|És|Etant donnée|Etant donné|Et|Étant données|Étant donnée|Étant donné|Etant données|Etant donnés|Étant donnés|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeśli|Jeżeli|Kad|Kada|Kadar|Kai|Kaj|Když|Keď|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|Lè sa a|Lè|Logo|Lorsqu'<|Lorsque|mä|Maar|Mais|Mając|Ma|Majd|Maka|Manawa|Mas|Men|Menawa|Mutta|Nalika|Nalikaning|Nanging|Når|När|Nato|Nhưng|Niin|Njuk|O zaman|Och|Og|Oletetaan|Ond|Onda|Oraz|Pak|Pero|Però|Podano|Pokiaľ|Pokud|Potem|Potom|Privzeto|Pryd|Quan|Quand|Quando|qaSDI'|Så|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|Şi|Și|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Thì|Thurh|Toda|Too right|Un|Und|ugeholl|Và|vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za předpokladu|Zadan|Zadani|Zadano|Zadate|Zadato|Zakładając|Zaradi|Zatati|Þa þe|Þa|Þá|Þegar|Þurh|Αλλά|Δεδομένου|Και|Όταν|Τότε|А також|Агар|Але|Али|Аммо|А|Әгәр|Әйтик|Әмма|Бирок|Ва|Вә|Дадено|Дано|Допустим|Если|Задате|Задати|Задато|И|І|К тому же|Када|Кад|Когато|Когда|Коли|Ләкин|Лекин|Нәтиҗәдә|Нехай|Но|Онда|Припустимо, що|Припустимо|Пусть|Также|Та|Тогда|Тоді|То|Унда|Һәм|Якщо|אבל|אזי|אז|בהינתן|וגם|כאשר|آنگاه|اذاً|اگر|اما|اور|با فرض|بالفرض|بفرض|پھر|تب|ثم|جب|عندما|فرض کیا|لكن|لیکن|متى|هنگامی|و|अगर|और|कदा|किन्तु|चूंकि|जब|तथा|तदा|तब|परन्तु|पर|यदि|ਅਤੇ|ਜਦੋਂ|ਜਿਵੇਂ ਕਿ|ਜੇਕਰ|ਤਦ|ਪਰ|అప్పుడు|ఈ పరిస్థితిలో|కాని|చెప్పబడినది|మరియు|ಆದರೆ|ನಂತರ|ನೀಡಿದ|ಮತ್ತು|ಸ್ಥಿತಿಯನ್ನು|กำหนดให้|ดังนั้น|แต่|เมื่อ|และ|그러면<|그리고<|단<|만약<|만일<|먼저<|조건<|하지만<|かつ<|しかし<|ただし<|ならば<|もし<|並且<|但し<|但是<|假如<|假定<|假設<|假设<|前提<|同时<|同時<|并且<|当<|當<|而且<|那么<|那麼<)(?=[ \t])/m,
	        lookbehind: true
	      },
	      string: {
	        pattern: /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/,
	        inside: {
	          outline: {
	            pattern: /<[^>]+>/,
	            alias: 'variable'
	          }
	        }
	      },
	      outline: {
	        pattern: /<[^>]+>/,
	        alias: 'variable'
	      }
	    };
	  })(Prism);
	}
	return gherkin_1;
}

var git_1;
var hasRequiredGit;

function requireGit () {
	if (hasRequiredGit) return git_1;
	hasRequiredGit = 1;

	git_1 = git;
	git.displayName = 'git';
	git.aliases = [];
	function git(Prism) {
	  Prism.languages.git = {
	    /*
	     * A simple one line comment like in a git status command
	     * For instance:
	     * $ git status
	     * # On branch infinite-scroll
	     * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,
	     * # and have 1 and 2 different commits each, respectively.
	     * nothing to commit (working directory clean)
	     */
	    comment: /^#.*/m,
	    /*
	     * Regexp to match the changed lines in a git diff output. Check the example below.
	     */
	    deleted: /^[-–].*/m,
	    inserted: /^\+.*/m,
	    /*
	     * a string (double and simple quote)
	     */
	    string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	    /*
	     * a git command. It starts with a random prompt finishing by a $, then "git" then some other parameters
	     * For instance:
	     * $ git add file.txt
	     */
	    command: {
	      pattern: /^.*\$ git .*$/m,
	      inside: {
	        /*
	         * A git command can contain a parameter starting by a single or a double dash followed by a string
	         * For instance:
	         * $ git diff --cached
	         * $ git log -p
	         */
	        parameter: /\s--?\w+/
	      }
	    },
	    /*
	     * Coordinates displayed in a git diff command
	     * For instance:
	     * $ git diff
	     * diff --git file.txt file.txt
	     * index 6214953..1d54a52 100644
	     * --- file.txt
	     * +++ file.txt
	     * @@ -1 +1,2 @@
	     * -Here's my tetx file
	     * +Here's my text file
	     * +And this is the second line
	     */
	    coord: /^@@.*@@$/m,
	    /*
	     * Match a "commit [SHA1]" line in a git log output.
	     * For instance:
	     * $ git log
	     * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09
	     * Author: lgiraudel
	     * Date:   Mon Feb 17 11:18:34 2014 +0100
	     *
	     *     Add of a new line
	     */
	    'commit-sha1': /^commit \w{40}$/m
	  };
	}
	return git_1;
}

var glsl_1;
var hasRequiredGlsl;

function requireGlsl () {
	if (hasRequiredGlsl) return glsl_1;
	hasRequiredGlsl = 1;
	var refractorC = c_1;
	glsl_1 = glsl;
	glsl.displayName = 'glsl';
	glsl.aliases = [];
	function glsl(Prism) {
	  Prism.register(refractorC);
	  Prism.languages.glsl = Prism.languages.extend('c', {
	    keyword:
	      /\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/
	  });
	}
	return glsl_1;
}

var gml_1;
var hasRequiredGml;

function requireGml () {
	if (hasRequiredGml) return gml_1;
	hasRequiredGml = 1;

	gml_1 = gml;
	gml.displayName = 'gml';
	gml.aliases = [];
	function gml(Prism) {
	  Prism.languages.gamemakerlanguage = Prism.languages.gml =
	    Prism.languages.extend('clike', {
	      keyword:
	        /\b(?:break|case|continue|default|do|else|enum|exit|for|globalvar|if|repeat|return|switch|until|var|while)\b/,
	      number:
	        /(?:\b0x[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ulf]{0,4}/i,
	      operator:
	        /--|\+\+|[-+%/=]=?|!=|\*\*?=?|<[<=>]?|>[=>]?|&&?|\^\^?|\|\|?|~|\b(?:and|at|not|or|with|xor)\b/,
	      constant:
	        /\b(?:GM_build_date|GM_version|action_(?:continue|restart|reverse|stop)|all|gamespeed_(?:fps|microseconds)|global|local|noone|other|pi|pointer_(?:invalid|null)|self|timezone_(?:local|utc)|undefined|ev_(?:create|destroy|step|alarm|keyboard|mouse|collision|other|draw|draw_(?:begin|end|post|pre)|keypress|keyrelease|trigger|(?:left|middle|no|right)_button|(?:left|middle|right)_press|(?:left|middle|right)_release|mouse_(?:enter|leave|wheel_down|wheel_up)|global_(?:left|middle|right)_button|global_(?:left|middle|right)_press|global_(?:left|middle|right)_release|joystick(?:1|2)_(?:button1|button2|button3|button4|button5|button6|button7|button8|down|left|right|up)|outside|boundary|game_start|game_end|room_start|room_end|no_more_lives|animation_end|end_of_path|no_more_health|user\d|gui|gui_begin|gui_end|step_(?:begin|end|normal))|vk_(?:alt|anykey|backspace|control|delete|down|end|enter|escape|home|insert|left|nokey|pagedown|pageup|pause|printscreen|return|right|shift|space|tab|up|f\d|numpad\d|add|decimal|divide|lalt|lcontrol|lshift|multiply|ralt|rcontrol|rshift|subtract)|achievement_(?:filter_(?:all_players|favorites_only|friends_only)|friends_info|info|leaderboard_info|our_info|pic_loaded|show_(?:achievement|bank|friend_picker|leaderboard|profile|purchase_prompt|ui)|type_challenge|type_score_challenge)|asset_(?:font|object|path|room|script|shader|sound|sprite|tiles|timeline|unknown)|audio_(?:3d|falloff_(?:exponent_distance|exponent_distance_clamped|inverse_distance|inverse_distance_clamped|linear_distance|linear_distance_clamped|none)|mono|new_system|old_system|stereo)|bm_(?:add|complex|dest_alpha|dest_color|dest_colour|inv_dest_alpha|inv_dest_color|inv_dest_colour|inv_src_alpha|inv_src_color|inv_src_colour|max|normal|one|src_alpha|src_alpha_sat|src_color|src_colour|subtract|zero)|browser_(?:chrome|firefox|ie|ie_mobile|not_a_browser|opera|safari|safari_mobile|tizen|unknown|windows_store)|buffer_(?:bool|f16|f32|f64|fast|fixed|generalerror|grow|invalidtype|network|outofbounds|outofspace|s16|s32|s8|seek_end|seek_relative|seek_start|string|text|u16|u32|u64|u8|vbuffer|wrap)|c_(?:aqua|black|blue|dkgray|fuchsia|gray|green|lime|ltgray|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)|cmpfunc_(?:always|equal|greater|greaterequal|less|lessequal|never|notequal)|cr_(?:appstart|arrow|beam|cross|default|drag|handpoint|hourglass|none|size_all|size_nesw|size_ns|size_nwse|size_we|uparrow)|cull_(?:clockwise|counterclockwise|noculling)|device_(?:emulator|tablet)|device_ios_(?:ipad|ipad_retina|iphone|iphone5|iphone6|iphone6plus|iphone_retina|unknown)|display_(?:landscape|landscape_flipped|portrait|portrait_flipped)|dll_(?:cdecl|cdel|stdcall)|ds_type_(?:grid|list|map|priority|queue|stack)|ef_(?:cloud|ellipse|explosion|firework|flare|rain|ring|smoke|smokeup|snow|spark|star)|fa_(?:archive|bottom|center|directory|hidden|left|middle|readonly|right|sysfile|top|volumeid)|fb_login_(?:default|fallback_to_webview|forcing_safari|forcing_webview|no_fallback_to_webview|use_system_account)|iap_(?:available|canceled|ev_consume|ev_product|ev_purchase|ev_restore|ev_storeload|failed|purchased|refunded|status_available|status_loading|status_processing|status_restoring|status_unavailable|status_uninitialised|storeload_failed|storeload_ok|unavailable)|leaderboard_type_(?:number|time_mins_secs)|lighttype_(?:dir|point)|matrix_(?:projection|view|world)|mb_(?:any|left|middle|none|right)|network_(?:config_(?:connect_timeout|disable_reliable_udp|enable_reliable_udp|use_non_blocking_socket)|socket_(?:bluetooth|tcp|udp)|type_(?:connect|data|disconnect|non_blocking_connect))|of_challenge_(?:lose|tie|win)|os_(?:android|ios|linux|macosx|ps3|ps4|psvita|unknown|uwp|win32|win8native|windows|winphone|xboxone)|phy_debug_render_(?:aabb|collision_pairs|coms|core_shapes|joints|obb|shapes)|phy_joint_(?:anchor_1_x|anchor_1_y|anchor_2_x|anchor_2_y|angle|angle_limits|damping_ratio|frequency|length_1|length_2|lower_angle_limit|max_force|max_length|max_motor_force|max_motor_torque|max_torque|motor_force|motor_speed|motor_torque|reaction_force_x|reaction_force_y|reaction_torque|speed|translation|upper_angle_limit)|phy_particle_data_flag_(?:category|color|colour|position|typeflags|velocity)|phy_particle_flag_(?:colormixing|colourmixing|elastic|powder|spring|tensile|viscous|wall|water|zombie)|phy_particle_group_flag_(?:rigid|solid)|pr_(?:linelist|linestrip|pointlist|trianglefan|trianglelist|trianglestrip)|ps_(?:distr|shape)_(?:diamond|ellipse|gaussian|invgaussian|line|linear|rectangle)|pt_shape_(?:circle|cloud|disk|explosion|flare|line|pixel|ring|smoke|snow|spark|sphere|square|star)|ty_(?:real|string)|gp_(?:face\d|axislh|axislv|axisrh|axisrv|padd|padl|padr|padu|select|shoulderl|shoulderlb|shoulderr|shoulderrb|start|stickl|stickr)|lb_disp_(?:none|numeric|time_ms|time_sec)|lb_sort_(?:ascending|descending|none)|ov_(?:achievements|community|friends|gamegroup|players|settings)|ugc_(?:filetype_(?:community|microtrans)|list_(?:Favorited|Followed|Published|Subscribed|UsedOrPlayed|VotedDown|VotedOn|VotedUp|WillVoteLater)|match_(?:AllGuides|Artwork|Collections|ControllerBindings|IntegratedGuides|Items|Items_Mtx|Items_ReadyToUse|Screenshots|UsableInGame|Videos|WebGuides)|query_(?:AcceptedForGameRankedByAcceptanceDate|CreatedByFriendsRankedByPublicationDate|FavoritedByFriendsRankedByPublicationDate|NotYetRated)|query_RankedBy(?:NumTimesReported|PublicationDate|TextSearch|TotalVotesAsc|Trend|Vote|VotesUp)|result_success|sortorder_CreationOrder(?:Asc|Desc)|sortorder_(?:ForModeration|LastUpdatedDesc|SubscriptionDateDesc|TitleAsc|VoteScoreDesc)|visibility_(?:friends_only|private|public))|vertex_usage_(?:binormal|blendindices|blendweight|color|colour|depth|fog|normal|position|psize|sample|tangent|texcoord|textcoord)|vertex_type_(?:float\d|color|colour|ubyte4)|input_type|layerelementtype_(?:background|instance|oldtilemap|particlesystem|sprite|tile|tilemap|undefined)|se_(?:chorus|compressor|echo|equalizer|flanger|gargle|none|reverb)|text_type|tile_(?:flip|index_mask|mirror|rotate)|(?:obj|rm|scr|spr)\w+)\b/,
	      variable:
	        /\b(?:alarm|application_surface|async_load|background_(?:alpha|blend|color|colour|foreground|height|hspeed|htiled|index|showcolor|showcolour|visible|vspeed|vtiled|width|x|xscale|y|yscale)|bbox_(?:bottom|left|right|top)|browser_(?:height|width)|caption_(?:health|lives|score)|current_(?:day|hour|minute|month|second|time|weekday|year)|cursor_sprite|debug_mode|delta_time|direction|display_aa|error_(?:last|occurred)|event_(?:action|number|object|type)|fps|fps_real|friction|game_(?:display|project|save)_(?:id|name)|gamemaker_(?:pro|registered|version)|gravity|gravity_direction|(?:h|v)speed|health|iap_data|id|image_(?:alpha|angle|blend|depth|index|number|speed|xscale|yscale)|instance_(?:count|id)|keyboard_(?:key|lastchar|lastkey|string)|layer|lives|mask_index|mouse_(?:button|lastbutton|x|y)|object_index|os_(?:browser|device|type|version)|path_(?:endaction|index|orientation|position|positionprevious|scale|speed)|persistent|phy_(?:rotation|(?:col_normal|collision|com|linear_velocity|position|speed)_(?:x|y)|angular_(?:damping|velocity)|position_(?:x|y)previous|speed|linear_damping|bullet|fixed_rotation|active|mass|inertia|dynamic|kinematic|sleeping|collision_points)|pointer_(?:invalid|null)|room|room_(?:caption|first|height|last|persistent|speed|width)|score|secure_mode|show_(?:health|lives|score)|solid|speed|sprite_(?:height|index|width|xoffset|yoffset)|temp_directory|timeline_(?:index|loop|position|running|speed)|transition_(?:color|kind|steps)|undefined|view_(?:angle|current|enabled|(?:h|v)(?:border|speed)|(?:h|w|x|y)port|(?:h|w|x|y)view|object|surface_id|visible)|visible|webgl_enabled|working_directory|(?:x|y)(?:previous|start)|x|y|argument(?:_relitive|_count|\d)|argument|global|local|other|self)\b/
	    });
	}
	return gml_1;
}

var gn_1;
var hasRequiredGn;

function requireGn () {
	if (hasRequiredGn) return gn_1;
	hasRequiredGn = 1;

	gn_1 = gn;
	gn.displayName = 'gn';
	gn.aliases = ['gni'];
	function gn(Prism) {
	  // https://gn.googlesource.com/gn/+/refs/heads/main/docs/reference.md#grammar
	  Prism.languages.gn = {
	    comment: {
	      pattern: /#.*/,
	      greedy: true
	    },
	    'string-literal': {
	      pattern: /(^|[^\\"])"(?:[^\r\n"\\]|\\.)*"/,
	      lookbehind: true,
	      greedy: true,
	      inside: {
	        interpolation: {
	          pattern:
	            /((?:^|[^\\])(?:\\{2})*)\$(?:\{[\s\S]*?\}|[a-zA-Z_]\w*|0x[a-fA-F0-9]{2})/,
	          lookbehind: true,
	          inside: {
	            number: /^\$0x[\s\S]{2}$/,
	            variable: /^\$\w+$/,
	            'interpolation-punctuation': {
	              pattern: /^\$\{|\}$/,
	              alias: 'punctuation'
	            },
	            expression: {
	              pattern: /[\s\S]+/,
	              inside: null // see below
	            }
	          }
	        },
	        string: /[\s\S]+/
	      }
	    },
	    keyword: /\b(?:else|if)\b/,
	    boolean: /\b(?:false|true)\b/,
	    'builtin-function': {
	      // a few functions get special highlighting to improve readability
	      pattern:
	        /\b(?:assert|defined|foreach|import|pool|print|template|tool|toolchain)(?=\s*\()/i,
	      alias: 'keyword'
	    },
	    function: /\b[a-z_]\w*(?=\s*\()/i,
	    constant:
	      /\b(?:current_cpu|current_os|current_toolchain|default_toolchain|host_cpu|host_os|root_build_dir|root_gen_dir|root_out_dir|target_cpu|target_gen_dir|target_os|target_out_dir)\b/,
	    number: /-?\b\d+\b/,
	    operator: /[-+!=<>]=?|&&|\|\|/,
	    punctuation: /[(){}[\],.]/
	  };
	  Prism.languages.gn['string-literal'].inside['interpolation'].inside[
	    'expression'
	  ].inside = Prism.languages.gn;
	  Prism.languages.gni = Prism.languages.gn;
	}
	return gn_1;
}

var goModule_1;
var hasRequiredGoModule;

function requireGoModule () {
	if (hasRequiredGoModule) return goModule_1;
	hasRequiredGoModule = 1;

	goModule_1 = goModule;
	goModule.displayName = 'goModule';
	goModule.aliases = [];
	function goModule(Prism) {
	  // https://go.dev/ref/mod#go-mod-file-module
	  Prism.languages['go-mod'] = Prism.languages['go-module'] = {
	    comment: {
	      pattern: /\/\/.*/,
	      greedy: true
	    },
	    version: {
	      pattern: /(^|[\s()[\],])v\d+\.\d+\.\d+(?:[+-][-+.\w]*)?(?![^\s()[\],])/,
	      lookbehind: true,
	      alias: 'number'
	    },
	    'go-version': {
	      pattern: /((?:^|\s)go\s+)\d+(?:\.\d+){1,2}/,
	      lookbehind: true,
	      alias: 'number'
	    },
	    keyword: {
	      pattern: /^([ \t]*)(?:exclude|go|module|replace|require|retract)\b/m,
	      lookbehind: true
	    },
	    operator: /=>/,
	    punctuation: /[()[\],]/
	  };
	}
	return goModule_1;
}

var go_1;
var hasRequiredGo;

function requireGo () {
	if (hasRequiredGo) return go_1;
	hasRequiredGo = 1;

	go_1 = go;
	go.displayName = 'go';
	go.aliases = [];
	function go(Prism) {
	  Prism.languages.go = Prism.languages.extend('clike', {
	    string: {
	      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
	      lookbehind: true,
	      greedy: true
	    },
	    keyword:
	      /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
	    boolean: /\b(?:_|false|iota|nil|true)\b/,
	    number: [
	      // binary and octal integers
	      /\b0(?:b[01_]+|o[0-7_]+)i?\b/i, // hexadecimal integers and floats
	      /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i, // decimal integers and floats
	      /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
	    ],
	    operator:
	      /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
	    builtin:
	      /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
	  });
	  Prism.languages.insertBefore('go', 'string', {
	    char: {
	      pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
	      greedy: true
	    }
	  });
	  delete Prism.languages.go['class-name'];
	}
	return go_1;
}

var graphql_1;
var hasRequiredGraphql;

function requireGraphql () {
	if (hasRequiredGraphql) return graphql_1;
	hasRequiredGraphql = 1;

	graphql_1 = graphql;
	graphql.displayName = 'graphql';
	graphql.aliases = [];
	function graphql(Prism) {
	  Prism.languages.graphql = {
	    comment: /#.*/,
	    description: {
	      pattern:
	        /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
	      greedy: true,
	      alias: 'string',
	      inside: {
	        'language-markdown': {
	          pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
	          lookbehind: true,
	          inside: Prism.languages.markdown
	        }
	      }
	    },
	    string: {
	      pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
	      greedy: true
	    },
	    number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
	    boolean: /\b(?:false|true)\b/,
	    variable: /\$[a-z_]\w*/i,
	    directive: {
	      pattern: /@[a-z_]\w*/i,
	      alias: 'function'
	    },
	    'attr-name': {
	      pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
	      greedy: true
	    },
	    'atom-input': {
	      pattern: /\b[A-Z]\w*Input\b/,
	      alias: 'class-name'
	    },
	    scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
	    constant: /\b[A-Z][A-Z_\d]*\b/,
	    'class-name': {
	      pattern:
	        /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
	      lookbehind: true
	    },
	    fragment: {
	      pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
	      lookbehind: true,
	      alias: 'function'
	    },
	    'definition-mutation': {
	      pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
	      lookbehind: true,
	      alias: 'function'
	    },
	    'definition-query': {
	      pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
	      lookbehind: true,
	      alias: 'function'
	    },
	    keyword:
	      /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
	    operator: /[!=|&]|\.{3}/,
	    'property-query': /\w+(?=\s*\()/,
	    object: /\w+(?=\s*\{)/,
	    punctuation: /[!(){}\[\]:=,]/,
	    property: /\w+/
	  };
	  Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {
	    if (env.language !== 'graphql') {
	      return
	    }
	    /**
	     * get the graphql token stream that we want to customize
	     *
	     * @typedef {InstanceType<import("./prism-core")["Token"]>} Token
	     * @type {Token[]}
	     */
	    var validTokens = env.tokens.filter(function (token) {
	      return (
	        typeof token !== 'string' &&
	        token.type !== 'comment' &&
	        token.type !== 'scalar'
	      )
	    });
	    var currentIndex = 0;
	    /**
	     * Returns whether the token relative to the current index has the given type.
	     *
	     * @param {number} offset
	     * @returns {Token | undefined}
	     */
	    function getToken(offset) {
	      return validTokens[currentIndex + offset]
	    }
	    /**
	     * Returns whether the token relative to the current index has the given type.
	     *
	     * @param {readonly string[]} types
	     * @param {number} [offset=0]
	     * @returns {boolean}
	     */
	    function isTokenType(types, offset) {
	      offset = offset || 0;
	      for (var i = 0; i < types.length; i++) {
	        var token = getToken(i + offset);
	        if (!token || token.type !== types[i]) {
	          return false
	        }
	      }
	      return true
	    }
	    /**
	     * Returns the index of the closing bracket to an opening bracket.
	     *
	     * It is assumed that `token[currentIndex - 1]` is an opening bracket.
	     *
	     * If no closing bracket could be found, `-1` will be returned.
	     *
	     * @param {RegExp} open
	     * @param {RegExp} close
	     * @returns {number}
	     */
	    function findClosingBracket(open, close) {
	      var stackHeight = 1;
	      for (var i = currentIndex; i < validTokens.length; i++) {
	        var token = validTokens[i];
	        var content = token.content;
	        if (token.type === 'punctuation' && typeof content === 'string') {
	          if (open.test(content)) {
	            stackHeight++;
	          } else if (close.test(content)) {
	            stackHeight--;
	            if (stackHeight === 0) {
	              return i
	            }
	          }
	        }
	      }
	      return -1
	    }
	    /**
	     * Adds an alias to the given token.
	     *
	     * @param {Token} token
	     * @param {string} alias
	     * @returns {void}
	     */
	    function addAlias(token, alias) {
	      var aliases = token.alias;
	      if (!aliases) {
	        token.alias = aliases = [];
	      } else if (!Array.isArray(aliases)) {
	        token.alias = aliases = [aliases];
	      }
	      aliases.push(alias);
	    }
	    for (; currentIndex < validTokens.length; ) {
	      var startToken = validTokens[currentIndex++]; // add special aliases for mutation tokens
	      if (startToken.type === 'keyword' && startToken.content === 'mutation') {
	        // any array of the names of all input variables (if any)
	        var inputVariables = [];
	        if (
	          isTokenType(['definition-mutation', 'punctuation']) &&
	          getToken(1).content === '('
	        ) {
	          // definition
	          currentIndex += 2; // skip 'definition-mutation' and 'punctuation'
	          var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
	          if (definitionEnd === -1) {
	            continue
	          } // find all input variables
	          for (; currentIndex < definitionEnd; currentIndex++) {
	            var t = getToken(0);
	            if (t.type === 'variable') {
	              addAlias(t, 'variable-input');
	              inputVariables.push(t.content);
	            }
	          }
	          currentIndex = definitionEnd + 1;
	        }
	        if (
	          isTokenType(['punctuation', 'property-query']) &&
	          getToken(0).content === '{'
	        ) {
	          currentIndex++; // skip opening bracket
	          addAlias(getToken(0), 'property-mutation');
	          if (inputVariables.length > 0) {
	            var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
	            if (mutationEnd === -1) {
	              continue
	            } // give references to input variables a special alias
	            for (var i = currentIndex; i < mutationEnd; i++) {
	              var varToken = validTokens[i];
	              if (
	                varToken.type === 'variable' &&
	                inputVariables.indexOf(varToken.content) >= 0
	              ) {
	                addAlias(varToken, 'variable-input');
	              }
	            }
	          }
	        }
	      }
	    }
	  });
	}
	return graphql_1;
}

var groovy_1;
var hasRequiredGroovy;

function requireGroovy () {
	if (hasRequiredGroovy) return groovy_1;
	hasRequiredGroovy = 1;

	groovy_1 = groovy;
	groovy.displayName = 'groovy';
	groovy.aliases = [];
	function groovy(Prism) {
	  Prism.languages.groovy = Prism.languages.extend('clike', {
	    string: [
	      {
	        // https://groovy-lang.org/syntax.html#_dollar_slashy_string
	        pattern:
	          /("""|''')(?:[^\\]|\\[\s\S])*?\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
	        greedy: true
	      },
	      {
	        // TODO: Slash strings (e.g. /foo/) can contain line breaks but this will cause a lot of trouble with
	        // simple division (see JS regex), so find a fix maybe?
	        pattern: /(["'/])(?:\\.|(?!\1)[^\\\r\n])*\1/,
	        greedy: true
	      }
	    ],
	    keyword:
	      /\b(?:abstract|as|assert|boolean|break|byte|case|catch|char|class|const|continue|def|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|in|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
	    number:
	      /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
	    operator: {
	      pattern:
	        /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
	      lookbehind: true
	    },
	    punctuation: /\.+|[{}[\];(),:$]/
	  });
	  Prism.languages.insertBefore('groovy', 'string', {
	    shebang: {
	      pattern: /#!.+/,
	      alias: 'comment'
	    }
	  });
	  Prism.languages.insertBefore('groovy', 'punctuation', {
	    'spock-block': /\b(?:and|cleanup|expect|given|setup|then|when|where):/
	  });
	  Prism.languages.insertBefore('groovy', 'function', {
	    annotation: {
	      pattern: /(^|[^.])@\w+/,
	      lookbehind: true,
	      alias: 'punctuation'
	    }
	  }); // Handle string interpolation
	  Prism.hooks.add('wrap', function (env) {
	    if (env.language === 'groovy' && env.type === 'string') {
	      var delimiter = env.content.value[0];
	      if (delimiter != "'") {
	        var pattern = /([^\\])(?:\$(?:\{.*?\}|[\w.]+))/;
	        if (delimiter === '$') {
	          pattern = /([^\$])(?:\$(?:\{.*?\}|[\w.]+))/;
	        } // To prevent double HTML-encoding we have to decode env.content first
	        env.content.value = env.content.value
	          .replace(/&lt;/g, '<')
	          .replace(/&amp;/g, '&');
	        env.content = Prism.highlight(env.content.value, {
	          expression: {
	            pattern: pattern,
	            lookbehind: true,
	            inside: Prism.languages.groovy
	          }
	        });
	        env.classes.push(delimiter === '/' ? 'regex' : 'gstring');
	      }
	    }
	  });
	}
	return groovy_1;
}

var haml_1;
var hasRequiredHaml;

function requireHaml () {
	if (hasRequiredHaml) return haml_1;
	hasRequiredHaml = 1;
	var refractorRuby = requireRuby();
	haml_1 = haml;
	haml.displayName = 'haml';
	haml.aliases = [];
	function haml(Prism) {
	  Prism.register(refractorRuby)
	  /* TODO
	Handle multiline code after tag
	%foo= some |
	multiline |
	code |
	*/
	  ;(function (Prism) {
	    Prism.languages.haml = {
	      // Multiline stuff should appear before the rest
	      'multiline-comment': {
	        pattern:
	          /((?:^|\r?\n|\r)([\t ]*))(?:\/|-#).*(?:(?:\r?\n|\r)\2[\t ].+)*/,
	        lookbehind: true,
	        alias: 'comment'
	      },
	      'multiline-code': [
	        {
	          pattern:
	            /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*(?:(?:\r?\n|\r)\2[\t ].*,[\t ]*)*(?:(?:\r?\n|\r)\2[\t ].+)/,
	          lookbehind: true,
	          inside: Prism.languages.ruby
	        },
	        {
	          pattern:
	            /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*(?:(?:\r?\n|\r)\2[\t ].*\|[\t ]*)*/,
	          lookbehind: true,
	          inside: Prism.languages.ruby
	        }
	      ],
	      // See at the end of the file for known filters
	      filter: {
	        pattern:
	          /((?:^|\r?\n|\r)([\t ]*)):[\w-]+(?:(?:\r?\n|\r)(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/,
	        lookbehind: true,
	        inside: {
	          'filter-name': {
	            pattern: /^:[\w-]+/,
	            alias: 'symbol'
	          }
	        }
	      },
	      markup: {
	        pattern: /((?:^|\r?\n|\r)[\t ]*)<.+/,
	        lookbehind: true,
	        inside: Prism.languages.markup
	      },
	      doctype: {
	        pattern: /((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/,
	        lookbehind: true
	      },
	      tag: {
	        // Allows for one nested group of braces
	        pattern:
	          /((?:^|\r?\n|\r)[\t ]*)[%.#][\w\-#.]*[\w\-](?:\([^)]+\)|\{(?:\{[^}]+\}|[^{}])+\}|\[[^\]]+\])*[\/<>]*/,
	        lookbehind: true,
	        inside: {
	          attributes: [
	            {
	              // Lookbehind tries to prevent interpolations from breaking it all
	              // Allows for one nested group of braces
	              pattern: /(^|[^#])\{(?:\{[^}]+\}|[^{}])+\}/,
	              lookbehind: true,
	              inside: Prism.languages.ruby
	            },
	            {
	              pattern: /\([^)]+\)/,
	              inside: {
	                'attr-value': {
	                  pattern: /(=\s*)(?:"(?:\\.|[^\\"\r\n])*"|[^)\s]+)/,
	                  lookbehind: true
	                },
	                'attr-name': /[\w:-]+(?=\s*!?=|\s*[,)])/,
	                punctuation: /[=(),]/
	              }
	            },
	            {
	              pattern: /\[[^\]]+\]/,
	              inside: Prism.languages.ruby
	            }
	          ],
	          punctuation: /[<>]/
	        }
	      },
	      code: {
	        pattern: /((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,
	        lookbehind: true,
	        inside: Prism.languages.ruby
	      },
	      // Interpolations in plain text
	      interpolation: {
	        pattern: /#\{[^}]+\}/,
	        inside: {
	          delimiter: {
	            pattern: /^#\{|\}$/,
	            alias: 'punctuation'
	          },
	          ruby: {
	            pattern: /[\s\S]+/,
	            inside: Prism.languages.ruby
	          }
	        }
	      },
	      punctuation: {
	        pattern: /((?:^|\r?\n|\r)[\t ]*)[~=\-&!]+/,
	        lookbehind: true
	      }
	    };
	    var filter_pattern =
	      '((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+'; // Non exhaustive list of available filters and associated languages
	    var filters = [
	      'css',
	      {
	        filter: 'coffee',
	        language: 'coffeescript'
	      },
	      'erb',
	      'javascript',
	      'less',
	      'markdown',
	      'ruby',
	      'scss',
	      'textile'
	    ];
	    var all_filters = {};
	    for (var i = 0, l = filters.length; i < l; i++) {
	      var filter = filters[i];
	      filter =
	        typeof filter === 'string'
	          ? {
	              filter: filter,
	              language: filter
	            }
	          : filter;
	      if (Prism.languages[filter.language]) {
	        all_filters['filter-' + filter.filter] = {
	          pattern: RegExp(
	            filter_pattern.replace('{{filter_name}}', function () {
	              return filter.filter
	            })
	          ),
	          lookbehind: true,
	          inside: {
	            'filter-name': {
	              pattern: /^:[\w-]+/,
	              alias: 'symbol'
	            },
	            text: {
	              pattern: /[\s\S]+/,
	              alias: [filter.language, 'language-' + filter.language],
	              inside: Prism.languages[filter.language]
	            }
	          }
	        };
	      }
	    }
	    Prism.languages.insertBefore('haml', 'filter', all_filters);
	  })(Prism);
	}
	return haml_1;
}

var handlebars_1;
var hasRequiredHandlebars;

function requireHandlebars () {
	if (hasRequiredHandlebars) return handlebars_1;
	hasRequiredHandlebars = 1;
	var refractorMarkupTemplating = requireMarkupTemplating();
	handlebars_1 = handlebars;
	handlebars.displayName = 'handlebars';
	handlebars.aliases = ['hbs'];
	function handlebars(Prism) {
	  Prism.register(refractorMarkupTemplating)
	  ;(function (Prism) {
	    Prism.languages.handlebars = {
	      comment: /\{\{![\s\S]*?\}\}/,
	      delimiter: {
	        pattern: /^\{\{\{?|\}\}\}?$/,
	        alias: 'punctuation'
	      },
	      string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
	      boolean: /\b(?:false|true)\b/,
	      block: {
	        pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
	        lookbehind: true,
	        alias: 'keyword'
	      },
	      brackets: {
	        pattern: /\[[^\]]+\]/,
	        inside: {
	          punctuation: /\[|\]/,
	          variable: /[\s\S]+/
	        }
	      },
	      punctuation: /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
	      variable: /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
	    };
	    Prism.hooks.add('before-tokenize', function (env) {
	      var handlebarsPattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
	      Prism.languages['markup-templating'].buildPlaceholders(
	        env,
	        'handlebars',
	        handlebarsPattern
	      );
	    });
	    Prism.hooks.add('after-tokenize', function (env) {
	      Prism.languages['markup-templating'].tokenizePlaceholders(
	        env,
	        'handlebars'
	      );
	    });
	    Prism.languages.hbs = Prism.languages.handlebars;
	  })(Prism);
	}
	return handlebars_1;
}

var haskell_1;
var hasRequiredHaskell;

function requireHaskell () {
	if (hasRequiredHaskell) return haskell_1;
	hasRequiredHaskell = 1;

	haskell_1 = haskell;
	haskell.displayName = 'haskell';
	haskell.aliases = ['hs'];
	function haskell(Prism) {
	  Prism.languages.haskell = {
	    comment: {
	      pattern:
	        /(^|[^-!#$%*+=?&@|~.:<>^\\\/])(?:--(?:(?=.)[^-!#$%*+=?&@|~.:<>^\\\/].*|$)|\{-[\s\S]*?-\})/m,
	      lookbehind: true
	    },
	    char: {
	      pattern:
	        /'(?:[^\\']|\\(?:[abfnrtv\\"'&]|\^[A-Z@[\]^_]|ACK|BEL|BS|CAN|CR|DC1|DC2|DC3|DC4|DEL|DLE|EM|ENQ|EOT|ESC|ETB|ETX|FF|FS|GS|HT|LF|NAK|NUL|RS|SI|SO|SOH|SP|STX|SUB|SYN|US|VT|\d+|o[0-7]+|x[0-9a-fA-F]+))'/,
	      alias: 'string'
	    },
	    string: {
	      pattern: /"(?:[^\\"]|\\(?:\S|\s+\\))*"/,
	      greedy: true
	    },
	    keyword:
	      /\b(?:case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b/,
	    'import-statement': {
	      // The imported or hidden names are not included in this import
	      // statement. This is because we want to highlight those exactly like
	      // we do for the names in the program.
	      pattern:
	        /(^[\t ]*)import\s+(?:qualified\s+)?(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*(?:\s+as\s+(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
	      lookbehind: true,
	      inside: {
	        keyword: /\b(?:as|hiding|import|qualified)\b/,
	        punctuation: /\./
	      }
	    },
	    // These are builtin variables only. Constructors are highlighted later as a constant.
	    builtin:
	      /\b(?:abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\b/,
	    // decimal integers and floating point numbers | octal integers | hexadecimal integers
	    number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0o[0-7]+|0x[0-9a-f]+)\b/i,
	    operator: [
	      {
	        // infix operator
	        pattern: /`(?:[A-Z][\w']*\.)*[_a-z][\w']*`/,
	        greedy: true
	      },
	      {
	        // function composition
	        pattern: /(\s)\.(?=\s)/,
	        lookbehind: true
	      }, // Most of this is needed because of the meaning of a single '.'.
	      // If it stands alone freely, it is the function composition.
	      // It may also be a separator between a module name and an identifier => no
	      // operator. If it comes together with other special characters it is an
	      // operator too.
	      //
	      // This regex means: /[-!#$%*+=?&@|~.:<>^\\\/]+/ without /\./.
	      /[-!#$%*+=?&@|~:<>^\\\/][-!#$%*+=?&@|~.:<>^\\\/]*|\.[-!#$%*+=?&@|~.:<>^\\\/]+/
	    ],
	    // In Haskell, nearly everything is a variable, do not highlight these.
	    hvariable: {
	      pattern: /\b(?:[A-Z][\w']*\.)*[_a-z][\w']*/,
	      inside: {
	        punctuation: /\./
	      }
	    },
	    constant: {
	      pattern: /\b(?:[A-Z][\w']*\.)*[A-Z][\w']*/,
	      inside: {
	        punctuation: /\./
	      }
	    },
	    punctuation: /[{}[\];(),.:]/
	  };
	  Prism.languages.hs = Prism.languages.haskell;
	}
	return haskell_1;
}

var haxe_1;
var hasRequiredHaxe;

function requireHaxe () {
	if (hasRequiredHaxe) return haxe_1;
	hasRequiredHaxe = 1;

	haxe_1 = haxe;
	haxe.displayName = 'haxe';
	haxe.aliases = [];
	function haxe(Prism) {
	  Prism.languages.haxe = Prism.languages.extend('clike', {
	    string: {
	      // Strings can be multi-line
	      pattern: /"(?:[^"\\]|\\[\s\S])*"/,
	      greedy: true
	    },
	    'class-name': [
	      {
	        pattern:
	          /(\b(?:abstract|class|enum|extends|implements|interface|new|typedef)\s+)[A-Z_]\w*/,
	        lookbehind: true
	      }, // based on naming convention
	      /\b[A-Z]\w*/
	    ],
	    // The final look-ahead prevents highlighting of keywords if expressions such as "haxe.macro.Expr"
	    keyword:
	      /\bthis\b|\b(?:abstract|as|break|case|cast|catch|class|continue|default|do|dynamic|else|enum|extends|extern|final|for|from|function|if|implements|import|in|inline|interface|macro|new|null|operator|overload|override|package|private|public|return|static|super|switch|throw|to|try|typedef|untyped|using|var|while)(?!\.)\b/,
	    function: {
	      pattern: /\b[a-z_]\w*(?=\s*(?:<[^<>]*>\s*)?\()/i,
	      greedy: true
	    },
	    operator: /\.{3}|\+\+|--|&&|\|\||->|=>|(?:<<?|>{1,3}|[-+*/%!=&|^])=?|[?:~]/
	  });
	  Prism.languages.insertBefore('haxe', 'string', {
	    'string-interpolation': {
	      pattern: /'(?:[^'\\]|\\[\s\S])*'/,
	      greedy: true,
	      inside: {
	        interpolation: {
	          pattern: /(^|[^\\])\$(?:\w+|\{[^{}]+\})/,
	          lookbehind: true,
	          inside: {
	            'interpolation-punctuation': {
	              pattern: /^\$\{?|\}$/,
	              alias: 'punctuation'
	            },
	            expression: {
	              pattern: /[\s\S]+/,
	              inside: Prism.languages.haxe
	            }
	          }
	        },
	        string: /[\s\S]+/
	      }
	    }
	  });
	  Prism.languages.insertBefore('haxe', 'class-name', {
	    regex: {
	      pattern: /~\/(?:[^\/\\\r\n]|\\.)+\/[a-z]*/,
	      greedy: true,
	      inside: {
	        'regex-flags': /\b[a-z]+$/,
	        'regex-source': {
	          pattern: /^(~\/)[\s\S]+(?=\/$)/,
	          lookbehind: true,
	          alias: 'language-regex',
	          inside: Prism.languages.regex
	        },
	        'regex-delimiter': /^~\/|\/$/
	      }
	    }
	  });
	  Prism.languages.insertBefore('haxe', 'keyword', {
	    preprocessor: {
	      pattern: /#(?:else|elseif|end|if)\b.*/,
	      alias: 'property'
	    },
	    metadata: {
	      pattern: /@:?[\w.]+/,
	      alias: 'symbol'
	    },
	    reification: {
	      pattern: /\$(?:\w+|(?=\{))/,
	      alias: 'important'
	    }
	  });
	}
	return haxe_1;
}

var hcl_1;
var hasRequiredHcl;

function requireHcl () {
	if (hasRequiredHcl) return hcl_1;
	hasRequiredHcl = 1;

	hcl_1 = hcl;
	hcl.displayName = 'hcl';
	hcl.aliases = [];
	function hcl(Prism) {
	  Prism.languages.hcl = {
	    comment: /(?:\/\/|#).*|\/\*[\s\S]*?(?:\*\/|$)/,
	    heredoc: {
	      pattern: /<<-?(\w+\b)[\s\S]*?^[ \t]*\1/m,
	      greedy: true,
	      alias: 'string'
	    },
	    keyword: [
	      {
	        pattern:
	          /(?:data|resource)\s+(?:"(?:\\[\s\S]|[^\\"])*")(?=\s+"[\w-]+"\s+\{)/i,
	        inside: {
	          type: {
	            pattern: /(resource|data|\s+)(?:"(?:\\[\s\S]|[^\\"])*")/i,
	            lookbehind: true,
	            alias: 'variable'
	          }
	        }
	      },
	      {
	        pattern:
	          /(?:backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+(?=\{)/i,
	        inside: {
	          type: {
	            pattern:
	              /(backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+/i,
	            lookbehind: true,
	            alias: 'variable'
	          }
	        }
	      },
	      /[\w-]+(?=\s+\{)/
	    ],
	    property: [/[-\w\.]+(?=\s*=(?!=))/, /"(?:\\[\s\S]|[^\\"])+"(?=\s*[:=])/],
	    string: {
	      pattern:
	        /"(?:[^\\$"]|\\[\s\S]|\$(?:(?=")|\$+(?!\$)|[^"${])|\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\})*"/,
	      greedy: true,
	      inside: {
	        interpolation: {
	          pattern: /(^|[^$])\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\}/,
	          lookbehind: true,
	          inside: {
	            type: {
	              pattern:
	                /(\b(?:count|data|local|module|path|self|terraform|var)\b\.)[\w\*]+/i,
	              lookbehind: true,
	              alias: 'variable'
	            },
	            keyword: /\b(?:count|data|local|module|path|self|terraform|var)\b/i,
	            function: /\w+(?=\()/,
	            string: {
	              pattern: /"(?:\\[\s\S]|[^\\"])*"/,
	              greedy: true
	            },
	            number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
	            punctuation: /[!\$#%&'()*+,.\/;<=>@\[\\\]^`{|}~?:]/
	          }
	        }
	      }
	    },
	    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
	    boolean: /\b(?:false|true)\b/i,
	    punctuation: /[=\[\]{}]/
	  };
	}
	return hcl_1;
}

var hlsl_1;
var hasRequiredHlsl;

function requireHlsl () {
	if (hasRequiredHlsl) return hlsl_1;
	hasRequiredHlsl = 1;
	var refractorC = c_1;
	hlsl_1 = hlsl;
	hlsl.displayName = 'hlsl';
	hlsl.aliases = [];
	function hlsl(Prism) {
	  Prism.register(refractorC);
	  Prism.languages.hlsl = Prism.languages.extend('c', {
	    // Regarding keywords and class names:
	    // The list of all keywords was split into 'keyword' and 'class-name' tokens based on whether they are capitalized.
	    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-keywords
	    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-reserved-words
	    'class-name': [
	      Prism.languages.c['class-name'],
	      /\b(?:AppendStructuredBuffer|BlendState|Buffer|ByteAddressBuffer|CompileShader|ComputeShader|ConsumeStructuredBuffer|DepthStencilState|DepthStencilView|DomainShader|GeometryShader|Hullshader|InputPatch|LineStream|OutputPatch|PixelShader|PointStream|RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture(?:1D|1DArray|2D|2DArray|3D)|RasterizerState|RenderTargetView|SamplerComparisonState|SamplerState|StructuredBuffer|Texture(?:1D|1DArray|2D|2DArray|2DMS|2DMSArray|3D|Cube|CubeArray)|TriangleStream|VertexShader)\b/
	    ],
	    keyword: [
	      // HLSL keyword
	      /\b(?:asm|asm_fragment|auto|break|case|catch|cbuffer|centroid|char|class|column_major|compile|compile_fragment|const|const_cast|continue|default|delete|discard|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|fxgroup|goto|groupshared|if|in|inline|inout|interface|line|lineadj|linear|long|matrix|mutable|namespace|new|nointerpolation|noperspective|operator|out|packoffset|pass|pixelfragment|point|precise|private|protected|public|register|reinterpret_cast|return|row_major|sample|sampler|shared|short|signed|sizeof|snorm|stateblock|stateblock_state|static|static_cast|string|struct|switch|tbuffer|technique|technique10|technique11|template|texture|this|throw|triangle|triangleadj|try|typedef|typename|uniform|union|unorm|unsigned|using|vector|vertexfragment|virtual|void|volatile|while)\b/, // scalar, vector, and matrix types
	      /\b(?:bool|double|dword|float|half|int|min(?:10float|12int|16(?:float|int|uint))|uint)(?:[1-4](?:x[1-4])?)?\b/
	    ],
	    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-grammar#floating-point-numbers
	    number:
	      /(?:(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?|\b0x[\da-fA-F]+)[fFhHlLuU]?\b/,
	    boolean: /\b(?:false|true)\b/
	  });
	}
	return hlsl_1;
}

var hoon_1;
var hasRequiredHoon;

function requireHoon () {
	if (hasRequiredHoon) return hoon_1;
	hasRequiredHoon = 1;

	hoon_1 = hoon;
	hoon.displayName = 'hoon';
	hoon.aliases = [];
	function hoon(Prism) {
	  Prism.languages.hoon = {
	    comment: {
	      pattern: /::.*/,
	      greedy: true
	    },
	    string: {
	      pattern: /"[^"]*"|'[^']*'/,
	      greedy: true
	    },
	    constant: /%(?:\.[ny]|[\w-]+)/,
	    'class-name': /@(?:[a-z0-9-]*[a-z0-9])?|\*/i,
	    function: /(?:\+[-+] {2})?(?:[a-z](?:[a-z0-9-]*[a-z0-9])?)/,
	    keyword:
	      /\.[\^\+\*=\?]|![><:\.=\?!]|=[>|:,\.\-\^<+;/~\*\?]|\?[>|:\.\-\^<\+&~=@!]|\|[\$_%:\.\-\^~\*=@\?]|\+[|\$\+\*]|:[_\-\^\+~\*]|%[_:\.\-\^\+~\*=]|\^[|:\.\-\+&~\*=\?]|\$[|_%:<>\-\^&~@=\?]|;[:<\+;\/~\*=]|~[>|\$_%<\+\/&=\?!]|--|==/
	  };
	}
	return hoon_1;
}

var hpkp_1;
var hasRequiredHpkp;

function requireHpkp () {
	if (hasRequiredHpkp) return hpkp_1;
	hasRequiredHpkp = 1;

	hpkp_1 = hpkp;
	hpkp.displayName = 'hpkp';
	hpkp.aliases = [];
	function hpkp(Prism) {
	  /**
	   * Original by Scott Helme.
	   *
	   * Reference: https://scotthelme.co.uk/hpkp-cheat-sheet/
	   */
	  Prism.languages.hpkp = {
	    directive: {
	      pattern:
	        /\b(?:includeSubDomains|max-age|pin-sha256|preload|report-to|report-uri|strict)(?=[\s;=]|$)/i,
	      alias: 'property'
	    },
	    operator: /=/,
	    punctuation: /;/
	  };
	}
	return hpkp_1;
}

var hsts_1;
var hasRequiredHsts;

function requireHsts () {
	if (hasRequiredHsts) return hsts_1;
	hasRequiredHsts = 1;

	hsts_1 = hsts;
	hsts.displayName = 'hsts';
	hsts.aliases = [];
	function hsts(Prism) {
	  /**
	   * Original by Scott Helme.
	   *
	   * Reference: https://scotthelme.co.uk/hsts-cheat-sheet/
	   */
	  Prism.languages.hsts = {
	    directive: {
	      pattern: /\b(?:includeSubDomains|max-age|preload)(?=[\s;=]|$)/i,
	      alias: 'property'
	    },
	    operator: /=/,
	    punctuation: /;/
	  };
	}
	return hsts_1;
}

var http_1;
var hasRequiredHttp;

function requireHttp () {
	if (hasRequiredHttp) return http_1;
	hasRequiredHttp = 1;

	http_1 = http;
	http.displayName = 'http';
	http.aliases = [];
	function http(Prism) {
(function (Prism) {
	    /**
	     * @param {string} name
	     * @returns {RegExp}
	     */
	    function headerValueOf(name) {
	      return RegExp('(^(?:' + name + '):[ \t]*(?![ \t]))[^]+', 'i')
	    }
	    Prism.languages.http = {
	      'request-line': {
	        pattern:
	          /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
	        inside: {
	          // HTTP Method
	          method: {
	            pattern: /^[A-Z]+\b/,
	            alias: 'property'
	          },
	          // Request Target e.g. http://example.com, /path/to/file
	          'request-target': {
	            pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
	            lookbehind: true,
	            alias: 'url',
	            inside: Prism.languages.uri
	          },
	          // HTTP Version
	          'http-version': {
	            pattern: /^(\s)HTTP\/[\d.]+/,
	            lookbehind: true,
	            alias: 'property'
	          }
	        }
	      },
	      'response-status': {
	        pattern: /^HTTP\/[\d.]+ \d+ .+/m,
	        inside: {
	          // HTTP Version
	          'http-version': {
	            pattern: /^HTTP\/[\d.]+/,
	            alias: 'property'
	          },
	          // Status Code
	          'status-code': {
	            pattern: /^(\s)\d+(?=\s)/,
	            lookbehind: true,
	            alias: 'number'
	          },
	          // Reason Phrase
	          'reason-phrase': {
	            pattern: /^(\s).+/,
	            lookbehind: true,
	            alias: 'string'
	          }
	        }
	      },
	      header: {
	        pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
	        inside: {
	          'header-value': [
	            {
	              pattern: headerValueOf(/Content-Security-Policy/.source),
	              lookbehind: true,
	              alias: ['csp', 'languages-csp'],
	              inside: Prism.languages.csp
	            },
	            {
	              pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),
	              lookbehind: true,
	              alias: ['hpkp', 'languages-hpkp'],
	              inside: Prism.languages.hpkp
	            },
	            {
	              pattern: headerValueOf(/Strict-Transport-Security/.source),
	              lookbehind: true,
	              alias: ['hsts', 'languages-hsts'],
	              inside: Prism.languages.hsts
	            },
	            {
	              pattern: headerValueOf(/[^:]+/.source),
	              lookbehind: true
	            }
	          ],
	          'header-name': {
	            pattern: /^[^:]+/,
	            alias: 'keyword'
	          },
	          punctuation: /^:/
	        }
	      }
	    }; // Create a mapping of Content-Type headers to language definitions
	    var langs = Prism.languages;
	    var httpLanguages = {
	      'application/javascript': langs.javascript,
	      'application/json': langs.json || langs.javascript,
	      'application/xml': langs.xml,
	      'text/xml': langs.xml,
	      'text/html': langs.html,
	      'text/css': langs.css,
	      'text/plain': langs.plain
	    }; // Declare which types can also be suffixes
	    var suffixTypes = {
	      'application/json': true,
	      'application/xml': true
	    };
	    /**
	     * Returns a pattern for the given content type which matches it and any type which has it as a suffix.
	     *
	     * @param {string} contentType
	     * @returns {string}
	     */
	    function getSuffixPattern(contentType) {
	      var suffix = contentType.replace(/^[a-z]+\//, '');
	      var suffixPattern = '\\w+/(?:[\\w.-]+\\+)+' + suffix + '(?![+\\w.-])';
	      return '(?:' + contentType + '|' + suffixPattern + ')'
	    } // Insert each content type parser that has its associated language
	    // currently loaded.
	    var options;
	    for (var contentType in httpLanguages) {
	      if (httpLanguages[contentType]) {
	        options = options || {};
	        var pattern = suffixTypes[contentType]
	          ? getSuffixPattern(contentType)
	          : contentType;
	        options[contentType.replace(/\//g, '-')] = {
	          pattern: RegExp(
	            '(' +
	              /content-type:\s*/.source +
	              pattern +
	              /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source +
	              ')' + // This is a little interesting:
	              // The HTTP format spec required 1 empty line before the body to make everything unambiguous.
	              // However, when writing code by hand (e.g. to display on a website) people can forget about this,
	              // so we want to be liberal here. We will allow the empty line to be omitted if the first line of
	              // the body does not start with a [\w-] character (as headers do).
	              /[^ \t\w-][\s\S]*/.source,
	            'i'
	          ),
	          lookbehind: true,
	          inside: httpLanguages[contentType]
	        };
	      }
	    }
	    if (options) {
	      Prism.languages.insertBefore('http', 'header', options);
	    }
	  })(Prism);
	}
	return http_1;
}

var ichigojam_1;
var hasRequiredIchigojam;

function requireIchigojam () {
	if (hasRequiredIchigojam) return ichigojam_1;
	hasRequiredIchigojam = 1;

	ichigojam_1 = ichigojam;
	ichigojam.displayName = 'ichigojam';
	ichigojam.aliases = [];
	function ichigojam(Prism) {
	  // according to the offical reference (EN)
	  // https://ichigojam.net/IchigoJam-en.html
	  Prism.languages.ichigojam = {
	    comment: /(?:\B'|REM)(?:[^\n\r]*)/i,
	    string: {
	      pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
	      greedy: true
	    },
	    number: /\B#[0-9A-F]+|\B`[01]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
	    keyword:
	      /\b(?:BEEP|BPS|CASE|CLEAR|CLK|CLO|CLP|CLS|CLT|CLV|CONT|COPY|ELSE|END|FILE|FILES|FOR|GOSUB|GOTO|GSB|IF|INPUT|KBD|LED|LET|LIST|LOAD|LOCATE|LRUN|NEW|NEXT|OUT|PLAY|POKE|PRINT|PWM|REM|RENUM|RESET|RETURN|RIGHT|RTN|RUN|SAVE|SCROLL|SLEEP|SRND|STEP|STOP|SUB|TEMPO|THEN|TO|UART|VIDEO|WAIT)(?:\$|\b)/i,
	    function:
	      /\b(?:ABS|ANA|ASC|BIN|BTN|DEC|END|FREE|HELP|HEX|I2CR|I2CW|IN|INKEY|LEN|LINE|PEEK|RND|SCR|SOUND|STR|TICK|USR|VER|VPEEK|ZER)(?:\$|\b)/i,
	    label: /(?:\B@\S+)/,
	    operator: /<[=>]?|>=?|\|\||&&|[+\-*\/=|&^~!]|\b(?:AND|NOT|OR)\b/i,
	    punctuation: /[\[,;:()\]]/
	  };
	}
	return ichigojam_1;
}

var icon_1;
var hasRequiredIcon;

function requireIcon () {
	if (hasRequiredIcon) return icon_1;
	hasRequiredIcon = 1;

	icon_1 = icon;
	icon.displayName = 'icon';
	icon.aliases = [];
	function icon(Prism) {
	  Prism.languages.icon = {
	    comment: /#.*/,
	    string: {
	      pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/,
	      greedy: true
	    },
	    number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,
	    'builtin-keyword': {
	      pattern:
	        /&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,
	      alias: 'variable'
	    },
	    directive: {
	      pattern: /\$\w+/,
	      alias: 'builtin'
	    },
	    keyword:
	      /\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,
	    function: /\b(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,
	    operator:
	      /[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,
	    punctuation: /[\[\](){},;]/
	  };
	}
	return icon_1;
}

var icuMessageFormat_1;
var hasRequiredIcuMessageFormat;

function requireIcuMessageFormat () {
	if (hasRequiredIcuMessageFormat) return icuMessageFormat_1;
	hasRequiredIcuMessageFormat = 1;

	icuMessageFormat_1 = icuMessageFormat;
	icuMessageFormat.displayName = 'icuMessageFormat';
	icuMessageFormat.aliases = [];
	function icuMessageFormat(Prism) {
(function (Prism) {
	    /**
	     * @param {string} source
	     * @param {number} level
	     * @returns {string}
	     */
	    function nested(source, level) {
	      if (level <= 0) {
	        return /[]/.source
	      } else {
	        return source.replace(/<SELF>/g, function () {
	          return nested(source, level - 1)
	        })
	      }
	    }
	    var stringPattern = /'[{}:=,](?:[^']|'')*'(?!')/;
	    var escape = {
	      pattern: /''/,
	      greedy: true,
	      alias: 'operator'
	    };
	    var string = {
	      pattern: stringPattern,
	      greedy: true,
	      inside: {
	        escape: escape
	      }
	    };
	    var argumentSource = nested(
	      /\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\}/.source.replace(
	        /<STR>/g,
	        function () {
	          return stringPattern.source
	        }
	      ),
	      8
	    );
	    var nestedMessage = {
	      pattern: RegExp(argumentSource),
	      inside: {
	        message: {
	          pattern: /^(\{)[\s\S]+(?=\}$)/,
	          lookbehind: true,
	          inside: null // see below
	        },
	        'message-delimiter': {
	          pattern: /./,
	          alias: 'punctuation'
	        }
	      }
	    };
	    Prism.languages['icu-message-format'] = {
	      argument: {
	        pattern: RegExp(argumentSource),
	        greedy: true,
	        inside: {
	          content: {
	            pattern: /^(\{)[\s\S]+(?=\}$)/,
	            lookbehind: true,
	            inside: {
	              'argument-name': {
	                pattern: /^(\s*)[^{}:=,\s]+/,
	                lookbehind: true
	              },
	              'choice-style': {
	                // https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1ChoiceFormat.html#details
	                pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/,
	                lookbehind: true,
	                inside: {
	                  punctuation: /\|/,
	                  range: {
	                    pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
	                    lookbehind: true,
	                    inside: {
	                      operator: /[<#\u2264]/,
	                      number: /\S+/
	                    }
	                  },
	                  rest: null // see below
	                }
	              },
	              'plural-style': {
	                // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/PluralFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
	                pattern:
	                  /^(\s*,\s*(?:plural|selectordinal)\s*,\s*)\S(?:[\s\S]*\S)?/,
	                lookbehind: true,
	                inside: {
	                  offset: /^offset:\s*\d+/,
	                  'nested-message': nestedMessage,
	                  selector: {
	                    pattern: /=\d+|[^{}:=,\s]+/,
	                    inside: {
	                      keyword: /^(?:few|many|one|other|two|zero)$/
	                    }
	                  }
	                }
	              },
	              'select-style': {
	                // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/SelectFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
	                pattern: /^(\s*,\s*select\s*,\s*)\S(?:[\s\S]*\S)?/,
	                lookbehind: true,
	                inside: {
	                  'nested-message': nestedMessage,
	                  selector: {
	                    pattern: /[^{}:=,\s]+/,
	                    inside: {
	                      keyword: /^other$/
	                    }
	                  }
	                }
	              },
	              keyword: /\b(?:choice|plural|select|selectordinal)\b/,
	              'arg-type': {
	                pattern: /\b(?:date|duration|number|ordinal|spellout|time)\b/,
	                alias: 'keyword'
	              },
	              'arg-skeleton': {
	                pattern: /(,\s*)::[^{}:=,\s]+/,
	                lookbehind: true
	              },
	              'arg-style': {
	                pattern:
	                  /(,\s*)(?:currency|full|integer|long|medium|percent|short)(?=\s*$)/,
	                lookbehind: true
	              },
	              'arg-style-text': {
	                pattern: RegExp(
	                  /(^\s*,\s*(?=\S))/.source +
	                    nested(/(?:[^{}']|'[^']*'|\{(?:<SELF>)?\})+/.source, 8) +
	                    '$'
	                ),
	                lookbehind: true,
	                alias: 'string'
	              },
	              punctuation: /,/
	            }
	          },
	          'argument-delimiter': {
	            pattern: /./,
	            alias: 'operator'
	          }
	        }
	      },
	      escape: escape,
	      string: string
	    };
	    nestedMessage.inside.message.inside = Prism.languages['icu-message-format'];
	    Prism.languages['icu-message-format'].argument.inside.content.inside[
	      'choice-style'
	    ].inside.rest = Prism.languages['icu-message-format'];
	  })(Prism);
	}
	return icuMessageFormat_1;
}

var idris_1;
var hasRequiredIdris;

function requireIdris () {
	if (hasRequiredIdris) return idris_1;
	hasRequiredIdris = 1;
	var refractorHaskell = requireHaskell();
	idris_1 = idris;
	idris.displayName = 'idris';
	idris.aliases = ['idr'];
	function idris(Prism) {
	  Prism.register(refractorHaskell);
	  Prism.languages.idris = Prism.languages.extend('haskell', {
	    comment: {
	      pattern: /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m
	    },
	    keyword:
	      /\b(?:Type|case|class|codata|constructor|corecord|data|do|dsl|else|export|if|implementation|implicit|import|impossible|in|infix|infixl|infixr|instance|interface|let|module|mutual|namespace|of|parameters|partial|postulate|private|proof|public|quoteGoal|record|rewrite|syntax|then|total|using|where|with)\b/,
	    builtin: undefined
	  });
	  Prism.languages.insertBefore('idris', 'keyword', {
	    'import-statement': {
	      pattern: /(^\s*import\s+)(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*/m,
	      lookbehind: true,
	      inside: {
	        punctuation: /\./
	      }
	    }
	  });
	  Prism.languages.idr = Prism.languages.idris;
	}
	return idris_1;
}

var iecst_1;
var hasRequiredIecst;

function requireIecst () {
	if (hasRequiredIecst) return iecst_1;
	hasRequiredIecst = 1;

	iecst_1 = iecst;
	iecst.displayName = 'iecst';
	iecst.aliases = [];
	function iecst(Prism) {
	  Prism.languages.iecst = {
	    comment: [
	      {
	        pattern:
	          /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\(\*[\s\S]*?(?:\*\)|$)|\{[\s\S]*?(?:\}|$))/,
	        lookbehind: true,
	        greedy: true
	      },
	      {
	        pattern: /(^|[^\\:])\/\/.*/,
	        lookbehind: true,
	        greedy: true
	      }
	    ],
	    string: {
	      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    keyword: [
	      /\b(?:END_)?(?:PROGRAM|CONFIGURATION|INTERFACE|FUNCTION_BLOCK|FUNCTION|ACTION|TRANSITION|TYPE|STRUCT|(?:INITIAL_)?STEP|NAMESPACE|LIBRARY|CHANNEL|FOLDER|RESOURCE|VAR_(?:ACCESS|CONFIG|EXTERNAL|GLOBAL|INPUT|IN_OUT|OUTPUT|TEMP)|VAR|METHOD|PROPERTY)\b/i,
	      /\b(?:AT|BY|(?:END_)?(?:CASE|FOR|IF|REPEAT|WHILE)|CONSTANT|CONTINUE|DO|ELSE|ELSIF|EXIT|EXTENDS|FROM|GET|GOTO|IMPLEMENTS|JMP|NON_RETAIN|OF|PRIVATE|PROTECTED|PUBLIC|RETAIN|RETURN|SET|TASK|THEN|TO|UNTIL|USING|WITH|__CATCH|__ENDTRY|__FINALLY|__TRY)\b/
	    ],
	    'class-name':
	      /\b(?:ANY|ARRAY|BOOL|BYTE|U?(?:D|L|S)?INT|(?:D|L)?WORD|DATE(?:_AND_TIME)?|DT|L?REAL|POINTER|STRING|TIME(?:_OF_DAY)?|TOD)\b/,
	    address: {
	      pattern: /%[IQM][XBWDL][\d.]*|%[IQ][\d.]*/,
	      alias: 'symbol'
	    },
	    number:
	      /\b(?:16#[\da-f]+|2#[01_]+|0x[\da-f]+)\b|\b(?:D|DT|T|TOD)#[\d_shmd:]*|\b[A-Z]*#[\d.,_]*|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
	    boolean: /\b(?:FALSE|NULL|TRUE)\b/,
	    operator:
	      /S?R?:?=>?|&&?|\*\*?|<[=>]?|>=?|[-:^/+#]|\b(?:AND|EQ|EXPT|GE|GT|LE|LT|MOD|NE|NOT|OR|XOR)\b/,
	    function: /\b[a-z_]\w*(?=\s*\()/i,
	    punctuation: /[()[\].,;]/
	  };
	}
	return iecst_1;
}

var ignore_1;
var hasRequiredIgnore;

function requireIgnore () {
	if (hasRequiredIgnore) return ignore_1;
	hasRequiredIgnore = 1;

	ignore_1 = ignore;
	ignore.displayName = 'ignore';
	ignore.aliases = ['gitignore', 'hgignore', 'npmignore'];
	function ignore(Prism) {
(function (Prism) {
	    Prism.languages.ignore = {
	      // https://git-scm.com/docs/gitignore
	      comment: /^#.*/m,
	      entry: {
	        pattern: /\S(?:.*(?:(?:\\ )|\S))?/,
	        alias: 'string',
	        inside: {
	          operator: /^!|\*\*?|\?/,
	          regex: {
	            pattern: /(^|[^\\])\[[^\[\]]*\]/,
	            lookbehind: true
	          },
	          punctuation: /\//
	        }
	      }
	    };
	    Prism.languages.gitignore = Prism.languages.ignore;
	    Prism.languages.hgignore = Prism.languages.ignore;
	    Prism.languages.npmignore = Prism.languages.ignore;
	  })(Prism);
	}
	return ignore_1;
}

var inform7_1;
var hasRequiredInform7;

function requireInform7 () {
	if (hasRequiredInform7) return inform7_1;
	hasRequiredInform7 = 1;

	inform7_1 = inform7;
	inform7.displayName = 'inform7';
	inform7.aliases = [];
	function inform7(Prism) {
	  Prism.languages.inform7 = {
	    string: {
	      pattern: /"[^"]*"/,
	      inside: {
	        substitution: {
	          pattern: /\[[^\[\]]+\]/,
	          inside: {
	            delimiter: {
	              pattern: /\[|\]/,
	              alias: 'punctuation'
	            } // See rest below
	          }
	        }
	      }
	    },
	    comment: {
	      pattern: /\[[^\[\]]+\]/,
	      greedy: true
	    },
	    title: {
	      pattern: /^[ \t]*(?:book|chapter|part(?! of)|section|table|volume)\b.+/im,
	      alias: 'important'
	    },
	    number: {
	      pattern:
	        /(^|[^-])(?:\b\d+(?:\.\d+)?(?:\^\d+)?(?:(?!\d)\w+)?|\b(?:eight|eleven|five|four|nine|one|seven|six|ten|three|twelve|two))\b(?!-)/i,
	      lookbehind: true
	    },
	    verb: {
	      pattern:
	        /(^|[^-])\b(?:answering|applying to|are|asking|attacking|be(?:ing)?|burning|buying|called|carries|carry(?! out)|carrying|climbing|closing|conceal(?:ing|s)?|consulting|contain(?:ing|s)?|cutting|drinking|dropping|eating|enclos(?:es?|ing)|entering|examining|exiting|getting|giving|going|ha(?:s|ve|ving)|hold(?:ing|s)?|impl(?:ies|y)|incorporat(?:es?|ing)|inserting|is|jumping|kissing|listening|locking|looking|mean(?:ing|s)?|opening|provid(?:es?|ing)|pulling|pushing|putting|relat(?:es?|ing)|removing|searching|see(?:ing|s)?|setting|showing|singing|sleeping|smelling|squeezing|support(?:ing|s)?|swearing|switching|taking|tasting|telling|thinking|throwing|touching|turning|tying|unlock(?:ing|s)?|var(?:ies|y|ying)|waiting|waking|waving|wear(?:ing|s)?)\b(?!-)/i,
	      lookbehind: true,
	      alias: 'operator'
	    },
	    keyword: {
	      pattern:
	        /(^|[^-])\b(?:after|before|carry out|check|continue the action|definition(?= *:)|do nothing|else|end (?:if|the story|unless)|every turn|if|include|instead(?: of)?|let|move|no|now|otherwise|repeat|report|resume the story|rule for|running through|say(?:ing)?|stop the action|test|try(?:ing)?|understand|unless|use|when|while|yes)\b(?!-)/i,
	      lookbehind: true
	    },
	    property: {
	      pattern:
	        /(^|[^-])\b(?:adjacent(?! to)|carried|closed|concealed|contained|dark|described|edible|empty|enclosed|enterable|even|female|fixed in place|full|handled|held|improper-named|incorporated|inedible|invisible|lighted|lit|lock(?:able|ed)|male|marked for listing|mentioned|negative|neuter|non-(?:empty|full|recurring)|odd|opaque|open(?:able)?|plural-named|portable|positive|privately-named|proper-named|provided|publically-named|pushable between rooms|recurring|related|rubbing|scenery|seen|singular-named|supported|swinging|switch(?:able|ed(?: off| on)?)|touch(?:able|ed)|transparent|unconcealed|undescribed|unlit|unlocked|unmarked for listing|unmentioned|unopenable|untouchable|unvisited|variable|visible|visited|wearable|worn)\b(?!-)/i,
	      lookbehind: true,
	      alias: 'symbol'
	    },
	    position: {
	      pattern:
	        /(^|[^-])\b(?:above|adjacent to|back side of|below|between|down|east|everywhere|front side|here|in|inside(?: from)?|north(?:east|west)?|nowhere|on(?: top of)?|other side|outside(?: from)?|parts? of|regionally in|south(?:east|west)?|through|up|west|within)\b(?!-)/i,
	      lookbehind: true,
	      alias: 'keyword'
	    },
	    type: {
	      pattern:
	        /(^|[^-])\b(?:actions?|activit(?:ies|y)|actors?|animals?|backdrops?|containers?|devices?|directions?|doors?|holders?|kinds?|lists?|m[ae]n|nobody|nothing|nouns?|numbers?|objects?|people|persons?|player(?:'s holdall)?|regions?|relations?|rooms?|rule(?:book)?s?|scenes?|someone|something|supporters?|tables?|texts?|things?|time|vehicles?|wom[ae]n)\b(?!-)/i,
	      lookbehind: true,
	      alias: 'variable'
	    },
	    punctuation: /[.,:;(){}]/
	  };
	  Prism.languages.inform7['string'].inside['substitution'].inside.rest =
	    Prism.languages.inform7; // We don't want the remaining text in the substitution to be highlighted as the string.
	  Prism.languages.inform7['string'].inside['substitution'].inside.rest.text = {
	    pattern: /\S(?:\s*\S)*/,
	    alias: 'comment'
	  };
	}
	return inform7_1;
}

var ini_1;
var hasRequiredIni;

function requireIni () {
	if (hasRequiredIni) return ini_1;
	hasRequiredIni = 1;

	ini_1 = ini;
	ini.displayName = 'ini';
	ini.aliases = [];
	function ini(Prism) {
	  Prism.languages.ini = {
	    /**
	     * The component mimics the behavior of the Win32 API parser.
	     *
	     * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
	     */
	    comment: {
	      pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
	      lookbehind: true
	    },
	    section: {
	      pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
	      lookbehind: true,
	      inside: {
	        'section-name': {
	          pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
	          lookbehind: true,
	          alias: 'selector'
	        },
	        punctuation: /\[|\]/
	      }
	    },
	    key: {
	      pattern:
	        /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
	      lookbehind: true,
	      alias: 'attr-name'
	    },
	    value: {
	      pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
	      lookbehind: true,
	      alias: 'attr-value',
	      inside: {
	        'inner-value': {
	          pattern: /^("|').+(?=\1$)/,
	          lookbehind: true
	        }
	      }
	    },
	    punctuation: /=/
	  };
	}
	return ini_1;
}

var io_1;
var hasRequiredIo;

function requireIo () {
	if (hasRequiredIo) return io_1;
	hasRequiredIo = 1;

	io_1 = io;
	io.displayName = 'io';
	io.aliases = [];
	function io(Prism) {
	  Prism.languages.io = {
	    comment: {
	      pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*|#.*)/,
	      lookbehind: true,
	      greedy: true
	    },
	    'triple-quoted-string': {
	      pattern: /"""(?:\\[\s\S]|(?!""")[^\\])*"""/,
	      greedy: true,
	      alias: 'string'
	    },
	    string: {
	      pattern: /"(?:\\.|[^\\\r\n"])*"/,
	      greedy: true
	    },
	    keyword:
	      /\b(?:activate|activeCoroCount|asString|block|break|call|catch|clone|collectGarbage|compileString|continue|do|doFile|doMessage|doString|else|elseif|exit|for|foreach|forward|getEnvironmentVariable|getSlot|hasSlot|if|ifFalse|ifNil|ifNilEval|ifTrue|isActive|isNil|isResumable|list|message|method|parent|pass|pause|perform|performWithArgList|print|println|proto|raise|raiseResumable|removeSlot|resend|resume|schedulerSleepSeconds|self|sender|setSchedulerSleepSeconds|setSlot|shallowCopy|slotNames|super|system|then|thisBlock|thisContext|try|type|uniqueId|updateSlot|wait|while|write|yield)\b/,
	    builtin:
	      /\b(?:Array|AudioDevice|AudioMixer|BigNum|Block|Box|Buffer|CFunction|CGI|Color|Curses|DBM|DNSResolver|DOConnection|DOProxy|DOServer|Date|Directory|Duration|DynLib|Error|Exception|FFT|File|Fnmatch|Font|Future|GL|GLE|GLScissor|GLU|GLUCylinder|GLUQuadric|GLUSphere|GLUT|Host|Image|Importer|LinkList|List|Lobby|Locals|MD5|MP3Decoder|MP3Encoder|Map|Message|Movie|Notification|Number|Object|OpenGL|Point|Protos|Random|Regex|SGML|SGMLElement|SGMLParser|SQLite|Sequence|Server|ShowMessage|SleepyCat|SleepyCatCursor|Socket|SocketManager|Sound|Soup|Store|String|Tree|UDPSender|UPDReceiver|URL|User|Warning|WeakLink)\b/,
	    boolean: /\b(?:false|nil|true)\b/,
	    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?/i,
	    operator:
	      /[=!*/%+\-^&|]=|>>?=?|<<?=?|:?:?=|\+\+?|--?|\*\*?|\/\/?|%|\|\|?|&&?|\b(?:and|not|or|return)\b|@@?|\?\??|\.\./,
	    punctuation: /[{}[\];(),.:]/
	  };
	}
	return io_1;
}

var j_1;
var hasRequiredJ;

function requireJ () {
	if (hasRequiredJ) return j_1;
	hasRequiredJ = 1;

	j_1 = j;
	j.displayName = 'j';
	j.aliases = [];
	function j(Prism) {
	  Prism.languages.j = {
	    comment: {
	      pattern: /\bNB\..*/,
	      greedy: true
	    },
	    string: {
	      pattern: /'(?:''|[^'\r\n])*'/,
	      greedy: true
	    },
	    keyword:
	      /\b(?:(?:CR|LF|adverb|conjunction|def|define|dyad|monad|noun|verb)\b|(?:assert|break|case|catch[dt]?|continue|do|else|elseif|end|fcase|for|for_\w+|goto_\w+|if|label_\w+|return|select|throw|try|while|whilst)\.)/,
	    verb: {
	      // Negative look-ahead prevents bad highlighting
	      // of ^: ;. =. =: !. !:
	      pattern:
	        /(?!\^:|;\.|[=!][.:])(?:\{(?:\.|::?)?|p(?:\.\.?|:)|[=!\]]|[<>+*\-%$|,#][.:]?|[?^]\.?|[;\[]:?|[~}"i][.:]|[ACeEIjLor]\.|(?:[_\/\\qsux]|_?\d):)/,
	      alias: 'keyword'
	    },
	    number:
	      /\b_?(?:(?!\d:)\d+(?:\.\d+)?(?:(?:ad|ar|[ejpx])_?\d+(?:\.\d+)?)*(?:b_?[\da-z]+(?:\.[\da-z]+)?)?|_\b(?!\.))/,
	    adverb: {
	      pattern: /[~}]|[\/\\]\.?|[bfM]\.|t[.:]/,
	      alias: 'builtin'
	    },
	    operator: /[=a][.:]|_\./,
	    conjunction: {
	      pattern: /&(?:\.:?|:)?|[.:@][.:]?|[!D][.:]|[;dHT]\.|`:?|[\^LS]:|"/,
	      alias: 'variable'
	    },
	    punctuation: /[()]/
	  };
	}
	return j_1;
}

var java_1;
var hasRequiredJava;

function requireJava () {
	if (hasRequiredJava) return java_1;
	hasRequiredJava = 1;

	java_1 = java;
	java.displayName = 'java';
	java.aliases = [];
	function java(Prism) {
(function (Prism) {
	    var keywords =
	      /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/; // full package (optional) + parent classes (optional)
	    var classNamePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/
	      .source; // based on the java naming conventions
	    var className = {
	      pattern: RegExp(classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
	      lookbehind: true,
	      inside: {
	        namespace: {
	          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
	          inside: {
	            punctuation: /\./
	          }
	        },
	        punctuation: /\./
	      }
	    };
	    Prism.languages.java = Prism.languages.extend('clike', {
	      string: {
	        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
	        lookbehind: true,
	        greedy: true
	      },
	      'class-name': [
	        className,
	        {
	          // variables and parameters
	          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
	          pattern: RegExp(
	            classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source
	          ),
	          lookbehind: true,
	          inside: className.inside
	        }
	      ],
	      keyword: keywords,
	      function: [
	        Prism.languages.clike.function,
	        {
	          pattern: /(::\s*)[a-z_]\w*/,
	          lookbehind: true
	        }
	      ],
	      number:
	        /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
	      operator: {
	        pattern:
	          /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
	        lookbehind: true
	      }
	    });
	    Prism.languages.insertBefore('java', 'string', {
	      'triple-quoted-string': {
	        // http://openjdk.java.net/jeps/355#Description
	        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
	        greedy: true,
	        alias: 'string'
	      },
	      char: {
	        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
	        greedy: true
	      }
	    });
	    Prism.languages.insertBefore('java', 'class-name', {
	      annotation: {
	        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
	        lookbehind: true,
	        alias: 'punctuation'
	      },
	      generics: {
	        pattern:
	          /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
	        inside: {
	          'class-name': className,
	          keyword: keywords,
	          punctuation: /[<>(),.:]/,
	          operator: /[?&|]/
	        }
	      },
	      namespace: {
	        pattern: RegExp(
	          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(
	            /<keyword>/g,
	            function () {
	              return keywords.source
	            }
	          )
	        ),
	        lookbehind: true,
	        inside: {
	          punctuation: /\./
	        }
	      }
	    });
	  })(Prism);
	}
	return java_1;
}

var javadoclike_1;
var hasRequiredJavadoclike;

function requireJavadoclike () {
	if (hasRequiredJavadoclike) return javadoclike_1;
	hasRequiredJavadoclike = 1;

	javadoclike_1 = javadoclike;
	javadoclike.displayName = 'javadoclike';
	javadoclike.aliases = [];
	function javadoclike(Prism) {
(function (Prism) {
	    var javaDocLike = (Prism.languages.javadoclike = {
	      parameter: {
	        pattern:
	          /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m,
	        lookbehind: true
	      },
	      keyword: {
	        // keywords are the first word in a line preceded be an `@` or surrounded by curly braces.
	        // @word, {@word}
	        pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m,
	        lookbehind: true
	      },
	      punctuation: /[{}]/
	    });
	    /**
	     * Adds doc comment support to the given language and calls a given callback on each doc comment pattern.
	     *
	     * @param {string} lang the language add doc comment support to.
	     * @param {(pattern: {inside: {rest: undefined}}) => void} callback the function called with each doc comment pattern as argument.
	     */
	    function docCommentSupport(lang, callback) {
	      var tokenName = 'doc-comment';
	      var grammar = Prism.languages[lang];
	      if (!grammar) {
	        return
	      }
	      var token = grammar[tokenName];
	      if (!token) {
	        // add doc comment: /** */
	        var definition = {};
	        definition[tokenName] = {
	          pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
	          lookbehind: true,
	          alias: 'comment'
	        };
	        grammar = Prism.languages.insertBefore(lang, 'comment', definition);
	        token = grammar[tokenName];
	      }
	      if (token instanceof RegExp) {
	        // convert regex to object
	        token = grammar[tokenName] = {
	          pattern: token
	        };
	      }
	      if (Array.isArray(token)) {
	        for (var i = 0, l = token.length; i < l; i++) {
	          if (token[i] instanceof RegExp) {
	            token[i] = {
	              pattern: token[i]
	            };
	          }
	          callback(token[i]);
	        }
	      } else {
	        callback(token);
	      }
	    }
	    /**
	     * Adds doc-comment support to the given languages for the given documentation language.
	     *
	     * @param {string[]|string} languages
	     * @param {Object} docLanguage
	     */
	    function addSupport(languages, docLanguage) {
	      if (typeof languages === 'string') {
	        languages = [languages];
	      }
	      languages.forEach(function (lang) {
	        docCommentSupport(lang, function (pattern) {
	          if (!pattern.inside) {
	            pattern.inside = {};
	          }
	          pattern.inside.rest = docLanguage;
	        });
	      });
	    }
	    Object.defineProperty(javaDocLike, 'addSupport', {
	      value: addSupport
	    });
	    javaDocLike.addSupport(['java', 'javascript', 'php'], javaDocLike);
	  })(Prism);
	}
	return javadoclike_1;
}

var javadoc_1;
var hasRequiredJavadoc;

function requireJavadoc () {
	if (hasRequiredJavadoc) return javadoc_1;
	hasRequiredJavadoc = 1;
	var refractorJava = requireJava();
	var refractorJavadoclike = requireJavadoclike();
	javadoc_1 = javadoc;
	javadoc.displayName = 'javadoc';
	javadoc.aliases = [];
	function javadoc(Prism) {
	  Prism.register(refractorJava);
	  Prism.register(refractorJavadoclike)
	  ;(function (Prism) {
	    var codeLinePattern = /(^(?:[\t ]*(?:\*\s*)*))[^*\s].*$/m;
	    var memberReference = /#\s*\w+(?:\s*\([^()]*\))?/.source;
	    var reference =
	      /(?:\b[a-zA-Z]\w+\s*\.\s*)*\b[A-Z]\w*(?:\s*<mem>)?|<mem>/.source.replace(
	        /<mem>/g,
	        function () {
	          return memberReference
	        }
	      );
	    Prism.languages.javadoc = Prism.languages.extend('javadoclike', {});
	    Prism.languages.insertBefore('javadoc', 'keyword', {
	      reference: {
	        pattern: RegExp(
	          /(@(?:exception|link|linkplain|see|throws|value)\s+(?:\*\s*)?)/
	            .source +
	            '(?:' +
	            reference +
	            ')'
	        ),
	        lookbehind: true,
	        inside: {
	          function: {
	            pattern: /(#\s*)\w+(?=\s*\()/,
	            lookbehind: true
	          },
	          field: {
	            pattern: /(#\s*)\w+/,
	            lookbehind: true
	          },
	          namespace: {
	            pattern: /\b(?:[a-z]\w*\s*\.\s*)+/,
	            inside: {
	              punctuation: /\./
	            }
	          },
	          'class-name': /\b[A-Z]\w*/,
	          keyword: Prism.languages.java.keyword,
	          punctuation: /[#()[\],.]/
	        }
	      },
	      'class-name': {
	        // @param <T> the first generic type parameter
	        pattern: /(@param\s+)<[A-Z]\w*>/,
	        lookbehind: true,
	        inside: {
	          punctuation: /[.<>]/
	        }
	      },
	      'code-section': [
	        {
	          pattern:
	            /(\{@code\s+(?!\s))(?:[^\s{}]|\s+(?![\s}])|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})+(?=\s*\})/,
	          lookbehind: true,
	          inside: {
	            code: {
	              // there can't be any HTML inside of {@code} tags
	              pattern: codeLinePattern,
	              lookbehind: true,
	              inside: Prism.languages.java,
	              alias: 'language-java'
	            }
	          }
	        },
	        {
	          pattern:
	            /(<(code|pre|tt)>(?!<code>)\s*)\S(?:\S|\s+\S)*?(?=\s*<\/\2>)/,
	          lookbehind: true,
	          inside: {
	            line: {
	              pattern: codeLinePattern,
	              lookbehind: true,
	              inside: {
	                // highlight HTML tags and entities
	                tag: Prism.languages.markup.tag,
	                entity: Prism.languages.markup.entity,
	                code: {
	                  // everything else is Java code
	                  pattern: /.+/,
	                  inside: Prism.languages.java,
	                  alias: 'language-java'
	                }
	              }
	            }
	          }
	        }
	      ],
	      tag: Prism.languages.markup.tag,
	      entity: Prism.languages.markup.entity
	    });
	    Prism.languages.javadoclike.addSupport('java', Prism.languages.javadoc);
	  })(Prism);
	}
	return javadoc_1;
}

var javastacktrace_1;
var hasRequiredJavastacktrace;

function requireJavastacktrace () {
	if (hasRequiredJavastacktrace) return javastacktrace_1;
	hasRequiredJavastacktrace = 1;

	javastacktrace_1 = javastacktrace;
	javastacktrace.displayName = 'javastacktrace';
	javastacktrace.aliases = [];
	function javastacktrace(Prism) {
	  // Specification:
	  // https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Throwable.html#printStackTrace()
	  Prism.languages.javastacktrace = {
	    // java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
	    // Caused by: java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
	    // Caused by: com.example.myproject.MyProjectServletException
	    // Caused by: MidLevelException: LowLevelException
	    // Suppressed: Resource$CloseFailException: Resource ID = 0
	    summary: {
	      pattern:
	        /^([\t ]*)(?:(?:Caused by:|Suppressed:|Exception in thread "[^"]*")[\t ]+)?[\w$.]+(?::.*)?$/m,
	      lookbehind: true,
	      inside: {
	        keyword: {
	          pattern:
	            /^([\t ]*)(?:(?:Caused by|Suppressed)(?=:)|Exception in thread)/m,
	          lookbehind: true
	        },
	        // the current thread if the summary starts with 'Exception in thread'
	        string: {
	          pattern: /^(\s*)"[^"]*"/,
	          lookbehind: true
	        },
	        exceptions: {
	          pattern: /^(:?\s*)[\w$.]+(?=:|$)/,
	          lookbehind: true,
	          inside: {
	            'class-name': /[\w$]+$/,
	            namespace: /\b[a-z]\w*\b/,
	            punctuation: /\./
	          }
	        },
	        message: {
	          pattern: /(:\s*)\S.*/,
	          lookbehind: true,
	          alias: 'string'
	        },
	        punctuation: /:/
	      }
	    },
	    // at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)
	    // at org.hsqldb.jdbc.Util.throwError(Unknown Source) here could be some notes
	    // at java.base/java.lang.Class.forName0(Native Method)
	    // at Util.<init>(Unknown Source)
	    // at com.foo.loader/foo@9.0/com.foo.Main.run(Main.java:101)
	    // at com.foo.loader//com.foo.bar.App.run(App.java:12)
	    // at acme@2.1/org.acme.Lib.test(Lib.java:80)
	    // at MyClass.mash(MyClass.java:9)
	    //
	    // More information:
	    // https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/StackTraceElement.html#toString()
	    //
	    // A valid Java module name is defined as:
	    //   "A module name consists of one or more Java identifiers (§3.8) separated by "." tokens."
	    // https://docs.oracle.com/javase/specs/jls/se9/html/jls-6.html#jls-ModuleName
	    //
	    // A Java module version is defined by this class:
	    // https://docs.oracle.com/javase/9/docs/api/java/lang/module/ModuleDescriptor.Version.html
	    // This is the implementation of the `parse` method in JDK13:
	    // https://github.com/matcdac/jdk/blob/2305df71d1b7710266ae0956d73927a225132c0f/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java#L1108
	    // However, to keep this simple, a version will be matched by the pattern /@[\w$.+-]*/.
	    'stack-frame': {
	      pattern: /^([\t ]*)at (?:[\w$./]|@[\w$.+-]*\/)+(?:<init>)?\([^()]*\)/m,
	      lookbehind: true,
	      inside: {
	        keyword: {
	          pattern: /^(\s*)at(?= )/,
	          lookbehind: true
	        },
	        source: [
	          // (Main.java:15)
	          // (Main.scala:15)
	          {
	            pattern: /(\()\w+\.\w+:\d+(?=\))/,
	            lookbehind: true,
	            inside: {
	              file: /^\w+\.\w+/,
	              punctuation: /:/,
	              'line-number': {
	                pattern: /\b\d+\b/,
	                alias: 'number'
	              }
	            }
	          }, // (Unknown Source)
	          // (Native Method)
	          // (...something...)
	          {
	            pattern: /(\()[^()]*(?=\))/,
	            lookbehind: true,
	            inside: {
	              keyword: /^(?:Native Method|Unknown Source)$/
	            }
	          }
	        ],
	        'class-name': /[\w$]+(?=\.(?:<init>|[\w$]+)\()/,
	        function: /(?:<init>|[\w$]+)(?=\()/,
	        'class-loader': {
	          pattern: /(\s)[a-z]\w*(?:\.[a-z]\w*)*(?=\/[\w@$.]*\/)/,
	          lookbehind: true,
	          alias: 'namespace',
	          inside: {
	            punctuation: /\./
	          }
	        },
	        module: {
	          pattern: /([\s/])[a-z]\w*(?:\.[a-z]\w*)*(?:@[\w$.+-]*)?(?=\/)/,
	          lookbehind: true,
	          inside: {
	            version: {
	              pattern: /(@)[\s\S]+/,
	              lookbehind: true,
	              alias: 'number'
	            },
	            punctuation: /[@.]/
	          }
	        },
	        namespace: {
	          pattern: /(?:\b[a-z]\w*\.)+/,
	          inside: {
	            punctuation: /\./
	          }
	        },
	        punctuation: /[()/.]/
	      }
	    },
	    // ... 32 more
	    // ... 32 common frames omitted
	    more: {
	      pattern: /^([\t ]*)\.{3} \d+ [a-z]+(?: [a-z]+)*/m,
	      lookbehind: true,
	      inside: {
	        punctuation: /\.{3}/,
	        number: /\d+/,
	        keyword: /\b[a-z]+(?: [a-z]+)*\b/
	      }
	    }
	  };
	}
	return javastacktrace_1;
}

var jexl_1;
var hasRequiredJexl;

function requireJexl () {
	if (hasRequiredJexl) return jexl_1;
	hasRequiredJexl = 1;

	jexl_1 = jexl;
	jexl.displayName = 'jexl';
	jexl.aliases = [];
	function jexl(Prism) {
	  Prism.languages.jexl = {
	    string: /(["'])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
	    transform: {
	      pattern:
	        /(\|\s*)[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*/,
	      alias: 'function',
	      lookbehind: true
	    },
	    function:
	      /[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*\s*(?=\()/,
	    number: /\b\d+(?:\.\d+)?\b|\B\.\d+\b/,
	    operator: /[<>!]=?|-|\+|&&|==|\|\|?|\/\/?|[?:*^%]/,
	    boolean: /\b(?:false|true)\b/,
	    keyword: /\bin\b/,
	    punctuation: /[{}[\](),.]/
	  };
	}
	return jexl_1;
}

var jolie_1;
var hasRequiredJolie;

function requireJolie () {
	if (hasRequiredJolie) return jolie_1;
	hasRequiredJolie = 1;

	jolie_1 = jolie;
	jolie.displayName = 'jolie';
	jolie.aliases = [];
	function jolie(Prism) {
	  Prism.languages.jolie = Prism.languages.extend('clike', {
	    string: {
	      pattern: /(^|[^\\])"(?:\\[\s\S]|[^"\\])*"/,
	      lookbehind: true,
	      greedy: true
	    },
	    'class-name': {
	      pattern:
	        /((?:\b(?:as|courier|embed|in|inputPort|outputPort|service)\b|@)[ \t]*)\w+/,
	      lookbehind: true
	    },
	    keyword:
	      /\b(?:as|cH|comp|concurrent|constants|courier|cset|csets|default|define|else|embed|embedded|execution|exit|extender|for|foreach|forward|from|global|if|import|in|include|init|inputPort|install|instanceof|interface|is_defined|linkIn|linkOut|main|new|nullProcess|outputPort|over|private|provide|public|scope|sequential|service|single|spawn|synchronized|this|throw|throws|type|undef|until|while|with)\b/,
	    function: /\b[a-z_]\w*(?=[ \t]*[@(])/i,
	    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?l?/i,
	    operator: /-[-=>]?|\+[+=]?|<[<=]?|[>=*!]=?|&&|\|\||[?\/%^@|]/,
	    punctuation: /[()[\]{},;.:]/,
	    builtin:
	      /\b(?:Byte|any|bool|char|double|enum|float|int|length|long|ranges|regex|string|undefined|void)\b/
	  });
	  Prism.languages.insertBefore('jolie', 'keyword', {
	    aggregates: {
	      pattern:
	        /(\bAggregates\s*:\s*)(?:\w+(?:\s+with\s+\w+)?\s*,\s*)*\w+(?:\s+with\s+\w+)?/,
	      lookbehind: true,
	      inside: {
	        keyword: /\bwith\b/,
	        'class-name': /\w+/,
	        punctuation: /,/
	      }
	    },
	    redirects: {
	      pattern:
	        /(\bRedirects\s*:\s*)(?:\w+\s*=>\s*\w+\s*,\s*)*(?:\w+\s*=>\s*\w+)/,
	      lookbehind: true,
	      inside: {
	        punctuation: /,/,
	        'class-name': /\w+/,
	        operator: /=>/
	      }
	    },
	    property: {
	      pattern:
	        /\b(?:Aggregates|[Ii]nterfaces|Java|Javascript|Jolie|[Ll]ocation|OneWay|[Pp]rotocol|Redirects|RequestResponse)\b(?=[ \t]*:)/
	    }
	  });
	}
	return jolie_1;
}

var jq_1;
var hasRequiredJq;

function requireJq () {
	if (hasRequiredJq) return jq_1;
	hasRequiredJq = 1;

	jq_1 = jq;
	jq.displayName = 'jq';
	jq.aliases = [];
	function jq(Prism) {
(function (Prism) {
	    var interpolation = /\\\((?:[^()]|\([^()]*\))*\)/.source;
	    var string = RegExp(
	      /(^|[^\\])"(?:[^"\r\n\\]|\\[^\r\n(]|__)*"/.source.replace(
	        /__/g,
	        function () {
	          return interpolation
	        }
	      )
	    );
	    var stringInterpolation = {
	      interpolation: {
	        pattern: RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + interpolation),
	        lookbehind: true,
	        inside: {
	          content: {
	            pattern: /^(\\\()[\s\S]+(?=\)$)/,
	            lookbehind: true,
	            inside: null // see below
	          },
	          punctuation: /^\\\(|\)$/
	        }
	      }
	    };
	    var jq = (Prism.languages.jq = {
	      comment: /#.*/,
	      property: {
	        pattern: RegExp(string.source + /(?=\s*:(?!:))/.source),
	        lookbehind: true,
	        greedy: true,
	        inside: stringInterpolation
	      },
	      string: {
	        pattern: string,
	        lookbehind: true,
	        greedy: true,
	        inside: stringInterpolation
	      },
	      function: {
	        pattern: /(\bdef\s+)[a-z_]\w+/i,
	        lookbehind: true
	      },
	      variable: /\B\$\w+/,
	      'property-literal': {
	        pattern: /\b[a-z_]\w*(?=\s*:(?!:))/i,
	        alias: 'property'
	      },
	      keyword:
	        /\b(?:as|break|catch|def|elif|else|end|foreach|if|import|include|label|module|modulemeta|null|reduce|then|try|while)\b/,
	      boolean: /\b(?:false|true)\b/,
	      number: /(?:\b\d+\.|\B\.)?\b\d+(?:[eE][+-]?\d+)?\b/,
	      operator: [
	        {
	          pattern: /\|=?/,
	          alias: 'pipe'
	        },
	        /\.\.|[!=<>]?=|\?\/\/|\/\/=?|[-+*/%]=?|[<>?]|\b(?:and|not|or)\b/
	      ],
	      'c-style-function': {
	        pattern: /\b[a-z_]\w*(?=\s*\()/i,
	        alias: 'function'
	      },
	      punctuation: /::|[()\[\]{},:;]|\.(?=\s*[\[\w$])/,
	      dot: {
	        pattern: /\./,
	        alias: 'important'
	      }
	    });
	    stringInterpolation.interpolation.inside.content.inside = jq;
	  })(Prism);
	}
	return jq_1;
}

var jsExtras_1;
var hasRequiredJsExtras;

function requireJsExtras () {
	if (hasRequiredJsExtras) return jsExtras_1;
	hasRequiredJsExtras = 1;

	jsExtras_1 = jsExtras;
	jsExtras.displayName = 'jsExtras';
	jsExtras.aliases = [];
	function jsExtras(Prism) {
(function (Prism) {
	    Prism.languages.insertBefore('javascript', 'function-variable', {
	      'method-variable': {
	        pattern: RegExp(
	          '(\\.\\s*)' +
	            Prism.languages.javascript['function-variable'].pattern.source
	        ),
	        lookbehind: true,
	        alias: ['function-variable', 'method', 'function', 'property-access']
	      }
	    });
	    Prism.languages.insertBefore('javascript', 'function', {
	      method: {
	        pattern: RegExp(
	          '(\\.\\s*)' + Prism.languages.javascript['function'].source
	        ),
	        lookbehind: true,
	        alias: ['function', 'property-access']
	      }
	    });
	    Prism.languages.insertBefore('javascript', 'constant', {
	      'known-class-name': [
	        {
	          // standard built-ins
	          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
	          pattern:
	            /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
	          alias: 'class-name'
	        },
	        {
	          // errors
	          pattern: /\b(?:[A-Z]\w*)Error\b/,
	          alias: 'class-name'
	        }
	      ]
	    });
	    /**
	     * Replaces the `<ID>` placeholder in the given pattern with a pattern for general JS identifiers.
	     *
	     * @param {string} source
	     * @param {string} [flags]
	     * @returns {RegExp}
	     */
	    function withId(source, flags) {
	      return RegExp(
	        source.replace(/<ID>/g, function () {
	          return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source
	        }),
	        flags
	      )
	    }
	    Prism.languages.insertBefore('javascript', 'keyword', {
	      imports: {
	        // https://tc39.es/ecma262/#sec-imports
	        pattern: withId(
	          /(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/
	            .source
	        ),
	        lookbehind: true,
	        inside: Prism.languages.javascript
	      },
	      exports: {
	        // https://tc39.es/ecma262/#sec-exports
	        pattern: withId(
	          /(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/
	            .source
	        ),
	        lookbehind: true,
	        inside: Prism.languages.javascript
	      }
	    });
	    Prism.languages.javascript['keyword'].unshift(
	      {
	        pattern: /\b(?:as|default|export|from|import)\b/,
	        alias: 'module'
	      },
	      {
	        pattern:
	          /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
	        alias: 'control-flow'
	      },
	      {
	        pattern: /\bnull\b/,
	        alias: ['null', 'nil']
	      },
	      {
	        pattern: /\bundefined\b/,
	        alias: 'nil'
	      }
	    );
	    Prism.languages.insertBefore('javascript', 'operator', {
	      spread: {
	        pattern: /\.{3}/,
	        alias: 'operator'
	      },
	      arrow: {
	        pattern: /=>/,
	        alias: 'operator'
	      }
	    });
	    Prism.languages.insertBefore('javascript', 'punctuation', {
	      'property-access': {
	        pattern: withId(/(\.\s*)#?<ID>/.source),
	        lookbehind: true
	      },
	      'maybe-class-name': {
	        pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
	        lookbehind: true
	      },
	      dom: {
	        // this contains only a few commonly used DOM variables
	        pattern:
	          /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
	        alias: 'variable'
	      },
	      console: {
	        pattern: /\bconsole(?=\s*\.)/,
	        alias: 'class-name'
	      }
	    }); // add 'maybe-class-name' to tokens which might be a class name
	    var maybeClassNameTokens = [
	      'function',
	      'function-variable',
	      'method',
	      'method-variable',
	      'property-access'
	    ];
	    for (var i = 0; i < maybeClassNameTokens.length; i++) {
	      var token = maybeClassNameTokens[i];
	      var value = Prism.languages.javascript[token]; // convert regex to object
	      if (Prism.util.type(value) === 'RegExp') {
	        value = Prism.languages.javascript[token] = {
	          pattern: value
	        };
	      } // keep in mind that we don't support arrays
	      var inside = value.inside || {};
	      value.inside = inside;
	      inside['maybe-class-name'] = /^[A-Z][\s\S]*/;
	    }
	  })(Prism);
	}
	return jsExtras_1;
}

var jsTemplates_1;
var hasRequiredJsTemplates;

function requireJsTemplates () {
	if (hasRequiredJsTemplates) return jsTemplates_1;
	hasRequiredJsTemplates = 1;

	jsTemplates_1 = jsTemplates;
	jsTemplates.displayName = 'jsTemplates';
	jsTemplates.aliases = [];
	function jsTemplates(Prism) {
(function (Prism) {
	    var templateString = Prism.languages.javascript['template-string']; // see the pattern in prism-javascript.js
	    var templateLiteralPattern = templateString.pattern.source;
	    var interpolationObject = templateString.inside['interpolation'];
	    var interpolationPunctuationObject =
	      interpolationObject.inside['interpolation-punctuation'];
	    var interpolationPattern = interpolationObject.pattern.source;
	    /**
	     * Creates a new pattern to match a template string with a special tag.
	     *
	     * This will return `undefined` if there is no grammar with the given language id.
	     *
	     * @param {string} language The language id of the embedded language. E.g. `markdown`.
	     * @param {string} tag The regex pattern to match the tag.
	     * @returns {object | undefined}
	     * @example
	     * createTemplate('css', /\bcss/.source);
	     */
	    function createTemplate(language, tag) {
	      if (!Prism.languages[language]) {
	        return undefined
	      }
	      return {
	        pattern: RegExp('((?:' + tag + ')\\s*)' + templateLiteralPattern),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          'template-punctuation': {
	            pattern: /^`|`$/,
	            alias: 'string'
	          },
	          'embedded-code': {
	            pattern: /[\s\S]+/,
	            alias: language
	          }
	        }
	      }
	    }
	    Prism.languages.javascript['template-string'] = [
	      // styled-jsx:
	      //   css`a { color: #25F; }`
	      // styled-components:
	      //   styled.h1`color: red;`
	      createTemplate(
	        'css',
	        /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/
	          .source
	      ), // html`<p></p>`
	      // div.innerHTML = `<p></p>`
	      createTemplate('html', /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source), // svg`<path fill="#fff" d="M55.37 ..."/>`
	      createTemplate('svg', /\bsvg/.source), // md`# h1`, markdown`## h2`
	      createTemplate('markdown', /\b(?:markdown|md)/.source), // gql`...`, graphql`...`, graphql.experimental`...`
	      createTemplate(
	        'graphql',
	        /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source
	      ), // sql`...`
	      createTemplate('sql', /\bsql/.source), // vanilla template string
	      templateString
	    ].filter(Boolean);
	    /**
	     * Returns a specific placeholder literal for the given language.
	     *
	     * @param {number} counter
	     * @param {string} language
	     * @returns {string}
	     */
	    function getPlaceholder(counter, language) {
	      return '___' + language.toUpperCase() + '_' + counter + '___'
	    }
	    /**
	     * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.
	     *
	     * @param {string} code
	     * @param {any} grammar
	     * @param {string} language
	     * @returns {(string|Token)[]}
	     */
	    function tokenizeWithHooks(code, grammar, language) {
	      var env = {
	        code: code,
	        grammar: grammar,
	        language: language
	      };
	      Prism.hooks.run('before-tokenize', env);
	      env.tokens = Prism.tokenize(env.code, env.grammar);
	      Prism.hooks.run('after-tokenize', env);
	      return env.tokens
	    }
	    /**
	     * Returns the token of the given JavaScript interpolation expression.
	     *
	     * @param {string} expression The code of the expression. E.g. `"${42}"`
	     * @returns {Token}
	     */
	    function tokenizeInterpolationExpression(expression) {
	      var tempGrammar = {};
	      tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;
	      /** @type {Array} */
	      var tokens = Prism.tokenize(expression, tempGrammar);
	      if (tokens.length === 3) {
	        /**
	         * The token array will look like this
	         * [
	         *     ["interpolation-punctuation", "${"]
	         *     "..." // JavaScript expression of the interpolation
	         *     ["interpolation-punctuation", "}"]
	         * ]
	         */
	        var args = [1, 1];
	        args.push.apply(
	          args,
	          tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript')
	        );
	        tokens.splice.apply(tokens, args);
	      }
	      return new Prism.Token(
	        'interpolation',
	        tokens,
	        interpolationObject.alias,
	        expression
	      )
	    }
	    /**
	     * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.
	     *
	     * This function has 3 phases:
	     *
	     * 1. Replace all JavaScript interpolation expression with a placeholder.
	     *    The placeholder will have the syntax of a identify of the target language.
	     * 2. Tokenize the code with placeholders.
	     * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.
	     *    The insertion only works if a placeholder hasn't been "ripped apart" meaning that the placeholder has been
	     *    tokenized as two tokens by the grammar of the embedded language.
	     *
	     * @param {string} code
	     * @param {object} grammar
	     * @param {string} language
	     * @returns {Token}
	     */
	    function tokenizeEmbedded(code, grammar, language) {
	      // 1. First filter out all interpolations
	      // because they might be escaped, we need a lookbehind, so we use Prism
	      /** @type {(Token|string)[]} */
	      var _tokens = Prism.tokenize(code, {
	        interpolation: {
	          pattern: RegExp(interpolationPattern),
	          lookbehind: true
	        }
	      }); // replace all interpolations with a placeholder which is not in the code already
	      var placeholderCounter = 0;
	      /** @type {Object<string, string>} */
	      var placeholderMap = {};
	      var embeddedCode = _tokens
	        .map(function (token) {
	          if (typeof token === 'string') {
	            return token
	          } else {
	            var interpolationExpression = token.content;
	            var placeholder;
	            while (
	              code.indexOf(
	                (placeholder = getPlaceholder(placeholderCounter++, language))
	              ) !== -1
	            ) {
	              /* noop */
	            }
	            placeholderMap[placeholder] = interpolationExpression;
	            return placeholder
	          }
	        })
	        .join(''); // 2. Tokenize the embedded code
	      var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language); // 3. Re-insert the interpolation
	      var placeholders = Object.keys(placeholderMap);
	      placeholderCounter = 0;
	      /**
	       *
	       * @param {(Token|string)[]} tokens
	       * @returns {void}
	       */
	      function walkTokens(tokens) {
	        for (var i = 0; i < tokens.length; i++) {
	          if (placeholderCounter >= placeholders.length) {
	            return
	          }
	          var token = tokens[i];
	          if (typeof token === 'string' || typeof token.content === 'string') {
	            var placeholder = placeholders[placeholderCounter];
	            var s =
	              typeof token === 'string'
	                ? token
	                : /** @type {string} */
	                  token.content;
	            var index = s.indexOf(placeholder);
	            if (index !== -1) {
	              ++placeholderCounter;
	              var before = s.substring(0, index);
	              var middle = tokenizeInterpolationExpression(
	                placeholderMap[placeholder]
	              );
	              var after = s.substring(index + placeholder.length);
	              var replacement = [];
	              if (before) {
	                replacement.push(before);
	              }
	              replacement.push(middle);
	              if (after) {
	                var afterTokens = [after];
	                walkTokens(afterTokens);
	                replacement.push.apply(replacement, afterTokens);
	              }
	              if (typeof token === 'string') {
	                tokens.splice.apply(tokens, [i, 1].concat(replacement));
	                i += replacement.length - 1;
	              } else {
	                token.content = replacement;
	              }
	            }
	          } else {
	            var content = token.content;
	            if (Array.isArray(content)) {
	              walkTokens(content);
	            } else {
	              walkTokens([content]);
	            }
	          }
	        }
	      }
	      walkTokens(embeddedTokens);
	      return new Prism.Token(
	        language,
	        embeddedTokens,
	        'language-' + language,
	        code
	      )
	    }
	    /**
	     * The languages for which JS templating will handle tagged template literals.
	     *
	     * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.
	     */
	    var supportedLanguages = {
	      javascript: true,
	      js: true,
	      typescript: true,
	      ts: true,
	      jsx: true,
	      tsx: true
	    };
	    Prism.hooks.add('after-tokenize', function (env) {
	      if (!(env.language in supportedLanguages)) {
	        return
	      }
	      /**
	       * Finds and tokenizes all template strings with an embedded languages.
	       *
	       * @param {(Token | string)[]} tokens
	       * @returns {void}
	       */
	      function findTemplateStrings(tokens) {
	        for (var i = 0, l = tokens.length; i < l; i++) {
	          var token = tokens[i];
	          if (typeof token === 'string') {
	            continue
	          }
	          var content = token.content;
	          if (!Array.isArray(content)) {
	            if (typeof content !== 'string') {
	              findTemplateStrings([content]);
	            }
	            continue
	          }
	          if (token.type === 'template-string') {
	            /**
	             * A JavaScript template-string token will look like this:
	             *
	             * ["template-string", [
	             *     ["template-punctuation", "`"],
	             *     (
	             *         An array of "string" and "interpolation" tokens. This is the simple string case.
	             *         or
	             *         ["embedded-code", "..."] This is the token containing the embedded code.
	             *                                  It also has an alias which is the language of the embedded code.
	             *     ),
	             *     ["template-punctuation", "`"]
	             * ]]
	             */
	            var embedded = content[1];
	            if (
	              content.length === 3 &&
	              typeof embedded !== 'string' &&
	              embedded.type === 'embedded-code'
	            ) {
	              // get string content
	              var code = stringContent(embedded);
	              var alias = embedded.alias;
	              var language = Array.isArray(alias) ? alias[0] : alias;
	              var grammar = Prism.languages[language];
	              if (!grammar) {
	                // the embedded language isn't registered.
	                continue
	              }
	              content[1] = tokenizeEmbedded(code, grammar, language);
	            }
	          } else {
	            findTemplateStrings(content);
	          }
	        }
	      }
	      findTemplateStrings(env.tokens);
	    });
	    /**
	     * Returns the string content of a token or token stream.
	     *
	     * @param {string | Token | (string | Token)[]} value
	     * @returns {string}
	     */
	    function stringContent(value) {
	      if (typeof value === 'string') {
	        return value
	      } else if (Array.isArray(value)) {
	        return value.map(stringContent).join('')
	      } else {
	        return stringContent(value.content)
	      }
	    }
	  })(Prism);
	}
	return jsTemplates_1;
}

var typescript_1;
var hasRequiredTypescript;

function requireTypescript () {
	if (hasRequiredTypescript) return typescript_1;
	hasRequiredTypescript = 1;

	typescript_1 = typescript;
	typescript.displayName = 'typescript';
	typescript.aliases = ['ts'];
	function typescript(Prism) {
(function (Prism) {
	    Prism.languages.typescript = Prism.languages.extend('javascript', {
	      'class-name': {
	        pattern:
	          /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
	        lookbehind: true,
	        greedy: true,
	        inside: null // see below
	      },
	      builtin:
	        /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
	    }); // The keywords TypeScript adds to JavaScript
	    Prism.languages.typescript.keyword.push(
	      /\b(?:abstract|declare|is|keyof|readonly|require)\b/, // keywords that have to be followed by an identifier
	      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, // This is for `import type *, {}`
	      /\btype\b(?=\s*(?:[\{*]|$))/
	    ); // doesn't work with TS because TS is too complex
	    delete Prism.languages.typescript['parameter'];
	    delete Prism.languages.typescript['literal-property']; // a version of typescript specifically for highlighting types
	    var typeInside = Prism.languages.extend('typescript', {});
	    delete typeInside['class-name'];
	    Prism.languages.typescript['class-name'].inside = typeInside;
	    Prism.languages.insertBefore('typescript', 'function', {
	      decorator: {
	        pattern: /@[$\w\xA0-\uFFFF]+/,
	        inside: {
	          at: {
	            pattern: /^@/,
	            alias: 'operator'
	          },
	          function: /^[\s\S]+/
	        }
	      },
	      'generic-function': {
	        // e.g. foo<T extends "bar" | "baz">( ...
	        pattern:
	          /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
	        greedy: true,
	        inside: {
	          function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
	          generic: {
	            pattern: /<[\s\S]+/,
	            // everything after the first <
	            alias: 'class-name',
	            inside: typeInside
	          }
	        }
	      }
	    });
	    Prism.languages.ts = Prism.languages.typescript;
	  })(Prism);
	}
	return typescript_1;
}

var jsdoc_1;
var hasRequiredJsdoc;

function requireJsdoc () {
	if (hasRequiredJsdoc) return jsdoc_1;
	hasRequiredJsdoc = 1;
	var refractorJavadoclike = requireJavadoclike();
	var refractorTypescript = requireTypescript();
	jsdoc_1 = jsdoc;
	jsdoc.displayName = 'jsdoc';
	jsdoc.aliases = [];
	function jsdoc(Prism) {
	  Prism.register(refractorJavadoclike);
	  Prism.register(refractorTypescript)
	  ;(function (Prism) {
	    var javascript = Prism.languages.javascript;
	    var type = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source;
	    var parameterPrefix =
	      '(@(?:arg|argument|param|property)\\s+(?:' + type + '\\s+)?)';
	    Prism.languages.jsdoc = Prism.languages.extend('javadoclike', {
	      parameter: {
	        // @param {string} foo - foo bar
	        pattern: RegExp(
	          parameterPrefix + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source
	        ),
	        lookbehind: true,
	        inside: {
	          punctuation: /\./
	        }
	      }
	    });
	    Prism.languages.insertBefore('jsdoc', 'keyword', {
	      'optional-parameter': {
	        // @param {string} [baz.foo="bar"] foo bar
	        pattern: RegExp(
	          parameterPrefix +
	            /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source
	        ),
	        lookbehind: true,
	        inside: {
	          parameter: {
	            pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/,
	            lookbehind: true,
	            inside: {
	              punctuation: /\./
	            }
	          },
	          code: {
	            pattern: /(=)[\s\S]*(?=\]$)/,
	            lookbehind: true,
	            inside: javascript,
	            alias: 'language-javascript'
	          },
	          punctuation: /[=[\]]/
	        }
	      },
	      'class-name': [
	        {
	          pattern: RegExp(
	            /(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(
	              /<TYPE>/g,
	              function () {
	                return type
	              }
	            )
	          ),
	          lookbehind: true,
	          inside: {
	            punctuation: /\./
	          }
	        },
	        {
	          pattern: RegExp('(@[a-z]+\\s+)' + type),
	          lookbehind: true,
	          inside: {
	            string: javascript.string,
	            number: javascript.number,
	            boolean: javascript.boolean,
	            keyword: Prism.languages.typescript.keyword,
	            operator: /=>|\.\.\.|[&|?:*]/,
	            punctuation: /[.,;=<>{}()[\]]/
	          }
	        }
	      ],
	      example: {
	        pattern:
	          /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/,
	        lookbehind: true,
	        inside: {
	          code: {
	            pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m,
	            lookbehind: true,
	            inside: javascript,
	            alias: 'language-javascript'
	          }
	        }
	      }
	    });
	    Prism.languages.javadoclike.addSupport('javascript', Prism.languages.jsdoc);
	  })(Prism);
	}
	return jsdoc_1;
}

var json_1;
var hasRequiredJson;

function requireJson () {
	if (hasRequiredJson) return json_1;
	hasRequiredJson = 1;

	json_1 = json;
	json.displayName = 'json';
	json.aliases = ['webmanifest'];
	function json(Prism) {
	  // https://www.json.org/json-en.html
	  Prism.languages.json = {
	    property: {
	      pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
	      lookbehind: true,
	      greedy: true
	    },
	    string: {
	      pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
	      lookbehind: true,
	      greedy: true
	    },
	    comment: {
	      pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
	      greedy: true
	    },
	    number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
	    punctuation: /[{}[\],]/,
	    operator: /:/,
	    boolean: /\b(?:false|true)\b/,
	    null: {
	      pattern: /\bnull\b/,
	      alias: 'keyword'
	    }
	  };
	  Prism.languages.webmanifest = Prism.languages.json;
	}
	return json_1;
}

var json5_1;
var hasRequiredJson5;

function requireJson5 () {
	if (hasRequiredJson5) return json5_1;
	hasRequiredJson5 = 1;
	var refractorJson = requireJson();
	json5_1 = json5;
	json5.displayName = 'json5';
	json5.aliases = [];
	function json5(Prism) {
	  Prism.register(refractorJson)
	  ;(function (Prism) {
	    var string = /("|')(?:\\(?:\r\n?|\n|.)|(?!\1)[^\\\r\n])*\1/;
	    Prism.languages.json5 = Prism.languages.extend('json', {
	      property: [
	        {
	          pattern: RegExp(string.source + '(?=\\s*:)'),
	          greedy: true
	        },
	        {
	          pattern:
	            /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/,
	          alias: 'unquoted'
	        }
	      ],
	      string: {
	        pattern: string,
	        greedy: true
	      },
	      number:
	        /[+-]?\b(?:NaN|Infinity|0x[a-fA-F\d]+)\b|[+-]?(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+\b)?/
	    });
	  })(Prism);
	}
	return json5_1;
}

var jsonp_1;
var hasRequiredJsonp;

function requireJsonp () {
	if (hasRequiredJsonp) return jsonp_1;
	hasRequiredJsonp = 1;
	var refractorJson = requireJson();
	jsonp_1 = jsonp;
	jsonp.displayName = 'jsonp';
	jsonp.aliases = [];
	function jsonp(Prism) {
	  Prism.register(refractorJson);
	  Prism.languages.jsonp = Prism.languages.extend('json', {
	    punctuation: /[{}[\]();,.]/
	  });
	  Prism.languages.insertBefore('jsonp', 'punctuation', {
	    function: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*\()/
	  });
	}
	return jsonp_1;
}

var jsstacktrace_1;
var hasRequiredJsstacktrace;

function requireJsstacktrace () {
	if (hasRequiredJsstacktrace) return jsstacktrace_1;
	hasRequiredJsstacktrace = 1;

	jsstacktrace_1 = jsstacktrace;
	jsstacktrace.displayName = 'jsstacktrace';
	jsstacktrace.aliases = [];
	function jsstacktrace(Prism) {
	  Prism.languages.jsstacktrace = {
	    'error-message': {
	      pattern: /^\S.*/m,
	      alias: 'string'
	    },
	    'stack-frame': {
	      pattern: /(^[ \t]+)at[ \t].*/m,
	      lookbehind: true,
	      inside: {
	        'not-my-code': {
	          pattern:
	            /^at[ \t]+(?!\s)(?:node\.js|<unknown>|.*(?:node_modules|\(<anonymous>\)|\(<unknown>|<anonymous>$|\(internal\/|\(node\.js)).*/m,
	          alias: 'comment'
	        },
	        filename: {
	          pattern: /(\bat\s+(?!\s)|\()(?:[a-zA-Z]:)?[^():]+(?=:)/,
	          lookbehind: true,
	          alias: 'url'
	        },
	        function: {
	          pattern:
	            /(\bat\s+(?:new\s+)?)(?!\s)[_$a-zA-Z\xA0-\uFFFF<][.$\w\xA0-\uFFFF<>]*/,
	          lookbehind: true,
	          inside: {
	            punctuation: /\./
	          }
	        },
	        punctuation: /[()]/,
	        keyword: /\b(?:at|new)\b/,
	        alias: {
	          pattern: /\[(?:as\s+)?(?!\s)[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\]/,
	          alias: 'variable'
	        },
	        'line-number': {
	          pattern: /:\d+(?::\d+)?\b/,
	          alias: 'number',
	          inside: {
	            punctuation: /:/
	          }
	        }
	      }
	    }
	  };
	}
	return jsstacktrace_1;
}

var jsx_1;
var hasRequiredJsx;

function requireJsx () {
	if (hasRequiredJsx) return jsx_1;
	hasRequiredJsx = 1;

	jsx_1 = jsx;
	jsx.displayName = 'jsx';
	jsx.aliases = [];
	function jsx(Prism) {
(function (Prism) {
	    var javascript = Prism.util.clone(Prism.languages.javascript);
	    var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
	    var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
	    var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
	    /**
	     * @param {string} source
	     * @param {string} [flags]
	     */
	    function re(source, flags) {
	      source = source
	        .replace(/<S>/g, function () {
	          return space
	        })
	        .replace(/<BRACES>/g, function () {
	          return braces
	        })
	        .replace(/<SPREAD>/g, function () {
	          return spread
	        });
	      return RegExp(source, flags)
	    }
	    spread = re(spread).source;
	    Prism.languages.jsx = Prism.languages.extend('markup', javascript);
	    Prism.languages.jsx.tag.pattern = re(
	      /<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/
	        .source
	    );
	    Prism.languages.jsx.tag.inside['tag'].pattern = /^<\/?[^\s>\/]*/;
	    Prism.languages.jsx.tag.inside['attr-value'].pattern =
	      /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
	    Prism.languages.jsx.tag.inside['tag'].inside['class-name'] =
	      /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
	    Prism.languages.jsx.tag.inside['comment'] = javascript['comment'];
	    Prism.languages.insertBefore(
	      'inside',
	      'attr-name',
	      {
	        spread: {
	          pattern: re(/<SPREAD>/.source),
	          inside: Prism.languages.jsx
	        }
	      },
	      Prism.languages.jsx.tag
	    );
	    Prism.languages.insertBefore(
	      'inside',
	      'special-attr',
	      {
	        script: {
	          // Allow for two levels of nesting
	          pattern: re(/=<BRACES>/.source),
	          alias: 'language-javascript',
	          inside: {
	            'script-punctuation': {
	              pattern: /^=(?=\{)/,
	              alias: 'punctuation'
	            },
	            rest: Prism.languages.jsx
	          }
	        }
	      },
	      Prism.languages.jsx.tag
	    ); // The following will handle plain text inside tags
	    var stringifyToken = function (token) {
	      if (!token) {
	        return ''
	      }
	      if (typeof token === 'string') {
	        return token
	      }
	      if (typeof token.content === 'string') {
	        return token.content
	      }
	      return token.content.map(stringifyToken).join('')
	    };
	    var walkTokens = function (tokens) {
	      var openedTags = [];
	      for (var i = 0; i < tokens.length; i++) {
	        var token = tokens[i];
	        var notTagNorBrace = false;
	        if (typeof token !== 'string') {
	          if (
	            token.type === 'tag' &&
	            token.content[0] &&
	            token.content[0].type === 'tag'
	          ) {
	            // We found a tag, now find its kind
	            if (token.content[0].content[0].content === '</') {
	              // Closing tag
	              if (
	                openedTags.length > 0 &&
	                openedTags[openedTags.length - 1].tagName ===
	                  stringifyToken(token.content[0].content[1])
	              ) {
	                // Pop matching opening tag
	                openedTags.pop();
	              }
	            } else {
	              if (token.content[token.content.length - 1].content === '/>') ; else {
	                // Opening tag
	                openedTags.push({
	                  tagName: stringifyToken(token.content[0].content[1]),
	                  openedBraces: 0
	                });
	              }
	            }
	          } else if (
	            openedTags.length > 0 &&
	            token.type === 'punctuation' &&
	            token.content === '{'
	          ) {
	            // Here we might have entered a JSX context inside a tag
	            openedTags[openedTags.length - 1].openedBraces++;
	          } else if (
	            openedTags.length > 0 &&
	            openedTags[openedTags.length - 1].openedBraces > 0 &&
	            token.type === 'punctuation' &&
	            token.content === '}'
	          ) {
	            // Here we might have left a JSX context inside a tag
	            openedTags[openedTags.length - 1].openedBraces--;
	          } else {
	            notTagNorBrace = true;
	          }
	        }
	        if (notTagNorBrace || typeof token === 'string') {
	          if (
	            openedTags.length > 0 &&
	            openedTags[openedTags.length - 1].openedBraces === 0
	          ) {
	            // Here we are inside a tag, and not inside a JSX context.
	            // That's plain text: drop any tokens matched.
	            var plainText = stringifyToken(token); // And merge text with adjacent text
	            if (
	              i < tokens.length - 1 &&
	              (typeof tokens[i + 1] === 'string' ||
	                tokens[i + 1].type === 'plain-text')
	            ) {
	              plainText += stringifyToken(tokens[i + 1]);
	              tokens.splice(i + 1, 1);
	            }
	            if (
	              i > 0 &&
	              (typeof tokens[i - 1] === 'string' ||
	                tokens[i - 1].type === 'plain-text')
	            ) {
	              plainText = stringifyToken(tokens[i - 1]) + plainText;
	              tokens.splice(i - 1, 1);
	              i--;
	            }
	            tokens[i] = new Prism.Token(
	              'plain-text',
	              plainText,
	              null,
	              plainText
	            );
	          }
	        }
	        if (token.content && typeof token.content !== 'string') {
	          walkTokens(token.content);
	        }
	      }
	    };
	    Prism.hooks.add('after-tokenize', function (env) {
	      if (env.language !== 'jsx' && env.language !== 'tsx') {
	        return
	      }
	      walkTokens(env.tokens);
	    });
	  })(Prism);
	}
	return jsx_1;
}

var julia_1;
var hasRequiredJulia;

function requireJulia () {
	if (hasRequiredJulia) return julia_1;
	hasRequiredJulia = 1;

	julia_1 = julia;
	julia.displayName = 'julia';
	julia.aliases = [];
	function julia(Prism) {
	  Prism.languages.julia = {
	    comment: {
	      // support one level of nested comments
	      // https://github.com/JuliaLang/julia/pull/6128
	      pattern:
	        /(^|[^\\])(?:#=(?:[^#=]|=(?!#)|#(?!=)|#=(?:[^#=]|=(?!#)|#(?!=))*=#)*=#|#.*)/,
	      lookbehind: true
	    },
	    regex: {
	      // https://docs.julialang.org/en/v1/manual/strings/#Regular-Expressions-1
	      pattern: /r"(?:\\.|[^"\\\r\n])*"[imsx]{0,4}/,
	      greedy: true
	    },
	    string: {
	      // https://docs.julialang.org/en/v1/manual/strings/#String-Basics-1
	      // https://docs.julialang.org/en/v1/manual/strings/#non-standard-string-literals-1
	      // https://docs.julialang.org/en/v1/manual/running-external-programs/#Running-External-Programs-1
	      pattern:
	        /"""[\s\S]+?"""|(?:\b\w+)?"(?:\\.|[^"\\\r\n])*"|`(?:[^\\`\r\n]|\\.)*`/,
	      greedy: true
	    },
	    char: {
	      // https://docs.julialang.org/en/v1/manual/strings/#man-characters-1
	      pattern: /(^|[^\w'])'(?:\\[^\r\n][^'\r\n]*|[^\\\r\n])'/,
	      lookbehind: true,
	      greedy: true
	    },
	    keyword:
	      /\b(?:abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|in|let|local|macro|module|print|println|quote|return|struct|try|type|typealias|using|while)\b/,
	    boolean: /\b(?:false|true)\b/,
	    number:
	      /(?:\b(?=\d)|\B(?=\.))(?:0[box])?(?:[\da-f]+(?:_[\da-f]+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[efp][+-]?\d+(?:_\d+)*)?j?/i,
	    // https://docs.julialang.org/en/v1/manual/mathematical-operations/
	    // https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity-1
	    operator:
	      /&&|\|\||[-+*^%÷⊻&$\\]=?|\/[\/=]?|!=?=?|\|[=>]?|<(?:<=?|[=:|])?|>(?:=|>>?=?)?|==?=?|[~≠≤≥'√∛]/,
	    punctuation: /::?|[{}[\]();,.?]/,
	    // https://docs.julialang.org/en/v1/base/numbers/#Base.im
	    constant: /\b(?:(?:Inf|NaN)(?:16|32|64)?|im|pi)\b|[πℯ]/
	  };
	}
	return julia_1;
}

var keepalived_1;
var hasRequiredKeepalived;

function requireKeepalived () {
	if (hasRequiredKeepalived) return keepalived_1;
	hasRequiredKeepalived = 1;

	keepalived_1 = keepalived;
	keepalived.displayName = 'keepalived';
	keepalived.aliases = [];
	function keepalived(Prism) {
	  Prism.languages.keepalived = {
	    comment: {
	      pattern: /[#!].*/,
	      greedy: true
	    },
	    string: {
	      pattern:
	        /(^|[^\\])(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/,
	      lookbehind: true,
	      greedy: true
	    },
	    // support IPv4, IPv6, subnet mask
	    ip: {
	      pattern: RegExp(
	        /\b(?:(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){5}:(?:[\da-f]{1,4}:)?[\da-f]{1,4}|(?:[\da-f]{1,4}:){4}:(?:[\da-f]{1,4}:){0,2}[\da-f]{1,4}|(?:[\da-f]{1,4}:){3}:(?:[\da-f]{1,4}:){0,3}[\da-f]{1,4}|(?:[\da-f]{1,4}:){2}:(?:[\da-f]{1,4}:){0,4}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}<ipv4>|(?:[\da-f]{1,4}:){0,5}:<ipv4>|::(?:[\da-f]{1,4}:){0,5}<ipv4>|[\da-f]{1,4}::(?:[\da-f]{1,4}:){0,5}[\da-f]{1,4}|::(?:[\da-f]{1,4}:){0,6}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:)(?:\/\d{1,3})?|<ipv4>(?:\/\d{1,2})?)\b/.source.replace(
	          /<ipv4>/g,
	          function () {
	            return /(?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d))/
	              .source
	          }
	        ),
	        'i'
	      ),
	      alias: 'number'
	    },
	    // support *nix / Windows, directory / file
	    path: {
	      pattern:
	        /(\s)\/(?:[^\/\s]+\/)*[^\/\s]*|\b[a-zA-Z]:\\(?:[^\\\s]+\\)*[^\\\s]*/,
	      lookbehind: true,
	      alias: 'string'
	    },
	    variable: /\$\{?\w+\}?/,
	    email: {
	      pattern: /[\w-]+@[\w-]+(?:\.[\w-]{2,3}){1,2}/,
	      alias: 'string'
	    },
	    'conditional-configuration': {
	      pattern: /@\^?[\w-]+/,
	      alias: 'variable'
	    },
	    operator: /=/,
	    property:
	      /\b(?:BFD_CHECK|DNS_CHECK|FILE_CHECK|HTTP_GET|MISC_CHECK|NAME|PING_CHECK|SCRIPTS|SMTP_CHECK|SSL|SSL_GET|TCP_CHECK|UDP_CHECK|accept|advert_int|alpha|auth_pass|auth_type|authentication|bfd_cpu_affinity|bfd_instance|bfd_no_swap|bfd_priority|bfd_process_name|bfd_rlimit_rttime|bfd_rt_priority|bind_if|bind_port|bindto|ca|certificate|check_unicast_src|checker|checker_cpu_affinity|checker_log_all_failures|checker_no_swap|checker_priority|checker_rlimit_rttime|checker_rt_priority|child_wait_time|connect_ip|connect_port|connect_timeout|dbus_service_name|debug|default_interface|delay|delay_before_retry|delay_loop|digest|dont_track_primary|dynamic|dynamic_interfaces|enable_(?:dbus|script_security|sni|snmp_checker|snmp_rfc|snmp_rfcv2|snmp_rfcv3|snmp_vrrp|traps)|end|fall|fast_recovery|file|flag-[123]|fork_delay|full_command|fwmark|garp_group|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|global_defs|global_tracking|gna_interval|group|ha_suspend|hashed|helo_name|higher_prio_send_advert|hoplimit|http_protocol|hysteresis|idle_tx|include|inhibit_on_failure|init_fail|init_file|instance|interface|interfaces|interval|ip_family|ipvs_process_name|keepalived.conf|kernel_rx_buf_size|key|linkbeat_interfaces|linkbeat_use_polling|log_all_failures|log_unknown_vrids|lower_prio_no_advert|lthreshold|lvs_flush|lvs_flush_onstop|lvs_method|lvs_netlink_cmd_rcv_bufs|lvs_netlink_cmd_rcv_bufs_force|lvs_netlink_monitor_rcv_bufs|lvs_netlink_monitor_rcv_bufs_force|lvs_notify_fifo|lvs_notify_fifo_script|lvs_sched|lvs_sync_daemon|max_auto_priority|max_hops|mcast_src_ip|mh-fallback|mh-port|min_auto_priority_delay|min_rx|min_tx|misc_dynamic|misc_path|misc_timeout|multiplier|name|namespace_with_ipsets|native_ipv6|neighbor_ip|net_namespace|net_namespace_ipvs|nftables|nftables_counters|nftables_ifindex|nftables_priority|no_accept|no_checker_emails|no_email_faults|nopreempt|notification_email|notification_email_from|notify|notify_backup|notify_deleted|notify_down|notify_fault|notify_fifo|notify_fifo_script|notify_master|notify_master_rx_lower_pri|notify_priority_changes|notify_stop|notify_up|old_unicast_checksum|omega|ops|param_match|passive|password|path|persistence_engine|persistence_granularity|persistence_timeout|preempt|preempt_delay|priority|process|process_monitor_rcv_bufs|process_monitor_rcv_bufs_force|process_name|process_names|promote_secondaries|protocol|proxy_arp|proxy_arp_pvlan|quorum|quorum_down|quorum_max|quorum_up|random_seed|real_server|regex|regex_max_offset|regex_min_offset|regex_no_match|regex_options|regex_stack|reload_repeat|reload_time_file|require_reply|retry|rise|router_id|rs_init_notifies|script|script_user|sh-fallback|sh-port|shutdown_script|shutdown_script_timeout|skip_check_adv_addr|smtp_alert|smtp_alert_checker|smtp_alert_vrrp|smtp_connect_timeout|smtp_helo_name|smtp_server|snmp_socket|sorry_server|sorry_server_inhibit|sorry_server_lvs_method|source_ip|start|startup_script|startup_script_timeout|state|static_ipaddress|static_routes|static_rules|status_code|step|strict_mode|sync_group_tracking_weight|terminate_delay|timeout|track_bfd|track_file|track_group|track_interface|track_process|track_script|track_src_ip|ttl|type|umask|unicast_peer|unicast_src_ip|unicast_ttl|url|use_ipvlan|use_pid_dir|use_vmac|user|uthreshold|val[123]|version|virtual_ipaddress|virtual_ipaddress_excluded|virtual_router_id|virtual_routes|virtual_rules|virtual_server|virtual_server_group|virtualhost|vmac_xmit_base|vrrp|vrrp_(?:check_unicast_src|cpu_affinity|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|gna_interval|higher_prio_send_advert|instance|ipsets|iptables|lower_prio_no_advert|mcast_group4|mcast_group6|min_garp|netlink_cmd_rcv_bufs|netlink_cmd_rcv_bufs_force|netlink_monitor_rcv_bufs|netlink_monitor_rcv_bufs_force|no_swap|notify_fifo|notify_fifo_script|notify_priority_changes|priority|process_name|rlimit_rttime|rt_priority|rx_bufs_multiplier|rx_bufs_policy|script|skip_check_adv_addr|startup_delay|strict|sync_group|track_process|version)|warmup|weight)\b/,
	    constant:
	      /\b(?:A|AAAA|AH|BACKUP|CNAME|DR|MASTER|MX|NAT|NS|PASS|SCTP|SOA|TCP|TUN|TXT|UDP|dh|fo|lblc|lblcr|lc|mh|nq|ovf|rr|sed|sh|wlc|wrr)\b/,
	    number: {
	      pattern: /(^|[^\w.-])-?\d+(?:\.\d+)?/,
	      lookbehind: true
	    },
	    boolean: /\b(?:false|no|off|on|true|yes)\b/,
	    punctuation: /[\{\}]/
	  };
	}
	return keepalived_1;
}

var keyman_1;
var hasRequiredKeyman;

function requireKeyman () {
	if (hasRequiredKeyman) return keyman_1;
	hasRequiredKeyman = 1;

	keyman_1 = keyman;
	keyman.displayName = 'keyman';
	keyman.aliases = [];
	function keyman(Prism) {
	  Prism.languages.keyman = {
	    comment: {
	      pattern: /\bc .*/i,
	      greedy: true
	    },
	    string: {
	      pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
	      greedy: true
	    },
	    'virtual-key': {
	      pattern:
	        /\[\s*(?:(?:ALT|CAPS|CTRL|LALT|LCTRL|NCAPS|RALT|RCTRL|SHIFT)\s+)*(?:[TKU]_[\w?]+|[A-E]\d\d?|"[^"\r\n]*"|'[^'\r\n]*')\s*\]/i,
	      greedy: true,
	      alias: 'function' // alias for styles
	    },
	    // https://help.keyman.com/developer/language/guide/headers
	    'header-keyword': {
	      pattern: /&\w+/,
	      alias: 'bold' // alias for styles
	    },
	    'header-statement': {
	      pattern:
	        /\b(?:bitmap|bitmaps|caps always off|caps on only|copyright|hotkey|language|layout|message|name|shift frees caps|version)\b/i,
	      alias: 'bold' // alias for styles
	    },
	    'rule-keyword': {
	      pattern:
	        /\b(?:any|baselayout|beep|call|context|deadkey|dk|if|index|layer|notany|nul|outs|platform|reset|return|save|set|store|use)\b/i,
	      alias: 'keyword'
	    },
	    'structural-keyword': {
	      pattern: /\b(?:ansi|begin|group|match|nomatch|unicode|using keys)\b/i,
	      alias: 'keyword'
	    },
	    'compile-target': {
	      pattern: /\$(?:keyman|keymanonly|keymanweb|kmfl|weaver):/i,
	      alias: 'property'
	    },
	    // U+####, x###, d### characters and numbers
	    number: /\b(?:U\+[\dA-F]+|d\d+|x[\da-f]+|\d+)\b/i,
	    operator: /[+>\\$]|\.\./,
	    punctuation: /[()=,]/
	  };
	}
	return keyman_1;
}

var kotlin_1;
var hasRequiredKotlin;

function requireKotlin () {
	if (hasRequiredKotlin) return kotlin_1;
	hasRequiredKotlin = 1;

	kotlin_1 = kotlin;
	kotlin.displayName = 'kotlin';
	kotlin.aliases = ['kt', 'kts'];
	function kotlin(Prism) {
(function (Prism) {
	    Prism.languages.kotlin = Prism.languages.extend('clike', {
	      keyword: {
	        // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
	        pattern:
	          /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
	        lookbehind: true
	      },
	      function: [
	        {
	          pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
	          greedy: true
	        },
	        {
	          pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
	          lookbehind: true,
	          greedy: true
	        }
	      ],
	      number:
	        /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
	      operator:
	        /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
	    });
	    delete Prism.languages.kotlin['class-name'];
	    var interpolationInside = {
	      'interpolation-punctuation': {
	        pattern: /^\$\{?|\}$/,
	        alias: 'punctuation'
	      },
	      expression: {
	        pattern: /[\s\S]+/,
	        inside: Prism.languages.kotlin
	      }
	    };
	    Prism.languages.insertBefore('kotlin', 'string', {
	      // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
	      'string-literal': [
	        {
	          pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
	          alias: 'multiline',
	          inside: {
	            interpolation: {
	              pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
	              inside: interpolationInside
	            },
	            string: /[\s\S]+/
	          }
	        },
	        {
	          pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
	          alias: 'singleline',
	          inside: {
	            interpolation: {
	              pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
	              lookbehind: true,
	              inside: interpolationInside
	            },
	            string: /[\s\S]+/
	          }
	        }
	      ],
	      char: {
	        // https://kotlinlang.org/spec/expressions.html#character-literals
	        pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
	        greedy: true
	      }
	    });
	    delete Prism.languages.kotlin['string'];
	    Prism.languages.insertBefore('kotlin', 'keyword', {
	      annotation: {
	        pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
	        alias: 'builtin'
	      }
	    });
	    Prism.languages.insertBefore('kotlin', 'function', {
	      label: {
	        pattern: /\b\w+@|@\w+\b/,
	        alias: 'symbol'
	      }
	    });
	    Prism.languages.kt = Prism.languages.kotlin;
	    Prism.languages.kts = Prism.languages.kotlin;
	  })(Prism);
	}
	return kotlin_1;
}

var kumir_1;
var hasRequiredKumir;

function requireKumir () {
	if (hasRequiredKumir) return kumir_1;
	hasRequiredKumir = 1;

	kumir_1 = kumir;
	kumir.displayName = 'kumir';
	kumir.aliases = ['kum'];
	function kumir(Prism) {
(function (Prism) {
	    /**
	     * Regular expression for characters that are not allowed in identifiers.
	     *
	     * @type {string}
	     */
	    var nonId = /\s\x00-\x1f\x22-\x2f\x3a-\x3f\x5b-\x5e\x60\x7b-\x7e/.source;
	    /**
	     * Surround a regular expression for IDs with patterns for non-ID sequences.
	     *
	     * @param {string} pattern A regular expression for identifiers.
	     * @param {string} [flags] The regular expression flags.
	     * @returns {RegExp} A wrapped regular expression for identifiers.
	     */
	    function wrapId(pattern, flags) {
	      return RegExp(pattern.replace(/<nonId>/g, nonId), flags)
	    }
	    Prism.languages.kumir = {
	      comment: {
	        pattern: /\|.*/
	      },
	      prolog: {
	        pattern: /#.*/,
	        greedy: true
	      },
	      string: {
	        pattern: /"[^\n\r"]*"|'[^\n\r']*'/,
	        greedy: true
	      },
	      boolean: {
	        pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),
	        lookbehind: true
	      },
	      'operator-word': {
	        pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),
	        lookbehind: true,
	        alias: 'keyword'
	      },
	      'system-variable': {
	        pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),
	        lookbehind: true,
	        alias: 'keyword'
	      },
	      type: [
	        {
	          pattern: wrapId(
	            /(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\x20*таб)?(?=[<nonId>]|$)/
	              .source
	          ),
	          lookbehind: true,
	          alias: 'builtin'
	        },
	        {
	          pattern: wrapId(
	            /(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source
	          ),
	          lookbehind: true,
	          alias: 'important'
	        }
	      ],
	      /**
	       * Should be performed after searching for type names because of "таб".
	       * "таб" is a reserved word, but never used without a preceding type name.
	       * "НАЗНАЧИТЬ", "Фввод", and "Фвывод" are not reserved words.
	       */
	      keyword: {
	        pattern: wrapId(
	          /(^|[<nonId>])(?:алг|арг(?:\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\x20+|_)исп)?|кц(?:(?:\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/
	            .source
	        ),
	        lookbehind: true
	      },
	      /** Should be performed after searching for reserved words. */
	      name: {
	        // eslint-disable-next-line regexp/no-super-linear-backtracking
	        pattern: wrapId(
	          /(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/
	            .source
	        ),
	        lookbehind: true
	      },
	      /** Should be performed after searching for names. */
	      number: {
	        pattern: wrapId(
	          /(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/
	            .source,
	          'i'
	        ),
	        lookbehind: true
	      },
	      /** Should be performed after searching for words. */
	      punctuation: /:=|[(),:;\[\]]/,
	      /**
	       * Should be performed after searching for
	       * - numeric constants (because of "+" and "-");
	       * - punctuation marks (because of ":=" and "=").
	       */
	      'operator-char': {
	        pattern: /\*\*?|<[=>]?|>=?|[-+/=]/,
	        alias: 'operator'
	      }
	    };
	    Prism.languages.kum = Prism.languages.kumir;
	  })(Prism);
	}
	return kumir_1;
}

var kusto_1;
var hasRequiredKusto;

function requireKusto () {
	if (hasRequiredKusto) return kusto_1;
	hasRequiredKusto = 1;

	kusto_1 = kusto;
	kusto.displayName = 'kusto';
	kusto.aliases = [];
	function kusto(Prism) {
	  Prism.languages.kusto = {
	    comment: {
	      pattern: /\/\/.*/,
	      greedy: true
	    },
	    string: {
	      pattern:
	        /```[\s\S]*?```|[hH]?(?:"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\.)*'|@(?:"[^\r\n"]*"|'[^\r\n']*'))/,
	      greedy: true
	    },
	    verb: {
	      pattern: /(\|\s*)[a-z][\w-]*/i,
	      lookbehind: true,
	      alias: 'keyword'
	    },
	    command: {
	      pattern: /\.[a-z][a-z\d-]*\b/,
	      alias: 'keyword'
	    },
	    'class-name':
	      /\b(?:bool|datetime|decimal|dynamic|guid|int|long|real|string|timespan)\b/,
	    keyword:
	      /\b(?:access|alias|and|anti|as|asc|auto|between|by|(?:contains|(?:ends|starts)with|has(?:perfix|suffix)?)(?:_cs)?|database|declare|desc|external|from|fullouter|has_all|in|ingestion|inline|inner|innerunique|into|(?:left|right)(?:anti(?:semi)?|inner|outer|semi)?|let|like|local|not|of|on|or|pattern|print|query_parameters|range|restrict|schema|set|step|table|tables|to|view|where|with|matches\s+regex|nulls\s+(?:first|last))(?![\w-])/,
	    boolean: /\b(?:false|null|true)\b/,
	    function: /\b[a-z_]\w*(?=\s*\()/,
	    datetime: [
	      {
	        // RFC 822 + RFC 850
	        pattern:
	          /\b(?:(?:Fri|Friday|Mon|Monday|Sat|Saturday|Sun|Sunday|Thu|Thursday|Tue|Tuesday|Wed|Wednesday)\s*,\s*)?\d{1,2}(?:\s+|-)(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)(?:\s+|-)\d{2}\s+\d{2}:\d{2}(?::\d{2})?(?:\s*(?:\b(?:[A-Z]|(?:[ECMT][DS]|GM|U)T)|[+-]\d{4}))?\b/,
	        alias: 'number'
	      },
	      {
	        // ISO 8601
	        pattern:
	          /[+-]?\b(?:\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)?|\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)Z?/,
	        alias: 'number'
	      }
	    ],
	    number:
	      /\b(?:0x[0-9A-Fa-f]+|\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)(?:(?:min|sec|[mnµ]s|[dhms]|microsecond|tick)\b)?|[+-]?\binf\b/,
	    operator: /=>|[!=]~|[!=<>]=?|[-+*/%|]|\.\./,
	    punctuation: /[()\[\]{},;.:]/
	  };
	}
	return kusto_1;
}

var latex_1;
var hasRequiredLatex;

function requireLatex () {
	if (hasRequiredLatex) return latex_1;
	hasRequiredLatex = 1;

	latex_1 = latex;
	latex.displayName = 'latex';
	latex.aliases = ['tex', 'context'];
	function latex(Prism) {
(function (Prism) {
	    var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i;
	    var insideEqu = {
	      'equation-command': {
	        pattern: funcPattern,
	        alias: 'regex'
	      }
	    };
	    Prism.languages.latex = {
	      comment: /%.*/,
	      // the verbatim environment prints whitespace to the document
	      cdata: {
	        pattern:
	          /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
	        lookbehind: true
	      },
	      /*
	       * equations can be between $$ $$ or $ $ or \( \) or \[ \]
	       * (all are multiline)
	       */
	      equation: [
	        {
	          pattern:
	            /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
	          inside: insideEqu,
	          alias: 'string'
	        },
	        {
	          pattern:
	            /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
	          lookbehind: true,
	          inside: insideEqu,
	          alias: 'string'
	        }
	      ],
	      /*
	       * arguments which are keywords or references are highlighted
	       * as keywords
	       */
	      keyword: {
	        pattern:
	          /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
	        lookbehind: true
	      },
	      url: {
	        pattern: /(\\url\{)[^}]+(?=\})/,
	        lookbehind: true
	      },
	      /*
	       * section or chapter headlines are highlighted as bold so that
	       * they stand out more
	       */
	      headline: {
	        pattern:
	          /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
	        lookbehind: true,
	        alias: 'class-name'
	      },
	      function: {
	        pattern: funcPattern,
	        alias: 'selector'
	      },
	      punctuation: /[[\]{}&]/
	    };
	    Prism.languages.tex = Prism.languages.latex;
	    Prism.languages.context = Prism.languages.latex;
	  })(Prism);
	}
	return latex_1;
}

var php_1;
var hasRequiredPhp;

function requirePhp () {
	if (hasRequiredPhp) return php_1;
	hasRequiredPhp = 1;
	var refractorMarkupTemplating = requireMarkupTemplating();
	php_1 = php;
	php.displayName = 'php';
	php.aliases = [];
	function php(Prism) {
	  Prism.register(refractorMarkupTemplating)
	  /**
	   * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/
	   * Modified by Miles Johnson: http://milesj.me
	   * Rewritten by Tom Pavelec
	   *
	   * Supports PHP 5.3 - 8.0
	   */
	  ;(function (Prism) {
	    var comment = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
	    var constant = [
	      {
	        pattern: /\b(?:false|true)\b/i,
	        alias: 'boolean'
	      },
	      {
	        pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
	        greedy: true,
	        lookbehind: true
	      },
	      {
	        pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
	        greedy: true,
	        lookbehind: true
	      },
	      /\b(?:null)\b/i,
	      /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
	    ];
	    var number =
	      /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
	    var operator =
	      /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
	    var punctuation = /[{}\[\](),:;]/;
	    Prism.languages.php = {
	      delimiter: {
	        pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
	        alias: 'important'
	      },
	      comment: comment,
	      variable: /\$+(?:\w+\b|(?=\{))/,
	      package: {
	        pattern:
	          /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
	        lookbehind: true,
	        inside: {
	          punctuation: /\\/
	        }
	      },
	      'class-name-definition': {
	        pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
	        lookbehind: true,
	        alias: 'class-name'
	      },
	      'function-definition': {
	        pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
	        lookbehind: true,
	        alias: 'function'
	      },
	      keyword: [
	        {
	          pattern:
	            /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
	          alias: 'type-casting',
	          greedy: true,
	          lookbehind: true
	        },
	        {
	          pattern:
	            /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
	          alias: 'type-hint',
	          greedy: true,
	          lookbehind: true
	        },
	        {
	          pattern:
	            /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string|void)\b/i,
	          alias: 'return-type',
	          greedy: true,
	          lookbehind: true
	        },
	        {
	          pattern:
	            /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
	          alias: 'type-declaration',
	          greedy: true
	        },
	        {
	          pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
	          alias: 'type-declaration',
	          greedy: true,
	          lookbehind: true
	        },
	        {
	          pattern: /\b(?:parent|self|static)(?=\s*::)/i,
	          alias: 'static-context',
	          greedy: true
	        },
	        {
	          // yield from
	          pattern: /(\byield\s+)from\b/i,
	          lookbehind: true
	        }, // `class` is always a keyword unlike other keywords
	        /\bclass\b/i,
	        {
	          // https://www.php.net/manual/en/reserved.keywords.php
	          //
	          // keywords cannot be preceded by "->"
	          // the complex lookbehind means `(?<!(?:->|::)\s*)`
	          pattern:
	            /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
	          lookbehind: true
	        }
	      ],
	      'argument-name': {
	        pattern: /([(,]\s+)\b[a-z_]\w*(?=\s*:(?!:))/i,
	        lookbehind: true
	      },
	      'class-name': [
	        {
	          pattern:
	            /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
	          greedy: true,
	          lookbehind: true
	        },
	        {
	          pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
	          greedy: true,
	          lookbehind: true
	        },
	        {
	          pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
	          greedy: true
	        },
	        {
	          pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
	          alias: 'class-name-fully-qualified',
	          greedy: true,
	          lookbehind: true,
	          inside: {
	            punctuation: /\\/
	          }
	        },
	        {
	          pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
	          alias: 'class-name-fully-qualified',
	          greedy: true,
	          inside: {
	            punctuation: /\\/
	          }
	        },
	        {
	          pattern:
	            /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
	          alias: 'class-name-fully-qualified',
	          greedy: true,
	          lookbehind: true,
	          inside: {
	            punctuation: /\\/
	          }
	        },
	        {
	          pattern: /\b[a-z_]\w*(?=\s*\$)/i,
	          alias: 'type-declaration',
	          greedy: true
	        },
	        {
	          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
	          alias: ['class-name-fully-qualified', 'type-declaration'],
	          greedy: true,
	          inside: {
	            punctuation: /\\/
	          }
	        },
	        {
	          pattern: /\b[a-z_]\w*(?=\s*::)/i,
	          alias: 'static-context',
	          greedy: true
	        },
	        {
	          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
	          alias: ['class-name-fully-qualified', 'static-context'],
	          greedy: true,
	          inside: {
	            punctuation: /\\/
	          }
	        },
	        {
	          pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
	          alias: 'type-hint',
	          greedy: true,
	          lookbehind: true
	        },
	        {
	          pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
	          alias: ['class-name-fully-qualified', 'type-hint'],
	          greedy: true,
	          lookbehind: true,
	          inside: {
	            punctuation: /\\/
	          }
	        },
	        {
	          pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
	          alias: 'return-type',
	          greedy: true,
	          lookbehind: true
	        },
	        {
	          pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
	          alias: ['class-name-fully-qualified', 'return-type'],
	          greedy: true,
	          lookbehind: true,
	          inside: {
	            punctuation: /\\/
	          }
	        }
	      ],
	      constant: constant,
	      function: {
	        pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
	        lookbehind: true,
	        inside: {
	          punctuation: /\\/
	        }
	      },
	      property: {
	        pattern: /(->\s*)\w+/,
	        lookbehind: true
	      },
	      number: number,
	      operator: operator,
	      punctuation: punctuation
	    };
	    var string_interpolation = {
	      pattern:
	        /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
	      lookbehind: true,
	      inside: Prism.languages.php
	    };
	    var string = [
	      {
	        pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
	        alias: 'nowdoc-string',
	        greedy: true,
	        inside: {
	          delimiter: {
	            pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
	            alias: 'symbol',
	            inside: {
	              punctuation: /^<<<'?|[';]$/
	            }
	          }
	        }
	      },
	      {
	        pattern:
	          /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
	        alias: 'heredoc-string',
	        greedy: true,
	        inside: {
	          delimiter: {
	            pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
	            alias: 'symbol',
	            inside: {
	              punctuation: /^<<<"?|[";]$/
	            }
	          },
	          interpolation: string_interpolation
	        }
	      },
	      {
	        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
	        alias: 'backtick-quoted-string',
	        greedy: true
	      },
	      {
	        pattern: /'(?:\\[\s\S]|[^\\'])*'/,
	        alias: 'single-quoted-string',
	        greedy: true
	      },
	      {
	        pattern: /"(?:\\[\s\S]|[^\\"])*"/,
	        alias: 'double-quoted-string',
	        greedy: true,
	        inside: {
	          interpolation: string_interpolation
	        }
	      }
	    ];
	    Prism.languages.insertBefore('php', 'variable', {
	      string: string,
	      attribute: {
	        pattern:
	          /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
	        greedy: true,
	        inside: {
	          'attribute-content': {
	            pattern: /^(#\[)[\s\S]+(?=\]$)/,
	            lookbehind: true,
	            // inside can appear subset of php
	            inside: {
	              comment: comment,
	              string: string,
	              'attribute-class-name': [
	                {
	                  pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
	                  alias: 'class-name',
	                  greedy: true,
	                  lookbehind: true
	                },
	                {
	                  pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
	                  alias: ['class-name', 'class-name-fully-qualified'],
	                  greedy: true,
	                  lookbehind: true,
	                  inside: {
	                    punctuation: /\\/
	                  }
	                }
	              ],
	              constant: constant,
	              number: number,
	              operator: operator,
	              punctuation: punctuation
	            }
	          },
	          delimiter: {
	            pattern: /^#\[|\]$/,
	            alias: 'punctuation'
	          }
	        }
	      }
	    });
	    Prism.hooks.add('before-tokenize', function (env) {
	      if (!/<\?/.test(env.code)) {
	        return
	      }
	      var phpPattern =
	        /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
	      Prism.languages['markup-templating'].buildPlaceholders(
	        env,
	        'php',
	        phpPattern
	      );
	    });
	    Prism.hooks.add('after-tokenize', function (env) {
	      Prism.languages['markup-templating'].tokenizePlaceholders(env, 'php');
	    });
	  })(Prism);
	}
	return php_1;
}

var latte_1;
var hasRequiredLatte;

function requireLatte () {
	if (hasRequiredLatte) return latte_1;
	hasRequiredLatte = 1;
	var refractorMarkupTemplating = requireMarkupTemplating();
	var refractorPhp = requirePhp();
	latte_1 = latte;
	latte.displayName = 'latte';
	latte.aliases = [];
	function latte(Prism) {
	  Prism.register(refractorMarkupTemplating);
	  Prism.register(refractorPhp)
	  ;(function (Prism) {
	    Prism.languages.latte = {
	      comment: /^\{\*[\s\S]*/,
	      'latte-tag': {
	        // https://latte.nette.org/en/tags
	        pattern: /(^\{(?:\/(?=[a-z]))?)(?:[=_]|[a-z]\w*\b(?!\())/i,
	        lookbehind: true,
	        alias: 'important'
	      },
	      delimiter: {
	        pattern: /^\{\/?|\}$/,
	        alias: 'punctuation'
	      },
	      php: {
	        pattern: /\S(?:[\s\S]*\S)?/,
	        alias: 'language-php',
	        inside: Prism.languages.php
	      }
	    };
	    var markupLatte = Prism.languages.extend('markup', {});
	    Prism.languages.insertBefore(
	      'inside',
	      'attr-value',
	      {
	        'n-attr': {
	          pattern: /n:[\w-]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+))?/,
	          inside: {
	            'attr-name': {
	              pattern: /^[^\s=]+/,
	              alias: 'important'
	            },
	            'attr-value': {
	              pattern: /=[\s\S]+/,
	              inside: {
	                punctuation: [
	                  /^=/,
	                  {
	                    pattern: /^(\s*)["']|["']$/,
	                    lookbehind: true
	                  }
	                ],
	                php: {
	                  pattern: /\S(?:[\s\S]*\S)?/,
	                  inside: Prism.languages.php
	                }
	              }
	            }
	          }
	        }
	      },
	      markupLatte.tag
	    );
	    Prism.hooks.add('before-tokenize', function (env) {
	      if (env.language !== 'latte') {
	        return
	      }
	      var lattePattern =
	        /\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g;
	      Prism.languages['markup-templating'].buildPlaceholders(
	        env,
	        'latte',
	        lattePattern
	      );
	      env.grammar = markupLatte;
	    });
	    Prism.hooks.add('after-tokenize', function (env) {
	      Prism.languages['markup-templating'].tokenizePlaceholders(env, 'latte');
	    });
	  })(Prism);
	}
	return latte_1;
}

var less_1;
var hasRequiredLess;

function requireLess () {
	if (hasRequiredLess) return less_1;
	hasRequiredLess = 1;

	less_1 = less;
	less.displayName = 'less';
	less.aliases = [];
	function less(Prism) {
	  /* FIXME :
	:extend() is not handled specifically : its highlighting is buggy.
	Mixin usage must be inside a ruleset to be highlighted.
	At-rules (e.g. import) containing interpolations are buggy.
	Detached rulesets are highlighted as at-rules.
	A comment before a mixin usage prevents the latter to be properly highlighted.
	*/
	  Prism.languages.less = Prism.languages.extend('css', {
	    comment: [
	      /\/\*[\s\S]*?\*\//,
	      {
	        pattern: /(^|[^\\])\/\/.*/,
	        lookbehind: true
	      }
	    ],
	    atrule: {
	      pattern:
	        /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
	      inside: {
	        punctuation: /[:()]/
	      }
	    },
	    // selectors and mixins are considered the same
	    selector: {
	      pattern:
	        /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
	      inside: {
	        // mixin parameters
	        variable: /@+[\w-]+/
	      }
	    },
	    property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
	    operator: /[+\-*\/]/
	  });
	  Prism.languages.insertBefore('less', 'property', {
	    variable: [
	      // Variable declaration (the colon must be consumed!)
	      {
	        pattern: /@[\w-]+\s*:/,
	        inside: {
	          punctuation: /:/
	        }
	      }, // Variable usage
	      /@@?[\w-]+/
	    ],
	    'mixin-usage': {
	      pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
	      lookbehind: true,
	      alias: 'function'
	    }
	  });
	}
	return less_1;
}

var scheme_1;
var hasRequiredScheme;

function requireScheme () {
	if (hasRequiredScheme) return scheme_1;
	hasRequiredScheme = 1;

	scheme_1 = scheme;
	scheme.displayName = 'scheme';
	scheme.aliases = [];
	function scheme(Prism) {
(function (Prism) {
	    Prism.languages.scheme = {
	      // this supports "normal" single-line comments:
	      //   ; comment
	      // and (potentially nested) multiline comments:
	      //   #| comment #| nested |# still comment |#
	      // (only 1 level of nesting is supported)
	      comment:
	        /;.*|#;\s*(?:\((?:[^()]|\([^()]*\))*\)|\[(?:[^\[\]]|\[[^\[\]]*\])*\])|#\|(?:[^#|]|#(?!\|)|\|(?!#)|#\|(?:[^#|]|#(?!\|)|\|(?!#))*\|#)*\|#/,
	      string: {
	        pattern: /"(?:[^"\\]|\\.)*"/,
	        greedy: true
	      },
	      symbol: {
	        pattern: /'[^()\[\]#'\s]+/,
	        greedy: true
	      },
	      char: {
	        pattern:
	          /#\\(?:[ux][a-fA-F\d]+\b|[-a-zA-Z]+\b|[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/,
	        greedy: true
	      },
	      'lambda-parameter': [
	        // https://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html#SEC30
	        {
	          pattern:
	            /((?:^|[^'`#])[(\[]lambda\s+)(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)/,
	          lookbehind: true
	        },
	        {
	          pattern: /((?:^|[^'`#])[(\[]lambda\s+[(\[])[^()\[\]']+/,
	          lookbehind: true
	        }
	      ],
	      keyword: {
	        pattern:
	          /((?:^|[^'`#])[(\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\*)?|let\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\[\]\s]|$)/,
	        lookbehind: true
	      },
	      builtin: {
	        // all functions of the base library of R7RS plus some of built-ins of R5Rs
	        pattern:
	          /((?:^|[^'`#])[(\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\?|boolean=?\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\?|\?|<\?|<=\?|=\?|>\?|>=\?)|close-(?:input-port|output-port|port)|complex\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\??|eq\?|equal\?|eqv\?|error|error-object(?:-irritants|-message|\?)|eval|even\?|exact(?:-integer-sqrt|-integer\?|\?)?|expt|features|file-error\?|floor(?:-quotient|-remainder|\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\??|input-port(?:-open\?|\?)|integer(?:->char|\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\?|newline|not|null\?|number(?:->string|\?)|numerator|odd\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\?|\?)|pair\?|peek-char|peek-u8|port\?|positive\?|procedure\?|quotient|raise|raise-continuable|rational\?|rationalize|read-(?:bytevector|bytevector!|char|error\?|line|string|u8)|real\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?|<\?|<=\?|=\?|>\?|>=\?)?|substring|symbol(?:->string|\?|=\?)|syntax-error|textual-port\?|truncate(?:-quotient|-remainder|\/)?|u8-ready\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\?)(?=[()\[\]\s]|$)/,
	        lookbehind: true
	      },
	      operator: {
	        pattern: /((?:^|[^'`#])[(\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\[\]\s]|$)/,
	        lookbehind: true
	      },
	      number: {
	        // The number pattern from [the R7RS spec](https://small.r7rs.org/attachment/r7rs.pdf).
	        //
	        // <number>      := <num 2>|<num 8>|<num 10>|<num 16>
	        // <num R>       := <prefix R><complex R>
	        // <complex R>   := <real R>(?:@<real R>|<imaginary R>)?|<imaginary R>
	        // <imaginary R> := [+-](?:<ureal R>|(?:inf|nan)\.0)?i
	        // <real R>      := [+-]?<ureal R>|[+-](?:inf|nan)\.0
	        // <ureal R>     := <uint R>(?:\/<uint R>)?
	        //                | <decimal R>
	        //
	        // <decimal 10>  := (?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?
	        // <uint R>      := <digit R>+
	        // <prefix R>    := <radix R>(?:#[ei])?|(?:#[ei])?<radix R>
	        // <radix 2>     := #b
	        // <radix 8>     := #o
	        // <radix 10>    := (?:#d)?
	        // <radix 16>    := #x
	        // <digit 2>     := [01]
	        // <digit 8>     := [0-7]
	        // <digit 10>    := \d
	        // <digit 16>    := [0-9a-f]
	        //
	        // The problem with this grammar is that the resulting regex is way to complex, so we simplify by grouping all
	        // non-decimal bases together. This results in a decimal (dec) and combined binary, octal, and hexadecimal (box)
	        // pattern:
	        pattern: RegExp(
	          SortedBNF({
	            '<ureal dec>':
	              /\d+(?:\/\d+)|(?:\d+(?:\.\d*)?|\.\d+)(?:[esfdl][+-]?\d+)?/.source,
	            '<real dec>': /[+-]?<ureal dec>|[+-](?:inf|nan)\.0/.source,
	            '<imaginary dec>': /[+-](?:<ureal dec>|(?:inf|nan)\.0)?i/.source,
	            '<complex dec>':
	              /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/
	                .source,
	            '<num dec>': /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,
	            '<ureal box>': /[0-9a-f]+(?:\/[0-9a-f]+)?/.source,
	            '<real box>': /[+-]?<ureal box>|[+-](?:inf|nan)\.0/.source,
	            '<imaginary box>': /[+-](?:<ureal box>|(?:inf|nan)\.0)?i/.source,
	            '<complex box>':
	              /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/
	                .source,
	            '<num box>': /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/
	              .source,
	            '<number>': /(^|[()\[\]\s])(?:<num dec>|<num box>)(?=[()\[\]\s]|$)/
	              .source
	          }),
	          'i'
	        ),
	        lookbehind: true
	      },
	      boolean: {
	        pattern: /(^|[()\[\]\s])#(?:[ft]|false|true)(?=[()\[\]\s]|$)/,
	        lookbehind: true
	      },
	      function: {
	        pattern:
	          /((?:^|[^'`#])[(\[])(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)(?=[()\[\]\s]|$)/,
	        lookbehind: true
	      },
	      identifier: {
	        pattern: /(^|[()\[\]\s])\|(?:[^\\|]|\\.)*\|(?=[()\[\]\s]|$)/,
	        lookbehind: true,
	        greedy: true
	      },
	      punctuation: /[()\[\]']/
	    };
	    /**
	     * Given a topologically sorted BNF grammar, this will return the RegExp source of last rule of the grammar.
	     *
	     * @param {Record<string, string>} grammar
	     * @returns {string}
	     */
	    function SortedBNF(grammar) {
	      for (var key in grammar) {
	        grammar[key] = grammar[key].replace(/<[\w\s]+>/g, function (key) {
	          return '(?:' + grammar[key].trim() + ')'
	        });
	      } // return the last item
	      return grammar[key]
	    }
	  })(Prism);
	}
	return scheme_1;
}

var lilypond_1;
var hasRequiredLilypond;

function requireLilypond () {
	if (hasRequiredLilypond) return lilypond_1;
	hasRequiredLilypond = 1;
	var refractorScheme = requireScheme();
	lilypond_1 = lilypond;
	lilypond.displayName = 'lilypond';
	lilypond.aliases = [];
	function lilypond(Prism) {
	  Prism.register(refractorScheme)
	  ;(function (Prism) {
	    var schemeExpression =
	      /\((?:[^();"#\\]|\\[\s\S]|;.*(?!.)|"(?:[^"\\]|\\.)*"|#(?:\{(?:(?!#\})[\s\S])*#\}|[^{])|<expr>)*\)/
	        .source; // allow for up to pow(2, recursivenessLog2) many levels of recursive brace expressions
	    // For some reason, this can't be 4
	    var recursivenessLog2 = 5;
	    for (var i = 0; i < recursivenessLog2; i++) {
	      schemeExpression = schemeExpression.replace(/<expr>/g, function () {
	        return schemeExpression
	      });
	    }
	    schemeExpression = schemeExpression.replace(/<expr>/g, /[^\s\S]/.source);
	    var lilypond = (Prism.languages.lilypond = {
	      comment: /%(?:(?!\{).*|\{[\s\S]*?%\})/,
	      'embedded-scheme': {
	        pattern: RegExp(
	          /(^|[=\s])#(?:"(?:[^"\\]|\\.)*"|[^\s()"]*(?:[^\s()]|<expr>))/.source.replace(
	            /<expr>/g,
	            function () {
	              return schemeExpression
	            }
	          ),
	          'm'
	        ),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          scheme: {
	            pattern: /^(#)[\s\S]+$/,
	            lookbehind: true,
	            alias: 'language-scheme',
	            inside: {
	              'embedded-lilypond': {
	                pattern: /#\{[\s\S]*?#\}/,
	                greedy: true,
	                inside: {
	                  punctuation: /^#\{|#\}$/,
	                  lilypond: {
	                    pattern: /[\s\S]+/,
	                    alias: 'language-lilypond',
	                    inside: null // see below
	                  }
	                }
	              },
	              rest: Prism.languages.scheme
	            }
	          },
	          punctuation: /#/
	        }
	      },
	      string: {
	        pattern: /"(?:[^"\\]|\\.)*"/,
	        greedy: true
	      },
	      'class-name': {
	        pattern: /(\\new\s+)[\w-]+/,
	        lookbehind: true
	      },
	      keyword: {
	        pattern: /\\[a-z][-\w]*/i,
	        inside: {
	          punctuation: /^\\/
	        }
	      },
	      operator: /[=|]|<<|>>/,
	      punctuation: {
	        pattern:
	          /(^|[a-z\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\d))|[_^]\.?|[.!])|[{}()[\]<>^~]|\\[()[\]<>\\!]|--|__/,
	        lookbehind: true
	      },
	      number: /\b\d+(?:\/\d+)?\b/
	    });
	    lilypond['embedded-scheme'].inside['scheme'].inside[
	      'embedded-lilypond'
	    ].inside['lilypond'].inside = lilypond;
	    Prism.languages.ly = lilypond;
	  })(Prism);
	}
	return lilypond_1;
}

var liquid_1;
var hasRequiredLiquid;

function requireLiquid () {
	if (hasRequiredLiquid) return liquid_1;
	hasRequiredLiquid = 1;
	var refractorMarkupTemplating = requireMarkupTemplating();
	liquid_1 = liquid;
	liquid.displayName = 'liquid';
	liquid.aliases = [];
	function liquid(Prism) {
	  Prism.register(refractorMarkupTemplating);
	  Prism.languages.liquid = {
	    comment: {
	      pattern: /(^\{%\s*comment\s*%\})[\s\S]+(?=\{%\s*endcomment\s*%\}$)/,
	      lookbehind: true
	    },
	    delimiter: {
	      pattern: /^\{(?:\{\{|[%\{])-?|-?(?:\}\}|[%\}])\}$/,
	      alias: 'punctuation'
	    },
	    string: {
	      pattern: /"[^"]*"|'[^']*'/,
	      greedy: true
	    },
	    keyword:
	      /\b(?:as|assign|break|(?:end)?(?:capture|case|comment|for|form|if|paginate|raw|style|tablerow|unless)|continue|cycle|decrement|echo|else|elsif|in|include|increment|limit|liquid|offset|range|render|reversed|section|when|with)\b/,
	    object:
	      /\b(?:address|all_country_option_tags|article|block|blog|cart|checkout|collection|color|country|country_option_tags|currency|current_page|current_tags|customer|customer_address|date|discount_allocation|discount_application|external_video|filter|filter_value|font|forloop|fulfillment|generic_file|gift_card|group|handle|image|line_item|link|linklist|localization|location|measurement|media|metafield|model|model_source|order|page|page_description|page_image|page_title|part|policy|product|product_option|recommendations|request|robots|routes|rule|script|search|selling_plan|selling_plan_allocation|selling_plan_group|shipping_method|shop|shop_locale|sitemap|store_availability|tax_line|template|theme|transaction|unit_price_measurement|user_agent|variant|video|video_source)\b/,
	    function: [
	      {
	        pattern: /(\|\s*)\w+/,
	        lookbehind: true,
	        alias: 'filter'
	      },
	      {
	        // array functions
	        pattern: /(\.\s*)(?:first|last|size)/,
	        lookbehind: true
	      }
	    ],
	    boolean: /\b(?:false|nil|true)\b/,
	    range: {
	      pattern: /\.\./,
	      alias: 'operator'
	    },
	    // https://github.com/Shopify/liquid/blob/698f5e0d967423e013f6169d9111bd969bd78337/lib/liquid/lexer.rb#L21
	    number: /\b\d+(?:\.\d+)?\b/,
	    operator: /[!=]=|<>|[<>]=?|[|?:=-]|\b(?:and|contains(?=\s)|or)\b/,
	    punctuation: /[.,\[\]()]/,
	    empty: {
	      pattern: /\bempty\b/,
	      alias: 'keyword'
	    }
	  };
	  Prism.hooks.add('before-tokenize', function (env) {
	    var liquidPattern =
	      /\{%\s*comment\s*%\}[\s\S]*?\{%\s*endcomment\s*%\}|\{(?:%[\s\S]*?%|\{\{[\s\S]*?\}\}|\{[\s\S]*?\})\}/g;
	    var insideRaw = false;
	    Prism.languages['markup-templating'].buildPlaceholders(
	      env,
	      'liquid',
	      liquidPattern,
	      function (match) {
	        var tagMatch = /^\{%-?\s*(\w+)/.exec(match);
	        if (tagMatch) {
	          var tag = tagMatch[1];
	          if (tag === 'raw' && !insideRaw) {
	            insideRaw = true;
	            return true
	          } else if (tag === 'endraw') {
	            insideRaw = false;
	            return true
	          }
	        }
	        return !insideRaw
	      }
	    );
	  });
	  Prism.hooks.add('after-tokenize', function (env) {
	    Prism.languages['markup-templating'].tokenizePlaceholders(env, 'liquid');
	  });
	}
	return liquid_1;
}

var lisp_1;
var hasRequiredLisp;

function requireLisp () {
	if (hasRequiredLisp) return lisp_1;
	hasRequiredLisp = 1;

	lisp_1 = lisp;
	lisp.displayName = 'lisp';
	lisp.aliases = [];
	function lisp(Prism) {
(function (Prism) {
	    /**
	     * Functions to construct regular expressions
	     * e.g. (interactive ... or (interactive)
	     *
	     * @param {string} name
	     * @returns {RegExp}
	     */
	    function simple_form(name) {
	      return RegExp(/(\()/.source + '(?:' + name + ')' + /(?=[\s\)])/.source)
	    }
	    /**
	     * booleans and numbers
	     *
	     * @param {string} pattern
	     * @returns {RegExp}
	     */
	    function primitive(pattern) {
	      return RegExp(
	        /([\s([])/.source + '(?:' + pattern + ')' + /(?=[\s)])/.source
	      )
	    } // Patterns in regular expressions
	    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html
	    // & and : are excluded as they are usually used for special purposes
	    var symbol = /(?!\d)[-+*/~!@$%^=<>{}\w]+/.source; // symbol starting with & used in function arguments
	    var marker = '&' + symbol; // Open parenthesis for look-behind
	    var par = '(\\()';
	    var endpar = '(?=\\))'; // End the pattern with look-ahead space
	    var space = '(?=\\s)';
	    var nestedPar =
	      /(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*/
	        .source;
	    var language = {
	      // Three or four semicolons are considered a heading.
	      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html
	      heading: {
	        pattern: /;;;.*/,
	        alias: ['comment', 'title']
	      },
	      comment: /;.*/,
	      string: {
	        pattern: /"(?:[^"\\]|\\.)*"/,
	        greedy: true,
	        inside: {
	          argument: /[-A-Z]+(?=[.,\s])/,
	          symbol: RegExp('`' + symbol + "'")
	        }
	      },
	      'quoted-symbol': {
	        pattern: RegExp("#?'" + symbol),
	        alias: ['variable', 'symbol']
	      },
	      'lisp-property': {
	        pattern: RegExp(':' + symbol),
	        alias: 'property'
	      },
	      splice: {
	        pattern: RegExp(',@?' + symbol),
	        alias: ['symbol', 'variable']
	      },
	      keyword: [
	        {
	          pattern: RegExp(
	            par +
	              '(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)' +
	              space
	          ),
	          lookbehind: true
	        },
	        {
	          pattern: RegExp(
	            par +
	              '(?:append|by|collect|concat|do|finally|for|in|return)' +
	              space
	          ),
	          lookbehind: true
	        }
	      ],
	      declare: {
	        pattern: simple_form(/declare/.source),
	        lookbehind: true,
	        alias: 'keyword'
	      },
	      interactive: {
	        pattern: simple_form(/interactive/.source),
	        lookbehind: true,
	        alias: 'keyword'
	      },
	      boolean: {
	        pattern: primitive(/nil|t/.source),
	        lookbehind: true
	      },
	      number: {
	        pattern: primitive(/[-+]?\d+(?:\.\d*)?/.source),
	        lookbehind: true
	      },
	      defvar: {
	        pattern: RegExp(par + 'def(?:const|custom|group|var)\\s+' + symbol),
	        lookbehind: true,
	        inside: {
	          keyword: /^def[a-z]+/,
	          variable: RegExp(symbol)
	        }
	      },
	      defun: {
	        pattern: RegExp(
	          par +
	            /(?:cl-)?(?:defmacro|defun\*?)\s+/.source +
	            symbol +
	            /\s+\(/.source +
	            nestedPar +
	            /\)/.source
	        ),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          keyword: /^(?:cl-)?def\S+/,
	          // See below, this property needs to be defined later so that it can
	          // reference the language object.
	          arguments: null,
	          function: {
	            pattern: RegExp('(^\\s)' + symbol),
	            lookbehind: true
	          },
	          punctuation: /[()]/
	        }
	      },
	      lambda: {
	        pattern: RegExp(
	          par +
	            'lambda\\s+\\(\\s*(?:&?' +
	            symbol +
	            '(?:\\s+&?' +
	            symbol +
	            ')*\\s*)?\\)'
	        ),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          keyword: /^lambda/,
	          // See below, this property needs to be defined later so that it can
	          // reference the language object.
	          arguments: null,
	          punctuation: /[()]/
	        }
	      },
	      car: {
	        pattern: RegExp(par + symbol),
	        lookbehind: true
	      },
	      punctuation: [
	        // open paren, brackets, and close paren
	        /(?:['`,]?\(|[)\[\]])/, // cons
	        {
	          pattern: /(\s)\.(?=\s)/,
	          lookbehind: true
	        }
	      ]
	    };
	    var arg = {
	      'lisp-marker': RegExp(marker),
	      varform: {
	        pattern: RegExp(
	          /\(/.source + symbol + /\s+(?=\S)/.source + nestedPar + /\)/.source
	        ),
	        inside: language
	      },
	      argument: {
	        pattern: RegExp(/(^|[\s(])/.source + symbol),
	        lookbehind: true,
	        alias: 'variable'
	      },
	      rest: language
	    };
	    var forms = '\\S+(?:\\s+\\S+)*';
	    var arglist = {
	      pattern: RegExp(par + nestedPar + endpar),
	      lookbehind: true,
	      inside: {
	        'rest-vars': {
	          pattern: RegExp('&(?:body|rest)\\s+' + forms),
	          inside: arg
	        },
	        'other-marker-vars': {
	          pattern: RegExp('&(?:aux|optional)\\s+' + forms),
	          inside: arg
	        },
	        keys: {
	          pattern: RegExp('&key\\s+' + forms + '(?:\\s+&allow-other-keys)?'),
	          inside: arg
	        },
	        argument: {
	          pattern: RegExp(symbol),
	          alias: 'variable'
	        },
	        punctuation: /[()]/
	      }
	    };
	    language['lambda'].inside.arguments = arglist;
	    language['defun'].inside.arguments = Prism.util.clone(arglist);
	    language['defun'].inside.arguments.inside.sublist = arglist;
	    Prism.languages.lisp = language;
	    Prism.languages.elisp = language;
	    Prism.languages.emacs = language;
	    Prism.languages['emacs-lisp'] = language;
	  })(Prism);
	}
	return lisp_1;
}

var livescript_1;
var hasRequiredLivescript;

function requireLivescript () {
	if (hasRequiredLivescript) return livescript_1;
	hasRequiredLivescript = 1;

	livescript_1 = livescript;
	livescript.displayName = 'livescript';
	livescript.aliases = [];
	function livescript(Prism) {
	  Prism.languages.livescript = {
	    comment: [
	      {
	        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
	        lookbehind: true
	      },
	      {
	        pattern: /(^|[^\\])#.*/,
	        lookbehind: true
	      }
	    ],
	    'interpolated-string': {
	      /* Look-behind and look-ahead prevents wrong behavior of the greedy pattern
	       * forcing it to match """-quoted string when it would otherwise match "-quoted first. */
	      pattern: /(^|[^"])("""|")(?:\\[\s\S]|(?!\2)[^\\])*\2(?!")/,
	      lookbehind: true,
	      greedy: true,
	      inside: {
	        variable: {
	          pattern: /(^|[^\\])#[a-z_](?:-?[a-z]|[\d_])*/m,
	          lookbehind: true
	        },
	        interpolation: {
	          pattern: /(^|[^\\])#\{[^}]+\}/m,
	          lookbehind: true,
	          inside: {
	            'interpolation-punctuation': {
	              pattern: /^#\{|\}$/,
	              alias: 'variable'
	            } // See rest below
	          }
	        },
	        string: /[\s\S]+/
	      }
	    },
	    string: [
	      {
	        pattern: /('''|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
	        greedy: true
	      },
	      {
	        pattern: /<\[[\s\S]*?\]>/,
	        greedy: true
	      },
	      /\\[^\s,;\])}]+/
	    ],
	    regex: [
	      {
	        pattern: /\/\/(?:\[[^\r\n\]]*\]|\\.|(?!\/\/)[^\\\[])+\/\/[gimyu]{0,5}/,
	        greedy: true,
	        inside: {
	          comment: {
	            pattern: /(^|[^\\])#.*/,
	            lookbehind: true
	          }
	        }
	      },
	      {
	        pattern: /\/(?:\[[^\r\n\]]*\]|\\.|[^/\\\r\n\[])+\/[gimyu]{0,5}/,
	        greedy: true
	      }
	    ],
	    keyword: {
	      pattern:
	        /(^|(?!-).)\b(?:break|case|catch|class|const|continue|default|do|else|extends|fallthrough|finally|for(?: ever)?|function|if|implements|it|let|loop|new|null|otherwise|own|return|super|switch|that|then|this|throw|try|unless|until|var|void|when|while|yield)(?!-)\b/m,
	      lookbehind: true
	    },
	    'keyword-operator': {
	      pattern:
	        /(^|[^-])\b(?:(?:delete|require|typeof)!|(?:and|by|delete|export|from|import(?: all)?|in|instanceof|is(?: not|nt)?|not|of|or|til|to|typeof|with|xor)(?!-)\b)/m,
	      lookbehind: true,
	      alias: 'operator'
	    },
	    boolean: {
	      pattern: /(^|[^-])\b(?:false|no|off|on|true|yes)(?!-)\b/m,
	      lookbehind: true
	    },
	    argument: {
	      // Don't match .&. nor &&
	      pattern: /(^|(?!\.&\.)[^&])&(?!&)\d*/m,
	      lookbehind: true,
	      alias: 'variable'
	    },
	    number: /\b(?:\d+~[\da-z]+|\d[\d_]*(?:\.\d[\d_]*)?(?:[a-z]\w*)?)/i,
	    identifier: /[a-z_](?:-?[a-z]|[\d_])*/i,
	    operator: [
	      // Spaced .
	      {
	        pattern: /( )\.(?= )/,
	        lookbehind: true
	      }, // Full list, in order:
	      // .= .~ .. ...
	      // .&. .^. .<<. .>>. .>>>.
	      // := :: ::=
	      // &&
	      // || |>
	      // < << <<< <<<<
	      // <- <-- <-! <--!
	      // <~ <~~ <~! <~~!
	      // <| <= <?
	      // > >> >= >?
	      // - -- -> -->
	      // + ++
	      // @ @@
	      // % %%
	      // * **
	      // ! != !~=
	      // !~> !~~>
	      // !-> !-->
	      // ~ ~> ~~> ~=
	      // = ==
	      // ^ ^^
	      // / ?
	      /\.(?:[=~]|\.\.?)|\.(?:[&|^]|<<|>>>?)\.|:(?:=|:=?)|&&|\|[|>]|<(?:<<?<?|--?!?|~~?!?|[|=?])?|>[>=?]?|-(?:->?|>)?|\+\+?|@@?|%%?|\*\*?|!(?:~?=|--?>|~?~>)?|~(?:~?>|=)?|==?|\^\^?|[\/?]/
	    ],
	    punctuation: /[(){}\[\]|.,:;`]/
	  };
	  Prism.languages.livescript['interpolated-string'].inside[
	    'interpolation'
	  ].inside.rest = Prism.languages.livescript;
	}
	return livescript_1;
}

var llvm_1;
var hasRequiredLlvm;

function requireLlvm () {
	if (hasRequiredLlvm) return llvm_1;
	hasRequiredLlvm = 1;

	llvm_1 = llvm;
	llvm.displayName = 'llvm';
	llvm.aliases = [];
	function llvm(Prism) {
(function (Prism) {
	    Prism.languages.llvm = {
	      comment: /;.*/,
	      string: {
	        pattern: /"[^"]*"/,
	        greedy: true
	      },
	      boolean: /\b(?:false|true)\b/,
	      variable: /[%@!#](?:(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+|\d+)/i,
	      label: /(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+:/i,
	      type: {
	        pattern:
	          /\b(?:double|float|fp128|half|i[1-9]\d*|label|metadata|ppc_fp128|token|void|x86_fp80|x86_mmx)\b/,
	        alias: 'class-name'
	      },
	      keyword: /\b[a-z_][a-z_0-9]*\b/,
	      number:
	        /[+-]?\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-Fa-f]+\b|\b0xK[\dA-Fa-f]{20}\b|\b0x[ML][\dA-Fa-f]{32}\b|\b0xH[\dA-Fa-f]{4}\b/,
	      punctuation: /[{}[\];(),.!*=<>]/
	    };
	  })(Prism);
	}
	return llvm_1;
}

var log_1;
var hasRequiredLog;

function requireLog () {
	if (hasRequiredLog) return log_1;
	hasRequiredLog = 1;

	log_1 = log;
	log.displayName = 'log';
	log.aliases = [];
	function log(Prism) {
	  // This is a language definition for generic log files.
	  // Since there is no one log format, this language definition has to support all formats to some degree.
	  //
	  // Based on https://github.com/MTDL9/vim-log-highlighting
	  Prism.languages.log = {
	    string: {
	      // Single-quoted strings must not be confused with plain text. E.g. Can't isn't Susan's Chris' toy
	      pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?![st] | \w)(?:[^'\\\r\n]|\\.)*'/,
	      greedy: true
	    },
	    exception: {
	      pattern:
	        /(^|[^\w.])[a-z][\w.]*(?:Error|Exception):.*(?:(?:\r\n?|\n)[ \t]*(?:at[ \t].+|\.{3}.*|Caused by:.*))+(?:(?:\r\n?|\n)[ \t]*\.\.\. .*)?/,
	      lookbehind: true,
	      greedy: true,
	      alias: ['javastacktrace', 'language-javastacktrace'],
	      inside: Prism.languages['javastacktrace'] || {
	        keyword: /\bat\b/,
	        function: /[a-z_][\w$]*(?=\()/,
	        punctuation: /[.:()]/
	      }
	    },
	    level: [
	      {
	        pattern:
	          /\b(?:ALERT|CRIT|CRITICAL|EMERG|EMERGENCY|ERR|ERROR|FAILURE|FATAL|SEVERE)\b/,
	        alias: ['error', 'important']
	      },
	      {
	        pattern: /\b(?:WARN|WARNING|WRN)\b/,
	        alias: ['warning', 'important']
	      },
	      {
	        pattern: /\b(?:DISPLAY|INF|INFO|NOTICE|STATUS)\b/,
	        alias: ['info', 'keyword']
	      },
	      {
	        pattern: /\b(?:DBG|DEBUG|FINE)\b/,
	        alias: ['debug', 'keyword']
	      },
	      {
	        pattern: /\b(?:FINER|FINEST|TRACE|TRC|VERBOSE|VRB)\b/,
	        alias: ['trace', 'comment']
	      }
	    ],
	    property: {
	      pattern:
	        /((?:^|[\]|])[ \t]*)[a-z_](?:[\w-]|\b\/\b)*(?:[. ]\(?\w(?:[\w-]|\b\/\b)*\)?)*:(?=\s)/im,
	      lookbehind: true
	    },
	    separator: {
	      pattern: /(^|[^-+])-{3,}|={3,}|\*{3,}|- - /m,
	      lookbehind: true,
	      alias: 'comment'
	    },
	    url: /\b(?:file|ftp|https?):\/\/[^\s|,;'"]*[^\s|,;'">.]/,
	    email: {
	      pattern: /(^|\s)[-\w+.]+@[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)+(?=\s)/,
	      lookbehind: true,
	      alias: 'url'
	    },
	    'ip-address': {
	      pattern: /\b(?:\d{1,3}(?:\.\d{1,3}){3})\b/,
	      alias: 'constant'
	    },
	    'mac-address': {
	      pattern: /\b[a-f0-9]{2}(?::[a-f0-9]{2}){5}\b/i,
	      alias: 'constant'
	    },
	    domain: {
	      pattern:
	        /(^|\s)[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)*\.[a-z][a-z0-9-]+(?=\s)/,
	      lookbehind: true,
	      alias: 'constant'
	    },
	    uuid: {
	      pattern:
	        /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/i,
	      alias: 'constant'
	    },
	    hash: {
	      pattern: /\b(?:[a-f0-9]{32}){1,2}\b/i,
	      alias: 'constant'
	    },
	    'file-path': {
	      pattern:
	        /\b[a-z]:[\\/][^\s|,;:(){}\[\]"']+|(^|[\s:\[\](>|])\.{0,2}\/\w[^\s|,;:(){}\[\]"']*/i,
	      lookbehind: true,
	      greedy: true,
	      alias: 'string'
	    },
	    date: {
	      pattern: RegExp(
	        /\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))/.source +
	          '|' +
	          /\b\d{1,4}[-/ ](?:\d{1,2}|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)[-/ ]\d{2,4}T?\b/
	            .source +
	          '|' +
	          /\b(?:(?:Fri|Mon|Sat|Sun|Thu|Tue|Wed)(?:\s{1,2}(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep))?|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)\s{1,2}\d{1,2}\b/
	            .source,
	        'i'
	      ),
	      alias: 'number'
	    },
	    time: {
	      pattern:
	        /\b\d{1,2}:\d{1,2}:\d{1,2}(?:[.,:]\d+)?(?:\s?[+-]\d{2}:?\d{2}|Z)?\b/,
	      alias: 'number'
	    },
	    boolean: /\b(?:false|null|true)\b/i,
	    number: {
	      pattern:
	        /(^|[^.\w])(?:0x[a-f0-9]+|0o[0-7]+|0b[01]+|v?\d[\da-f]*(?:\.\d+)*(?:e[+-]?\d+)?[a-z]{0,3}\b)\b(?!\.\w)/i,
	      lookbehind: true
	    },
	    operator: /[;:?<=>~/@!$%&+\-|^(){}*#]/,
	    punctuation: /[\[\].,]/
	  };
	}
	return log_1;
}

var lolcode_1;
var hasRequiredLolcode;

function requireLolcode () {
	if (hasRequiredLolcode) return lolcode_1;
	hasRequiredLolcode = 1;

	lolcode_1 = lolcode;
	lolcode.displayName = 'lolcode';
	lolcode.aliases = [];
	function lolcode(Prism) {
	  Prism.languages.lolcode = {
	    comment: [/\bOBTW\s[\s\S]*?\sTLDR\b/, /\bBTW.+/],
	    string: {
	      pattern: /"(?::.|[^":])*"/,
	      inside: {
	        variable: /:\{[^}]+\}/,
	        symbol: [/:\([a-f\d]+\)/i, /:\[[^\]]+\]/, /:[)>o":]/]
	      },
	      greedy: true
	    },
	    number: /(?:\B-)?(?:\b\d+(?:\.\d*)?|\B\.\d+)/,
	    symbol: {
	      pattern: /(^|\s)(?:A )?(?:BUKKIT|NOOB|NUMBAR|NUMBR|TROOF|YARN)(?=\s|,|$)/,
	      lookbehind: true,
	      inside: {
	        keyword: /A(?=\s)/
	      }
	    },
	    label: {
	      pattern: /((?:^|\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\w*/,
	      lookbehind: true,
	      alias: 'string'
	    },
	    function: {
	      pattern: /((?:^|\s)(?:HOW IZ I|I IZ|IZ) )[a-zA-Z]\w*/,
	      lookbehind: true
	    },
	    keyword: [
	      {
	        pattern:
	          /(^|\s)(?:AN|FOUND YR|GIMMEH|GTFO|HAI|HAS A|HOW IZ I|I HAS A|I IZ|IF U SAY SO|IM IN YR|IM OUTTA YR|IS NOW(?: A)?|ITZ(?: A)?|IZ|KTHX|KTHXBYE|LIEK(?: A)?|MAEK|MEBBE|MKAY|NERFIN|NO WAI|O HAI IM|O RLY\?|OIC|OMG|OMGWTF|R|SMOOSH|SRS|TIL|UPPIN|VISIBLE|WILE|WTF\?|YA RLY|YR)(?=\s|,|$)/,
	        lookbehind: true
	      },
	      /'Z(?=\s|,|$)/
	    ],
	    boolean: {
	      pattern: /(^|\s)(?:FAIL|WIN)(?=\s|,|$)/,
	      lookbehind: true
	    },
	    variable: {
	      pattern: /(^|\s)IT(?=\s|,|$)/,
	      lookbehind: true
	    },
	    operator: {
	      pattern:
	        /(^|\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:ALL|ANY|BIGGR|BOTH|DIFF|EITHER|MOD|PRODUKT|QUOSHUNT|SMALLR|SUM|WON) OF)(?=\s|,|$)/,
	      lookbehind: true
	    },
	    punctuation: /\.{3}|…|,|!/
	  };
	}
	return lolcode_1;
}

var magma_1;
var hasRequiredMagma;

function requireMagma () {
	if (hasRequiredMagma) return magma_1;
	hasRequiredMagma = 1;

	magma_1 = magma;
	magma.displayName = 'magma';
	magma.aliases = [];
	function magma(Prism) {
	  Prism.languages.magma = {
	    output: {
	      pattern:
	        /^(>.*(?:\r(?:\n|(?!\n))|\n))(?!>)(?:.+|(?:\r(?:\n|(?!\n))|\n)(?!>).*)(?:(?:\r(?:\n|(?!\n))|\n)(?!>).*)*/m,
	      lookbehind: true,
	      greedy: true
	    },
	    comment: {
	      pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
	      greedy: true
	    },
	    string: {
	      pattern: /(^|[^\\"])"(?:[^\r\n\\"]|\\.)*"/,
	      lookbehind: true,
	      greedy: true
	    },
	    // http://magma.maths.usyd.edu.au/magma/handbook/text/82
	    keyword:
	      /\b(?:_|adj|and|assert|assert2|assert3|assigned|break|by|case|cat|catch|clear|cmpeq|cmpne|continue|declare|default|delete|diff|div|do|elif|else|end|eq|error|eval|exists|exit|for|forall|forward|fprintf|freeze|function|ge|gt|if|iload|import|in|intrinsic|is|join|le|load|local|lt|meet|mod|ne|not|notadj|notin|notsubset|or|print|printf|procedure|quit|random|read|readi|repeat|require|requirege|requirerange|restore|return|save|sdiff|select|subset|then|time|to|try|until|vprint|vprintf|vtime|when|where|while|xor)\b/,
	    boolean: /\b(?:false|true)\b/,
	    generator: {
	      pattern: /\b[a-z_]\w*(?=\s*<)/i,
	      alias: 'class-name'
	    },
	    function: /\b[a-z_]\w*(?=\s*\()/i,
	    number: {
	      pattern:
	        /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
	      lookbehind: true
	    },
	    operator: /->|[-+*/^~!|#=]|:=|\.\./,
	    punctuation: /[()[\]{}<>,;.:]/
	  };
	}
	return magma_1;
}

var makefile_1;
var hasRequiredMakefile;

function requireMakefile () {
	if (hasRequiredMakefile) return makefile_1;
	hasRequiredMakefile = 1;

	makefile_1 = makefile;
	makefile.displayName = 'makefile';
	makefile.aliases = [];
	function makefile(Prism) {
	  Prism.languages.makefile = {
	    comment: {
	      pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
	      lookbehind: true
	    },
	    string: {
	      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    'builtin-target': {
	      pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
	      alias: 'builtin'
	    },
	    target: {
	      pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
	      alias: 'symbol',
	      inside: {
	        variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
	      }
	    },
	    variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
	    // Directives
	    keyword:
	      /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
	    function: {
	      pattern:
	        /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
	      lookbehind: true
	    },
	    operator: /(?:::|[?:+!])?=|[|@]/,
	    punctuation: /[:;(){}]/
	  };
	}
	return makefile_1;
}

var markdown_1;
var hasRequiredMarkdown;

function requireMarkdown () {
	if (hasRequiredMarkdown) return markdown_1;
	hasRequiredMarkdown = 1;

	markdown_1 = markdown;
	markdown.displayName = 'markdown';
	markdown.aliases = ['md'];
	function markdown(Prism) {
(function (Prism) {
	    // Allow only one line break
	    var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
	    /**
	     * This function is intended for the creation of the bold or italic pattern.
	     *
	     * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.
	     *
	     * _Note:_ Keep in mind that this adds a capturing group.
	     *
	     * @param {string} pattern
	     * @returns {RegExp}
	     */
	    function createInline(pattern) {
	      pattern = pattern.replace(/<inner>/g, function () {
	        return inner
	      });
	      return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + '(?:' + pattern + ')')
	    }
	    var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/
	      .source;
	    var tableRow =
	      /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(
	        /__/g,
	        function () {
	          return tableCell
	        }
	      );
	    var tableLine =
	      /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/
	        .source;
	    Prism.languages.markdown = Prism.languages.extend('markup', {});
	    Prism.languages.insertBefore('markdown', 'prolog', {
	      'front-matter-block': {
	        pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          punctuation: /^---|---$/,
	          'front-matter': {
	            pattern: /\S+(?:\s+\S+)*/,
	            alias: ['yaml', 'language-yaml'],
	            inside: Prism.languages.yaml
	          }
	        }
	      },
	      blockquote: {
	        // > ...
	        pattern: /^>(?:[\t ]*>)*/m,
	        alias: 'punctuation'
	      },
	      table: {
	        pattern: RegExp(
	          '^' + tableRow + tableLine + '(?:' + tableRow + ')*',
	          'm'
	        ),
	        inside: {
	          'table-data-rows': {
	            pattern: RegExp(
	              '^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'
	            ),
	            lookbehind: true,
	            inside: {
	              'table-data': {
	                pattern: RegExp(tableCell),
	                inside: Prism.languages.markdown
	              },
	              punctuation: /\|/
	            }
	          },
	          'table-line': {
	            pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),
	            lookbehind: true,
	            inside: {
	              punctuation: /\||:?-{3,}:?/
	            }
	          },
	          'table-header-row': {
	            pattern: RegExp('^' + tableRow + '$'),
	            inside: {
	              'table-header': {
	                pattern: RegExp(tableCell),
	                alias: 'important',
	                inside: Prism.languages.markdown
	              },
	              punctuation: /\|/
	            }
	          }
	        }
	      },
	      code: [
	        {
	          // Prefixed by 4 spaces or 1 tab and preceded by an empty line
	          pattern:
	            /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
	          lookbehind: true,
	          alias: 'keyword'
	        },
	        {
	          // ```optional language
	          // code block
	          // ```
	          pattern: /^```[\s\S]*?^```$/m,
	          greedy: true,
	          inside: {
	            'code-block': {
	              pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
	              lookbehind: true
	            },
	            'code-language': {
	              pattern: /^(```).+/,
	              lookbehind: true
	            },
	            punctuation: /```/
	          }
	        }
	      ],
	      title: [
	        {
	          // title 1
	          // =======
	          // title 2
	          // -------
	          pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
	          alias: 'important',
	          inside: {
	            punctuation: /==+$|--+$/
	          }
	        },
	        {
	          // # title 1
	          // ###### title 6
	          pattern: /(^\s*)#.+/m,
	          lookbehind: true,
	          alias: 'important',
	          inside: {
	            punctuation: /^#+|#+$/
	          }
	        }
	      ],
	      hr: {
	        // ***
	        // ---
	        // * * *
	        // -----------
	        pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
	        lookbehind: true,
	        alias: 'punctuation'
	      },
	      list: {
	        // * item
	        // + item
	        // - item
	        // 1. item
	        pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
	        lookbehind: true,
	        alias: 'punctuation'
	      },
	      'url-reference': {
	        // [id]: http://example.com "Optional title"
	        // [id]: http://example.com 'Optional title'
	        // [id]: http://example.com (Optional title)
	        // [id]: <http://example.com> "Optional title"
	        pattern:
	          /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
	        inside: {
	          variable: {
	            pattern: /^(!?\[)[^\]]+/,
	            lookbehind: true
	          },
	          string:
	            /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
	          punctuation: /^[\[\]!:]|[<>]/
	        },
	        alias: 'url'
	      },
	      bold: {
	        // **strong**
	        // __strong__
	        // allow one nested instance of italic text using the same delimiter
	        pattern: createInline(
	          /\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/
	            .source
	        ),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          content: {
	            pattern: /(^..)[\s\S]+(?=..$)/,
	            lookbehind: true,
	            inside: {} // see below
	          },
	          punctuation: /\*\*|__/
	        }
	      },
	      italic: {
	        // *em*
	        // _em_
	        // allow one nested instance of bold text using the same delimiter
	        pattern: createInline(
	          /\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/
	            .source
	        ),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          content: {
	            pattern: /(^.)[\s\S]+(?=.$)/,
	            lookbehind: true,
	            inside: {} // see below
	          },
	          punctuation: /[*_]/
	        }
	      },
	      strike: {
	        // ~~strike through~~
	        // ~strike~
	        // eslint-disable-next-line regexp/strict
	        pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          content: {
	            pattern: /(^~~?)[\s\S]+(?=\1$)/,
	            lookbehind: true,
	            inside: {} // see below
	          },
	          punctuation: /~~?/
	        }
	      },
	      'code-snippet': {
	        // `code`
	        // ``code``
	        pattern:
	          /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
	        lookbehind: true,
	        greedy: true,
	        alias: ['code', 'keyword']
	      },
	      url: {
	        // [example](http://example.com "Optional title")
	        // [example][id]
	        // [example] [id]
	        pattern: createInline(
	          /!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/
	            .source
	        ),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          operator: /^!/,
	          content: {
	            pattern: /(^\[)[^\]]+(?=\])/,
	            lookbehind: true,
	            inside: {} // see below
	          },
	          variable: {
	            pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
	            lookbehind: true
	          },
	          url: {
	            pattern: /(^\]\()[^\s)]+/,
	            lookbehind: true
	          },
	          string: {
	            pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
	            lookbehind: true
	          }
	        }
	      }
	    })
	    ;['url', 'bold', 'italic', 'strike'].forEach(function (token) {
['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (
	        inside
	      ) {
	        if (token !== inside) {
	          Prism.languages.markdown[token].inside.content.inside[inside] =
	            Prism.languages.markdown[inside];
	        }
	      });
	    });
	    Prism.hooks.add('after-tokenize', function (env) {
	      if (env.language !== 'markdown' && env.language !== 'md') {
	        return
	      }
	      function walkTokens(tokens) {
	        if (!tokens || typeof tokens === 'string') {
	          return
	        }
	        for (var i = 0, l = tokens.length; i < l; i++) {
	          var token = tokens[i];
	          if (token.type !== 'code') {
	            walkTokens(token.content);
	            continue
	          }
	          /*
	           * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token
	           * is optional. But the grammar is defined so that there is only one case we have to handle:
	           *
	           * token.content = [
	           *     <span class="punctuation">```</span>,
	           *     <span class="code-language">xxxx</span>,
	           *     '\n', // exactly one new lines (\r or \n or \r\n)
	           *     <span class="code-block">...</span>,
	           *     '\n', // exactly one new lines again
	           *     <span class="punctuation">```</span>
	           * ];
	           */
	          var codeLang = token.content[1];
	          var codeBlock = token.content[3];
	          if (
	            codeLang &&
	            codeBlock &&
	            codeLang.type === 'code-language' &&
	            codeBlock.type === 'code-block' &&
	            typeof codeLang.content === 'string'
	          ) {
	            // this might be a language that Prism does not support
	            // do some replacements to support C++, C#, and F#
	            var lang = codeLang.content
	              .replace(/\b#/g, 'sharp')
	              .replace(/\b\+\+/g, 'pp'); // only use the first word
	            lang = (/[a-z][\w-]*/i.exec(lang) || [''])[0].toLowerCase();
	            var alias = 'language-' + lang; // add alias
	            if (!codeBlock.alias) {
	              codeBlock.alias = [alias];
	            } else if (typeof codeBlock.alias === 'string') {
	              codeBlock.alias = [codeBlock.alias, alias];
	            } else {
	              codeBlock.alias.push(alias);
	            }
	          }
	        }
	      }
	      walkTokens(env.tokens);
	    });
	    Prism.hooks.add('wrap', function (env) {
	      if (env.type !== 'code-block') {
	        return
	      }
	      var codeLang = '';
	      for (var i = 0, l = env.classes.length; i < l; i++) {
	        var cls = env.classes[i];
	        var match = /language-(.+)/.exec(cls);
	        if (match) {
	          codeLang = match[1];
	          break
	        }
	      }
	      var grammar = Prism.languages[codeLang];
	      if (!grammar) {
	        if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {
	          var id =
	            'md-' +
	            new Date().valueOf() +
	            '-' +
	            Math.floor(Math.random() * 1e16);
	          env.attributes['id'] = id;
	          Prism.plugins.autoloader.loadLanguages(codeLang, function () {
	            var ele = document.getElementById(id);
	            if (ele) {
	              ele.innerHTML = Prism.highlight(
	                ele.textContent,
	                Prism.languages[codeLang],
	                codeLang
	              );
	            }
	          });
	        }
	      } else {
	        env.content = Prism.highlight(
	          textContent(env.content.value),
	          grammar,
	          codeLang
	        );
	      }
	    });
	    var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');
	    /**
	     * A list of known entity names.
	     *
	     * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.
	     *
	     * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}
	     */
	    var KNOWN_ENTITY_NAMES = {
	      amp: '&',
	      lt: '<',
	      gt: '>',
	      quot: '"'
	    }; // IE 11 doesn't support `String.fromCodePoint`
	    var fromCodePoint = String.fromCodePoint || String.fromCharCode;
	    /**
	     * Returns the text content of a given HTML source code string.
	     *
	     * @param {string} html
	     * @returns {string}
	     */
	    function textContent(html) {
	      // remove all tags
	      var text = html.replace(tagPattern, ''); // decode known entities
	      text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (m, code) {
	        code = code.toLowerCase();
	        if (code[0] === '#') {
	          var value;
	          if (code[1] === 'x') {
	            value = parseInt(code.slice(2), 16);
	          } else {
	            value = Number(code.slice(1));
	          }
	          return fromCodePoint(value)
	        } else {
	          var known = KNOWN_ENTITY_NAMES[code];
	          if (known) {
	            return known
	          } // unable to decode
	          return m
	        }
	      });
	      return text
	    }
	    Prism.languages.md = Prism.languages.markdown;
	  })(Prism);
	}
	return markdown_1;
}

var matlab_1;
var hasRequiredMatlab;

function requireMatlab () {
	if (hasRequiredMatlab) return matlab_1;
	hasRequiredMatlab = 1;

	matlab_1 = matlab;
	matlab.displayName = 'matlab';
	matlab.aliases = [];
	function matlab(Prism) {
	  Prism.languages.matlab = {
	    comment: [/%\{[\s\S]*?\}%/, /%.+/],
	    string: {
	      pattern: /\B'(?:''|[^'\r\n])*'/,
	      greedy: true
	    },
	    // FIXME We could handle imaginary numbers as a whole
	    number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?(?:[ij])?|\b[ij]\b/,
	    keyword:
	      /\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\b/,
	    function: /\b(?!\d)\w+(?=\s*\()/,
	    operator: /\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,
	    punctuation: /\.{3}|[.,;\[\](){}!]/
	  };
	}
	return matlab_1;
}

var maxscript_1;
var hasRequiredMaxscript;

function requireMaxscript () {
	if (hasRequiredMaxscript) return maxscript_1;
	hasRequiredMaxscript = 1;

	maxscript_1 = maxscript;
	maxscript.displayName = 'maxscript';
	maxscript.aliases = [];
	function maxscript(Prism) {
(function (Prism) {
	    var keywords =
	      /\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\b/i;
	    Prism.languages.maxscript = {
	      comment: {
	        pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/,
	        greedy: true
	      },
	      string: {
	        pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/,
	        lookbehind: true,
	        greedy: true
	      },
	      path: {
	        pattern: /\$(?:[\w/\\.*?]|'[^']*')*/,
	        greedy: true,
	        alias: 'string'
	      },
	      'function-call': {
	        pattern: RegExp(
	          '((?:' + // start of line
	            (/^/.source +
	              '|' + // operators and other language constructs
	              /[;=<>+\-*/^({\[]/.source +
	              '|' + // keywords as part of statements
	              /\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\b/
	                .source) +
	            ')[ \t]*)' +
	            '(?!' +
	            keywords.source +
	            ')' +
	            /[a-z_]\w*\b/.source +
	            '(?=[ \t]*(?:' + // variable
	            ('(?!' +
	              keywords.source +
	              ')' +
	              /[a-z_]/.source +
	              '|' + // number
	              /\d|-\.?\d/.source +
	              '|' + // other expressions or literals
	              /[({'"$@#?]/.source) +
	            '))',
	          'im'
	        ),
	        lookbehind: true,
	        greedy: true,
	        alias: 'function'
	      },
	      'function-definition': {
	        pattern: /(\b(?:fn|function)\s+)\w+\b/i,
	        lookbehind: true,
	        alias: 'function'
	      },
	      argument: {
	        pattern: /\b[a-z_]\w*(?=:)/i,
	        alias: 'attr-name'
	      },
	      keyword: keywords,
	      boolean: /\b(?:false|true)\b/,
	      time: {
	        pattern:
	          /(^|[^\w.])(?:(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?[msft])+|\d+:\d+(?:\.\d*)?)(?![\w.:])/,
	        lookbehind: true,
	        alias: 'number'
	      },
	      number: [
	        {
	          pattern:
	            /(^|[^\w.])(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?|0x[a-fA-F0-9]+)(?![\w.:])/,
	          lookbehind: true
	        },
	        /\b(?:e|pi)\b/
	      ],
	      constant: /\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\b/,
	      color: {
	        pattern: /\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\b/i,
	        alias: 'constant'
	      },
	      operator: /[-+*/<>=!]=?|[&^?]|#(?!\()/,
	      punctuation: /[()\[\]{}.:,;]|#(?=\()|\\$/m
	    };
	  })(Prism);
	}
	return maxscript_1;
}

var mel_1;
var hasRequiredMel;

function requireMel () {
	if (hasRequiredMel) return mel_1;
	hasRequiredMel = 1;

	mel_1 = mel;
	mel.displayName = 'mel';
	mel.aliases = [];
	function mel(Prism) {
	  Prism.languages.mel = {
	    comment: /\/\/.*/,
	    code: {
	      pattern: /`(?:\\.|[^\\`\r\n])*`/,
	      greedy: true,
	      alias: 'italic',
	      inside: {
	        delimiter: {
	          pattern: /^`|`$/,
	          alias: 'punctuation'
	        } // See rest below
	      }
	    },
	    string: {
	      pattern: /"(?:\\.|[^\\"\r\n])*"/,
	      greedy: true
	    },
	    variable: /\$\w+/,
	    number: /\b0x[\da-fA-F]+\b|\b\d+(?:\.\d*)?|\B\.\d+/,
	    flag: {
	      pattern: /-[^\d\W]\w*/,
	      alias: 'operator'
	    },
	    keyword:
	      /\b(?:break|case|continue|default|do|else|float|for|global|if|in|int|matrix|proc|return|string|switch|vector|while)\b/,
	    function:
	      /\b\w+(?=\()|\b(?:CBG|HfAddAttractorToAS|HfAssignAS|HfBuildEqualMap|HfBuildFurFiles|HfBuildFurImages|HfCancelAFR|HfConnectASToHF|HfCreateAttractor|HfDeleteAS|HfEditAS|HfPerformCreateAS|HfRemoveAttractorFromAS|HfSelectAttached|HfSelectAttractors|HfUnAssignAS|Mayatomr|about|abs|addAttr|addAttributeEditorNodeHelp|addDynamic|addNewShelfTab|addPP|addPanelCategory|addPrefixToName|advanceToNextDrivenKey|affectedNet|affects|aimConstraint|air|alias|aliasAttr|align|alignCtx|alignCurve|alignSurface|allViewFit|ambientLight|angle|angleBetween|animCone|animCurveEditor|animDisplay|animView|annotate|appendStringArray|applicationName|applyAttrPreset|applyTake|arcLenDimContext|arcLengthDimension|arclen|arrayMapper|art3dPaintCtx|artAttrCtx|artAttrPaintVertexCtx|artAttrSkinPaintCtx|artAttrTool|artBuildPaintMenu|artFluidAttrCtx|artPuttyCtx|artSelectCtx|artSetPaintCtx|artUserPaintCtx|assignCommand|assignInputDevice|assignViewportFactories|attachCurve|attachDeviceAttr|attachSurface|attrColorSliderGrp|attrCompatibility|attrControlGrp|attrEnumOptionMenu|attrEnumOptionMenuGrp|attrFieldGrp|attrFieldSliderGrp|attrNavigationControlGrp|attrPresetEditWin|attributeExists|attributeInfo|attributeMenu|attributeQuery|autoKeyframe|autoPlace|bakeClip|bakeFluidShading|bakePartialHistory|bakeResults|bakeSimulation|basename|basenameEx|batchRender|bessel|bevel|bevelPlus|binMembership|bindSkin|blend2|blendShape|blendShapeEditor|blendShapePanel|blendTwoAttr|blindDataType|boneLattice|boundary|boxDollyCtx|boxZoomCtx|bufferCurve|buildBookmarkMenu|buildKeyframeMenu|button|buttonManip|cacheFile|cacheFileCombine|cacheFileMerge|cacheFileTrack|camera|cameraView|canCreateManip|canvas|capitalizeString|catch|catchQuiet|ceil|changeSubdivComponentDisplayLevel|changeSubdivRegion|channelBox|character|characterMap|characterOutlineEditor|characterize|chdir|checkBox|checkBoxGrp|checkDefaultRenderGlobals|choice|circle|circularFillet|clamp|clear|clearCache|clip|clipEditor|clipEditorCurrentTimeCtx|clipSchedule|clipSchedulerOutliner|clipTrimBefore|closeCurve|closeSurface|cluster|cmdFileOutput|cmdScrollFieldExecuter|cmdScrollFieldReporter|cmdShell|coarsenSubdivSelectionList|collision|color|colorAtPoint|colorEditor|colorIndex|colorIndexSliderGrp|colorSliderButtonGrp|colorSliderGrp|columnLayout|commandEcho|commandLine|commandPort|compactHairSystem|componentEditor|compositingInterop|computePolysetVolume|condition|cone|confirmDialog|connectAttr|connectControl|connectDynamic|connectJoint|connectionInfo|constrain|constrainValue|constructionHistory|container|containsMultibyte|contextInfo|control|convertFromOldLayers|convertIffToPsd|convertLightmap|convertSolidTx|convertTessellation|convertUnit|copyArray|copyFlexor|copyKey|copySkinWeights|cos|cpButton|cpCache|cpClothSet|cpCollision|cpConstraint|cpConvClothToMesh|cpForces|cpGetSolverAttr|cpPanel|cpProperty|cpRigidCollisionFilter|cpSeam|cpSetEdit|cpSetSolverAttr|cpSolver|cpSolverTypes|cpTool|cpUpdateClothUVs|createDisplayLayer|createDrawCtx|createEditor|createLayeredPsdFile|createMotionField|createNewShelf|createNode|createRenderLayer|createSubdivRegion|cross|crossProduct|ctxAbort|ctxCompletion|ctxEditMode|ctxTraverse|currentCtx|currentTime|currentTimeCtx|currentUnit|curve|curveAddPtCtx|curveCVCtx|curveEPCtx|curveEditorCtx|curveIntersect|curveMoveEPCtx|curveOnSurface|curveSketchCtx|cutKey|cycleCheck|cylinder|dagPose|date|defaultLightListCheckBox|defaultNavigation|defineDataServer|defineVirtualDevice|deformer|deg_to_rad|delete|deleteAttr|deleteShadingGroupsAndMaterials|deleteShelfTab|deleteUI|deleteUnusedBrushes|delrandstr|detachCurve|detachDeviceAttr|detachSurface|deviceEditor|devicePanel|dgInfo|dgdirty|dgeval|dgtimer|dimWhen|directKeyCtx|directionalLight|dirmap|dirname|disable|disconnectAttr|disconnectJoint|diskCache|displacementToPoly|displayAffected|displayColor|displayCull|displayLevelOfDetail|displayPref|displayRGBColor|displaySmoothness|displayStats|displayString|displaySurface|distanceDimContext|distanceDimension|doBlur|dolly|dollyCtx|dopeSheetEditor|dot|dotProduct|doubleProfileBirailSurface|drag|dragAttrContext|draggerContext|dropoffLocator|duplicate|duplicateCurve|duplicateSurface|dynCache|dynControl|dynExport|dynExpression|dynGlobals|dynPaintEditor|dynParticleCtx|dynPref|dynRelEdPanel|dynRelEditor|dynamicLoad|editAttrLimits|editDisplayLayerGlobals|editDisplayLayerMembers|editRenderLayerAdjustment|editRenderLayerGlobals|editRenderLayerMembers|editor|editorTemplate|effector|emit|emitter|enableDevice|encodeString|endString|endsWith|env|equivalent|equivalentTol|erf|error|eval|evalDeferred|evalEcho|event|exactWorldBoundingBox|exclusiveLightCheckBox|exec|executeForEachObject|exists|exp|expression|expressionEditorListen|extendCurve|extendSurface|extrude|fcheck|fclose|feof|fflush|fgetline|fgetword|file|fileBrowserDialog|fileDialog|fileExtension|fileInfo|filetest|filletCurve|filter|filterCurve|filterExpand|filterStudioImport|findAllIntersections|findAnimCurves|findKeyframe|findMenuItem|findRelatedSkinCluster|finder|firstParentOf|fitBspline|flexor|floatEq|floatField|floatFieldGrp|floatScrollBar|floatSlider|floatSlider2|floatSliderButtonGrp|floatSliderGrp|floor|flow|fluidCacheInfo|fluidEmitter|fluidVoxelInfo|flushUndo|fmod|fontDialog|fopen|formLayout|format|fprint|frameLayout|fread|freeFormFillet|frewind|fromNativePath|fwrite|gamma|gauss|geometryConstraint|getApplicationVersionAsFloat|getAttr|getClassification|getDefaultBrush|getFileList|getFluidAttr|getInputDeviceRange|getMayaPanelTypes|getModifiers|getPanel|getParticleAttr|getPluginResource|getenv|getpid|glRender|glRenderEditor|globalStitch|gmatch|goal|gotoBindPose|grabColor|gradientControl|gradientControlNoAttr|graphDollyCtx|graphSelectContext|graphTrackCtx|gravity|grid|gridLayout|group|groupObjectsByName|hardenPointCurve|hardware|hardwareRenderPanel|headsUpDisplay|headsUpMessage|help|helpLine|hermite|hide|hilite|hitTest|hotBox|hotkey|hotkeyCheck|hsv_to_rgb|hudButton|hudSlider|hudSliderButton|hwReflectionMap|hwRender|hwRenderLoad|hyperGraph|hyperPanel|hyperShade|hypot|iconTextButton|iconTextCheckBox|iconTextRadioButton|iconTextRadioCollection|iconTextScrollList|iconTextStaticLabel|ikHandle|ikHandleCtx|ikHandleDisplayScale|ikSolver|ikSplineHandleCtx|ikSystem|ikSystemInfo|ikfkDisplayMethod|illustratorCurves|image|imfPlugins|inheritTransform|insertJoint|insertJointCtx|insertKeyCtx|insertKnotCurve|insertKnotSurface|instance|instanceable|instancer|intField|intFieldGrp|intScrollBar|intSlider|intSliderGrp|interToUI|internalVar|intersect|iprEngine|isAnimCurve|isConnected|isDirty|isParentOf|isSameObject|isTrue|isValidObjectName|isValidString|isValidUiName|isolateSelect|itemFilter|itemFilterAttr|itemFilterRender|itemFilterType|joint|jointCluster|jointCtx|jointDisplayScale|jointLattice|keyTangent|keyframe|keyframeOutliner|keyframeRegionCurrentTimeCtx|keyframeRegionDirectKeyCtx|keyframeRegionDollyCtx|keyframeRegionInsertKeyCtx|keyframeRegionMoveKeyCtx|keyframeRegionScaleKeyCtx|keyframeRegionSelectKeyCtx|keyframeRegionSetKeyCtx|keyframeRegionTrackCtx|keyframeStats|lassoContext|lattice|latticeDeformKeyCtx|launch|launchImageEditor|layerButton|layeredShaderPort|layeredTexturePort|layout|layoutDialog|lightList|lightListEditor|lightListPanel|lightlink|lineIntersection|linearPrecision|linstep|listAnimatable|listAttr|listCameras|listConnections|listDeviceAttachments|listHistory|listInputDeviceAxes|listInputDeviceButtons|listInputDevices|listMenuAnnotation|listNodeTypes|listPanelCategories|listRelatives|listSets|listTransforms|listUnselected|listerEditor|loadFluid|loadNewShelf|loadPlugin|loadPluginLanguageResources|loadPrefObjects|localizedPanelLabel|lockNode|loft|log|longNameOf|lookThru|ls|lsThroughFilter|lsType|lsUI|mag|makeIdentity|makeLive|makePaintable|makeRoll|makeSingleSurface|makeTubeOn|makebot|manipMoveContext|manipMoveLimitsCtx|manipOptions|manipRotateContext|manipRotateLimitsCtx|manipScaleContext|manipScaleLimitsCtx|marker|match|max|memory|menu|menuBarLayout|menuEditor|menuItem|menuItemToShelf|menuSet|menuSetPref|messageLine|min|minimizeApp|mirrorJoint|modelCurrentTimeCtx|modelEditor|modelPanel|mouse|movIn|movOut|move|moveIKtoFK|moveKeyCtx|moveVertexAlongDirection|multiProfileBirailSurface|mute|nParticle|nameCommand|nameField|namespace|namespaceInfo|newPanelItems|newton|nodeCast|nodeIconButton|nodeOutliner|nodePreset|nodeType|noise|nonLinear|normalConstraint|normalize|nurbsBoolean|nurbsCopyUVSet|nurbsCube|nurbsEditUV|nurbsPlane|nurbsSelect|nurbsSquare|nurbsToPoly|nurbsToPolygonsPref|nurbsToSubdiv|nurbsToSubdivPref|nurbsUVSet|nurbsViewDirectionVector|objExists|objectCenter|objectLayer|objectType|objectTypeUI|obsoleteProc|oceanNurbsPreviewPlane|offsetCurve|offsetCurveOnSurface|offsetSurface|openGLExtension|openMayaPref|optionMenu|optionMenuGrp|optionVar|orbit|orbitCtx|orientConstraint|outlinerEditor|outlinerPanel|overrideModifier|paintEffectsDisplay|pairBlend|palettePort|paneLayout|panel|panelConfiguration|panelHistory|paramDimContext|paramDimension|paramLocator|parent|parentConstraint|particle|particleExists|particleInstancer|particleRenderInfo|partition|pasteKey|pathAnimation|pause|pclose|percent|performanceOptions|pfxstrokes|pickWalk|picture|pixelMove|planarSrf|plane|play|playbackOptions|playblast|plugAttr|plugNode|pluginInfo|pluginResourceUtil|pointConstraint|pointCurveConstraint|pointLight|pointMatrixMult|pointOnCurve|pointOnSurface|pointPosition|poleVectorConstraint|polyAppend|polyAppendFacetCtx|polyAppendVertex|polyAutoProjection|polyAverageNormal|polyAverageVertex|polyBevel|polyBlendColor|polyBlindData|polyBoolOp|polyBridgeEdge|polyCacheMonitor|polyCheck|polyChipOff|polyClipboard|polyCloseBorder|polyCollapseEdge|polyCollapseFacet|polyColorBlindData|polyColorDel|polyColorPerVertex|polyColorSet|polyCompare|polyCone|polyCopyUV|polyCrease|polyCreaseCtx|polyCreateFacet|polyCreateFacetCtx|polyCube|polyCut|polyCutCtx|polyCylinder|polyCylindricalProjection|polyDelEdge|polyDelFacet|polyDelVertex|polyDuplicateAndConnect|polyDuplicateEdge|polyEditUV|polyEditUVShell|polyEvaluate|polyExtrudeEdge|polyExtrudeFacet|polyExtrudeVertex|polyFlipEdge|polyFlipUV|polyForceUV|polyGeoSampler|polyHelix|polyInfo|polyInstallAction|polyLayoutUV|polyListComponentConversion|polyMapCut|polyMapDel|polyMapSew|polyMapSewMove|polyMergeEdge|polyMergeEdgeCtx|polyMergeFacet|polyMergeFacetCtx|polyMergeUV|polyMergeVertex|polyMirrorFace|polyMoveEdge|polyMoveFacet|polyMoveFacetUV|polyMoveUV|polyMoveVertex|polyNormal|polyNormalPerVertex|polyNormalizeUV|polyOptUvs|polyOptions|polyOutput|polyPipe|polyPlanarProjection|polyPlane|polyPlatonicSolid|polyPoke|polyPrimitive|polyPrism|polyProjection|polyPyramid|polyQuad|polyQueryBlindData|polyReduce|polySelect|polySelectConstraint|polySelectConstraintMonitor|polySelectCtx|polySelectEditCtx|polySeparate|polySetToFaceNormal|polySewEdge|polyShortestPathCtx|polySmooth|polySoftEdge|polySphere|polySphericalProjection|polySplit|polySplitCtx|polySplitEdge|polySplitRing|polySplitVertex|polyStraightenUVBorder|polySubdivideEdge|polySubdivideFacet|polyToSubdiv|polyTorus|polyTransfer|polyTriangulate|polyUVSet|polyUnite|polyWedgeFace|popen|popupMenu|pose|pow|preloadRefEd|print|progressBar|progressWindow|projFileViewer|projectCurve|projectTangent|projectionContext|projectionManip|promptDialog|propModCtx|propMove|psdChannelOutliner|psdEditTextureFile|psdExport|psdTextureFile|putenv|pwd|python|querySubdiv|quit|rad_to_deg|radial|radioButton|radioButtonGrp|radioCollection|radioMenuItemCollection|rampColorPort|rand|randomizeFollicles|randstate|rangeControl|readTake|rebuildCurve|rebuildSurface|recordAttr|recordDevice|redo|reference|referenceEdit|referenceQuery|refineSubdivSelectionList|refresh|refreshAE|registerPluginResource|rehash|reloadImage|removeJoint|removeMultiInstance|removePanelCategory|rename|renameAttr|renameSelectionList|renameUI|render|renderGlobalsNode|renderInfo|renderLayerButton|renderLayerParent|renderLayerPostProcess|renderLayerUnparent|renderManip|renderPartition|renderQualityNode|renderSettings|renderThumbnailUpdate|renderWindowEditor|renderWindowSelectContext|renderer|reorder|reorderDeformers|requires|reroot|resampleFluid|resetAE|resetPfxToPolyCamera|resetTool|resolutionNode|retarget|reverseCurve|reverseSurface|revolve|rgb_to_hsv|rigidBody|rigidSolver|roll|rollCtx|rootOf|rot|rotate|rotationInterpolation|roundConstantRadius|rowColumnLayout|rowLayout|runTimeCommand|runup|sampleImage|saveAllShelves|saveAttrPreset|saveFluid|saveImage|saveInitialState|saveMenu|savePrefObjects|savePrefs|saveShelf|saveToolSettings|scale|scaleBrushBrightness|scaleComponents|scaleConstraint|scaleKey|scaleKeyCtx|sceneEditor|sceneUIReplacement|scmh|scriptCtx|scriptEditorInfo|scriptJob|scriptNode|scriptTable|scriptToShelf|scriptedPanel|scriptedPanelType|scrollField|scrollLayout|sculpt|searchPathArray|seed|selLoadSettings|select|selectContext|selectCurveCV|selectKey|selectKeyCtx|selectKeyframeRegionCtx|selectMode|selectPref|selectPriority|selectType|selectedNodes|selectionConnection|separator|setAttr|setAttrEnumResource|setAttrMapping|setAttrNiceNameResource|setConstraintRestPosition|setDefaultShadingGroup|setDrivenKeyframe|setDynamic|setEditCtx|setEditor|setFluidAttr|setFocus|setInfinity|setInputDeviceMapping|setKeyCtx|setKeyPath|setKeyframe|setKeyframeBlendshapeTargetWts|setMenuMode|setNodeNiceNameResource|setNodeTypeFlag|setParent|setParticleAttr|setPfxToPolyCamera|setPluginResource|setProject|setStampDensity|setStartupMessage|setState|setToolTo|setUITemplate|setXformManip|sets|shadingConnection|shadingGeometryRelCtx|shadingLightRelCtx|shadingNetworkCompare|shadingNode|shapeCompare|shelfButton|shelfLayout|shelfTabLayout|shellField|shortNameOf|showHelp|showHidden|showManipCtx|showSelectionInTitle|showShadingGroupAttrEditor|showWindow|sign|simplify|sin|singleProfileBirailSurface|size|sizeBytes|skinCluster|skinPercent|smoothCurve|smoothTangentSurface|smoothstep|snap2to2|snapKey|snapMode|snapTogetherCtx|snapshot|soft|softMod|softModCtx|sort|sound|soundControl|source|spaceLocator|sphere|sphrand|spotLight|spotLightPreviewPort|spreadSheetEditor|spring|sqrt|squareSurface|srtContext|stackTrace|startString|startsWith|stitchAndExplodeShell|stitchSurface|stitchSurfacePoints|strcmp|stringArrayCatenate|stringArrayContains|stringArrayCount|stringArrayInsertAtIndex|stringArrayIntersector|stringArrayRemove|stringArrayRemoveAtIndex|stringArrayRemoveDuplicates|stringArrayRemoveExact|stringArrayToString|stringToStringArray|strip|stripPrefixFromName|stroke|subdAutoProjection|subdCleanTopology|subdCollapse|subdDuplicateAndConnect|subdEditUV|subdListComponentConversion|subdMapCut|subdMapSewMove|subdMatchTopology|subdMirror|subdToBlind|subdToPoly|subdTransferUVsToCache|subdiv|subdivCrease|subdivDisplaySmoothness|substitute|substituteAllString|substituteGeometry|substring|surface|surfaceSampler|surfaceShaderList|swatchDisplayPort|switchTable|symbolButton|symbolCheckBox|sysFile|system|tabLayout|tan|tangentConstraint|texLatticeDeformContext|texManipContext|texMoveContext|texMoveUVShellContext|texRotateContext|texScaleContext|texSelectContext|texSelectShortestPathCtx|texSmudgeUVContext|texWinToolCtx|text|textCurves|textField|textFieldButtonGrp|textFieldGrp|textManip|textScrollList|textToShelf|textureDisplacePlane|textureHairColor|texturePlacementContext|textureWindow|threadCount|threePointArcCtx|timeControl|timePort|timerX|toNativePath|toggle|toggleAxis|toggleWindowVisibility|tokenize|tokenizeList|tolerance|tolower|toolButton|toolCollection|toolDropped|toolHasOptions|toolPropertyWindow|torus|toupper|trace|track|trackCtx|transferAttributes|transformCompare|transformLimits|translator|trim|trunc|truncateFluidCache|truncateHairCache|tumble|tumbleCtx|turbulence|twoPointArcCtx|uiRes|uiTemplate|unassignInputDevice|undo|undoInfo|ungroup|uniform|unit|unloadPlugin|untangleUV|untitledFileName|untrim|upAxis|updateAE|userCtx|uvLink|uvSnapshot|validateShelfName|vectorize|view2dToolCtx|viewCamera|viewClipPlane|viewFit|viewHeadOn|viewLookAt|viewManip|viewPlace|viewSet|visor|volumeAxis|vortex|waitCursor|warning|webBrowser|webBrowserPrefs|whatIs|window|windowPref|wire|wireContext|workspace|wrinkle|wrinkleContext|writeTake|xbmLangPathList|xform)\b/,
	    operator: [
	      /\+[+=]?|-[-=]?|&&|\|\||[<>]=|[*\/!=]=?|[%^]/,
	      {
	        // We don't want to match <<
	        pattern: /(^|[^<])<(?!<)/,
	        lookbehind: true
	      },
	      {
	        // We don't want to match >>
	        pattern: /(^|[^>])>(?!>)/,
	        lookbehind: true
	      }
	    ],
	    punctuation: /<<|>>|[.,:;?\[\](){}]/
	  };
	  Prism.languages.mel['code'].inside.rest = Prism.languages.mel;
	}
	return mel_1;
}

var mermaid_1;
var hasRequiredMermaid;

function requireMermaid () {
	if (hasRequiredMermaid) return mermaid_1;
	hasRequiredMermaid = 1;

	mermaid_1 = mermaid;
	mermaid.displayName = 'mermaid';
	mermaid.aliases = [];
	function mermaid(Prism) {
	  Prism.languages.mermaid = {
	    comment: {
	      pattern: /%%.*/,
	      greedy: true
	    },
	    style: {
	      pattern:
	        /^([ \t]*(?:classDef|linkStyle|style)[ \t]+[\w$-]+[ \t]+)\w.*[^\s;]/m,
	      lookbehind: true,
	      inside: {
	        property: /\b\w[\w-]*(?=[ \t]*:)/,
	        operator: /:/,
	        punctuation: /,/
	      }
	    },
	    'inter-arrow-label': {
	      pattern:
	        /([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \t]*(?:"[^"\r\n]*"|[^\s".=-](?:[^\r\n.=-]*[^\s.=-])?)[ \t]*(?:\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,
	      lookbehind: true,
	      greedy: true,
	      inside: {
	        arrow: {
	          pattern: /(?:\.+->?|--+[->]|==+[=>])$/,
	          alias: 'operator'
	        },
	        label: {
	          pattern: /^([\s\S]{2}[ \t]*)\S(?:[\s\S]*\S)?/,
	          lookbehind: true,
	          alias: 'property'
	        },
	        'arrow-head': {
	          pattern: /^\S+/,
	          alias: ['arrow', 'operator']
	        }
	      }
	    },
	    arrow: [
	      // This might look complex but it really isn't.
	      // There are many possible arrows (see tests) and it's impossible to fit all of them into one pattern. The
	      // problem is that we only have one lookbehind per pattern. However, we cannot disallow too many arrow
	      // characters in the one lookbehind because that would create too many false negatives. So we have to split the
	      // arrows into different patterns.
	      {
	        // ER diagram
	        pattern: /(^|[^{}|o.-])[|}][|o](?:--|\.\.)[|o][|{](?![{}|o.-])/,
	        lookbehind: true,
	        alias: 'operator'
	      },
	      {
	        // flow chart
	        // (?:==+|--+|-\.*-)
	        pattern:
	          /(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\.*-)[>ox]?|(?:==+|--+|-\.*-)[>ox]|===+|---+|-\.+-)(?![<>ox.=-])/,
	        lookbehind: true,
	        alias: 'operator'
	      },
	      {
	        // sequence diagram
	        pattern:
	          /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,
	        lookbehind: true,
	        alias: 'operator'
	      },
	      {
	        // class diagram
	        pattern:
	          /(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\|?(?:--|\.\.)|(?:--|\.\.)\|?>|--|\.\.)(?![<>|*o.-])/,
	        lookbehind: true,
	        alias: 'operator'
	      }
	    ],
	    label: {
	      pattern: /(^|[^|<])\|(?:[^\r\n"|]|"[^"\r\n]*")+\|/,
	      lookbehind: true,
	      greedy: true,
	      alias: 'property'
	    },
	    text: {
	      pattern: /(?:[(\[{]+|\b>)(?:[^\r\n"()\[\]{}]|"[^"\r\n]*")+(?:[)\]}]+|>)/,
	      alias: 'string'
	    },
	    string: {
	      pattern: /"[^"\r\n]*"/,
	      greedy: true
	    },
	    annotation: {
	      pattern:
	        /<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\[\[(?:choice|fork|join)\]\]/i,
	      alias: 'important'
	    },
	    keyword: [
	      // This language has both case-sensitive and case-insensitive keywords
	      {
	        pattern:
	          /(^[ \t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\w$-])/m,
	        lookbehind: true,
	        greedy: true
	      },
	      {
	        pattern:
	          /(^[ \t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \t]+note)?|loop|opt|par|participant|rect|state|note[ \t]+(?:over|(?:left|right)[ \t]+of))(?![\w$-])/im,
	        lookbehind: true,
	        greedy: true
	      }
	    ],
	    entity: /#[a-z0-9]+;/,
	    operator: {
	      pattern: /(\w[ \t]*)&(?=[ \t]*\w)|:::|:/,
	      lookbehind: true
	    },
	    punctuation: /[(){};]/
	  };
	}
	return mermaid_1;
}

var mizar_1;
var hasRequiredMizar;

function requireMizar () {
	if (hasRequiredMizar) return mizar_1;
	hasRequiredMizar = 1;

	mizar_1 = mizar;
	mizar.displayName = 'mizar';
	mizar.aliases = [];
	function mizar(Prism) {
	  Prism.languages.mizar = {
	    comment: /::.+/,
	    keyword:
	      /@proof\b|\b(?:according|aggregate|all|and|antonym|are|as|associativity|assume|asymmetry|attr|be|begin|being|by|canceled|case|cases|clusters?|coherence|commutativity|compatibility|connectedness|consider|consistency|constructors|contradiction|correctness|def|deffunc|define|definitions?|defpred|do|does|end|environ|equals|ex|exactly|existence|for|from|func|given|hence|hereby|holds|idempotence|identity|iff?|implies|involutiveness|irreflexivity|is|it|let|means|mode|non|not|notations?|now|of|or|otherwise|over|per|pred|prefix|projectivity|proof|provided|qua|reconsider|redefine|reduce|reducibility|reflexivity|registrations?|requirements|reserve|sch|schemes?|section|selector|set|sethood|st|struct|such|suppose|symmetry|synonym|take|that|the|then|theorems?|thesis|thus|to|transitivity|uniqueness|vocabular(?:ies|y)|when|where|with|wrt)\b/,
	    parameter: {
	      pattern: /\$(?:10|\d)/,
	      alias: 'variable'
	    },
	    variable: /\b\w+(?=:)/,
	    number: /(?:\b|-)\d+\b/,
	    operator: /\.\.\.|->|&|\.?=/,
	    punctuation: /\(#|#\)|[,:;\[\](){}]/
	  };
	}
	return mizar_1;
}

var mongodb_1;
var hasRequiredMongodb;

function requireMongodb () {
	if (hasRequiredMongodb) return mongodb_1;
	hasRequiredMongodb = 1;

	mongodb_1 = mongodb;
	mongodb.displayName = 'mongodb';
	mongodb.aliases = [];
	function mongodb(Prism) {
(function (Prism) {
	    var operators = [
	      // query and projection
	      '$eq',
	      '$gt',
	      '$gte',
	      '$in',
	      '$lt',
	      '$lte',
	      '$ne',
	      '$nin',
	      '$and',
	      '$not',
	      '$nor',
	      '$or',
	      '$exists',
	      '$type',
	      '$expr',
	      '$jsonSchema',
	      '$mod',
	      '$regex',
	      '$text',
	      '$where',
	      '$geoIntersects',
	      '$geoWithin',
	      '$near',
	      '$nearSphere',
	      '$all',
	      '$elemMatch',
	      '$size',
	      '$bitsAllClear',
	      '$bitsAllSet',
	      '$bitsAnyClear',
	      '$bitsAnySet',
	      '$comment',
	      '$elemMatch',
	      '$meta',
	      '$slice', // update
	      '$currentDate',
	      '$inc',
	      '$min',
	      '$max',
	      '$mul',
	      '$rename',
	      '$set',
	      '$setOnInsert',
	      '$unset',
	      '$addToSet',
	      '$pop',
	      '$pull',
	      '$push',
	      '$pullAll',
	      '$each',
	      '$position',
	      '$slice',
	      '$sort',
	      '$bit', // aggregation pipeline stages
	      '$addFields',
	      '$bucket',
	      '$bucketAuto',
	      '$collStats',
	      '$count',
	      '$currentOp',
	      '$facet',
	      '$geoNear',
	      '$graphLookup',
	      '$group',
	      '$indexStats',
	      '$limit',
	      '$listLocalSessions',
	      '$listSessions',
	      '$lookup',
	      '$match',
	      '$merge',
	      '$out',
	      '$planCacheStats',
	      '$project',
	      '$redact',
	      '$replaceRoot',
	      '$replaceWith',
	      '$sample',
	      '$set',
	      '$skip',
	      '$sort',
	      '$sortByCount',
	      '$unionWith',
	      '$unset',
	      '$unwind',
	      '$setWindowFields', // aggregation pipeline operators
	      '$abs',
	      '$accumulator',
	      '$acos',
	      '$acosh',
	      '$add',
	      '$addToSet',
	      '$allElementsTrue',
	      '$and',
	      '$anyElementTrue',
	      '$arrayElemAt',
	      '$arrayToObject',
	      '$asin',
	      '$asinh',
	      '$atan',
	      '$atan2',
	      '$atanh',
	      '$avg',
	      '$binarySize',
	      '$bsonSize',
	      '$ceil',
	      '$cmp',
	      '$concat',
	      '$concatArrays',
	      '$cond',
	      '$convert',
	      '$cos',
	      '$dateFromParts',
	      '$dateToParts',
	      '$dateFromString',
	      '$dateToString',
	      '$dayOfMonth',
	      '$dayOfWeek',
	      '$dayOfYear',
	      '$degreesToRadians',
	      '$divide',
	      '$eq',
	      '$exp',
	      '$filter',
	      '$first',
	      '$floor',
	      '$function',
	      '$gt',
	      '$gte',
	      '$hour',
	      '$ifNull',
	      '$in',
	      '$indexOfArray',
	      '$indexOfBytes',
	      '$indexOfCP',
	      '$isArray',
	      '$isNumber',
	      '$isoDayOfWeek',
	      '$isoWeek',
	      '$isoWeekYear',
	      '$last',
	      '$last',
	      '$let',
	      '$literal',
	      '$ln',
	      '$log',
	      '$log10',
	      '$lt',
	      '$lte',
	      '$ltrim',
	      '$map',
	      '$max',
	      '$mergeObjects',
	      '$meta',
	      '$min',
	      '$millisecond',
	      '$minute',
	      '$mod',
	      '$month',
	      '$multiply',
	      '$ne',
	      '$not',
	      '$objectToArray',
	      '$or',
	      '$pow',
	      '$push',
	      '$radiansToDegrees',
	      '$range',
	      '$reduce',
	      '$regexFind',
	      '$regexFindAll',
	      '$regexMatch',
	      '$replaceOne',
	      '$replaceAll',
	      '$reverseArray',
	      '$round',
	      '$rtrim',
	      '$second',
	      '$setDifference',
	      '$setEquals',
	      '$setIntersection',
	      '$setIsSubset',
	      '$setUnion',
	      '$size',
	      '$sin',
	      '$slice',
	      '$split',
	      '$sqrt',
	      '$stdDevPop',
	      '$stdDevSamp',
	      '$strcasecmp',
	      '$strLenBytes',
	      '$strLenCP',
	      '$substr',
	      '$substrBytes',
	      '$substrCP',
	      '$subtract',
	      '$sum',
	      '$switch',
	      '$tan',
	      '$toBool',
	      '$toDate',
	      '$toDecimal',
	      '$toDouble',
	      '$toInt',
	      '$toLong',
	      '$toObjectId',
	      '$toString',
	      '$toLower',
	      '$toUpper',
	      '$trim',
	      '$trunc',
	      '$type',
	      '$week',
	      '$year',
	      '$zip',
	      '$count',
	      '$dateAdd',
	      '$dateDiff',
	      '$dateSubtract',
	      '$dateTrunc',
	      '$getField',
	      '$rand',
	      '$sampleRate',
	      '$setField',
	      '$unsetField', // aggregation pipeline query modifiers
	      '$comment',
	      '$explain',
	      '$hint',
	      '$max',
	      '$maxTimeMS',
	      '$min',
	      '$orderby',
	      '$query',
	      '$returnKey',
	      '$showDiskLoc',
	      '$natural'
	    ];
	    var builtinFunctions = [
	      'ObjectId',
	      'Code',
	      'BinData',
	      'DBRef',
	      'Timestamp',
	      'NumberLong',
	      'NumberDecimal',
	      'MaxKey',
	      'MinKey',
	      'RegExp',
	      'ISODate',
	      'UUID'
	    ];
	    operators = operators.map(function (operator) {
	      return operator.replace('$', '\\$')
	    });
	    var operatorsSource = '(?:' + operators.join('|') + ')\\b';
	    Prism.languages.mongodb = Prism.languages.extend('javascript', {});
	    Prism.languages.insertBefore('mongodb', 'string', {
	      property: {
	        pattern:
	          /(?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)(?=\s*:)/,
	        greedy: true,
	        inside: {
	          keyword: RegExp('^([\'"])?' + operatorsSource + '(?:\\1)?$')
	        }
	      }
	    });
	    Prism.languages.mongodb.string.inside = {
	      url: {
	        // url pattern
	        pattern:
	          /https?:\/\/[-\w@:%.+~#=]{1,256}\.[a-z0-9()]{1,6}\b[-\w()@:%+.~#?&/=]*/i,
	        greedy: true
	      },
	      entity: {
	        // ipv4
	        pattern:
	          /\b(?:(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d\d?|2[0-4]\d|25[0-5])\b/,
	        greedy: true
	      }
	    };
	    Prism.languages.insertBefore('mongodb', 'constant', {
	      builtin: {
	        pattern: RegExp('\\b(?:' + builtinFunctions.join('|') + ')\\b'),
	        alias: 'keyword'
	      }
	    });
	  })(Prism);
	}
	return mongodb_1;
}

var monkey_1;
var hasRequiredMonkey;

function requireMonkey () {
	if (hasRequiredMonkey) return monkey_1;
	hasRequiredMonkey = 1;

	monkey_1 = monkey;
	monkey.displayName = 'monkey';
	monkey.aliases = [];
	function monkey(Prism) {
	  Prism.languages.monkey = {
	    comment: {
	      pattern: /^#Rem\s[\s\S]*?^#End|'.+/im,
	      greedy: true
	    },
	    string: {
	      pattern: /"[^"\r\n]*"/,
	      greedy: true
	    },
	    preprocessor: {
	      pattern: /(^[ \t]*)#.+/m,
	      lookbehind: true,
	      greedy: true,
	      alias: 'property'
	    },
	    function: /\b\w+(?=\()/,
	    'type-char': {
	      pattern: /\b[?%#$]/,
	      alias: 'class-name'
	    },
	    number: {
	      pattern:
	        /((?:\.\.)?)(?:(?:\b|\B-\.?|\B\.)\d+(?:(?!\.\.)\.\d*)?|\$[\da-f]+)/i,
	      lookbehind: true
	    },
	    keyword:
	      /\b(?:Abstract|Array|Bool|Case|Catch|Class|Const|Continue|Default|Eachin|Else|ElseIf|End|EndIf|Exit|Extends|Extern|False|Field|Final|Float|For|Forever|Function|Global|If|Implements|Import|Inline|Int|Interface|Local|Method|Module|New|Next|Null|Object|Private|Property|Public|Repeat|Return|Select|Self|Step|Strict|String|Super|Then|Throw|To|True|Try|Until|Void|Wend|While)\b/i,
	    operator:
	      /\.\.|<[=>]?|>=?|:?=|(?:[+\-*\/&~|]|\b(?:Mod|Shl|Shr)\b)=?|\b(?:And|Not|Or)\b/i,
	    punctuation: /[.,:;()\[\]]/
	  };
	}
	return monkey_1;
}

var moonscript_1;
var hasRequiredMoonscript;

function requireMoonscript () {
	if (hasRequiredMoonscript) return moonscript_1;
	hasRequiredMoonscript = 1;

	moonscript_1 = moonscript;
	moonscript.displayName = 'moonscript';
	moonscript.aliases = ['moon'];
	function moonscript(Prism) {
	  Prism.languages.moonscript = {
	    comment: /--.*/,
	    string: [
	      {
	        pattern: /'[^']*'|\[(=*)\[[\s\S]*?\]\1\]/,
	        greedy: true
	      },
	      {
	        pattern: /"[^"]*"/,
	        greedy: true,
	        inside: {
	          interpolation: {
	            pattern: /#\{[^{}]*\}/,
	            inside: {
	              moonscript: {
	                pattern: /(^#\{)[\s\S]+(?=\})/,
	                lookbehind: true,
	                inside: null // see beow
	              },
	              'interpolation-punctuation': {
	                pattern: /#\{|\}/,
	                alias: 'punctuation'
	              }
	            }
	          }
	        }
	      }
	    ],
	    'class-name': [
	      {
	        pattern: /(\b(?:class|extends)[ \t]+)\w+/,
	        lookbehind: true
	      }, // class-like names start with a capital letter
	      /\b[A-Z]\w*/
	    ],
	    keyword:
	      /\b(?:class|continue|do|else|elseif|export|extends|for|from|if|import|in|local|nil|return|self|super|switch|then|unless|using|when|while|with)\b/,
	    variable: /@@?\w*/,
	    property: {
	      pattern: /\b(?!\d)\w+(?=:)|(:)(?!\d)\w+/,
	      lookbehind: true
	    },
	    function: {
	      pattern:
	        /\b(?:_G|_VERSION|assert|collectgarbage|coroutine\.(?:create|resume|running|status|wrap|yield)|debug\.(?:debug|getfenv|gethook|getinfo|getlocal|getmetatable|getregistry|getupvalue|setfenv|sethook|setlocal|setmetatable|setupvalue|traceback)|dofile|error|getfenv|getmetatable|io\.(?:close|flush|input|lines|open|output|popen|read|stderr|stdin|stdout|tmpfile|type|write)|ipairs|load|loadfile|loadstring|math\.(?:abs|acos|asin|atan|atan2|ceil|cos|cosh|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pi|pow|rad|random|randomseed|sin|sinh|sqrt|tan|tanh)|module|next|os\.(?:clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package\.(?:cpath|loaded|loadlib|path|preload|seeall)|pairs|pcall|print|rawequal|rawget|rawset|require|select|setfenv|setmetatable|string\.(?:byte|char|dump|find|format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper)|table\.(?:concat|insert|maxn|remove|sort)|tonumber|tostring|type|unpack|xpcall)\b/,
	      inside: {
	        punctuation: /\./
	      }
	    },
	    boolean: /\b(?:false|true)\b/,
	    number:
	      /(?:\B\.\d+|\b\d+\.\d+|\b\d+(?=[eE]))(?:[eE][-+]?\d+)?\b|\b(?:0x[a-fA-F\d]+|\d+)(?:U?LL)?\b/,
	    operator:
	      /\.{3}|[-=]>|~=|(?:[-+*/%<>!=]|\.\.)=?|[:#^]|\b(?:and|or)\b=?|\b(?:not)\b/,
	    punctuation: /[.,()[\]{}\\]/
	  };
	  Prism.languages.moonscript.string[1].inside.interpolation.inside.moonscript.inside =
	    Prism.languages.moonscript;
	  Prism.languages.moon = Prism.languages.moonscript;
	}
	return moonscript_1;
}

var n1ql_1;
var hasRequiredN1ql;

function requireN1ql () {
	if (hasRequiredN1ql) return n1ql_1;
	hasRequiredN1ql = 1;

	n1ql_1 = n1ql;
	n1ql.displayName = 'n1ql';
	n1ql.aliases = [];
	function n1ql(Prism) {
	  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/index.html
	  Prism.languages.n1ql = {
	    comment: {
	      pattern: /\/\*[\s\S]*?(?:$|\*\/)|--.*/,
	      greedy: true
	    },
	    string: {
	      pattern: /(["'])(?:\\[\s\S]|(?!\1)[^\\]|\1\1)*\1/,
	      greedy: true
	    },
	    identifier: {
	      pattern: /`(?:\\[\s\S]|[^\\`]|``)*`/,
	      greedy: true
	    },
	    parameter: /\$[\w.]+/,
	    // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html#n1ql-reserved-words
	    keyword:
	      /\b(?:ADVISE|ALL|ALTER|ANALYZE|AS|ASC|AT|BEGIN|BINARY|BOOLEAN|BREAK|BUCKET|BUILD|BY|CALL|CAST|CLUSTER|COLLATE|COLLECTION|COMMIT|COMMITTED|CONNECT|CONTINUE|CORRELATE|CORRELATED|COVER|CREATE|CURRENT|DATABASE|DATASET|DATASTORE|DECLARE|DECREMENT|DELETE|DERIVED|DESC|DESCRIBE|DISTINCT|DO|DROP|EACH|ELEMENT|EXCEPT|EXCLUDE|EXECUTE|EXPLAIN|FETCH|FILTER|FLATTEN|FLUSH|FOLLOWING|FOR|FORCE|FROM|FTS|FUNCTION|GOLANG|GRANT|GROUP|GROUPS|GSI|HASH|HAVING|IF|IGNORE|ILIKE|INCLUDE|INCREMENT|INDEX|INFER|INLINE|INNER|INSERT|INTERSECT|INTO|IS|ISOLATION|JAVASCRIPT|JOIN|KEY|KEYS|KEYSPACE|KNOWN|LANGUAGE|LAST|LEFT|LET|LETTING|LEVEL|LIMIT|LSM|MAP|MAPPING|MATCHED|MATERIALIZED|MERGE|MINUS|MISSING|NAMESPACE|NEST|NL|NO|NTH_VALUE|NULL|NULLS|NUMBER|OBJECT|OFFSET|ON|OPTION|OPTIONS|ORDER|OTHERS|OUTER|OVER|PARSE|PARTITION|PASSWORD|PATH|POOL|PRECEDING|PREPARE|PRIMARY|PRIVATE|PRIVILEGE|PROBE|PROCEDURE|PUBLIC|RANGE|RAW|REALM|REDUCE|RENAME|RESPECT|RETURN|RETURNING|REVOKE|RIGHT|ROLE|ROLLBACK|ROW|ROWS|SATISFIES|SAVEPOINT|SCHEMA|SCOPE|SELECT|SELF|SEMI|SET|SHOW|SOME|START|STATISTICS|STRING|SYSTEM|TIES|TO|TRAN|TRANSACTION|TRIGGER|TRUNCATE|UNBOUNDED|UNDER|UNION|UNIQUE|UNKNOWN|UNNEST|UNSET|UPDATE|UPSERT|USE|USER|USING|VALIDATE|VALUE|VALUES|VIA|VIEW|WHERE|WHILE|WINDOW|WITH|WORK|XOR)\b/i,
	    function: /\b[a-z_]\w*(?=\s*\()/i,
	    boolean: /\b(?:FALSE|TRUE)\b/i,
	    number: /(?:\b\d+\.|\B\.)\d+e[+\-]?\d+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
	    operator:
	      /[-+*\/%]|!=|==?|\|\||<[>=]?|>=?|\b(?:AND|ANY|ARRAY|BETWEEN|CASE|ELSE|END|EVERY|EXISTS|FIRST|IN|LIKE|NOT|OR|THEN|VALUED|WHEN|WITHIN)\b/i,
	    punctuation: /[;[\](),.{}:]/
	  };
	}
	return n1ql_1;
}

var n4js_1;
var hasRequiredN4js;

function requireN4js () {
	if (hasRequiredN4js) return n4js_1;
	hasRequiredN4js = 1;

	n4js_1 = n4js;
	n4js.displayName = 'n4js';
	n4js.aliases = ['n4jsd'];
	function n4js(Prism) {
	  Prism.languages.n4js = Prism.languages.extend('javascript', {
	    // Keywords from N4JS language spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html
	    keyword:
	      /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/
	  });
	  Prism.languages.insertBefore('n4js', 'constant', {
	    // Annotations in N4JS spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html#_annotations
	    annotation: {
	      pattern: /@+\w+/,
	      alias: 'operator'
	    }
	  });
	  Prism.languages.n4jsd = Prism.languages.n4js;
	}
	return n4js_1;
}

var nand2tetrisHdl_1;
var hasRequiredNand2tetrisHdl;

function requireNand2tetrisHdl () {
	if (hasRequiredNand2tetrisHdl) return nand2tetrisHdl_1;
	hasRequiredNand2tetrisHdl = 1;

	nand2tetrisHdl_1 = nand2tetrisHdl;
	nand2tetrisHdl.displayName = 'nand2tetrisHdl';
	nand2tetrisHdl.aliases = [];
	function nand2tetrisHdl(Prism) {
	  Prism.languages['nand2tetris-hdl'] = {
	    comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
	    keyword: /\b(?:BUILTIN|CHIP|CLOCKED|IN|OUT|PARTS)\b/,
	    boolean: /\b(?:false|true)\b/,
	    function: /\b[A-Za-z][A-Za-z0-9]*(?=\()/,
	    number: /\b\d+\b/,
	    operator: /=|\.\./,
	    punctuation: /[{}[\];(),:]/
	  };
	}
	return nand2tetrisHdl_1;
}

var naniscript_1;
var hasRequiredNaniscript;

function requireNaniscript () {
	if (hasRequiredNaniscript) return naniscript_1;
	hasRequiredNaniscript = 1;

	naniscript_1 = naniscript;
	naniscript.displayName = 'naniscript';
	naniscript.aliases = [];
	function naniscript(Prism) {
(function (Prism) {
	    var expressionDef = /\{[^\r\n\[\]{}]*\}/;
	    var params = {
	      'quoted-string': {
	        pattern: /"(?:[^"\\]|\\.)*"/,
	        alias: 'operator'
	      },
	      'command-param-id': {
	        pattern: /(\s)\w+:/,
	        lookbehind: true,
	        alias: 'property'
	      },
	      'command-param-value': [
	        {
	          pattern: expressionDef,
	          alias: 'selector'
	        },
	        {
	          pattern: /([\t ])\S+/,
	          lookbehind: true,
	          greedy: true,
	          alias: 'operator'
	        },
	        {
	          pattern: /\S(?:.*\S)?/,
	          alias: 'operator'
	        }
	      ]
	    };
	    Prism.languages.naniscript = {
	      // ; ...
	      comment: {
	        pattern: /^([\t ]*);.*/m,
	        lookbehind: true
	      },
	      // > ...
	      // Define is a control line starting with '>' followed by a word, a space and a text.
	      define: {
	        pattern: /^>.+/m,
	        alias: 'tag',
	        inside: {
	          value: {
	            pattern: /(^>\w+[\t ]+)(?!\s)[^{}\r\n]+/,
	            lookbehind: true,
	            alias: 'operator'
	          },
	          key: {
	            pattern: /(^>)\w+/,
	            lookbehind: true
	          }
	        }
	      },
	      // # ...
	      label: {
	        pattern: /^([\t ]*)#[\t ]*\w+[\t ]*$/m,
	        lookbehind: true,
	        alias: 'regex'
	      },
	      command: {
	        pattern: /^([\t ]*)@\w+(?=[\t ]|$).*/m,
	        lookbehind: true,
	        alias: 'function',
	        inside: {
	          'command-name': /^@\w+/,
	          expression: {
	            pattern: expressionDef,
	            greedy: true,
	            alias: 'selector'
	          },
	          'command-params': {
	            pattern: /\s*\S[\s\S]*/,
	            inside: params
	          }
	        }
	      },
	      // Generic is any line that doesn't start with operators: ;>#@
	      'generic-text': {
	        pattern: /(^[ \t]*)[^#@>;\s].*/m,
	        lookbehind: true,
	        alias: 'punctuation',
	        inside: {
	          // \{ ... \} ... \[ ... \] ... \"
	          'escaped-char': /\\[{}\[\]"]/,
	          expression: {
	            pattern: expressionDef,
	            greedy: true,
	            alias: 'selector'
	          },
	          'inline-command': {
	            pattern: /\[[\t ]*\w[^\r\n\[\]]*\]/,
	            greedy: true,
	            alias: 'function',
	            inside: {
	              'command-params': {
	                pattern: /(^\[[\t ]*\w+\b)[\s\S]+(?=\]$)/,
	                lookbehind: true,
	                inside: params
	              },
	              'command-param-name': {
	                pattern: /^(\[[\t ]*)\w+/,
	                lookbehind: true,
	                alias: 'name'
	              },
	              'start-stop-char': /[\[\]]/
	            }
	          }
	        }
	      }
	    };
	    Prism.languages.nani = Prism.languages['naniscript'];
	    /** @typedef {InstanceType<import("./prism-core")["Token"]>} Token */
	    /**
	     * This hook is used to validate generic-text tokens for balanced brackets.
	     * Mark token as bad-line when contains not balanced brackets: {},[]
	     */
	    Prism.hooks.add('after-tokenize', function (env) {
	      /** @type {(Token | string)[]} */
	      var tokens = env.tokens;
	      tokens.forEach(function (token) {
	        if (typeof token !== 'string' && token.type === 'generic-text') {
	          var content = getTextContent(token);
	          if (!isBracketsBalanced(content)) {
	            token.type = 'bad-line';
	            token.content = content;
	          }
	        }
	      });
	    });
	    /**
	     * @param {string} input
	     * @returns {boolean}
	     */
	    function isBracketsBalanced(input) {
	      var brackets = '[]{}';
	      var stack = [];
	      for (var i = 0; i < input.length; i++) {
	        var bracket = input[i];
	        var bracketsIndex = brackets.indexOf(bracket);
	        if (bracketsIndex !== -1) {
	          if (bracketsIndex % 2 === 0) {
	            stack.push(bracketsIndex + 1);
	          } else if (stack.pop() !== bracketsIndex) {
	            return false
	          }
	        }
	      }
	      return stack.length === 0
	    }
	    /**
	     * @param {string | Token | (string | Token)[]} token
	     * @returns {string}
	     */
	    function getTextContent(token) {
	      if (typeof token === 'string') {
	        return token
	      } else if (Array.isArray(token)) {
	        return token.map(getTextContent).join('')
	      } else {
	        return getTextContent(token.content)
	      }
	    }
	  })(Prism);
	}
	return naniscript_1;
}

var nasm_1;
var hasRequiredNasm;

function requireNasm () {
	if (hasRequiredNasm) return nasm_1;
	hasRequiredNasm = 1;

	nasm_1 = nasm;
	nasm.displayName = 'nasm';
	nasm.aliases = [];
	function nasm(Prism) {
	  Prism.languages.nasm = {
	    comment: /;.*$/m,
	    string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
	    label: {
	      pattern: /(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,
	      lookbehind: true,
	      alias: 'function'
	    },
	    keyword: [
	      /\[?BITS (?:16|32|64)\]?/,
	      {
	        pattern: /(^\s*)section\s*[a-z.]+:?/im,
	        lookbehind: true
	      },
	      /(?:extern|global)[^;\r\n]*/i,
	      /(?:CPU|DEFAULT|FLOAT).*$/m
	    ],
	    register: {
	      pattern:
	        /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s)\b/i,
	      alias: 'variable'
	    },
	    number:
	      /(?:\b|(?=\$))(?:0[hx](?:\.[\da-f]+|[\da-f]+(?:\.[\da-f]+)?)(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
	    operator: /[\[\]*+\-\/%<>=&|$!]/
	  };
	}
	return nasm_1;
}

var neon_1;
var hasRequiredNeon;

function requireNeon () {
	if (hasRequiredNeon) return neon_1;
	hasRequiredNeon = 1;

	neon_1 = neon;
	neon.displayName = 'neon';
	neon.aliases = [];
	function neon(Prism) {
	  Prism.languages.neon = {
	    comment: {
	      pattern: /#.*/,
	      greedy: true
	    },
	    datetime: {
	      pattern:
	        /(^|[[{(=:,\s])\d\d\d\d-\d\d?-\d\d?(?:(?:[Tt]| +)\d\d?:\d\d:\d\d(?:\.\d*)? *(?:Z|[-+]\d\d?(?::?\d\d)?)?)?(?=$|[\]}),\s])/,
	      lookbehind: true,
	      alias: 'number'
	    },
	    key: {
	      pattern: /(^|[[{(,\s])[^,:=[\]{}()'"\s]+(?=\s*:(?:$|[\]}),\s])|\s*=)/,
	      lookbehind: true,
	      alias: 'atrule'
	    },
	    number: {
	      pattern:
	        /(^|[[{(=:,\s])[+-]?(?:0x[\da-fA-F]+|0o[0-7]+|0b[01]+|(?:\d+(?:\.\d*)?|\.?\d+)(?:[eE][+-]?\d+)?)(?=$|[\]}),:=\s])/,
	      lookbehind: true
	    },
	    boolean: {
	      pattern: /(^|[[{(=:,\s])(?:false|no|true|yes)(?=$|[\]}),:=\s])/i,
	      lookbehind: true
	    },
	    null: {
	      pattern: /(^|[[{(=:,\s])(?:null)(?=$|[\]}),:=\s])/i,
	      lookbehind: true,
	      alias: 'keyword'
	    },
	    string: {
	      pattern:
	        /(^|[[{(=:,\s])(?:('''|""")\r?\n(?:(?:[^\r\n]|\r?\n(?![\t ]*\2))*\r?\n)?[\t ]*\2|'[^'\r\n]*'|"(?:\\.|[^\\"\r\n])*")/,
	      lookbehind: true,
	      greedy: true
	    },
	    literal: {
	      pattern:
	        /(^|[[{(=:,\s])(?:[^#"',:=[\]{}()\s`-]|[:-][^"',=[\]{}()\s])(?:[^,:=\]})(\s]|:(?![\s,\]})]|$)|[ \t]+[^#,:=\]})(\s])*/,
	      lookbehind: true,
	      alias: 'string'
	    },
	    punctuation: /[,:=[\]{}()-]/
	  };
	}
	return neon_1;
}

var nevod_1;
var hasRequiredNevod;

function requireNevod () {
	if (hasRequiredNevod) return nevod_1;
	hasRequiredNevod = 1;

	nevod_1 = nevod;
	nevod.displayName = 'nevod';
	nevod.aliases = [];
	function nevod(Prism) {
	  Prism.languages.nevod = {
	    comment: /\/\/.*|(?:\/\*[\s\S]*?(?:\*\/|$))/,
	    string: {
	      pattern: /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))!?\*?/,
	      greedy: true,
	      inside: {
	        'string-attrs': /!$|!\*$|\*$/
	      }
	    },
	    namespace: {
	      pattern: /(@namespace\s+)[a-zA-Z0-9\-.]+(?=\s*\{)/,
	      lookbehind: true
	    },
	    pattern: {
	      pattern:
	        /(@pattern\s+)?#?[a-zA-Z0-9\-.]+(?:\s*\(\s*(?:~\s*)?[a-zA-Z0-9\-.]+\s*(?:,\s*(?:~\s*)?[a-zA-Z0-9\-.]*)*\))?(?=\s*=)/,
	      lookbehind: true,
	      inside: {
	        'pattern-name': {
	          pattern: /^#?[a-zA-Z0-9\-.]+/,
	          alias: 'class-name'
	        },
	        fields: {
	          pattern: /\(.*\)/,
	          inside: {
	            'field-name': {
	              pattern: /[a-zA-Z0-9\-.]+/,
	              alias: 'variable'
	            },
	            punctuation: /[,()]/,
	            operator: {
	              pattern: /~/,
	              alias: 'field-hidden-mark'
	            }
	          }
	        }
	      }
	    },
	    search: {
	      pattern: /(@search\s+|#)[a-zA-Z0-9\-.]+(?:\.\*)?(?=\s*;)/,
	      alias: 'function',
	      lookbehind: true
	    },
	    keyword:
	      /@(?:having|inside|namespace|outside|pattern|require|search|where)\b/,
	    'standard-pattern': {
	      pattern:
	        /\b(?:Alpha|AlphaNum|Any|Blank|End|LineBreak|Num|NumAlpha|Punct|Space|Start|Symbol|Word|WordBreak)\b(?:\([a-zA-Z0-9\-.,\s+]*\))?/,
	      inside: {
	        'standard-pattern-name': {
	          pattern: /^[a-zA-Z0-9\-.]+/,
	          alias: 'builtin'
	        },
	        quantifier: {
	          pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
	          alias: 'number'
	        },
	        'standard-pattern-attr': {
	          pattern: /[a-zA-Z0-9\-.]+/,
	          alias: 'builtin'
	        },
	        punctuation: /[,()]/
	      }
	    },
	    quantifier: {
	      pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
	      alias: 'number'
	    },
	    operator: [
	      {
	        pattern: /=/,
	        alias: 'pattern-def'
	      },
	      {
	        pattern: /&/,
	        alias: 'conjunction'
	      },
	      {
	        pattern: /~/,
	        alias: 'exception'
	      },
	      {
	        pattern: /\?/,
	        alias: 'optionality'
	      },
	      {
	        pattern: /[[\]]/,
	        alias: 'repetition'
	      },
	      {
	        pattern: /[{}]/,
	        alias: 'variation'
	      },
	      {
	        pattern: /[+_]/,
	        alias: 'sequence'
	      },
	      {
	        pattern: /\.{2,3}/,
	        alias: 'span'
	      }
	    ],
	    'field-capture': [
	      {
	        pattern:
	          /([a-zA-Z0-9\-.]+\s*\()\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+(?:\s*,\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+)*(?=\s*\))/,
	        lookbehind: true,
	        inside: {
	          'field-name': {
	            pattern: /[a-zA-Z0-9\-.]+/,
	            alias: 'variable'
	          },
	          colon: /:/
	        }
	      },
	      {
	        pattern: /[a-zA-Z0-9\-.]+\s*:/,
	        inside: {
	          'field-name': {
	            pattern: /[a-zA-Z0-9\-.]+/,
	            alias: 'variable'
	          },
	          colon: /:/
	        }
	      }
	    ],
	    punctuation: /[:;,()]/,
	    name: /[a-zA-Z0-9\-.]+/
	  };
	}
	return nevod_1;
}

var nginx_1;
var hasRequiredNginx;

function requireNginx () {
	if (hasRequiredNginx) return nginx_1;
	hasRequiredNginx = 1;

	nginx_1 = nginx;
	nginx.displayName = 'nginx';
	nginx.aliases = [];
	function nginx(Prism) {
(function (Prism) {
	    var variable =
	      /\$(?:\w[a-z\d]*(?:_[^\x00-\x1F\s"'\\()$]*)?|\{[^}\s"'\\]+\})/i;
	    Prism.languages.nginx = {
	      comment: {
	        pattern: /(^|[\s{};])#.*/,
	        lookbehind: true,
	        greedy: true
	      },
	      directive: {
	        pattern:
	          /(^|\s)\w(?:[^;{}"'\\\s]|\\.|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\s+(?:#.*(?!.)|(?![#\s])))*?(?=\s*[;{])/,
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          string: {
	            pattern:
	              /((?:^|[^\\])(?:\\\\)*)(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/,
	            lookbehind: true,
	            greedy: true,
	            inside: {
	              escape: {
	                pattern: /\\["'\\nrt]/,
	                alias: 'entity'
	              },
	              variable: variable
	            }
	          },
	          comment: {
	            pattern: /(\s)#.*/,
	            lookbehind: true,
	            greedy: true
	          },
	          keyword: {
	            pattern: /^\S+/,
	            greedy: true
	          },
	          // other patterns
	          boolean: {
	            pattern: /(\s)(?:off|on)(?!\S)/,
	            lookbehind: true
	          },
	          number: {
	            pattern: /(\s)\d+[a-z]*(?!\S)/i,
	            lookbehind: true
	          },
	          variable: variable
	        }
	      },
	      punctuation: /[{};]/
	    };
	  })(Prism);
	}
	return nginx_1;
}

var nim_1;
var hasRequiredNim;

function requireNim () {
	if (hasRequiredNim) return nim_1;
	hasRequiredNim = 1;

	nim_1 = nim;
	nim.displayName = 'nim';
	nim.aliases = [];
	function nim(Prism) {
	  Prism.languages.nim = {
	    comment: {
	      pattern: /#.*/,
	      greedy: true
	    },
	    string: {
	      // Double-quoted strings can be prefixed by an identifier (Generalized raw string literals)
	      pattern:
	        /(?:\b(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+)?(?:"""[\s\S]*?"""(?!")|"(?:\\[\s\S]|""|[^"\\])*")/,
	      greedy: true
	    },
	    char: {
	      // Character literals are handled specifically to prevent issues with numeric type suffixes
	      pattern: /'(?:\\(?:\d+|x[\da-fA-F]{0,2}|.)|[^'])'/,
	      greedy: true
	    },
	    function: {
	      pattern:
	        /(?:(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+|`[^`\r\n]+`)\*?(?:\[[^\]]+\])?(?=\s*\()/,
	      greedy: true,
	      inside: {
	        operator: /\*$/
	      }
	    },
	    // We don't want to highlight operators (and anything really) inside backticks
	    identifier: {
	      pattern: /`[^`\r\n]+`/,
	      greedy: true,
	      inside: {
	        punctuation: /`/
	      }
	    },
	    // The negative look ahead prevents wrong highlighting of the .. operator
	    number:
	      /\b(?:0[xXoObB][\da-fA-F_]+|\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)(?:'?[iuf]\d*)?/,
	    keyword:
	      /\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\b/,
	    operator: {
	      // Look behind and look ahead prevent wrong highlighting of punctuations [. .] {. .} (. .)
	      // but allow the slice operator .. to take precedence over them
	      // One can define his own operators in Nim so all combination of operators might be an operator.
	      pattern:
	        /(^|[({\[](?=\.\.)|(?![({\[]\.).)(?:(?:[=+\-*\/<>@$~&%|!?^:\\]|\.\.|\.(?![)}\]]))+|\b(?:and|div|in|is|isnot|mod|not|notin|of|or|shl|shr|xor)\b)/m,
	      lookbehind: true
	    },
	    punctuation: /[({\[]\.|\.[)}\]]|[`(){}\[\],:]/
	  };
	}
	return nim_1;
}

var nix_1;
var hasRequiredNix;

function requireNix () {
	if (hasRequiredNix) return nix_1;
	hasRequiredNix = 1;

	nix_1 = nix;
	nix.displayName = 'nix';
	nix.aliases = [];
	function nix(Prism) {
	  Prism.languages.nix = {
	    comment: {
	      pattern: /\/\*[\s\S]*?\*\/|#.*/,
	      greedy: true
	    },
	    string: {
	      pattern: /"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,
	      greedy: true,
	      inside: {
	        interpolation: {
	          // The lookbehind ensures the ${} is not preceded by \ or ''
	          pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^{}]|\{[^}]*\})*\}/,
	          lookbehind: true,
	          inside: null // see below
	        }
	      }
	    },
	    url: [
	      /\b(?:[a-z]{3,7}:\/\/)[\w\-+%~\/.:#=?&]+/,
	      {
	        pattern:
	          /([^\/])(?:[\w\-+%~.:#=?&]*(?!\/\/)[\w\-+%~\/.:#=?&])?(?!\/\/)\/[\w\-+%~\/.:#=?&]*/,
	        lookbehind: true
	      }
	    ],
	    antiquotation: {
	      pattern: /\$(?=\{)/,
	      alias: 'important'
	    },
	    number: /\b\d+\b/,
	    keyword: /\b(?:assert|builtins|else|if|in|inherit|let|null|or|then|with)\b/,
	    function:
	      /\b(?:abort|add|all|any|attrNames|attrValues|baseNameOf|compareVersions|concatLists|currentSystem|deepSeq|derivation|dirOf|div|elem(?:At)?|fetch(?:Tarball|url)|filter(?:Source)?|fromJSON|genList|getAttr|getEnv|hasAttr|hashString|head|import|intersectAttrs|is(?:Attrs|Bool|Function|Int|List|Null|String)|length|lessThan|listToAttrs|map|mul|parseDrvName|pathExists|read(?:Dir|File)|removeAttrs|replaceStrings|seq|sort|stringLength|sub(?:string)?|tail|throw|to(?:File|JSON|Path|String|XML)|trace|typeOf)\b|\bfoldl'\B/,
	    boolean: /\b(?:false|true)\b/,
	    operator: /[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,
	    punctuation: /[{}()[\].,:;]/
	  };
	  Prism.languages.nix.string.inside.interpolation.inside = Prism.languages.nix;
	}
	return nix_1;
}

var nsis_1;
var hasRequiredNsis;

function requireNsis () {
	if (hasRequiredNsis) return nsis_1;
	hasRequiredNsis = 1;

	nsis_1 = nsis;
	nsis.displayName = 'nsis';
	nsis.aliases = [];
	function nsis(Prism) {
	  /**
	   * Original by Jan T. Sott (http://github.com/idleberg)
	   *
	   * Includes all commands and plug-ins shipped with NSIS 3.08
	   */
	  Prism.languages.nsis = {
	    comment: {
	      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|[#;].*)/,
	      lookbehind: true,
	      greedy: true
	    },
	    string: {
	      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    keyword: {
	      pattern:
	        /(^[\t ]*)(?:Abort|Add(?:BrandingImage|Size)|AdvSplash|Allow(?:RootDirInstall|SkipFiles)|AutoCloseWindow|BG(?:Font|Gradient|Image)|Banner|BrandingText|BringToFront|CRCCheck|Call(?:InstDLL)?|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|Create(?:Directory|Font|ShortCut)|Delete(?:INISec|INIStr|RegKey|RegValue)?|Detail(?:Print|sButtonText)|Dialer|Dir(?:Text|Var|Verify)|EnableWindow|Enum(?:RegKey|RegValue)|Exch|Exec(?:Shell(?:Wait)?|Wait)?|ExpandEnvStrings|File(?:BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|Seek|Write|WriteByte|WriteUTF16LE|WriteWord)?|Find(?:Close|First|Next|Window)|FlushINI|Get(?:CurInstType|CurrentAddress|DLLVersion(?:Local)?|DlgItem|ErrorLevel|FileTime(?:Local)?|FullPathName|Function(?:Address|End)?|InstDirError|LabelAddress|TempFileName)|Goto|HideWindow|Icon|If(?:Abort|Errors|FileExists|RebootFlag|Silent)|InitPluginsDir|InstProgressFlags|Inst(?:Type(?:GetText|SetText)?)|Install(?:ButtonText|Colors|Dir(?:RegKey)?)|Int(?:64|Ptr)?CmpU?|Int(?:64)?Fmt|Int(?:Ptr)?Op|IsWindow|Lang(?:DLL|String)|License(?:BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(?:Set|Text)|Manifest(?:DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|NSISdl|Name|Nop|OutFile|PE(?:DllCharacteristics|SubsysVer)|Page(?:Callbacks)?|Pop|Push|Quit|RMDir|Read(?:EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|SearchPath|Section(?:End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)?|SendMessage|Set(?:AutoClose|BrandingImage|Compress|Compressor(?:DictSize)?|CtlColors|CurInstType|DatablockOptimize|DateSave|Details(?:Print|View)|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|PluginUnload|RebootFlag|RegView|ShellVarContext|Silent)|Show(?:InstDetails|UninstDetails|Window)|Silent(?:Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(?:CmpS?|Cpy|Len)|SubCaption|System|UnRegDLL|Unicode|UninstPage|Uninstall(?:ButtonText|Caption|Icon|SubCaption|Text)|UserInfo|VI(?:AddVersionKey|FileVersion|ProductVersion)|VPatch|Var|WindowIcon|Write(?:INIStr|Reg(?:Bin|DWORD|ExpandStr|MultiStr|None|Str)|Uninstaller)|XPStyle|ns(?:Dialogs|Exec))\b/m,
	      lookbehind: true
	    },
	    property:
	      /\b(?:ARCHIVE|FILE_(?:ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK(?:(?:CR|CU|LM)(?:32|64)?|DD|PD|U)|HKEY_(?:CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(?:ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(?:ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY|admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user)\b/,
	    constant: /\$\{[!\w\.:\^-]+\}|\$\([!\w\.:\^-]+\)/,
	    variable: /\$\w[\w\.]*/,
	    number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
	    operator: /--?|\+\+?|<=?|>=?|==?=?|&&?|\|\|?|[?*\/~^%]/,
	    punctuation: /[{}[\];(),.:]/,
	    important: {
	      pattern:
	        /(^[\t ]*)!(?:addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversion|gettlbversion|if|ifdef|ifmacrodef|ifmacrondef|ifndef|include|insertmacro|macro|macroend|makensis|packhdr|pragma|searchparse|searchreplace|system|tempfile|undef|verbose|warning)\b/im,
	      lookbehind: true
	    }
	  };
	}
	return nsis_1;
}

var objectivec_1;
var hasRequiredObjectivec;

function requireObjectivec () {
	if (hasRequiredObjectivec) return objectivec_1;
	hasRequiredObjectivec = 1;
	var refractorC = c_1;
	objectivec_1 = objectivec;
	objectivec.displayName = 'objectivec';
	objectivec.aliases = ['objc'];
	function objectivec(Prism) {
	  Prism.register(refractorC);
	  Prism.languages.objectivec = Prism.languages.extend('c', {
	    string: {
	      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
	      greedy: true
	    },
	    keyword:
	      /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
	    operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
	  });
	  delete Prism.languages.objectivec['class-name'];
	  Prism.languages.objc = Prism.languages.objectivec;
	}
	return objectivec_1;
}

var ocaml_1;
var hasRequiredOcaml;

function requireOcaml () {
	if (hasRequiredOcaml) return ocaml_1;
	hasRequiredOcaml = 1;

	ocaml_1 = ocaml;
	ocaml.displayName = 'ocaml';
	ocaml.aliases = [];
	function ocaml(Prism) {
	  // https://ocaml.org/manual/lex.html
	  Prism.languages.ocaml = {
	    comment: {
	      pattern: /\(\*[\s\S]*?\*\)/,
	      greedy: true
	    },
	    char: {
	      pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
	      greedy: true
	    },
	    string: [
	      {
	        pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
	        greedy: true
	      },
	      {
	        pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
	        greedy: true
	      }
	    ],
	    number: [
	      // binary and octal
	      /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i, // hexadecimal
	      /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i, // decimal
	      /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
	    ],
	    directive: {
	      pattern: /\B#\w+/,
	      alias: 'property'
	    },
	    label: {
	      pattern: /\B~\w+/,
	      alias: 'property'
	    },
	    'type-variable': {
	      pattern: /\B'\w+/,
	      alias: 'function'
	    },
	    variant: {
	      pattern: /`\w+/,
	      alias: 'symbol'
	    },
	    // For the list of keywords and operators,
	    // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84
	    keyword:
	      /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
	    boolean: /\b(?:false|true)\b/,
	    'operator-like-punctuation': {
	      pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
	      alias: 'punctuation'
	    },
	    // Custom operators are allowed
	    operator:
	      /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
	    punctuation: /;;|::|[(){}\[\].,:;#]|\b_\b/
	  };
	}
	return ocaml_1;
}

var opencl_1;
var hasRequiredOpencl;

function requireOpencl () {
	if (hasRequiredOpencl) return opencl_1;
	hasRequiredOpencl = 1;
	var refractorC = c_1;
	opencl_1 = opencl;
	opencl.displayName = 'opencl';
	opencl.aliases = [];
	function opencl(Prism) {
	  Prism.register(refractorC)
	  ;(function (Prism) {
	    /* OpenCL kernel language */
	    Prism.languages.opencl = Prism.languages.extend('c', {
	      // Extracted from the official specs (2.0) and http://streamcomputing.eu/downloads/?opencl.lang (opencl-keywords, opencl-types) and http://sourceforge.net/tracker/?func=detail&aid=2957794&group_id=95717&atid=612384 (Words2, partly Words3)
	      keyword:
	        /\b(?:(?:__)?(?:constant|global|kernel|local|private|read_only|read_write|write_only)|__attribute__|auto|(?:bool|u?(?:char|int|long|short)|half|quad)(?:2|3|4|8|16)?|break|case|complex|const|continue|(?:double|float)(?:16(?:x(?:1|2|4|8|16))?|1x(?:1|2|4|8|16)|2(?:x(?:1|2|4|8|16))?|3|4(?:x(?:1|2|4|8|16))?|8(?:x(?:1|2|4|8|16))?)?|default|do|else|enum|extern|for|goto|if|imaginary|inline|packed|pipe|register|restrict|return|signed|sizeof|static|struct|switch|typedef|uniform|union|unsigned|void|volatile|while)\b/,
	      // Extracted from http://streamcomputing.eu/downloads/?opencl.lang (opencl-const)
	      // Math Constants: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/mathConstants.html
	      // Macros and Limits: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/macroLimits.html
	      number:
	        /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[fuhl]{0,4}/i,
	      boolean: /\b(?:false|true)\b/,
	      'constant-opencl-kernel': {
	        pattern:
	          /\b(?:CHAR_(?:BIT|MAX|MIN)|CLK_(?:ADDRESS_(?:CLAMP(?:_TO_EDGE)?|NONE|REPEAT)|FILTER_(?:LINEAR|NEAREST)|(?:GLOBAL|LOCAL)_MEM_FENCE|NORMALIZED_COORDS_(?:FALSE|TRUE))|CL_(?:BGRA|(?:HALF_)?FLOAT|INTENSITY|LUMINANCE|A?R?G?B?[Ax]?|(?:(?:UN)?SIGNED|[US]NORM)_(?:INT(?:8|16|32))|UNORM_(?:INT_101010|SHORT_(?:555|565)))|(?:DBL|FLT|HALF)_(?:DIG|EPSILON|(?:MAX|MIN)(?:(?:_10)?_EXP)?|MANT_DIG)|FLT_RADIX|HUGE_VALF?|(?:INT|LONG|SCHAR|SHRT)_(?:MAX|MIN)|INFINITY|MAXFLOAT|M_(?:[12]_PI|2_SQRTPI|E|LN(?:2|10)|LOG(?:2|10)E?|PI(?:_[24])?|SQRT(?:1_2|2))(?:_F|_H)?|NAN|(?:UCHAR|UINT|ULONG|USHRT)_MAX)\b/,
	        alias: 'constant'
	      }
	    });
	    Prism.languages.insertBefore('opencl', 'class-name', {
	      // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/scalarDataTypes.html
	      // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/otherDataTypes.html
	      'builtin-type': {
	        pattern:
	          /\b(?:_cl_(?:command_queue|context|device_id|event|kernel|mem|platform_id|program|sampler)|cl_(?:image_format|mem_fence_flags)|clk_event_t|event_t|image(?:1d_(?:array_|buffer_)?t|2d_(?:array_(?:depth_|msaa_depth_|msaa_)?|depth_|msaa_depth_|msaa_)?t|3d_t)|intptr_t|ndrange_t|ptrdiff_t|queue_t|reserve_id_t|sampler_t|size_t|uintptr_t)\b/,
	        alias: 'keyword'
	      }
	    });
	    var attributes = {
	      // Extracted from http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-types and opencl-host)
	      'type-opencl-host': {
	        pattern:
	          /\b(?:cl_(?:GLenum|GLint|GLuin|addressing_mode|bitfield|bool|buffer_create_type|build_status|channel_(?:order|type)|(?:u?(?:char|int|long|short)|double|float)(?:2|3|4|8|16)?|command_(?:queue(?:_info|_properties)?|type)|context(?:_info|_properties)?|device_(?:exec_capabilities|fp_config|id|info|local_mem_type|mem_cache_type|type)|(?:event|sampler)(?:_info)?|filter_mode|half|image_info|kernel(?:_info|_work_group_info)?|map_flags|mem(?:_flags|_info|_object_type)?|platform_(?:id|info)|profiling_info|program(?:_build_info|_info)?))\b/,
	        alias: 'keyword'
	      },
	      'boolean-opencl-host': {
	        pattern: /\bCL_(?:FALSE|TRUE)\b/,
	        alias: 'boolean'
	      },
	      // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-const)
	      'constant-opencl-host': {
	        pattern:
	          /\bCL_(?:A|ABGR|ADDRESS_(?:CLAMP(?:_TO_EDGE)?|MIRRORED_REPEAT|NONE|REPEAT)|ARGB|BGRA|BLOCKING|BUFFER_CREATE_TYPE_REGION|BUILD_(?:ERROR|IN_PROGRESS|NONE|PROGRAM_FAILURE|SUCCESS)|COMMAND_(?:ACQUIRE_GL_OBJECTS|BARRIER|COPY_(?:BUFFER(?:_RECT|_TO_IMAGE)?|IMAGE(?:_TO_BUFFER)?)|FILL_(?:BUFFER|IMAGE)|MAP(?:_BUFFER|_IMAGE)|MARKER|MIGRATE(?:_SVM)?_MEM_OBJECTS|NATIVE_KERNEL|NDRANGE_KERNEL|READ_(?:BUFFER(?:_RECT)?|IMAGE)|RELEASE_GL_OBJECTS|SVM_(?:FREE|MAP|MEMCPY|MEMFILL|UNMAP)|TASK|UNMAP_MEM_OBJECT|USER|WRITE_(?:BUFFER(?:_RECT)?|IMAGE))|COMPILER_NOT_AVAILABLE|COMPILE_PROGRAM_FAILURE|COMPLETE|CONTEXT_(?:DEVICES|INTEROP_USER_SYNC|NUM_DEVICES|PLATFORM|PROPERTIES|REFERENCE_COUNT)|DEPTH(?:_STENCIL)?|DEVICE_(?:ADDRESS_BITS|AFFINITY_DOMAIN_(?:L[1-4]_CACHE|NEXT_PARTITIONABLE|NUMA)|AVAILABLE|BUILT_IN_KERNELS|COMPILER_AVAILABLE|DOUBLE_FP_CONFIG|ENDIAN_LITTLE|ERROR_CORRECTION_SUPPORT|EXECUTION_CAPABILITIES|EXTENSIONS|GLOBAL_(?:MEM_(?:CACHELINE_SIZE|CACHE_SIZE|CACHE_TYPE|SIZE)|VARIABLE_PREFERRED_TOTAL_SIZE)|HOST_UNIFIED_MEMORY|IL_VERSION|IMAGE(?:2D_MAX_(?:HEIGHT|WIDTH)|3D_MAX_(?:DEPTH|HEIGHT|WIDTH)|_BASE_ADDRESS_ALIGNMENT|_MAX_ARRAY_SIZE|_MAX_BUFFER_SIZE|_PITCH_ALIGNMENT|_SUPPORT)|LINKER_AVAILABLE|LOCAL_MEM_SIZE|LOCAL_MEM_TYPE|MAX_(?:CLOCK_FREQUENCY|COMPUTE_UNITS|CONSTANT_ARGS|CONSTANT_BUFFER_SIZE|GLOBAL_VARIABLE_SIZE|MEM_ALLOC_SIZE|NUM_SUB_GROUPS|ON_DEVICE_(?:EVENTS|QUEUES)|PARAMETER_SIZE|PIPE_ARGS|READ_IMAGE_ARGS|READ_WRITE_IMAGE_ARGS|SAMPLERS|WORK_GROUP_SIZE|WORK_ITEM_DIMENSIONS|WORK_ITEM_SIZES|WRITE_IMAGE_ARGS)|MEM_BASE_ADDR_ALIGN|MIN_DATA_TYPE_ALIGN_SIZE|NAME|NATIVE_VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT)|NOT_(?:AVAILABLE|FOUND)|OPENCL_C_VERSION|PARENT_DEVICE|PARTITION_(?:AFFINITY_DOMAIN|BY_AFFINITY_DOMAIN|BY_COUNTS|BY_COUNTS_LIST_END|EQUALLY|FAILED|MAX_SUB_DEVICES|PROPERTIES|TYPE)|PIPE_MAX_(?:ACTIVE_RESERVATIONS|PACKET_SIZE)|PLATFORM|PREFERRED_(?:GLOBAL_ATOMIC_ALIGNMENT|INTEROP_USER_SYNC|LOCAL_ATOMIC_ALIGNMENT|PLATFORM_ATOMIC_ALIGNMENT|VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT))|PRINTF_BUFFER_SIZE|PROFILE|PROFILING_TIMER_RESOLUTION|QUEUE_(?:ON_(?:DEVICE_(?:MAX_SIZE|PREFERRED_SIZE|PROPERTIES)|HOST_PROPERTIES)|PROPERTIES)|REFERENCE_COUNT|SINGLE_FP_CONFIG|SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS|SVM_(?:ATOMICS|CAPABILITIES|COARSE_GRAIN_BUFFER|FINE_GRAIN_BUFFER|FINE_GRAIN_SYSTEM)|TYPE(?:_ACCELERATOR|_ALL|_CPU|_CUSTOM|_DEFAULT|_GPU)?|VENDOR(?:_ID)?|VERSION)|DRIVER_VERSION|EVENT_(?:COMMAND_(?:EXECUTION_STATUS|QUEUE|TYPE)|CONTEXT|REFERENCE_COUNT)|EXEC_(?:KERNEL|NATIVE_KERNEL|STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST)|FILTER_(?:LINEAR|NEAREST)|FLOAT|FP_(?:CORRECTLY_ROUNDED_DIVIDE_SQRT|DENORM|FMA|INF_NAN|ROUND_TO_INF|ROUND_TO_NEAREST|ROUND_TO_ZERO|SOFT_FLOAT)|GLOBAL|HALF_FLOAT|IMAGE_(?:ARRAY_SIZE|BUFFER|DEPTH|ELEMENT_SIZE|FORMAT|FORMAT_MISMATCH|FORMAT_NOT_SUPPORTED|HEIGHT|NUM_MIP_LEVELS|NUM_SAMPLES|ROW_PITCH|SLICE_PITCH|WIDTH)|INTENSITY|INVALID_(?:ARG_INDEX|ARG_SIZE|ARG_VALUE|BINARY|BUFFER_SIZE|BUILD_OPTIONS|COMMAND_QUEUE|COMPILER_OPTIONS|CONTEXT|DEVICE|DEVICE_PARTITION_COUNT|DEVICE_QUEUE|DEVICE_TYPE|EVENT|EVENT_WAIT_LIST|GLOBAL_OFFSET|GLOBAL_WORK_SIZE|GL_OBJECT|HOST_PTR|IMAGE_DESCRIPTOR|IMAGE_FORMAT_DESCRIPTOR|IMAGE_SIZE|KERNEL|KERNEL_ARGS|KERNEL_DEFINITION|KERNEL_NAME|LINKER_OPTIONS|MEM_OBJECT|MIP_LEVEL|OPERATION|PIPE_SIZE|PLATFORM|PROGRAM|PROGRAM_EXECUTABLE|PROPERTY|QUEUE_PROPERTIES|SAMPLER|VALUE|WORK_DIMENSION|WORK_GROUP_SIZE|WORK_ITEM_SIZE)|KERNEL_(?:ARG_(?:ACCESS_(?:NONE|QUALIFIER|READ_ONLY|READ_WRITE|WRITE_ONLY)|ADDRESS_(?:CONSTANT|GLOBAL|LOCAL|PRIVATE|QUALIFIER)|INFO_NOT_AVAILABLE|NAME|TYPE_(?:CONST|NAME|NONE|PIPE|QUALIFIER|RESTRICT|VOLATILE))|ATTRIBUTES|COMPILE_NUM_SUB_GROUPS|COMPILE_WORK_GROUP_SIZE|CONTEXT|EXEC_INFO_SVM_FINE_GRAIN_SYSTEM|EXEC_INFO_SVM_PTRS|FUNCTION_NAME|GLOBAL_WORK_SIZE|LOCAL_MEM_SIZE|LOCAL_SIZE_FOR_SUB_GROUP_COUNT|MAX_NUM_SUB_GROUPS|MAX_SUB_GROUP_SIZE_FOR_NDRANGE|NUM_ARGS|PREFERRED_WORK_GROUP_SIZE_MULTIPLE|PRIVATE_MEM_SIZE|PROGRAM|REFERENCE_COUNT|SUB_GROUP_COUNT_FOR_NDRANGE|WORK_GROUP_SIZE)|LINKER_NOT_AVAILABLE|LINK_PROGRAM_FAILURE|LOCAL|LUMINANCE|MAP_(?:FAILURE|READ|WRITE|WRITE_INVALIDATE_REGION)|MEM_(?:ALLOC_HOST_PTR|ASSOCIATED_MEMOBJECT|CONTEXT|COPY_HOST_PTR|COPY_OVERLAP|FLAGS|HOST_NO_ACCESS|HOST_PTR|HOST_READ_ONLY|HOST_WRITE_ONLY|KERNEL_READ_AND_WRITE|MAP_COUNT|OBJECT_(?:ALLOCATION_FAILURE|BUFFER|IMAGE1D|IMAGE1D_ARRAY|IMAGE1D_BUFFER|IMAGE2D|IMAGE2D_ARRAY|IMAGE3D|PIPE)|OFFSET|READ_ONLY|READ_WRITE|REFERENCE_COUNT|SIZE|SVM_ATOMICS|SVM_FINE_GRAIN_BUFFER|TYPE|USES_SVM_POINTER|USE_HOST_PTR|WRITE_ONLY)|MIGRATE_MEM_OBJECT_(?:CONTENT_UNDEFINED|HOST)|MISALIGNED_SUB_BUFFER_OFFSET|NONE|NON_BLOCKING|OUT_OF_(?:HOST_MEMORY|RESOURCES)|PIPE_(?:MAX_PACKETS|PACKET_SIZE)|PLATFORM_(?:EXTENSIONS|HOST_TIMER_RESOLUTION|NAME|PROFILE|VENDOR|VERSION)|PROFILING_(?:COMMAND_(?:COMPLETE|END|QUEUED|START|SUBMIT)|INFO_NOT_AVAILABLE)|PROGRAM_(?:BINARIES|BINARY_SIZES|BINARY_TYPE(?:_COMPILED_OBJECT|_EXECUTABLE|_LIBRARY|_NONE)?|BUILD_(?:GLOBAL_VARIABLE_TOTAL_SIZE|LOG|OPTIONS|STATUS)|CONTEXT|DEVICES|IL|KERNEL_NAMES|NUM_DEVICES|NUM_KERNELS|REFERENCE_COUNT|SOURCE)|QUEUED|QUEUE_(?:CONTEXT|DEVICE|DEVICE_DEFAULT|ON_DEVICE|ON_DEVICE_DEFAULT|OUT_OF_ORDER_EXEC_MODE_ENABLE|PROFILING_ENABLE|PROPERTIES|REFERENCE_COUNT|SIZE)|R|RA|READ_(?:ONLY|WRITE)_CACHE|RG|RGB|RGBA|RGBx|RGx|RUNNING|Rx|SAMPLER_(?:ADDRESSING_MODE|CONTEXT|FILTER_MODE|LOD_MAX|LOD_MIN|MIP_FILTER_MODE|NORMALIZED_COORDS|REFERENCE_COUNT)|(?:UN)?SIGNED_INT(?:8|16|32)|SNORM_INT(?:8|16)|SUBMITTED|SUCCESS|UNORM_INT(?:8|16|24|_101010|_101010_2)|UNORM_SHORT_(?:555|565)|VERSION_(?:1_0|1_1|1_2|2_0|2_1)|sBGRA|sRGB|sRGBA|sRGBx)\b/,
	        alias: 'constant'
	      },
	      // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-host)
	      'function-opencl-host': {
	        pattern:
	          /\bcl(?:BuildProgram|CloneKernel|CompileProgram|Create(?:Buffer|CommandQueue(?:WithProperties)?|Context|ContextFromType|Image|Image2D|Image3D|Kernel|KernelsInProgram|Pipe|ProgramWith(?:Binary|BuiltInKernels|IL|Source)|Sampler|SamplerWithProperties|SubBuffer|SubDevices|UserEvent)|Enqueue(?:(?:Barrier|Marker)(?:WithWaitList)?|Copy(?:Buffer(?:Rect|ToImage)?|Image(?:ToBuffer)?)|(?:Fill|Map)(?:Buffer|Image)|MigrateMemObjects|NDRangeKernel|NativeKernel|(?:Read|Write)(?:Buffer(?:Rect)?|Image)|SVM(?:Free|Map|MemFill|Memcpy|MigrateMem|Unmap)|Task|UnmapMemObject|WaitForEvents)|Finish|Flush|Get(?:CommandQueueInfo|ContextInfo|Device(?:AndHostTimer|IDs|Info)|Event(?:Profiling)?Info|ExtensionFunctionAddress(?:ForPlatform)?|HostTimer|ImageInfo|Kernel(?:ArgInfo|Info|SubGroupInfo|WorkGroupInfo)|MemObjectInfo|PipeInfo|Platform(?:IDs|Info)|Program(?:Build)?Info|SamplerInfo|SupportedImageFormats)|LinkProgram|(?:Release|Retain)(?:CommandQueue|Context|Device|Event|Kernel|MemObject|Program|Sampler)|SVM(?:Alloc|Free)|Set(?:CommandQueueProperty|DefaultDeviceCommandQueue|EventCallback|Kernel|Kernel(?:Arg(?:SVMPointer)?|ExecInfo)|MemObjectDestructorCallback|UserEventStatus)|Unload(?:Platform)?Compiler|WaitForEvents)\b/,
	        alias: 'function'
	      }
	    };
	    /* OpenCL host API */
	    Prism.languages.insertBefore('c', 'keyword', attributes); // C++ includes everything from the OpenCL C host API plus the classes defined in cl2.h
	    if (Prism.languages.cpp) {
	      // Extracted from doxygen class list http://github.khronos.org/OpenCL-CLHPP/annotated.html
	      attributes['type-opencl-host-cpp'] = {
	        pattern:
	          /\b(?:Buffer|BufferGL|BufferRenderGL|CommandQueue|Context|Device|DeviceCommandQueue|EnqueueArgs|Event|Image|Image1D|Image1DArray|Image1DBuffer|Image2D|Image2DArray|Image2DGL|Image3D|Image3DGL|ImageFormat|ImageGL|Kernel|KernelFunctor|LocalSpaceArg|Memory|NDRange|Pipe|Platform|Program|SVMAllocator|SVMTraitAtomic|SVMTraitCoarse|SVMTraitFine|SVMTraitReadOnly|SVMTraitReadWrite|SVMTraitWriteOnly|Sampler|UserEvent)\b/,
	        alias: 'keyword'
	      };
	      Prism.languages.insertBefore('cpp', 'keyword', attributes);
	    }
	  })(Prism);
	}
	return opencl_1;
}

var openqasm_1;
var hasRequiredOpenqasm;

function requireOpenqasm () {
	if (hasRequiredOpenqasm) return openqasm_1;
	hasRequiredOpenqasm = 1;

	openqasm_1 = openqasm;
	openqasm.displayName = 'openqasm';
	openqasm.aliases = ['qasm'];
	function openqasm(Prism) {
	  // https://qiskit.github.io/openqasm/grammar/index.html
	  Prism.languages.openqasm = {
	    comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
	    string: {
	      pattern: /"[^"\r\n\t]*"|'[^'\r\n\t]*'/,
	      greedy: true
	    },
	    keyword:
	      /\b(?:CX|OPENQASM|U|barrier|boxas|boxto|break|const|continue|ctrl|def|defcal|defcalgrammar|delay|else|end|for|gate|gphase|if|in|include|inv|kernel|lengthof|let|measure|pow|reset|return|rotary|stretchinf|while)\b|#pragma\b/,
	    'class-name':
	      /\b(?:angle|bit|bool|creg|fixed|float|int|length|qreg|qubit|stretch|uint)\b/,
	    function: /\b(?:cos|exp|ln|popcount|rotl|rotr|sin|sqrt|tan)\b(?=\s*\()/,
	    constant: /\b(?:euler|pi|tau)\b|π|𝜏|ℇ/,
	    number: {
	      pattern:
	        /(^|[^.\w$])(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?(?:dt|ns|us|µs|ms|s)?/i,
	      lookbehind: true
	    },
	    operator: /->|>>=?|<<=?|&&|\|\||\+\+|--|[!=<>&|~^+\-*/%]=?|@/,
	    punctuation: /[(){}\[\];,:.]/
	  };
	  Prism.languages.qasm = Prism.languages.openqasm;
	}
	return openqasm_1;
}

var oz_1;
var hasRequiredOz;

function requireOz () {
	if (hasRequiredOz) return oz_1;
	hasRequiredOz = 1;

	oz_1 = oz;
	oz.displayName = 'oz';
	oz.aliases = [];
	function oz(Prism) {
	  Prism.languages.oz = {
	    comment: {
	      pattern: /\/\*[\s\S]*?\*\/|%.*/,
	      greedy: true
	    },
	    string: {
	      pattern: /"(?:[^"\\]|\\[\s\S])*"/,
	      greedy: true
	    },
	    atom: {
	      pattern: /'(?:[^'\\]|\\[\s\S])*'/,
	      greedy: true,
	      alias: 'builtin'
	    },
	    keyword:
	      /\$|\[\]|\b(?:_|at|attr|case|catch|choice|class|cond|declare|define|dis|else(?:case|if)?|end|export|fail|false|feat|finally|from|fun|functor|if|import|in|local|lock|meth|nil|not|of|or|prepare|proc|prop|raise|require|self|skip|then|thread|true|try|unit)\b/,
	    function: [
	      /\b[a-z][A-Za-z\d]*(?=\()/,
	      {
	        pattern: /(\{)[A-Z][A-Za-z\d]*\b/,
	        lookbehind: true
	      }
	    ],
	    number:
	      /\b(?:0[bx][\da-f]+|\d+(?:\.\d*)?(?:e~?\d+)?)\b|&(?:[^\\]|\\(?:\d{3}|.))/i,
	    variable: /`(?:[^`\\]|\\.)+`/,
	    'attr-name': /\b\w+(?=[ \t]*:(?![:=]))/,
	    operator:
	      /:(?:=|::?)|<[-:=]?|=(?:=|<?:?)|>=?:?|\\=:?|!!?|[|#+\-*\/,~^@]|\b(?:andthen|div|mod|orelse)\b/,
	    punctuation: /[\[\](){}.:;?]/
	  };
	}
	return oz_1;
}

var parigp_1;
var hasRequiredParigp;

function requireParigp () {
	if (hasRequiredParigp) return parigp_1;
	hasRequiredParigp = 1;

	parigp_1 = parigp;
	parigp.displayName = 'parigp';
	parigp.aliases = [];
	function parigp(Prism) {
	  Prism.languages.parigp = {
	    comment: /\/\*[\s\S]*?\*\/|\\\\.*/,
	    string: {
	      pattern: /"(?:[^"\\\r\n]|\\.)*"/,
	      greedy: true
	    },
	    // PARI/GP does not care about white spaces at all
	    // so let's process the keywords to build an appropriate regexp
	    // (e.g. "b *r *e *a *k", etc.)
	    keyword: (function () {
	      var keywords = [
	        'breakpoint',
	        'break',
	        'dbg_down',
	        'dbg_err',
	        'dbg_up',
	        'dbg_x',
	        'forcomposite',
	        'fordiv',
	        'forell',
	        'forpart',
	        'forprime',
	        'forstep',
	        'forsubgroup',
	        'forvec',
	        'for',
	        'iferr',
	        'if',
	        'local',
	        'my',
	        'next',
	        'return',
	        'until',
	        'while'
	      ];
	      keywords = keywords
	        .map(function (keyword) {
	          return keyword.split('').join(' *')
	        })
	        .join('|');
	      return RegExp('\\b(?:' + keywords + ')\\b')
	    })(),
	    function: /\b\w(?:[\w ]*\w)?(?= *\()/,
	    number: {
	      // The lookbehind and the negative lookahead prevent from breaking the .. operator
	      pattern:
	        /((?:\. *\. *)?)(?:\b\d(?: *\d)*(?: *(?!\. *\.)\.(?: *\d)*)?|\. *\d(?: *\d)*)(?: *e *(?:[+-] *)?\d(?: *\d)*)?/i,
	      lookbehind: true
	    },
	    operator:
	      /\. *\.|[*\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\(?: *\/)?(?: *=)?|&(?: *&)?|\| *\||['#~^]/,
	    punctuation: /[\[\]{}().,:;|]/
	  };
	}
	return parigp_1;
}

var parser_1;
var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return parser_1;
	hasRequiredParser = 1;

	parser_1 = parser;
	parser.displayName = 'parser';
	parser.aliases = [];
	function parser(Prism) {
(function (Prism) {
	    var parser = (Prism.languages.parser = Prism.languages.extend('markup', {
	      keyword: {
	        pattern:
	          /(^|[^^])(?:\^(?:case|eval|for|if|switch|throw)\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\b)/,
	        lookbehind: true
	      },
	      variable: {
	        pattern: /(^|[^^])\B\$(?:\w+|(?=[.{]))(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
	        lookbehind: true,
	        inside: {
	          punctuation: /\.|:+/
	        }
	      },
	      function: {
	        pattern: /(^|[^^])\B[@^]\w+(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
	        lookbehind: true,
	        inside: {
	          keyword: {
	            pattern: /(^@)(?:GET_|SET_)/,
	            lookbehind: true
	          },
	          punctuation: /\.|:+/
	        }
	      },
	      escape: {
	        pattern: /\^(?:[$^;@()\[\]{}"':]|#[a-f\d]*)/i,
	        alias: 'builtin'
	      },
	      punctuation: /[\[\](){};]/
	    }));
	    parser = Prism.languages.insertBefore('parser', 'keyword', {
	      'parser-comment': {
	        pattern: /(\s)#.*/,
	        lookbehind: true,
	        alias: 'comment'
	      },
	      expression: {
	        // Allow for 3 levels of depth
	        pattern: /(^|[^^])\((?:[^()]|\((?:[^()]|\((?:[^()])*\))*\))*\)/,
	        greedy: true,
	        lookbehind: true,
	        inside: {
	          string: {
	            pattern: /(^|[^^])(["'])(?:(?!\2)[^^]|\^[\s\S])*\2/,
	            lookbehind: true
	          },
	          keyword: parser.keyword,
	          variable: parser.variable,
	          function: parser.function,
	          boolean: /\b(?:false|true)\b/,
	          number: /\b(?:0x[a-f\d]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?)\b/i,
	          escape: parser.escape,
	          operator:
	            /[~+*\/\\%]|!(?:\|\|?|=)?|&&?|\|\|?|==|<[<=]?|>[>=]?|-[fd]?|\b(?:def|eq|ge|gt|in|is|le|lt|ne)\b/,
	          punctuation: parser.punctuation
	        }
	      }
	    });
	    Prism.languages.insertBefore(
	      'inside',
	      'punctuation',
	      {
	        expression: parser.expression,
	        keyword: parser.keyword,
	        variable: parser.variable,
	        function: parser.function,
	        escape: parser.escape,
	        'parser-punctuation': {
	          pattern: parser.punctuation,
	          alias: 'punctuation'
	        }
	      },
	      parser['tag'].inside['attr-value']
	    );
	  })(Prism);
	}
	return parser_1;
}

var pascal_1;
var hasRequiredPascal;

function requirePascal () {
	if (hasRequiredPascal) return pascal_1;
	hasRequiredPascal = 1;

	pascal_1 = pascal;
	pascal.displayName = 'pascal';
	pascal.aliases = ['objectpascal'];
	function pascal(Prism) {
	  // Based on Free Pascal
	  /* TODO
	Support inline asm ?
	*/
	  Prism.languages.pascal = {
	    directive: {
	      pattern: /\{\$[\s\S]*?\}/,
	      greedy: true,
	      alias: ['marco', 'property']
	    },
	    comment: {
	      pattern: /\(\*[\s\S]*?\*\)|\{[\s\S]*?\}|\/\/.*/,
	      greedy: true
	    },
	    string: {
	      pattern: /(?:'(?:''|[^'\r\n])*'(?!')|#[&$%]?[a-f\d]+)+|\^[a-z]/i,
	      greedy: true
	    },
	    asm: {
	      pattern: /(\basm\b)[\s\S]+?(?=\bend\s*[;[])/i,
	      lookbehind: true,
	      greedy: true,
	      inside: null // see below
	    },
	    keyword: [
	      {
	        // Turbo Pascal
	        pattern:
	          /(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,
	        lookbehind: true
	      },
	      {
	        // Free Pascal
	        pattern: /(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,
	        lookbehind: true
	      },
	      {
	        // Object Pascal
	        pattern:
	          /(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,
	        lookbehind: true
	      },
	      {
	        // Modifiers
	        pattern:
	          /(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,
	        lookbehind: true
	      }
	    ],
	    number: [
	      // Hexadecimal, octal and binary
	      /(?:[&%]\d+|\$[a-f\d]+)/i, // Decimal
	      /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?/i
	    ],
	    operator: [
	      /\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/,
	      {
	        pattern:
	          /(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,
	        lookbehind: true
	      }
	    ],
	    punctuation: /\(\.|\.\)|[()\[\]:;,.]/
	  };
	  Prism.languages.pascal.asm.inside = Prism.languages.extend('pascal', {
	    asm: undefined,
	    keyword: undefined,
	    operator: undefined
	  });
	  Prism.languages.objectpascal = Prism.languages.pascal;
	}
	return pascal_1;
}

var pascaligo_1;
var hasRequiredPascaligo;

function requirePascaligo () {
	if (hasRequiredPascaligo) return pascaligo_1;
	hasRequiredPascaligo = 1;

	pascaligo_1 = pascaligo;
	pascaligo.displayName = 'pascaligo';
	pascaligo.aliases = [];
	function pascaligo(Prism) {
(function (Prism) {
	    // Pascaligo is a layer 2 smart contract language for the tezos blockchain
	    var braces = /\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)/.source;
	    var type = /(?:\b\w+(?:<braces>)?|<braces>)/.source.replace(
	      /<braces>/g,
	      function () {
	        return braces
	      }
	    );
	    var pascaligo = (Prism.languages.pascaligo = {
	      comment: /\(\*[\s\S]+?\*\)|\/\/.*/,
	      string: {
	        pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1|\^[a-z]/i,
	        greedy: true
	      },
	      'class-name': [
	        {
	          pattern: RegExp(
	            /(\btype\s+\w+\s+is\s+)<type>/.source.replace(
	              /<type>/g,
	              function () {
	                return type
	              }
	            ),
	            'i'
	          ),
	          lookbehind: true,
	          inside: null // see below
	        },
	        {
	          pattern: RegExp(
	            /<type>(?=\s+is\b)/.source.replace(/<type>/g, function () {
	              return type
	            }),
	            'i'
	          ),
	          inside: null // see below
	        },
	        {
	          pattern: RegExp(
	            /(:\s*)<type>/.source.replace(/<type>/g, function () {
	              return type
	            })
	          ),
	          lookbehind: true,
	          inside: null // see below
	        }
	      ],
	      keyword: {
	        pattern:
	          /(^|[^&])\b(?:begin|block|case|const|else|end|fail|for|from|function|if|is|nil|of|remove|return|skip|then|type|var|while|with)\b/i,
	        lookbehind: true
	      },
	      boolean: {
	        pattern: /(^|[^&])\b(?:False|True)\b/i,
	        lookbehind: true
	      },
	      builtin: {
	        pattern: /(^|[^&])\b(?:bool|int|list|map|nat|record|string|unit)\b/i,
	        lookbehind: true
	      },
	      function: /\b\w+(?=\s*\()/,
	      number: [
	        // Hexadecimal, octal and binary
	        /%[01]+|&[0-7]+|\$[a-f\d]+/i, // Decimal
	        /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?(?:mtz|n)?/i
	      ],
	      operator:
	        /->|=\/=|\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=|]|\b(?:and|mod|or)\b/,
	      punctuation: /\(\.|\.\)|[()\[\]:;,.{}]/
	    });
	    var classNameInside = [
	      'comment',
	      'keyword',
	      'builtin',
	      'operator',
	      'punctuation'
	    ].reduce(function (accum, key) {
	      accum[key] = pascaligo[key];
	      return accum
	    }, {});
	    pascaligo['class-name'].forEach(function (p) {
	      p.inside = classNameInside;
	    });
	  })(Prism);
	}
	return pascaligo_1;
}

var pcaxis_1;
var hasRequiredPcaxis;

function requirePcaxis () {
	if (hasRequiredPcaxis) return pcaxis_1;
	hasRequiredPcaxis = 1;

	pcaxis_1 = pcaxis;
	pcaxis.displayName = 'pcaxis';
	pcaxis.aliases = ['px'];
	function pcaxis(Prism) {
	  Prism.languages.pcaxis = {
	    string: /"[^"]*"/,
	    keyword: {
	      pattern:
	        /((?:^|;)\s*)[-A-Z\d]+(?:\s*\[[-\w]+\])?(?:\s*\("[^"]*"(?:,\s*"[^"]*")*\))?(?=\s*=)/,
	      lookbehind: true,
	      greedy: true,
	      inside: {
	        keyword: /^[-A-Z\d]+/,
	        language: {
	          pattern: /^(\s*)\[[-\w]+\]/,
	          lookbehind: true,
	          inside: {
	            punctuation: /^\[|\]$/,
	            property: /[-\w]+/
	          }
	        },
	        'sub-key': {
	          pattern: /^(\s*)\S[\s\S]*/,
	          lookbehind: true,
	          inside: {
	            parameter: {
	              pattern: /"[^"]*"/,
	              alias: 'property'
	            },
	            punctuation: /^\(|\)$|,/
	          }
	        }
	      }
	    },
	    operator: /=/,
	    tlist: {
	      pattern:
	        /TLIST\s*\(\s*\w+(?:(?:\s*,\s*"[^"]*")+|\s*,\s*"[^"]*"-"[^"]*")?\s*\)/,
	      greedy: true,
	      inside: {
	        function: /^TLIST/,
	        property: {
	          pattern: /^(\s*\(\s*)\w+/,
	          lookbehind: true
	        },
	        string: /"[^"]*"/,
	        punctuation: /[(),]/,
	        operator: /-/
	      }
	    },
	    punctuation: /[;,]/,
	    number: {
	      pattern: /(^|\s)\d+(?:\.\d+)?(?!\S)/,
	      lookbehind: true
	    },
	    boolean: /NO|YES/
	  };
	  Prism.languages.px = Prism.languages.pcaxis;
	}
	return pcaxis_1;
}

var peoplecode_1;
var hasRequiredPeoplecode;

function requirePeoplecode () {
	if (hasRequiredPeoplecode) return peoplecode_1;
	hasRequiredPeoplecode = 1;

	peoplecode_1 = peoplecode;
	peoplecode.displayName = 'peoplecode';
	peoplecode.aliases = ['pcode'];
	function peoplecode(Prism) {
	  Prism.languages.peoplecode = {
	    comment: RegExp(
	      [
	        // C-style multiline comments
	        /\/\*[\s\S]*?\*\//.source, // REM comments
	        /\bREM[^;]*;/.source, // Nested <* *> comments
	        /<\*(?:[^<*]|\*(?!>)|<(?!\*)|<\*(?:(?!\*>)[\s\S])*\*>)*\*>/.source, // /+ +/ comments
	        /\/\+[\s\S]*?\+\//.source
	      ].join('|')
	    ),
	    string: {
	      pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
	      greedy: true
	    },
	    variable: /%\w+/,
	    'function-definition': {
	      pattern: /((?:^|[^\w-])(?:function|method)\s+)\w+/i,
	      lookbehind: true,
	      alias: 'function'
	    },
	    'class-name': {
	      pattern:
	        /((?:^|[^-\w])(?:as|catch|class|component|create|extends|global|implements|instance|local|of|property|returns)\s+)\w+(?::\w+)*/i,
	      lookbehind: true,
	      inside: {
	        punctuation: /:/
	      }
	    },
	    keyword:
	      /\b(?:abstract|alias|as|catch|class|component|constant|create|declare|else|end-(?:class|evaluate|for|function|get|if|method|set|try|while)|evaluate|extends|for|function|get|global|if|implements|import|instance|library|local|method|null|of|out|peopleCode|private|program|property|protected|readonly|ref|repeat|returns?|set|step|then|throw|to|try|until|value|when(?:-other)?|while)\b/i,
	    'operator-keyword': {
	      pattern: /\b(?:and|not|or)\b/i,
	      alias: 'operator'
	    },
	    function: /[_a-z]\w*(?=\s*\()/i,
	    boolean: /\b(?:false|true)\b/i,
	    number: /\b\d+(?:\.\d+)?\b/,
	    operator: /<>|[<>]=?|!=|\*\*|[-+*/|=@]/,
	    punctuation: /[:.;,()[\]]/
	  };
	  Prism.languages.pcode = Prism.languages.peoplecode;
	}
	return peoplecode_1;
}

var perl_1;
var hasRequiredPerl;

function requirePerl () {
	if (hasRequiredPerl) return perl_1;
	hasRequiredPerl = 1;

	perl_1 = perl;
	perl.displayName = 'perl';
	perl.aliases = [];
	function perl(Prism) {
(function (Prism) {
	    var brackets =
	      /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/
	        .source;
	    Prism.languages.perl = {
	      comment: [
	        {
	          // POD
	          pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
	          lookbehind: true,
	          greedy: true
	        },
	        {
	          pattern: /(^|[^\\$])#.*/,
	          lookbehind: true,
	          greedy: true
	        }
	      ],
	      // TODO Could be nice to handle Heredoc too.
	      string: [
	        {
	          pattern: RegExp(
	            /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source +
	              '(?:' +
	              [
	                // q/.../
	                /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, // q a...a
	                // eslint-disable-next-line regexp/strict
	                /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source, // q(...)
	                // q{...}
	                // q[...]
	                // q<...>
	                brackets
	              ].join('|') +
	              ')'
	          ),
	          greedy: true
	        }, // "...", `...`
	        {
	          pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
	          greedy: true
	        }, // '...'
	        // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
	        {
	          pattern: /'(?:[^'\\\r\n]|\\.)*'/,
	          greedy: true
	        }
	      ],
	      regex: [
	        {
	          pattern: RegExp(
	            /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source +
	              '(?:' +
	              [
	                // m/.../
	                /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, // m a...a
	                // eslint-disable-next-line regexp/strict
	                /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source, // m(...)
	                // m{...}
	                // m[...]
	                // m<...>
	                brackets
	              ].join('|') +
	              ')' +
	              /[msixpodualngc]*/.source
	          ),
	          greedy: true
	        }, // The lookbehinds prevent -s from breaking
	        {
	          pattern: RegExp(
	            /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source +
	              '(?:' +
	              [
	                // s/.../.../
	                // eslint-disable-next-line regexp/strict
	                /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/
	                  .source, // s a...a...a
	                // eslint-disable-next-line regexp/strict
	                /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/
	                  .source, // s(...)(...)
	                // s{...}{...}
	                // s[...][...]
	                // s<...><...>
	                // s(...)[...]
	                brackets + /\s*/.source + brackets
	              ].join('|') +
	              ')' +
	              /[msixpodualngcer]*/.source
	          ),
	          lookbehind: true,
	          greedy: true
	        }, // /.../
	        // The look-ahead tries to prevent two divisions on
	        // the same line from being highlighted as regex.
	        // This does not support multi-line regex.
	        {
	          pattern:
	            /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
	          greedy: true
	        }
	      ],
	      // FIXME Not sure about the handling of ::, ', and #
	      variable: [
	        // ${^POSTMATCH}
	        /[&*$@%]\{\^[A-Z]+\}/, // $^V
	        /[&*$@%]\^[A-Z_]/, // ${...}
	        /[&*$@%]#?(?=\{)/, // $foo
	        /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/, // $1
	        /[&*$@%]\d+/, // $_, @_, %!
	        // The negative lookahead prevents from breaking the %= operator
	        /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
	      ],
	      filehandle: {
	        // <>, <FOO>, _
	        pattern: /<(?![<=])\S*?>|\b_\b/,
	        alias: 'symbol'
	      },
	      'v-string': {
	        // v1.2, 1.2.3
	        pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
	        alias: 'string'
	      },
	      function: {
	        pattern: /(\bsub[ \t]+)\w+/,
	        lookbehind: true
	      },
	      keyword:
	        /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
	      number:
	        /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
	      operator:
	        /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
	      punctuation: /[{}[\];(),:]/
	    };
	  })(Prism);
	}
	return perl_1;
}

var phpExtras_1;
var hasRequiredPhpExtras;

function requirePhpExtras () {
	if (hasRequiredPhpExtras) return phpExtras_1;
	hasRequiredPhpExtras = 1;
	var refractorPhp = requirePhp();
	phpExtras_1 = phpExtras;
	phpExtras.displayName = 'phpExtras';
	phpExtras.aliases = [];
	function phpExtras(Prism) {
	  Prism.register(refractorPhp);
	  Prism.languages.insertBefore('php', 'variable', {
	    this: {
	      pattern: /\$this\b/,
	      alias: 'keyword'
	    },
	    global:
	      /\$(?:GLOBALS|HTTP_RAW_POST_DATA|_(?:COOKIE|ENV|FILES|GET|POST|REQUEST|SERVER|SESSION)|argc|argv|http_response_header|php_errormsg)\b/,
	    scope: {
	      pattern: /\b[\w\\]+::/,
	      inside: {
	        keyword: /\b(?:parent|self|static)\b/,
	        punctuation: /::|\\/
	      }
	    }
	  });
	}
	return phpExtras_1;
}

var phpdoc_1;
var hasRequiredPhpdoc;

function requirePhpdoc () {
	if (hasRequiredPhpdoc) return phpdoc_1;
	hasRequiredPhpdoc = 1;
	var refractorPhp = requirePhp();
	var refractorJavadoclike = requireJavadoclike();
	phpdoc_1 = phpdoc;
	phpdoc.displayName = 'phpdoc';
	phpdoc.aliases = [];
	function phpdoc(Prism) {
	  Prism.register(refractorPhp);
	  Prism.register(refractorJavadoclike)
	  ;(function (Prism) {
	    var typeExpression = /(?:\b[a-zA-Z]\w*|[|\\[\]])+/.source;
	    Prism.languages.phpdoc = Prism.languages.extend('javadoclike', {
	      parameter: {
	        pattern: RegExp(
	          '(@(?:global|param|property(?:-read|-write)?|var)\\s+(?:' +
	            typeExpression +
	            '\\s+)?)\\$\\w+'
	        ),
	        lookbehind: true
	      }
	    });
	    Prism.languages.insertBefore('phpdoc', 'keyword', {
	      'class-name': [
	        {
	          pattern: RegExp(
	            '(@(?:global|package|param|property(?:-read|-write)?|return|subpackage|throws|var)\\s+)' +
	              typeExpression
	          ),
	          lookbehind: true,
	          inside: {
	            keyword:
	              /\b(?:array|bool|boolean|callback|double|false|float|int|integer|mixed|null|object|resource|self|string|true|void)\b/,
	            punctuation: /[|\\[\]()]/
	          }
	        }
	      ]
	    });
	    Prism.languages.javadoclike.addSupport('php', Prism.languages.phpdoc);
	  })(Prism);
	}
	return phpdoc_1;
}

var plsql_1;
var hasRequiredPlsql;

function requirePlsql () {
	if (hasRequiredPlsql) return plsql_1;
	hasRequiredPlsql = 1;
	var refractorSql = sql_1;
	plsql_1 = plsql;
	plsql.displayName = 'plsql';
	plsql.aliases = [];
	function plsql(Prism) {
	  Prism.register(refractorSql);
	  Prism.languages.plsql = Prism.languages.extend('sql', {
	    comment: {
	      pattern: /\/\*[\s\S]*?\*\/|--.*/,
	      greedy: true
	    },
	    // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-reserved-words-keywords.html
	    keyword:
	      /\b(?:A|ACCESSIBLE|ADD|AGENT|AGGREGATE|ALL|ALTER|AND|ANY|ARRAY|AS|ASC|AT|ATTRIBUTE|AUTHID|AVG|BEGIN|BETWEEN|BFILE_BASE|BINARY|BLOB_BASE|BLOCK|BODY|BOTH|BOUND|BULK|BY|BYTE|C|CALL|CALLING|CASCADE|CASE|CHAR|CHARACTER|CHARSET|CHARSETFORM|CHARSETID|CHAR_BASE|CHECK|CLOB_BASE|CLONE|CLOSE|CLUSTER|CLUSTERS|COLAUTH|COLLECT|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPILED|COMPRESS|CONNECT|CONSTANT|CONSTRUCTOR|CONTEXT|CONTINUE|CONVERT|COUNT|CRASH|CREATE|CREDENTIAL|CURRENT|CURSOR|CUSTOMDATUM|DANGLING|DATA|DATE|DATE_BASE|DAY|DECLARE|DEFAULT|DEFINE|DELETE|DESC|DETERMINISTIC|DIRECTORY|DISTINCT|DOUBLE|DROP|DURATION|ELEMENT|ELSE|ELSIF|EMPTY|END|ESCAPE|EXCEPT|EXCEPTION|EXCEPTIONS|EXCLUSIVE|EXECUTE|EXISTS|EXIT|EXTERNAL|FETCH|FINAL|FIRST|FIXED|FLOAT|FOR|FORALL|FORCE|FROM|FUNCTION|GENERAL|GOTO|GRANT|GROUP|HASH|HAVING|HEAP|HIDDEN|HOUR|IDENTIFIED|IF|IMMEDIATE|IMMUTABLE|IN|INCLUDING|INDEX|INDEXES|INDICATOR|INDICES|INFINITE|INSERT|INSTANTIABLE|INT|INTERFACE|INTERSECT|INTERVAL|INTO|INVALIDATE|IS|ISOLATION|JAVA|LANGUAGE|LARGE|LEADING|LENGTH|LEVEL|LIBRARY|LIKE|LIKE2|LIKE4|LIKEC|LIMIT|LIMITED|LOCAL|LOCK|LONG|LOOP|MAP|MAX|MAXLEN|MEMBER|MERGE|MIN|MINUS|MINUTE|MOD|MODE|MODIFY|MONTH|MULTISET|MUTABLE|NAME|NAN|NATIONAL|NATIVE|NCHAR|NEW|NOCOMPRESS|NOCOPY|NOT|NOWAIT|NULL|NUMBER_BASE|OBJECT|OCICOLL|OCIDATE|OCIDATETIME|OCIDURATION|OCIINTERVAL|OCILOBLOCATOR|OCINUMBER|OCIRAW|OCIREF|OCIREFCURSOR|OCIROWID|OCISTRING|OCITYPE|OF|OLD|ON|ONLY|OPAQUE|OPEN|OPERATOR|OPTION|OR|ORACLE|ORADATA|ORDER|ORGANIZATION|ORLANY|ORLVARY|OTHERS|OUT|OVERLAPS|OVERRIDING|PACKAGE|PARALLEL_ENABLE|PARAMETER|PARAMETERS|PARENT|PARTITION|PASCAL|PERSISTABLE|PIPE|PIPELINED|PLUGGABLE|POLYMORPHIC|PRAGMA|PRECISION|PRIOR|PRIVATE|PROCEDURE|PUBLIC|RAISE|RANGE|RAW|READ|RECORD|REF|REFERENCE|RELIES_ON|REM|REMAINDER|RENAME|RESOURCE|RESULT|RESULT_CACHE|RETURN|RETURNING|REVERSE|REVOKE|ROLLBACK|ROW|SAMPLE|SAVE|SAVEPOINT|SB1|SB2|SB4|SECOND|SEGMENT|SELECT|SELF|SEPARATE|SEQUENCE|SERIALIZABLE|SET|SHARE|SHORT|SIZE|SIZE_T|SOME|SPARSE|SQL|SQLCODE|SQLDATA|SQLNAME|SQLSTATE|STANDARD|START|STATIC|STDDEV|STORED|STRING|STRUCT|STYLE|SUBMULTISET|SUBPARTITION|SUBSTITUTABLE|SUBTYPE|SUM|SYNONYM|TABAUTH|TABLE|TDO|THE|THEN|TIME|TIMESTAMP|TIMEZONE_ABBR|TIMEZONE_HOUR|TIMEZONE_MINUTE|TIMEZONE_REGION|TO|TRAILING|TRANSACTION|TRANSACTIONAL|TRUSTED|TYPE|UB1|UB2|UB4|UNDER|UNION|UNIQUE|UNPLUG|UNSIGNED|UNTRUSTED|UPDATE|USE|USING|VALIST|VALUE|VALUES|VARIABLE|VARIANCE|VARRAY|VARYING|VIEW|VIEWS|VOID|WHEN|WHERE|WHILE|WITH|WORK|WRAPPED|WRITE|YEAR|ZONE)\b/i,
	    // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-language-fundamentals.html#GUID-96A42F7C-7A71-4B90-8255-CA9C8BD9722E
	    operator: /:=?|=>|[<>^~!]=|\.\.|\|\||\*\*|[-+*/%<>=@]/
	  });
	  Prism.languages.insertBefore('plsql', 'operator', {
	    label: {
	      pattern: /<<\s*\w+\s*>>/,
	      alias: 'symbol'
	    }
	  });
	}
	return plsql_1;
}

var powerquery_1;
var hasRequiredPowerquery;

function requirePowerquery () {
	if (hasRequiredPowerquery) return powerquery_1;
	hasRequiredPowerquery = 1;

	powerquery_1 = powerquery;
	powerquery.displayName = 'powerquery';
	powerquery.aliases = [];
	function powerquery(Prism) {
	  // https://docs.microsoft.com/en-us/powerquery-m/power-query-m-language-specification
	  Prism.languages.powerquery = {
	    comment: {
	      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
	      lookbehind: true,
	      greedy: true
	    },
	    'quoted-identifier': {
	      pattern: /#"(?:[^"\r\n]|"")*"(?!")/,
	      greedy: true
	    },
	    string: {
	      pattern: /(?:#!)?"(?:[^"\r\n]|"")*"(?!")/,
	      greedy: true
	    },
	    constant: [
	      /\bDay\.(?:Friday|Monday|Saturday|Sunday|Thursday|Tuesday|Wednesday)\b/,
	      /\bTraceLevel\.(?:Critical|Error|Information|Verbose|Warning)\b/,
	      /\bOccurrence\.(?:All|First|Last)\b/,
	      /\bOrder\.(?:Ascending|Descending)\b/,
	      /\bRoundingMode\.(?:AwayFromZero|Down|ToEven|TowardZero|Up)\b/,
	      /\bMissingField\.(?:Error|Ignore|UseNull)\b/,
	      /\bQuoteStyle\.(?:Csv|None)\b/,
	      /\bJoinKind\.(?:FullOuter|Inner|LeftAnti|LeftOuter|RightAnti|RightOuter)\b/,
	      /\bGroupKind\.(?:Global|Local)\b/,
	      /\bExtraValues\.(?:Error|Ignore|List)\b/,
	      /\bJoinAlgorithm\.(?:Dynamic|LeftHash|LeftIndex|PairwiseHash|RightHash|RightIndex|SortMerge)\b/,
	      /\bJoinSide\.(?:Left|Right)\b/,
	      /\bPrecision\.(?:Decimal|Double)\b/,
	      /\bRelativePosition\.From(?:End|Start)\b/,
	      /\bTextEncoding\.(?:Ascii|BigEndianUnicode|Unicode|Utf16|Utf8|Windows)\b/,
	      /\b(?:Any|Binary|Date|DateTime|DateTimeZone|Duration|Function|Int16|Int32|Int64|Int8|List|Logical|None|Number|Record|Table|Text|Time)\.Type\b/,
	      /\bnull\b/
	    ],
	    boolean: /\b(?:false|true)\b/,
	    keyword:
	      /\b(?:and|as|each|else|error|if|in|is|let|meta|not|nullable|optional|or|otherwise|section|shared|then|try|type)\b|#(?:binary|date|datetime|datetimezone|duration|infinity|nan|sections|shared|table|time)\b/,
	    function: {
	      pattern: /(^|[^#\w.])[a-z_][\w.]*(?=\s*\()/i,
	      lookbehind: true
	    },
	    'data-type': {
	      pattern:
	        /\b(?:any|anynonnull|binary|date|datetime|datetimezone|duration|function|list|logical|none|number|record|table|text|time)\b/,
	      alias: 'class-name'
	    },
	    number: {
	      pattern:
	        /\b0x[\da-f]+\b|(?:[+-]?(?:\b\d+\.)?\b\d+|[+-]\.\d+|(^|[^.])\B\.\d+)(?:e[+-]?\d+)?\b/i,
	      lookbehind: true
	    },
	    operator: /[-+*\/&?@^]|<(?:=>?|>)?|>=?|=>?|\.\.\.?/,
	    punctuation: /[,;\[\](){}]/
	  };
	  Prism.languages.pq = Prism.languages['powerquery'];
	  Prism.languages.mscript = Prism.languages['powerquery'];
	}
	return powerquery_1;
}

var powershell_1;
var hasRequiredPowershell;

function requirePowershell () {
	if (hasRequiredPowershell) return powershell_1;
	hasRequiredPowershell = 1;

	powershell_1 = powershell;
	powershell.displayName = 'powershell';
	powershell.aliases = [];
	function powershell(Prism) {
(function (Prism) {
	    var powershell = (Prism.languages.powershell = {
	      comment: [
	        {
	          pattern: /(^|[^`])<#[\s\S]*?#>/,
	          lookbehind: true
	        },
	        {
	          pattern: /(^|[^`])#.*/,
	          lookbehind: true
	        }
	      ],
	      string: [
	        {
	          pattern: /"(?:`[\s\S]|[^`"])*"/,
	          greedy: true,
	          inside: null // see below
	        },
	        {
	          pattern: /'(?:[^']|'')*'/,
	          greedy: true
	        }
	      ],
	      // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
	      // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
	      namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
	      boolean: /\$(?:false|true)\b/i,
	      variable: /\$\w+\b/,
	      // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
	      // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
	      // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
	      function: [
	        /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
	        /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
	      ],
	      // per http://technet.microsoft.com/en-us/library/hh847744.aspx
	      keyword:
	        /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
	      operator: {
	        pattern:
	          /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
	        lookbehind: true
	      },
	      punctuation: /[|{}[\];(),.]/
	    }); // Variable interpolation inside strings, and nested expressions
	    powershell.string[0].inside = {
	      function: {
	        // Allow for one level of nesting
	        pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
	        lookbehind: true,
	        inside: powershell
	      },
	      boolean: powershell.boolean,
	      variable: powershell.variable
	    };
	  })(Prism);
	}
	return powershell_1;
}

var processing_1;
var hasRequiredProcessing;

function requireProcessing () {
	if (hasRequiredProcessing) return processing_1;
	hasRequiredProcessing = 1;

	processing_1 = processing;
	processing.displayName = 'processing';
	processing.aliases = [];
	function processing(Prism) {
	  Prism.languages.processing = Prism.languages.extend('clike', {
	    keyword:
	      /\b(?:break|case|catch|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\b/,
	    // Spaces are allowed between function name and parenthesis
	    function: /\b\w+(?=\s*\()/,
	    operator: /<[<=]?|>[>=]?|&&?|\|\|?|[%?]|[!=+\-*\/]=?/
	  });
	  Prism.languages.insertBefore('processing', 'number', {
	    // Special case: XML is a type
	    constant: /\b(?!XML\b)[A-Z][A-Z\d_]+\b/,
	    type: {
	      pattern: /\b(?:boolean|byte|char|color|double|float|int|[A-Z]\w*)\b/,
	      alias: 'class-name'
	    }
	  });
	}
	return processing_1;
}

var prolog_1;
var hasRequiredProlog;

function requireProlog () {
	if (hasRequiredProlog) return prolog_1;
	hasRequiredProlog = 1;

	prolog_1 = prolog;
	prolog.displayName = 'prolog';
	prolog.aliases = [];
	function prolog(Prism) {
	  Prism.languages.prolog = {
	    // Syntax depends on the implementation
	    comment: {
	      pattern: /\/\*[\s\S]*?\*\/|%.*/,
	      greedy: true
	    },
	    // Depending on the implementation, strings may allow escaped newlines and quote-escape
	    string: {
	      pattern: /(["'])(?:\1\1|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1(?!\1)/,
	      greedy: true
	    },
	    builtin: /\b(?:fx|fy|xf[xy]?|yfx?)\b/,
	    // FIXME: Should we list all null-ary predicates (not followed by a parenthesis) like halt, trace, etc.?
	    function: /\b[a-z]\w*(?:(?=\()|\/\d+)/,
	    number: /\b\d+(?:\.\d*)?/,
	    // Custom operators are allowed
	    operator: /[:\\=><\-?*@\/;+^|!$.]+|\b(?:is|mod|not|xor)\b/,
	    punctuation: /[(){}\[\],]/
	  };
	}
	return prolog_1;
}

var promql_1;
var hasRequiredPromql;

function requirePromql () {
	if (hasRequiredPromql) return promql_1;
	hasRequiredPromql = 1;

	promql_1 = promql;
	promql.displayName = 'promql';
	promql.aliases = [];
	function promql(Prism) {
(function (Prism) {
	    // PromQL Aggregation Operators
	    // (https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
	    var aggregations = [
	      'sum',
	      'min',
	      'max',
	      'avg',
	      'group',
	      'stddev',
	      'stdvar',
	      'count',
	      'count_values',
	      'bottomk',
	      'topk',
	      'quantile'
	    ]; // PromQL vector matching + the by and without clauses
	    // (https://prometheus.io/docs/prometheus/latest/querying/operators/#vector-matching)
	    var vectorMatching = [
	      'on',
	      'ignoring',
	      'group_right',
	      'group_left',
	      'by',
	      'without'
	    ]; // PromQL offset modifier
	    // (https://prometheus.io/docs/prometheus/latest/querying/basics/#offset-modifier)
	    var offsetModifier = ['offset'];
	    var keywords = aggregations.concat(vectorMatching, offsetModifier);
	    Prism.languages.promql = {
	      comment: {
	        pattern: /(^[ \t]*)#.*/m,
	        lookbehind: true
	      },
	      'vector-match': {
	        // Match the comma-separated label lists inside vector matching:
	        pattern: new RegExp(
	          '((?:' + vectorMatching.join('|') + ')\\s*)\\([^)]*\\)'
	        ),
	        lookbehind: true,
	        inside: {
	          'label-key': {
	            pattern: /\b[^,]+\b/,
	            alias: 'attr-name'
	          },
	          punctuation: /[(),]/
	        }
	      },
	      'context-labels': {
	        pattern: /\{[^{}]*\}/,
	        inside: {
	          'label-key': {
	            pattern: /\b[a-z_]\w*(?=\s*(?:=|![=~]))/,
	            alias: 'attr-name'
	          },
	          'label-value': {
	            pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
	            greedy: true,
	            alias: 'attr-value'
	          },
	          punctuation: /\{|\}|=~?|![=~]|,/
	        }
	      },
	      'context-range': [
	        {
	          pattern: /\[[\w\s:]+\]/,
	          // [1m]
	          inside: {
	            punctuation: /\[|\]|:/,
	            'range-duration': {
	              pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
	              alias: 'number'
	            }
	          }
	        },
	        {
	          pattern: /(\boffset\s+)\w+/,
	          // offset 1m
	          lookbehind: true,
	          inside: {
	            'range-duration': {
	              pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
	              alias: 'number'
	            }
	          }
	        }
	      ],
	      keyword: new RegExp('\\b(?:' + keywords.join('|') + ')\\b', 'i'),
	      function: /\b[a-z_]\w*(?=\s*\()/i,
	      number:
	        /[-+]?(?:(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[-+]?\d+)?\b|\b(?:0x[0-9a-f]+|nan|inf)\b)/i,
	      operator: /[\^*/%+-]|==|!=|<=|<|>=|>|\b(?:and|or|unless)\b/i,
	      punctuation: /[{};()`,.[\]]/
	    };
	  })(Prism);
	}
	return promql_1;
}

var properties_1;
var hasRequiredProperties;

function requireProperties () {
	if (hasRequiredProperties) return properties_1;
	hasRequiredProperties = 1;

	properties_1 = properties;
	properties.displayName = 'properties';
	properties.aliases = [];
	function properties(Prism) {
	  Prism.languages.properties = {
	    comment: /^[ \t]*[#!].*$/m,
	    'attr-value': {
	      pattern:
	        /(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?: *[=:] *(?! )| ))(?:\\(?:\r\n|[\s\S])|[^\\\r\n])+/m,
	      lookbehind: true
	    },
	    'attr-name': /^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?= *[=:]| )/m,
	    punctuation: /[=:]/
	  };
	}
	return properties_1;
}

var protobuf_1;
var hasRequiredProtobuf;

function requireProtobuf () {
	if (hasRequiredProtobuf) return protobuf_1;
	hasRequiredProtobuf = 1;

	protobuf_1 = protobuf;
	protobuf.displayName = 'protobuf';
	protobuf.aliases = [];
	function protobuf(Prism) {
(function (Prism) {
	    var builtinTypes =
	      /\b(?:bool|bytes|double|s?fixed(?:32|64)|float|[su]?int(?:32|64)|string)\b/;
	    Prism.languages.protobuf = Prism.languages.extend('clike', {
	      'class-name': [
	        {
	          pattern:
	            /(\b(?:enum|extend|message|service)\s+)[A-Za-z_]\w*(?=\s*\{)/,
	          lookbehind: true
	        },
	        {
	          pattern:
	            /(\b(?:rpc\s+\w+|returns)\s*\(\s*(?:stream\s+)?)\.?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*(?=\s*\))/,
	          lookbehind: true
	        }
	      ],
	      keyword:
	        /\b(?:enum|extend|extensions|import|message|oneof|option|optional|package|public|repeated|required|reserved|returns|rpc(?=\s+\w)|service|stream|syntax|to)\b(?!\s*=\s*\d)/,
	      function: /\b[a-z_]\w*(?=\s*\()/i
	    });
	    Prism.languages.insertBefore('protobuf', 'operator', {
	      map: {
	        pattern: /\bmap<\s*[\w.]+\s*,\s*[\w.]+\s*>(?=\s+[a-z_]\w*\s*[=;])/i,
	        alias: 'class-name',
	        inside: {
	          punctuation: /[<>.,]/,
	          builtin: builtinTypes
	        }
	      },
	      builtin: builtinTypes,
	      'positional-class-name': {
	        pattern: /(?:\b|\B\.)[a-z_]\w*(?:\.[a-z_]\w*)*(?=\s+[a-z_]\w*\s*[=;])/i,
	        alias: 'class-name',
	        inside: {
	          punctuation: /\./
	        }
	      },
	      annotation: {
	        pattern: /(\[\s*)[a-z_]\w*(?=\s*=)/i,
	        lookbehind: true
	      }
	    });
	  })(Prism);
	}
	return protobuf_1;
}

var psl_1;
var hasRequiredPsl;

function requirePsl () {
	if (hasRequiredPsl) return psl_1;
	hasRequiredPsl = 1;

	psl_1 = psl;
	psl.displayName = 'psl';
	psl.aliases = [];
	function psl(Prism) {
	  Prism.languages.psl = {
	    comment: {
	      pattern: /#.*/,
	      greedy: true
	    },
	    string: {
	      pattern: /"(?:\\.|[^\\"])*"/,
	      greedy: true,
	      inside: {
	        symbol: /\\[ntrbA-Z"\\]/
	      }
	    },
	    'heredoc-string': {
	      pattern: /<<<([a-zA-Z_]\w*)[\r\n](?:.*[\r\n])*?\1\b/,
	      alias: 'string',
	      greedy: true
	    },
	    keyword:
	      /\b(?:__multi|__single|case|default|do|else|elsif|exit|export|for|foreach|function|if|last|line|local|next|requires|return|switch|until|while|word)\b/,
	    constant:
	      /\b(?:ALARM|CHART_ADD_GRAPH|CHART_DELETE_GRAPH|CHART_DESTROY|CHART_LOAD|CHART_PRINT|EOF|OFFLINE|OK|PSL_PROF_LOG|R_CHECK_HORIZ|R_CHECK_VERT|R_CLICKER|R_COLUMN|R_FRAME|R_ICON|R_LABEL|R_LABEL_CENTER|R_LIST_MULTIPLE|R_LIST_MULTIPLE_ND|R_LIST_SINGLE|R_LIST_SINGLE_ND|R_MENU|R_POPUP|R_POPUP_SCROLLED|R_RADIO_HORIZ|R_RADIO_VERT|R_ROW|R_SCALE_HORIZ|R_SCALE_VERT|R_SEP_HORIZ|R_SEP_VERT|R_SPINNER|R_TEXT_FIELD|R_TEXT_FIELD_LABEL|R_TOGGLE|TRIM_LEADING|TRIM_LEADING_AND_TRAILING|TRIM_REDUNDANT|TRIM_TRAILING|VOID|WARN)\b/,
	    boolean: /\b(?:FALSE|False|NO|No|TRUE|True|YES|Yes|false|no|true|yes)\b/,
	    variable: /\b(?:PslDebug|errno|exit_status)\b/,
	    builtin: {
	      pattern:
	        /\b(?:PslExecute|PslFunctionCall|PslFunctionExists|PslSetOptions|_snmp_debug|acos|add_diary|annotate|annotate_get|ascii_to_ebcdic|asctime|asin|atan|atexit|batch_set|blackout|cat|ceil|chan_exists|change_state|close|code_cvt|cond_signal|cond_wait|console_type|convert_base|convert_date|convert_locale_date|cos|cosh|create|date|dcget_text|destroy|destroy_lock|dget_text|difference|dump_hist|ebcdic_to_ascii|encrypt|event_archive|event_catalog_get|event_check|event_query|event_range_manage|event_range_query|event_report|event_schedule|event_trigger|event_trigger2|execute|exists|exp|fabs|file|floor|fmod|fopen|fseek|ftell|full_discovery|get|get_chan_info|get_ranges|get_text|get_vars|getenv|gethostinfo|getpid|getpname|grep|history|history_get_retention|in_transition|index|int|internal|intersection|is_var|isnumber|join|kill|length|lines|lock|lock_info|log|log10|loge|matchline|msg_check|msg_get_format|msg_get_severity|msg_printf|msg_sprintf|ntharg|nthargf|nthline|nthlinef|num_bytes|num_consoles|pconfig|popen|poplines|pow|print|printf|proc_exists|process|random|read|readln|refresh_parameters|remote_check|remote_close|remote_event_query|remote_event_trigger|remote_file_send|remote_open|remove|replace|rindex|sec_check_priv|sec_store_get|sec_store_set|set|set_alarm_ranges|set_locale|share|sin|sinh|sleep|snmp_agent_config|snmp_agent_start|snmp_agent_stop|snmp_close|snmp_config|snmp_get|snmp_get_next|snmp_h_get|snmp_h_get_next|snmp_h_set|snmp_open|snmp_set|snmp_trap_ignore|snmp_trap_listen|snmp_trap_raise_std_trap|snmp_trap_receive|snmp_trap_register_im|snmp_trap_send|snmp_walk|sopen|sort|splitline|sprintf|sqrt|srandom|str_repeat|strcasecmp|subset|substr|system|tail|tan|tanh|text_domain|time|tmpnam|tolower|toupper|trace_psl_process|trim|union|unique|unlock|unset|va_arg|va_start|write)\b/,
	      alias: 'builtin-function'
	    },
	    'foreach-variable': {
	      pattern:
	        /(\bforeach\s+(?:(?:\w+\b|"(?:\\.|[^\\"])*")\s+){0,2})[_a-zA-Z]\w*(?=\s*\()/,
	      lookbehind: true,
	      greedy: true
	    },
	    function: /\b[_a-z]\w*\b(?=\s*\()/i,
	    number: /\b(?:0x[0-9a-f]+|\d+(?:\.\d+)?)\b/i,
	    operator: /--|\+\+|&&=?|\|\|=?|<<=?|>>=?|[=!]~|[-+*/%&|^!=<>]=?|\.|[:?]/,
	    punctuation: /[(){}\[\];,]/
	  };
	}
	return psl_1;
}

var pug_1;
var hasRequiredPug;

function requirePug () {
	if (hasRequiredPug) return pug_1;
	hasRequiredPug = 1;

	pug_1 = pug;
	pug.displayName = 'pug';
	pug.aliases = [];
	function pug(Prism) {
(function (Prism) {
	    // TODO:
	    // - Add CSS highlighting inside <style> tags
	    // - Add support for multi-line code blocks
	    // - Add support for interpolation #{} and !{}
	    // - Add support for tag interpolation #[]
	    // - Add explicit support for plain text using |
	    // - Add support for markup embedded in plain text
	    Prism.languages.pug = {
	      // Multiline stuff should appear before the rest
	      // This handles both single-line and multi-line comments
	      comment: {
	        pattern: /(^([\t ]*))\/\/.*(?:(?:\r?\n|\r)\2[\t ].+)*/m,
	        lookbehind: true
	      },
	      // All the tag-related part is in lookbehind
	      // so that it can be highlighted by the "tag" pattern
	      'multiline-script': {
	        pattern:
	          /(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
	        lookbehind: true,
	        inside: Prism.languages.javascript
	      },
	      // See at the end of the file for known filters
	      filter: {
	        pattern:
	          /(^([\t ]*)):.+(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
	        lookbehind: true,
	        inside: {
	          'filter-name': {
	            pattern: /^:[\w-]+/,
	            alias: 'variable'
	          },
	          text: /\S[\s\S]*/
	        }
	      },
	      'multiline-plain-text': {
	        pattern:
	          /(^([\t ]*)[\w\-#.]+\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
	        lookbehind: true
	      },
	      markup: {
	        pattern: /(^[\t ]*)<.+/m,
	        lookbehind: true,
	        inside: Prism.languages.markup
	      },
	      doctype: {
	        pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/,
	        lookbehind: true
	      },
	      // This handle all conditional and loop keywords
	      'flow-control': {
	        pattern:
	          /(^[\t ]*)(?:case|default|each|else|if|unless|when|while)\b(?: .+)?/m,
	        lookbehind: true,
	        inside: {
	          each: {
	            pattern: /^each .+? in\b/,
	            inside: {
	              keyword: /\b(?:each|in)\b/,
	              punctuation: /,/
	            }
	          },
	          branch: {
	            pattern: /^(?:case|default|else|if|unless|when|while)\b/,
	            alias: 'keyword'
	          },
	          rest: Prism.languages.javascript
	        }
	      },
	      keyword: {
	        pattern: /(^[\t ]*)(?:append|block|extends|include|prepend)\b.+/m,
	        lookbehind: true
	      },
	      mixin: [
	        // Declaration
	        {
	          pattern: /(^[\t ]*)mixin .+/m,
	          lookbehind: true,
	          inside: {
	            keyword: /^mixin/,
	            function: /\w+(?=\s*\(|\s*$)/,
	            punctuation: /[(),.]/
	          }
	        }, // Usage
	        {
	          pattern: /(^[\t ]*)\+.+/m,
	          lookbehind: true,
	          inside: {
	            name: {
	              pattern: /^\+\w+/,
	              alias: 'function'
	            },
	            rest: Prism.languages.javascript
	          }
	        }
	      ],
	      script: {
	        pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]).+/m,
	        lookbehind: true,
	        inside: Prism.languages.javascript
	      },
	      'plain-text': {
	        pattern:
	          /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]).+/m,
	        lookbehind: true
	      },
	      tag: {
	        pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
	        lookbehind: true,
	        inside: {
	          attributes: [
	            {
	              pattern: /&[^(]+\([^)]+\)/,
	              inside: Prism.languages.javascript
	            },
	            {
	              pattern: /\([^)]+\)/,
	              inside: {
	                'attr-value': {
	                  pattern: /(=\s*(?!\s))(?:\{[^}]*\}|[^,)\r\n]+)/,
	                  lookbehind: true,
	                  inside: Prism.languages.javascript
	                },
	                'attr-name': /[\w-]+(?=\s*!?=|\s*[,)])/,
	                punctuation: /[!=(),]+/
	              }
	            }
	          ],
	          punctuation: /:/,
	          'attr-id': /#[\w\-]+/,
	          'attr-class': /\.[\w\-]+/
	        }
	      },
	      code: [
	        {
	          pattern: /(^[\t ]*(?:-|!?=)).+/m,
	          lookbehind: true,
	          inside: Prism.languages.javascript
	        }
	      ],
	      punctuation: /[.\-!=|]+/
	    };
	    var filter_pattern =
	      /(^([\t ]*)):<filter_name>(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/
	        .source; // Non exhaustive list of available filters and associated languages
	    var filters = [
	      {
	        filter: 'atpl',
	        language: 'twig'
	      },
	      {
	        filter: 'coffee',
	        language: 'coffeescript'
	      },
	      'ejs',
	      'handlebars',
	      'less',
	      'livescript',
	      'markdown',
	      {
	        filter: 'sass',
	        language: 'scss'
	      },
	      'stylus'
	    ];
	    var all_filters = {};
	    for (var i = 0, l = filters.length; i < l; i++) {
	      var filter = filters[i];
	      filter =
	        typeof filter === 'string'
	          ? {
	              filter: filter,
	              language: filter
	            }
	          : filter;
	      if (Prism.languages[filter.language]) {
	        all_filters['filter-' + filter.filter] = {
	          pattern: RegExp(
	            filter_pattern.replace('<filter_name>', function () {
	              return filter.filter
	            }),
	            'm'
	          ),
	          lookbehind: true,
	          inside: {
	            'filter-name': {
	              pattern: /^:[\w-]+/,
	              alias: 'variable'
	            },
	            text: {
	              pattern: /\S[\s\S]*/,
	              alias: [filter.language, 'language-' + filter.language],
	              inside: Prism.languages[filter.language]
	            }
	          }
	        };
	      }
	    }
	    Prism.languages.insertBefore('pug', 'filter', all_filters);
	  })(Prism);
	}
	return pug_1;
}

var puppet_1;
var hasRequiredPuppet;

function requirePuppet () {
	if (hasRequiredPuppet) return puppet_1;
	hasRequiredPuppet = 1;

	puppet_1 = puppet;
	puppet.displayName = 'puppet';
	puppet.aliases = [];
	function puppet(Prism) {
(function (Prism) {
	    Prism.languages.puppet = {
	      heredoc: [
	        // Matches the content of a quoted heredoc string (subject to interpolation)
	        {
	          pattern:
	            /(@\("([^"\r\n\/):]+)"(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
	          lookbehind: true,
	          alias: 'string',
	          inside: {
	            // Matches the end tag
	            punctuation: /(?=\S).*\S(?= *$)/ // See interpolation below
	          }
	        }, // Matches the content of an unquoted heredoc string (no interpolation)
	        {
	          pattern:
	            /(@\(([^"\r\n\/):]+)(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
	          lookbehind: true,
	          greedy: true,
	          alias: 'string',
	          inside: {
	            // Matches the end tag
	            punctuation: /(?=\S).*\S(?= *$)/
	          }
	        }, // Matches the start tag of heredoc strings
	        {
	          pattern: /@\("?(?:[^"\r\n\/):]+)"?(?:\/[nrts$uL]*)?\)/,
	          alias: 'string',
	          inside: {
	            punctuation: {
	              pattern: /(\().+?(?=\))/,
	              lookbehind: true
	            }
	          }
	        }
	      ],
	      'multiline-comment': {
	        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
	        lookbehind: true,
	        greedy: true,
	        alias: 'comment'
	      },
	      regex: {
	        // Must be prefixed with the keyword "node" or a non-word char
	        pattern:
	          /((?:\bnode\s+|[~=\(\[\{,]\s*|[=+]>\s*|^\s*))\/(?:[^\/\\]|\\[\s\S])+\/(?:[imx]+\b|\B)/,
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          // Extended regexes must have the x flag. They can contain single-line comments.
	          'extended-regex': {
	            pattern: /^\/(?:[^\/\\]|\\[\s\S])+\/[im]*x[im]*$/,
	            inside: {
	              comment: /#.*/
	            }
	          }
	        }
	      },
	      comment: {
	        pattern: /(^|[^\\])#.*/,
	        lookbehind: true,
	        greedy: true
	      },
	      string: {
	        // Allow for one nested level of double quotes inside interpolation
	        pattern:
	          /(["'])(?:\$\{(?:[^'"}]|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}|\$(?!\{)|(?!\1)[^\\$]|\\[\s\S])*\1/,
	        greedy: true,
	        inside: {
	          'double-quoted': {
	            pattern: /^"[\s\S]*"$/,
	            inside: {
	              // See interpolation below
	            }
	          }
	        }
	      },
	      variable: {
	        pattern: /\$(?:::)?\w+(?:::\w+)*/,
	        inside: {
	          punctuation: /::/
	        }
	      },
	      'attr-name': /(?:\b\w+|\*)(?=\s*=>)/,
	      function: [
	        {
	          pattern: /(\.)(?!\d)\w+/,
	          lookbehind: true
	        },
	        /\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\b|\b(?!\d)\w+(?=\()/
	      ],
	      number: /\b(?:0x[a-f\d]+|\d+(?:\.\d+)?(?:e-?\d+)?)\b/i,
	      boolean: /\b(?:false|true)\b/,
	      // Includes words reserved for future use
	      keyword:
	        /\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\b/,
	      datatype: {
	        pattern:
	          /\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\b/,
	        alias: 'symbol'
	      },
	      operator:
	        /=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,
	      punctuation: /[\[\]{}().,;]|:+/
	    };
	    var interpolation = [
	      {
	        // Allow for one nested level of braces inside interpolation
	        pattern:
	          /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
	        lookbehind: true,
	        inside: {
	          'short-variable': {
	            // Negative look-ahead prevent wrong highlighting of functions
	            pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
	            lookbehind: true,
	            alias: 'variable',
	            inside: {
	              punctuation: /::/
	            }
	          },
	          delimiter: {
	            pattern: /^\$/,
	            alias: 'variable'
	          },
	          rest: Prism.languages.puppet
	        }
	      },
	      {
	        pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
	        lookbehind: true,
	        alias: 'variable',
	        inside: {
	          punctuation: /::/
	        }
	      }
	    ];
	    Prism.languages.puppet['heredoc'][0].inside.interpolation = interpolation;
	    Prism.languages.puppet['string'].inside[
	      'double-quoted'
	    ].inside.interpolation = interpolation;
	  })(Prism);
	}
	return puppet_1;
}

var pure_1;
var hasRequiredPure;

function requirePure () {
	if (hasRequiredPure) return pure_1;
	hasRequiredPure = 1;

	pure_1 = pure;
	pure.displayName = 'pure';
	pure.aliases = [];
	function pure(Prism) {
(function (Prism) {
	    // https://agraef.github.io/pure-docs/pure.html#lexical-matters
	    Prism.languages.pure = {
	      comment: [
	        {
	          pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
	          lookbehind: true
	        },
	        {
	          pattern: /(^|[^\\:])\/\/.*/,
	          lookbehind: true
	        },
	        /#!.+/
	      ],
	      'inline-lang': {
	        pattern: /%<[\s\S]+?%>/,
	        greedy: true,
	        inside: {
	          lang: {
	            pattern: /(^%< *)-\*-.+?-\*-/,
	            lookbehind: true,
	            alias: 'comment'
	          },
	          delimiter: {
	            pattern: /^%<.*|%>$/,
	            alias: 'punctuation'
	          }
	        }
	      },
	      string: {
	        pattern: /"(?:\\.|[^"\\\r\n])*"/,
	        greedy: true
	      },
	      number: {
	        // The look-behind prevents wrong highlighting of the .. operator
	        pattern:
	          /((?:\.\.)?)(?:\b(?:inf|nan)\b|\b0x[\da-f]+|(?:\b(?:0b)?\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?L?)/i,
	        lookbehind: true
	      },
	      keyword:
	        /\b(?:NULL|ans|break|bt|case|catch|cd|clear|const|def|del|dump|else|end|exit|extern|false|force|help|if|infix[lr]?|interface|let|ls|mem|namespace|nonfix|of|otherwise|outfix|override|postfix|prefix|private|public|pwd|quit|run|save|show|stats|then|throw|trace|true|type|underride|using|when|with)\b/,
	      function:
	        /\b(?:abs|add_(?:addr|constdef|(?:fundef|interface|macdef|typedef)(?:_at)?|vardef)|all|any|applp?|arity|bigintp?|blob(?:_crc|_size|p)?|boolp?|byte_c?string(?:_pointer)?|byte_(?:matrix|pointer)|calloc|cat|catmap|ceil|char[ps]?|check_ptrtag|chr|clear_sentry|clearsym|closurep?|cmatrixp?|cols?|colcat(?:map)?|colmap|colrev|colvector(?:p|seq)?|complex(?:_float_(?:matrix|pointer)|_matrix(?:_view)?|_pointer|p)?|conj|cookedp?|cst|cstring(?:_(?:dup|list|vector))?|curry3?|cyclen?|del_(?:constdef|fundef|interface|macdef|typedef|vardef)|delete|diag(?:mat)?|dim|dmatrixp?|do|double(?:_matrix(?:_view)?|_pointer|p)?|dowith3?|drop|dropwhile|eval(?:cmd)?|exactp|filter|fix|fixity|flip|float(?:_matrix|_pointer)|floor|fold[lr]1?|frac|free|funp?|functionp?|gcd|get(?:_(?:byte|constdef|double|float|fundef|int(?:64)?|interface(?:_typedef)?|long|macdef|pointer|ptrtag|sentry|short|string|typedef|vardef))?|globsym|hash|head|id|im|imatrixp?|index|inexactp|infp|init|insert|int(?:_matrix(?:_view)?|_pointer|p)?|int64_(?:matrix|pointer)|integerp?|iteraten?|iterwhile|join|keys?|lambdap?|last(?:err(?:pos)?)?|lcd|list[2p]?|listmap|make_ptrtag|malloc|map|matcat|matrixp?|max|member|min|nanp|nargs|nmatrixp?|null|numberp?|ord|pack(?:ed)?|pointer(?:_cast|_tag|_type|p)?|pow|pred|ptrtag|put(?:_(?:byte|double|float|int(?:64)?|long|pointer|short|string))?|rationalp?|re|realp?|realloc|recordp?|redim|reduce(?:_with)?|refp?|repeatn?|reverse|rlistp?|round|rows?|rowcat(?:map)?|rowmap|rowrev|rowvector(?:p|seq)?|same|scan[lr]1?|sentry|sgn|short_(?:matrix|pointer)|slice|smatrixp?|sort|split|str|strcat|stream|stride|string(?:_(?:dup|list|vector)|p)?|subdiag(?:mat)?|submat|subseq2?|substr|succ|supdiag(?:mat)?|symbolp?|tail|take|takewhile|thunkp?|transpose|trunc|tuplep?|typep|ubyte|uint(?:64)?|ulong|uncurry3?|unref|unzip3?|update|ushort|vals?|varp?|vector(?:p|seq)?|void|zip3?|zipwith3?)\b/,
	      special: {
	        pattern: /\b__[a-z]+__\b/i,
	        alias: 'builtin'
	      },
	      // Any combination of operator chars can be an operator
	      // eslint-disable-next-line no-misleading-character-class
	      operator:
	        /(?:[!"#$%&'*+,\-.\/:<=>?@\\^`|~\u00a1-\u00bf\u00d7-\u00f7\u20d0-\u2bff]|\b_+\b)+|\b(?:and|div|mod|not|or)\b/,
	      // FIXME: How can we prevent | and , to be highlighted as operator when they are used alone?
	      punctuation: /[(){}\[\];,|]/
	    };
	    var inlineLanguages = [
	      'c',
	      {
	        lang: 'c++',
	        alias: 'cpp'
	      },
	      'fortran'
	    ];
	    var inlineLanguageRe = /%< *-\*- *<lang>\d* *-\*-[\s\S]+?%>/.source;
	    inlineLanguages.forEach(function (lang) {
	      var alias = lang;
	      if (typeof lang !== 'string') {
	        alias = lang.alias;
	        lang = lang.lang;
	      }
	      if (Prism.languages[alias]) {
	        var o = {};
	        o['inline-lang-' + alias] = {
	          pattern: RegExp(
	            inlineLanguageRe.replace(
	              '<lang>',
	              lang.replace(/([.+*?\/\\(){}\[\]])/g, '\\$1')
	            ),
	            'i'
	          ),
	          inside: Prism.util.clone(Prism.languages.pure['inline-lang'].inside)
	        };
	        o['inline-lang-' + alias].inside.rest = Prism.util.clone(
	          Prism.languages[alias]
	        );
	        Prism.languages.insertBefore('pure', 'inline-lang', o);
	      }
	    }); // C is the default inline language
	    if (Prism.languages.c) {
	      Prism.languages.pure['inline-lang'].inside.rest = Prism.util.clone(
	        Prism.languages.c
	      );
	    }
	  })(Prism);
	}
	return pure_1;
}

var purebasic_1;
var hasRequiredPurebasic;

function requirePurebasic () {
	if (hasRequiredPurebasic) return purebasic_1;
	hasRequiredPurebasic = 1;

	purebasic_1 = purebasic;
	purebasic.displayName = 'purebasic';
	purebasic.aliases = [];
	function purebasic(Prism) {
	  /*
	Original Code by Bas Groothedde
	!!MANY THANKS!! I never would have made this, regex and me will never be best friends ;)
	==> https://codepen.io/ImagineProgramming/details/JYydBy/
	slightly changed to pass all tests
	*/
	  // PureBasic support, steal stuff from ansi-c
	  Prism.languages.purebasic = Prism.languages.extend('clike', {
	    comment: /;.*/,
	    keyword:
	      /\b(?:align|and|as|break|calldebugger|case|compilercase|compilerdefault|compilerelse|compilerelseif|compilerendif|compilerendselect|compilererror|compilerif|compilerselect|continue|data|datasection|debug|debuglevel|declare|declarec|declarecdll|declaredll|declaremodule|default|define|dim|disableasm|disabledebugger|disableexplicit|else|elseif|enableasm|enabledebugger|enableexplicit|end|enddatasection|enddeclaremodule|endenumeration|endif|endimport|endinterface|endmacro|endmodule|endprocedure|endselect|endstructure|endstructureunion|endwith|enumeration|extends|fakereturn|for|foreach|forever|global|gosub|goto|if|import|importc|includebinary|includefile|includepath|interface|macro|module|newlist|newmap|next|not|or|procedure|procedurec|procedurecdll|proceduredll|procedurereturn|protected|prototype|prototypec|read|redim|repeat|restore|return|runtime|select|shared|static|step|structure|structureunion|swap|threaded|to|until|wend|while|with|xincludefile|xor)\b/i,
	    function: /\b\w+(?:\.\w+)?\s*(?=\()/,
	    number: /(?:\$[\da-f]+|\b-?(?:\d+(?:\.\d+)?|\.\d+)(?:e[+-]?\d+)?)\b/i,
	    operator:
	      /(?:@\*?|\?|\*)\w+|-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*/@]/
	  });
	  Prism.languages.insertBefore('purebasic', 'keyword', {
	    tag: /#\w+\$?/,
	    asm: {
	      pattern: /(^[\t ]*)!.*/m,
	      lookbehind: true,
	      alias: 'tag',
	      inside: {
	        comment: /;.*/,
	        string: {
	          pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
	          greedy: true
	        },
	        // Anonymous label references, i.e.: jmp @b
	        'label-reference-anonymous': {
	          pattern: /(!\s*j[a-z]+\s+)@[fb]/i,
	          lookbehind: true,
	          alias: 'fasm-label'
	        },
	        // Named label reference, i.e.: jne label1
	        'label-reference-addressed': {
	          pattern: /(!\s*j[a-z]+\s+)[A-Z._?$@][\w.?$@~#]*/i,
	          lookbehind: true,
	          alias: 'fasm-label'
	        },
	        keyword: [
	          /\b(?:extern|global)\b[^;\r\n]*/i,
	          /\b(?:CPU|DEFAULT|FLOAT)\b.*/
	        ],
	        function: {
	          pattern: /^([\t ]*!\s*)[\da-z]+(?=\s|$)/im,
	          lookbehind: true
	        },
	        'function-inline': {
	          pattern: /(:\s*)[\da-z]+(?=\s)/i,
	          lookbehind: true,
	          alias: 'function'
	        },
	        label: {
	          pattern: /^([\t ]*!\s*)[A-Za-z._?$@][\w.?$@~#]*(?=:)/m,
	          lookbehind: true,
	          alias: 'fasm-label'
	        },
	        register:
	          /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s|mm\d+)\b/i,
	        number:
	          /(?:\b|-|(?=\$))(?:0[hx](?:[\da-f]*\.)?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
	        operator: /[\[\]*+\-/%<>=&|$!,.:]/
	      }
	    }
	  });
	  delete Prism.languages.purebasic['class-name'];
	  delete Prism.languages.purebasic['boolean'];
	  Prism.languages.pbfasm = Prism.languages['purebasic'];
	}
	return purebasic_1;
}

var purescript_1;
var hasRequiredPurescript;

function requirePurescript () {
	if (hasRequiredPurescript) return purescript_1;
	hasRequiredPurescript = 1;
	var refractorHaskell = requireHaskell();
	purescript_1 = purescript;
	purescript.displayName = 'purescript';
	purescript.aliases = ['purs'];
	function purescript(Prism) {
	  Prism.register(refractorHaskell);
	  Prism.languages.purescript = Prism.languages.extend('haskell', {
	    keyword:
	      /\b(?:ado|case|class|data|derive|do|else|forall|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b|∀/,
	    'import-statement': {
	      // The imported or hidden names are not included in this import
	      // statement. This is because we want to highlight those exactly like
	      // we do for the names in the program.
	      pattern:
	        /(^[\t ]*)import\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*(?:\s+as\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
	      lookbehind: true,
	      inside: {
	        keyword: /\b(?:as|hiding|import)\b/,
	        punctuation: /\./
	      }
	    },
	    // These are builtin functions only. Constructors are highlighted later as a constant.
	    builtin:
	      /\b(?:absurd|add|ap|append|apply|between|bind|bottom|clamp|compare|comparing|compose|conj|const|degree|discard|disj|div|eq|flap|flip|gcd|identity|ifM|join|lcm|liftA1|liftM1|map|max|mempty|min|mod|mul|negate|not|notEq|one|otherwise|recip|show|sub|top|unit|unless|unlessM|void|when|whenM|zero)\b/,
	    operator: [
	      // Infix operators
	      Prism.languages.haskell.operator[0], // ASCII operators
	      Prism.languages.haskell.operator[2], // All UTF16 Unicode operator symbols
	      // This regex is equivalent to /(?=[\x80-\uFFFF])[\p{gc=Math_Symbol}\p{gc=Currency_Symbol}\p{Modifier_Symbol}\p{Other_Symbol}]/u
	      // See https://github.com/PrismJS/prism/issues/3006 for more details.
	      /[\xa2-\xa6\xa8\xa9\xac\xae-\xb1\xb4\xb8\xd7\xf7\u02c2-\u02c5\u02d2-\u02df\u02e5-\u02eb\u02ed\u02ef-\u02ff\u0375\u0384\u0385\u03f6\u0482\u058d-\u058f\u0606-\u0608\u060b\u060e\u060f\u06de\u06e9\u06fd\u06fe\u07f6\u07fe\u07ff\u09f2\u09f3\u09fa\u09fb\u0af1\u0b70\u0bf3-\u0bfa\u0c7f\u0d4f\u0d79\u0e3f\u0f01-\u0f03\u0f13\u0f15-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fce\u0fcf\u0fd5-\u0fd8\u109e\u109f\u1390-\u1399\u166d\u17db\u1940\u19de-\u19ff\u1b61-\u1b6a\u1b74-\u1b7c\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u2052\u207a-\u207c\u208a-\u208c\u20a0-\u20bf\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u213a\u213b\u2140-\u2144\u214a-\u214d\u214f\u218a\u218b\u2190-\u2307\u230c-\u2328\u232b-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2767\u2794-\u27c4\u27c7-\u27e5\u27f0-\u2982\u2999-\u29d7\u29dc-\u29fb\u29fe-\u2b73\u2b76-\u2b95\u2b97-\u2bff\u2ce5-\u2cea\u2e50\u2e51\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u31c0-\u31e3\u3200-\u321e\u322a-\u3247\u3250\u3260-\u327f\u328a-\u32b0\u32c0-\u33ff\u4dc0-\u4dff\ua490-\ua4c6\ua700-\ua716\ua720\ua721\ua789\ua78a\ua828-\ua82b\ua836-\ua839\uaa77-\uaa79\uab5b\uab6a\uab6b\ufb29\ufbb2-\ufbc1\ufdfc\ufdfd\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]/
	    ]
	  });
	  Prism.languages.purs = Prism.languages.purescript;
	}
	return purescript_1;
}

var python_1;
var hasRequiredPython;

function requirePython () {
	if (hasRequiredPython) return python_1;
	hasRequiredPython = 1;

	python_1 = python;
	python.displayName = 'python';
	python.aliases = ['py'];
	function python(Prism) {
	  Prism.languages.python = {
	    comment: {
	      pattern: /(^|[^\\])#.*/,
	      lookbehind: true,
	      greedy: true
	    },
	    'string-interpolation': {
	      pattern:
	        /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
	      greedy: true,
	      inside: {
	        interpolation: {
	          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
	          pattern:
	            /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
	          lookbehind: true,
	          inside: {
	            'format-spec': {
	              pattern: /(:)[^:(){}]+(?=\}$)/,
	              lookbehind: true
	            },
	            'conversion-option': {
	              pattern: /![sra](?=[:}]$)/,
	              alias: 'punctuation'
	            },
	            rest: null
	          }
	        },
	        string: /[\s\S]+/
	      }
	    },
	    'triple-quoted-string': {
	      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
	      greedy: true,
	      alias: 'string'
	    },
	    string: {
	      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
	      greedy: true
	    },
	    function: {
	      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
	      lookbehind: true
	    },
	    'class-name': {
	      pattern: /(\bclass\s+)\w+/i,
	      lookbehind: true
	    },
	    decorator: {
	      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
	      lookbehind: true,
	      alias: ['annotation', 'punctuation'],
	      inside: {
	        punctuation: /\./
	      }
	    },
	    keyword:
	      /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
	    builtin:
	      /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
	    boolean: /\b(?:False|None|True)\b/,
	    number:
	      /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
	    operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
	    punctuation: /[{}[\];(),.:]/
	  };
	  Prism.languages.python['string-interpolation'].inside[
	    'interpolation'
	  ].inside.rest = Prism.languages.python;
	  Prism.languages.py = Prism.languages.python;
	}
	return python_1;
}

var q_1;
var hasRequiredQ;

function requireQ () {
	if (hasRequiredQ) return q_1;
	hasRequiredQ = 1;

	q_1 = q;
	q.displayName = 'q';
	q.aliases = [];
	function q(Prism) {
	  Prism.languages.q = {
	    string: /"(?:\\.|[^"\\\r\n])*"/,
	    comment: [
	      // From http://code.kx.com/wiki/Reference/Slash:
	      // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
	      {
	        pattern: /([\t )\]}])\/.*/,
	        lookbehind: true,
	        greedy: true
	      }, // From http://code.kx.com/wiki/Reference/Slash:
	      // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
	      // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
	      // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
	      // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
	      {
	        pattern:
	          /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
	        lookbehind: true,
	        greedy: true
	      }, // From http://code.kx.com/wiki/Reference/Slash:
	      // A \ on a line by itself with no preceding matching / will comment to end of file.
	      {
	        pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
	        greedy: true
	      },
	      {
	        pattern: /^#!.+/m,
	        greedy: true
	      }
	    ],
	    symbol: /`(?::\S+|[\w.]*)/,
	    datetime: {
	      pattern:
	        /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
	      alias: 'number'
	    },
	    // The negative look-ahead prevents bad highlighting
	    // of verbs 0: and 1:
	    number:
	      /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
	    keyword:
	      /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
	    adverb: {
	      pattern: /['\/\\]:?|\beach\b/,
	      alias: 'function'
	    },
	    verb: {
	      pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
	      alias: 'operator'
	    },
	    punctuation: /[(){}\[\];.]/
	  };
	}
	return q_1;
}

var qml_1;
var hasRequiredQml;

function requireQml () {
	if (hasRequiredQml) return qml_1;
	hasRequiredQml = 1;

	qml_1 = qml;
	qml.displayName = 'qml';
	qml.aliases = [];
	function qml(Prism) {
(function (Prism) {
	    var jsString = /"(?:\\.|[^\\"\r\n])*"|'(?:\\.|[^\\'\r\n])*'/.source;
	    var jsComment = /\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))*\*\//.source;
	    var jsExpr =
	      /(?:[^\\()[\]{}"'/]|<string>|\/(?![*/])|<comment>|\(<expr>*\)|\[<expr>*\]|\{<expr>*\}|\\[\s\S])/.source
	        .replace(/<string>/g, function () {
	          return jsString
	        })
	        .replace(/<comment>/g, function () {
	          return jsComment
	        }); // the pattern will blow up, so only a few iterations
	    for (var i = 0; i < 2; i++) {
	      jsExpr = jsExpr.replace(/<expr>/g, function () {
	        return jsExpr
	      });
	    }
	    jsExpr = jsExpr.replace(/<expr>/g, '[^\\s\\S]');
	    Prism.languages.qml = {
	      comment: {
	        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
	        greedy: true
	      },
	      'javascript-function': {
	        pattern: RegExp(
	          /((?:^|;)[ \t]*)function\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*\(<js>*\)\s*\{<js>*\}/.source.replace(
	            /<js>/g,
	            function () {
	              return jsExpr
	            }
	          ),
	          'm'
	        ),
	        lookbehind: true,
	        greedy: true,
	        alias: 'language-javascript',
	        inside: Prism.languages.javascript
	      },
	      'class-name': {
	        pattern: /((?:^|[:;])[ \t]*)(?!\d)\w+(?=[ \t]*\{|[ \t]+on\b)/m,
	        lookbehind: true
	      },
	      property: [
	        {
	          pattern: /((?:^|[;{])[ \t]*)(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
	          lookbehind: true
	        },
	        {
	          pattern:
	            /((?:^|[;{])[ \t]*)property[ \t]+(?!\d)\w+(?:\.\w+)*[ \t]+(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
	          lookbehind: true,
	          inside: {
	            keyword: /^property/,
	            property: /\w+(?:\.\w+)*/
	          }
	        }
	      ],
	      'javascript-expression': {
	        pattern: RegExp(
	          /(:[ \t]*)(?![\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(
	            /<js>/g,
	            function () {
	              return jsExpr
	            }
	          ),
	          'm'
	        ),
	        lookbehind: true,
	        greedy: true,
	        alias: 'language-javascript',
	        inside: Prism.languages.javascript
	      },
	      string: {
	        pattern: /"(?:\\.|[^\\"\r\n])*"/,
	        greedy: true
	      },
	      keyword: /\b(?:as|import|on)\b/,
	      punctuation: /[{}[\]:;,]/
	    };
	  })(Prism);
	}
	return qml_1;
}

var qore_1;
var hasRequiredQore;

function requireQore () {
	if (hasRequiredQore) return qore_1;
	hasRequiredQore = 1;

	qore_1 = qore;
	qore.displayName = 'qore';
	qore.aliases = [];
	function qore(Prism) {
	  Prism.languages.qore = Prism.languages.extend('clike', {
	    comment: {
	      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:\/\/|#).*)/,
	      lookbehind: true
	    },
	    // Overridden to allow unescaped multi-line strings
	    string: {
	      pattern: /("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
	      greedy: true
	    },
	    keyword:
	      /\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:bool|date|float|int|list|number|string)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\b/,
	    boolean: /\b(?:false|true)\b/i,
	    function: /\$?\b(?!\d)\w+(?=\()/,
	    number:
	      /\b(?:0b[01]+|0x(?:[\da-f]*\.)?[\da-fp\-]+|(?:\d+(?:\.\d+)?|\.\d+)(?:e\d+)?[df]|(?:\d+(?:\.\d+)?|\.\d+))\b/i,
	    operator: {
	      pattern:
	        /(^|[^.])(?:\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\|[|=]?|[*\/%^]=?|[~?])/,
	      lookbehind: true
	    },
	    variable: /\$(?!\d)\w+\b/
	  });
	}
	return qore_1;
}

var qsharp_1;
var hasRequiredQsharp;

function requireQsharp () {
	if (hasRequiredQsharp) return qsharp_1;
	hasRequiredQsharp = 1;

	qsharp_1 = qsharp;
	qsharp.displayName = 'qsharp';
	qsharp.aliases = ['qs'];
	function qsharp(Prism) {
(function (Prism) {
	    /**
	     * Replaces all placeholders "<<n>>" of given pattern with the n-th replacement (zero based).
	     *
	     * Note: This is a simple text based replacement. Be careful when using backreferences!
	     *
	     * @param {string} pattern the given pattern.
	     * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.
	     * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.
	     * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source
	     */
	    function replace(pattern, replacements) {
	      return pattern.replace(/<<(\d+)>>/g, function (m, index) {
	        return '(?:' + replacements[+index] + ')'
	      })
	    }
	    /**
	     * @param {string} pattern
	     * @param {string[]} replacements
	     * @param {string} [flags]
	     * @returns {RegExp}
	     */
	    function re(pattern, replacements, flags) {
	      return RegExp(replace(pattern, replacements), flags || '')
	    }
	    /**
	     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.
	     *
	     * @param {string} pattern
	     * @param {number} depthLog2
	     * @returns {string}
	     */
	    function nested(pattern, depthLog2) {
	      for (var i = 0; i < depthLog2; i++) {
	        pattern = pattern.replace(/<<self>>/g, function () {
	          return '(?:' + pattern + ')'
	        });
	      }
	      return pattern.replace(/<<self>>/g, '[^\\s\\S]')
	    } // https://docs.microsoft.com/en-us/azure/quantum/user-guide/language/typesystem/
	    // https://github.com/microsoft/qsharp-language/tree/main/Specifications/Language/5_Grammar
	    var keywordKinds = {
	      // keywords which represent a return or variable type
	      type: 'Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero',
	      // all other keywords
	      other:
	        'Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within'
	    }; // keywords
	    function keywordsToPattern(words) {
	      return '\\b(?:' + words.trim().replace(/ /g, '|') + ')\\b'
	    }
	    var keywords = RegExp(
	      keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.other)
	    ); // types
	    var identifier = /\b[A-Za-z_]\w*\b/.source;
	    var qualifiedName = replace(/<<0>>(?:\s*\.\s*<<0>>)*/.source, [identifier]);
	    var typeInside = {
	      keyword: keywords,
	      punctuation: /[<>()?,.:[\]]/
	    }; // strings
	    var regularString = /"(?:\\.|[^\\"])*"/.source;
	    Prism.languages.qsharp = Prism.languages.extend('clike', {
	      comment: /\/\/.*/,
	      string: [
	        {
	          pattern: re(/(^|[^$\\])<<0>>/.source, [regularString]),
	          lookbehind: true,
	          greedy: true
	        }
	      ],
	      'class-name': [
	        {
	          // open Microsoft.Quantum.Canon;
	          // open Microsoft.Quantum.Canon as CN;
	          pattern: re(/(\b(?:as|open)\s+)<<0>>(?=\s*(?:;|as\b))/.source, [
	            qualifiedName
	          ]),
	          lookbehind: true,
	          inside: typeInside
	        },
	        {
	          // namespace Quantum.App1;
	          pattern: re(/(\bnamespace\s+)<<0>>(?=\s*\{)/.source, [qualifiedName]),
	          lookbehind: true,
	          inside: typeInside
	        }
	      ],
	      keyword: keywords,
	      number:
	        /(?:\b0(?:x[\da-f]+|b[01]+|o[0-7]+)|(?:\B\.\d+|\b\d+(?:\.\d*)?)(?:e[-+]?\d+)?)l?\b/i,
	      operator:
	        /\band=|\bor=|\band\b|\bnot\b|\bor\b|<[-=]|[-=]>|>>>=?|<<<=?|\^\^\^=?|\|\|\|=?|&&&=?|w\/=?|~~~|[*\/+\-^=!%]=?/,
	      punctuation: /::|[{}[\];(),.:]/
	    });
	    Prism.languages.insertBefore('qsharp', 'number', {
	      range: {
	        pattern: /\.\./,
	        alias: 'operator'
	      }
	    }); // single line
	    var interpolationExpr = nested(
	      replace(/\{(?:[^"{}]|<<0>>|<<self>>)*\}/.source, [regularString]),
	      2
	    );
	    Prism.languages.insertBefore('qsharp', 'string', {
	      'interpolation-string': {
	        pattern: re(/\$"(?:\\.|<<0>>|[^\\"{])*"/.source, [interpolationExpr]),
	        greedy: true,
	        inside: {
	          interpolation: {
	            pattern: re(/((?:^|[^\\])(?:\\\\)*)<<0>>/.source, [
	              interpolationExpr
	            ]),
	            lookbehind: true,
	            inside: {
	              punctuation: /^\{|\}$/,
	              expression: {
	                pattern: /[\s\S]+/,
	                alias: 'language-qsharp',
	                inside: Prism.languages.qsharp
	              }
	            }
	          },
	          string: /[\s\S]+/
	        }
	      }
	    });
	  })(Prism);
	  Prism.languages.qs = Prism.languages.qsharp;
	}
	return qsharp_1;
}

var r_1;
var hasRequiredR;

function requireR () {
	if (hasRequiredR) return r_1;
	hasRequiredR = 1;

	r_1 = r;
	r.displayName = 'r';
	r.aliases = [];
	function r(Prism) {
	  Prism.languages.r = {
	    comment: /#.*/,
	    string: {
	      pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    'percent-operator': {
	      // Includes user-defined operators
	      // and %%, %*%, %/%, %in%, %o%, %x%
	      pattern: /%[^%\s]*%/,
	      alias: 'operator'
	    },
	    boolean: /\b(?:FALSE|TRUE)\b/,
	    ellipsis: /\.\.(?:\.|\d+)/,
	    number: [
	      /\b(?:Inf|NaN)\b/,
	      /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
	    ],
	    keyword:
	      /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
	    operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
	    punctuation: /[(){}\[\],;]/
	  };
	}
	return r_1;
}

var racket_1;
var hasRequiredRacket;

function requireRacket () {
	if (hasRequiredRacket) return racket_1;
	hasRequiredRacket = 1;
	var refractorScheme = requireScheme();
	racket_1 = racket;
	racket.displayName = 'racket';
	racket.aliases = ['rkt'];
	function racket(Prism) {
	  Prism.register(refractorScheme);
	  Prism.languages.racket = Prism.languages.extend('scheme', {
	    'lambda-parameter': {
	      // the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.
	      // this will just prevent false positives of the `function` pattern
	      pattern: /([(\[]lambda\s+[(\[])[^()\[\]'\s]+/,
	      lookbehind: true
	    }
	  });
	  Prism.languages.insertBefore('racket', 'string', {
	    lang: {
	      pattern: /^#lang.+/m,
	      greedy: true,
	      alias: 'keyword'
	    }
	  });
	  Prism.languages.rkt = Prism.languages.racket;
	}
	return racket_1;
}

var reason_1;
var hasRequiredReason;

function requireReason () {
	if (hasRequiredReason) return reason_1;
	hasRequiredReason = 1;

	reason_1 = reason;
	reason.displayName = 'reason';
	reason.aliases = [];
	function reason(Prism) {
	  Prism.languages.reason = Prism.languages.extend('clike', {
	    string: {
	      pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
	      greedy: true
	    },
	    // 'class-name' must be matched *after* 'constructor' defined below
	    'class-name': /\b[A-Z]\w*/,
	    keyword:
	      /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
	    operator:
	      /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
	  });
	  Prism.languages.insertBefore('reason', 'class-name', {
	    char: {
	      pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
	      greedy: true
	    },
	    // Negative look-ahead prevents from matching things like String.capitalize
	    constructor: /\b[A-Z]\w*\b(?!\s*\.)/,
	    label: {
	      pattern: /\b[a-z]\w*(?=::)/,
	      alias: 'symbol'
	    }
	  }); // We can't match functions property, so let's not even try.
	  delete Prism.languages.reason.function;
	}
	return reason_1;
}

var regex_1;
var hasRequiredRegex;

function requireRegex () {
	if (hasRequiredRegex) return regex_1;
	hasRequiredRegex = 1;

	regex_1 = regex;
	regex.displayName = 'regex';
	regex.aliases = [];
	function regex(Prism) {
(function (Prism) {
	    var specialEscape = {
	      pattern: /\\[\\(){}[\]^$+*?|.]/,
	      alias: 'escape'
	    };
	    var escape =
	      /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;
	    var charSet = {
	      pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
	      alias: 'class-name'
	    };
	    var charSetWithoutDot = {
	      pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
	      alias: 'class-name'
	    };
	    var rangeChar = '(?:[^\\\\-]|' + escape.source + ')';
	    var range = RegExp(rangeChar + '-' + rangeChar); // the name of a capturing group
	    var groupName = {
	      pattern: /(<|')[^<>']+(?=[>']$)/,
	      lookbehind: true,
	      alias: 'variable'
	    };
	    Prism.languages.regex = {
	      'char-class': {
	        pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
	        lookbehind: true,
	        inside: {
	          'char-class-negation': {
	            pattern: /(^\[)\^/,
	            lookbehind: true,
	            alias: 'operator'
	          },
	          'char-class-punctuation': {
	            pattern: /^\[|\]$/,
	            alias: 'punctuation'
	          },
	          range: {
	            pattern: range,
	            inside: {
	              escape: escape,
	              'range-punctuation': {
	                pattern: /-/,
	                alias: 'operator'
	              }
	            }
	          },
	          'special-escape': specialEscape,
	          'char-set': charSetWithoutDot,
	          escape: escape
	        }
	      },
	      'special-escape': specialEscape,
	      'char-set': charSet,
	      backreference: [
	        {
	          // a backreference which is not an octal escape
	          pattern: /\\(?![123][0-7]{2})[1-9]/,
	          alias: 'keyword'
	        },
	        {
	          pattern: /\\k<[^<>']+>/,
	          alias: 'keyword',
	          inside: {
	            'group-name': groupName
	          }
	        }
	      ],
	      anchor: {
	        pattern: /[$^]|\\[ABbGZz]/,
	        alias: 'function'
	      },
	      escape: escape,
	      group: [
	        {
	          // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
	          // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
	          // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
	          pattern:
	            /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
	          alias: 'punctuation',
	          inside: {
	            'group-name': groupName
	          }
	        },
	        {
	          pattern: /\)/,
	          alias: 'punctuation'
	        }
	      ],
	      quantifier: {
	        pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
	        alias: 'number'
	      },
	      alternation: {
	        pattern: /\|/,
	        alias: 'keyword'
	      }
	    };
	  })(Prism);
	}
	return regex_1;
}

var rego_1;
var hasRequiredRego;

function requireRego () {
	if (hasRequiredRego) return rego_1;
	hasRequiredRego = 1;

	rego_1 = rego;
	rego.displayName = 'rego';
	rego.aliases = [];
	function rego(Prism) {
	  // https://www.openpolicyagent.org/docs/latest/policy-reference/
	  Prism.languages.rego = {
	    comment: /#.*/,
	    property: {
	      pattern:
	        /(^|[^\\.])(?:"(?:\\.|[^\\"\r\n])*"|`[^`]*`|\b[a-z_]\w*\b)(?=\s*:(?!=))/i,
	      lookbehind: true,
	      greedy: true
	    },
	    string: {
	      pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"|`[^`]*`/,
	      lookbehind: true,
	      greedy: true
	    },
	    keyword:
	      /\b(?:as|default|else|import|not|null|package|set(?=\s*\()|some|with)\b/,
	    boolean: /\b(?:false|true)\b/,
	    function: {
	      pattern: /\b[a-z_]\w*\b(?:\s*\.\s*\b[a-z_]\w*\b)*(?=\s*\()/i,
	      inside: {
	        namespace: /\b\w+\b(?=\s*\.)/,
	        punctuation: /\./
	      }
	    },
	    number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
	    operator: /[-+*/%|&]|[<>:=]=?|!=|\b_\b/,
	    punctuation: /[,;.\[\]{}()]/
	  };
	}
	return rego_1;
}

var renpy_1;
var hasRequiredRenpy;

function requireRenpy () {
	if (hasRequiredRenpy) return renpy_1;
	hasRequiredRenpy = 1;

	renpy_1 = renpy;
	renpy.displayName = 'renpy';
	renpy.aliases = ['rpy'];
	function renpy(Prism) {
	  Prism.languages.renpy = {
	    comment: {
	      pattern: /(^|[^\\])#.+/,
	      lookbehind: true
	    },
	    string: {
	      pattern:
	        /("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\])*\2|(?:^#?(?:(?:[0-9a-fA-F]){3}|[0-9a-fA-F]{6})$)/m,
	      greedy: true
	    },
	    function: /\b[a-z_]\w*(?=\()/i,
	    property:
	      /\b(?:Update|UpdateVersion|action|activate_sound|adv_nvl_transition|after_load_transition|align|alpha|alt|anchor|antialias|area|auto|background|bar_invert|bar_resizing|bar_vertical|black_color|bold|bottom_bar|bottom_gutter|bottom_margin|bottom_padding|box_reverse|box_wrap|can_update|caret|child|color|crop|default_afm_enable|default_afm_time|default_fullscreen|default_text_cps|developer|directory_name|drag_handle|drag_joined|drag_name|drag_raise|draggable|dragged|drop_shadow|drop_shadow_color|droppable|dropped|easein|easeout|edgescroll|end_game_transition|end_splash_transition|enter_replay_transition|enter_sound|enter_transition|enter_yesno_transition|executable_name|exit_replay_transition|exit_sound|exit_transition|exit_yesno_transition|fadein|fadeout|first_indent|first_spacing|fit_first|focus|focus_mask|font|foreground|game_main_transition|get_installed_packages|google_play_key|google_play_salt|ground|has_music|has_sound|has_voice|height|help|hinting|hover|hover_background|hover_color|hover_sound|hovered|hyperlink_functions|idle|idle_color|image_style|include_update|insensitive|insensitive_background|insensitive_color|inside|intra_transition|italic|justify|kerning|keyboard_focus|language|layer_clipping|layers|layout|left_bar|left_gutter|left_margin|left_padding|length|line_leading|line_overlap_split|line_spacing|linear|main_game_transition|main_menu_music|maximum|min_width|minimum|minwidth|modal|mouse|mousewheel|name|narrator_menu|newline_indent|nvl_adv_transition|offset|order_reverse|outlines|overlay_functions|pos|position|prefix|radius|range|rest_indent|right_bar|right_gutter|right_margin|right_padding|rotate|rotate_pad|ruby_style|sample_sound|save_directory|say_attribute_transition|screen_height|screen_width|scrollbars|selected_hover|selected_hover_color|selected_idle|selected_idle_color|selected_insensitive|show_side_image|show_two_window|side_spacing|side_xpos|side_ypos|size|size_group|slow_cps|slow_cps_multiplier|spacing|strikethrough|subpixel|text_align|text_style|text_xpos|text_y_fudge|text_ypos|thumb|thumb_offset|thumb_shadow|thumbnail_height|thumbnail_width|time|top_bar|top_gutter|top_margin|top_padding|translations|underline|unscrollable|update|value|version|version_name|version_tuple|vertical|width|window_hide_transition|window_icon|window_left_padding|window_show_transition|window_title|windows_icon|xadjustment|xalign|xanchor|xanchoraround|xaround|xcenter|xfill|xinitial|xmargin|xmaximum|xminimum|xoffset|xofsset|xpadding|xpos|xsize|xzoom|yadjustment|yalign|yanchor|yanchoraround|yaround|ycenter|yfill|yinitial|ymargin|ymaximum|yminimum|yoffset|ypadding|ypos|ysize|ysizexysize|yzoom|zoom|zorder)\b/,
	    tag: /\b(?:bar|block|button|buttoscreenn|drag|draggroup|fixed|frame|grid|[hv]box|hotbar|hotspot|image|imagebutton|imagemap|input|key|label|menu|mm_menu_frame|mousearea|nvl|parallel|screen|self|side|tag|text|textbutton|timer|vbar|viewport|window)\b|\$/,
	    keyword:
	      /\b(?:None|add|adjustment|alignaround|allow|angle|animation|around|as|assert|behind|box_layout|break|build|cache|call|center|changed|child_size|choice|circles|class|clear|clicked|clipping|clockwise|config|contains|continue|corner1|corner2|counterclockwise|def|default|define|del|delay|disabled|disabled_text|dissolve|elif|else|event|except|exclude|exec|expression|fade|finally|for|from|function|global|gm_root|has|hide|id|if|import|in|init|is|jump|knot|lambda|left|less_rounded|mm_root|movie|music|null|on|onlayer|pass|pause|persistent|play|print|python|queue|raise|random|renpy|repeat|return|right|rounded_window|scene|scope|set|show|slow|slow_abortable|slow_done|sound|stop|store|style|style_group|substitute|suffix|theme|transform|transform_anchor|transpose|try|ui|unhovered|updater|use|voice|while|widget|widget_hover|widget_selected|widget_text|yield)\b/,
	    boolean: /\b(?:[Ff]alse|[Tt]rue)\b/,
	    number:
	      /(?:\b(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?)|\B\.\d+)(?:e[+-]?\d+)?j?/i,
	    operator:
	      /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:and|at|not|or|with)\b/,
	    punctuation: /[{}[\];(),.:]/
	  };
	  Prism.languages.rpy = Prism.languages.renpy;
	}
	return renpy_1;
}

var rest_1;
var hasRequiredRest;

function requireRest () {
	if (hasRequiredRest) return rest_1;
	hasRequiredRest = 1;

	rest_1 = rest;
	rest.displayName = 'rest';
	rest.aliases = [];
	function rest(Prism) {
	  Prism.languages.rest = {
	    table: [
	      {
	        pattern:
	          /(^[\t ]*)(?:\+[=-]+)+\+(?:\r?\n|\r)(?:\1[+|].+[+|](?:\r?\n|\r))+\1(?:\+[=-]+)+\+/m,
	        lookbehind: true,
	        inside: {
	          punctuation: /\||(?:\+[=-]+)+\+/
	        }
	      },
	      {
	        pattern:
	          /(^[\t ]*)=+ [ =]*=(?:(?:\r?\n|\r)\1.+)+(?:\r?\n|\r)\1=+ [ =]*=(?=(?:\r?\n|\r){2}|\s*$)/m,
	        lookbehind: true,
	        inside: {
	          punctuation: /[=-]+/
	        }
	      }
	    ],
	    // Directive-like patterns
	    'substitution-def': {
	      pattern: /(^[\t ]*\.\. )\|(?:[^|\s](?:[^|]*[^|\s])?)\| [^:]+::/m,
	      lookbehind: true,
	      inside: {
	        substitution: {
	          pattern: /^\|(?:[^|\s]|[^|\s][^|]*[^|\s])\|/,
	          alias: 'attr-value',
	          inside: {
	            punctuation: /^\||\|$/
	          }
	        },
	        directive: {
	          pattern: /( )(?! )[^:]+::/,
	          lookbehind: true,
	          alias: 'function',
	          inside: {
	            punctuation: /::$/
	          }
	        }
	      }
	    },
	    'link-target': [
	      {
	        pattern: /(^[\t ]*\.\. )\[[^\]]+\]/m,
	        lookbehind: true,
	        alias: 'string',
	        inside: {
	          punctuation: /^\[|\]$/
	        }
	      },
	      {
	        pattern: /(^[\t ]*\.\. )_(?:`[^`]+`|(?:[^:\\]|\\.)+):/m,
	        lookbehind: true,
	        alias: 'string',
	        inside: {
	          punctuation: /^_|:$/
	        }
	      }
	    ],
	    directive: {
	      pattern: /(^[\t ]*\.\. )[^:]+::/m,
	      lookbehind: true,
	      alias: 'function',
	      inside: {
	        punctuation: /::$/
	      }
	    },
	    comment: {
	      // The two alternatives try to prevent highlighting of blank comments
	      pattern:
	        /(^[\t ]*\.\.)(?:(?: .+)?(?:(?:\r?\n|\r).+)+| .+)(?=(?:\r?\n|\r){2}|$)/m,
	      lookbehind: true
	    },
	    title: [
	      // Overlined and underlined
	      {
	        pattern:
	          /^(([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+)(?:\r?\n|\r).+(?:\r?\n|\r)\1$/m,
	        inside: {
	          punctuation:
	            /^[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+|[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
	          important: /.+/
	        }
	      }, // Underlined only
	      {
	        pattern:
	          /(^|(?:\r?\n|\r){2}).+(?:\r?\n|\r)([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+(?=\r?\n|\r|$)/,
	        lookbehind: true,
	        inside: {
	          punctuation: /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
	          important: /.+/
	        }
	      }
	    ],
	    hr: {
	      pattern:
	        /((?:\r?\n|\r){2})([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2{3,}(?=(?:\r?\n|\r){2})/,
	      lookbehind: true,
	      alias: 'punctuation'
	    },
	    field: {
	      pattern: /(^[\t ]*):[^:\r\n]+:(?= )/m,
	      lookbehind: true,
	      alias: 'attr-name'
	    },
	    'command-line-option': {
	      pattern:
	        /(^[\t ]*)(?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?)*(?=(?:\r?\n|\r)? {2,}\S)/im,
	      lookbehind: true,
	      alias: 'symbol'
	    },
	    'literal-block': {
	      pattern: /::(?:\r?\n|\r){2}([ \t]+)(?![ \t]).+(?:(?:\r?\n|\r)\1.+)*/,
	      inside: {
	        'literal-block-punctuation': {
	          pattern: /^::/,
	          alias: 'punctuation'
	        }
	      }
	    },
	    'quoted-literal-block': {
	      pattern:
	        /::(?:\r?\n|\r){2}([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]).*(?:(?:\r?\n|\r)\1.*)*/,
	      inside: {
	        'literal-block-punctuation': {
	          pattern: /^(?:::|([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\1*)/m,
	          alias: 'punctuation'
	        }
	      }
	    },
	    'list-bullet': {
	      pattern:
	        /(^[\t ]*)(?:[*+\-•‣⁃]|\(?(?:\d+|[a-z]|[ivxdclm]+)\)|(?:\d+|[a-z]|[ivxdclm]+)\.)(?= )/im,
	      lookbehind: true,
	      alias: 'punctuation'
	    },
	    'doctest-block': {
	      pattern: /(^[\t ]*)>>> .+(?:(?:\r?\n|\r).+)*/m,
	      lookbehind: true,
	      inside: {
	        punctuation: /^>>>/
	      }
	    },
	    inline: [
	      {
	        pattern:
	          /(^|[\s\-:\/'"<(\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\*\*?|``?|\|)(?!\s)(?:(?!\2).)*\S\2(?=[\s\-.,:;!?\\\/'")\]}]|$))/m,
	        lookbehind: true,
	        inside: {
	          bold: {
	            pattern: /(^\*\*).+(?=\*\*$)/,
	            lookbehind: true
	          },
	          italic: {
	            pattern: /(^\*).+(?=\*$)/,
	            lookbehind: true
	          },
	          'inline-literal': {
	            pattern: /(^``).+(?=``$)/,
	            lookbehind: true,
	            alias: 'symbol'
	          },
	          role: {
	            pattern: /^:[^:]+:|:[^:]+:$/,
	            alias: 'function',
	            inside: {
	              punctuation: /^:|:$/
	            }
	          },
	          'interpreted-text': {
	            pattern: /(^`).+(?=`$)/,
	            lookbehind: true,
	            alias: 'attr-value'
	          },
	          substitution: {
	            pattern: /(^\|).+(?=\|$)/,
	            lookbehind: true,
	            alias: 'attr-value'
	          },
	          punctuation: /\*\*?|``?|\|/
	        }
	      }
	    ],
	    link: [
	      {
	        pattern: /\[[^\[\]]+\]_(?=[\s\-.,:;!?\\\/'")\]}]|$)/,
	        alias: 'string',
	        inside: {
	          punctuation: /^\[|\]_$/
	        }
	      },
	      {
	        pattern:
	          /(?:\b[a-z\d]+(?:[_.:+][a-z\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\s\-.,:;!?\\\/'")\]}]|$)/i,
	        alias: 'string',
	        inside: {
	          punctuation: /^_?`|`$|`?_?_$/
	        }
	      }
	    ],
	    // Line block start,
	    // quote attribution,
	    // explicit markup start,
	    // and anonymous hyperlink target shortcut (__)
	    punctuation: {
	      pattern: /(^[\t ]*)(?:\|(?= |$)|(?:---?|—|\.\.|__)(?= )|\.\.$)/m,
	      lookbehind: true
	    }
	  };
	}
	return rest_1;
}

var rip_1;
var hasRequiredRip;

function requireRip () {
	if (hasRequiredRip) return rip_1;
	hasRequiredRip = 1;

	rip_1 = rip;
	rip.displayName = 'rip';
	rip.aliases = [];
	function rip(Prism) {
	  Prism.languages.rip = {
	    comment: {
	      pattern: /#.*/,
	      greedy: true
	    },
	    char: {
	      pattern: /\B`[^\s`'",.:;#\/\\()<>\[\]{}]\b/,
	      greedy: true
	    },
	    string: {
	      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    regex: {
	      pattern:
	        /(^|[^/])\/(?!\/)(?:\[[^\n\r\]]*\]|\\.|[^/\\\r\n\[])+\/(?=\s*(?:$|[\r\n,.;})]))/,
	      lookbehind: true,
	      greedy: true
	    },
	    keyword:
	      /(?:=>|->)|\b(?:case|catch|class|else|exit|finally|if|raise|return|switch|try)\b/,
	    builtin: /@|\bSystem\b/,
	    boolean: /\b(?:false|true)\b/,
	    date: /\b\d{4}-\d{2}-\d{2}\b/,
	    time: /\b\d{2}:\d{2}:\d{2}\b/,
	    datetime: /\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\b/,
	    symbol: /:[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/,
	    number: /[+-]?\b(?:\d+\.\d+|\d+)\b/,
	    punctuation: /(?:\.{2,3})|[`,.:;=\/\\()<>\[\]{}]/,
	    reference: /[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/
	  };
	}
	return rip_1;
}

var roboconf_1;
var hasRequiredRoboconf;

function requireRoboconf () {
	if (hasRequiredRoboconf) return roboconf_1;
	hasRequiredRoboconf = 1;

	roboconf_1 = roboconf;
	roboconf.displayName = 'roboconf';
	roboconf.aliases = [];
	function roboconf(Prism) {
	  Prism.languages.roboconf = {
	    comment: /#.*/,
	    keyword: {
	      pattern:
	        /(^|\s)(?:(?:external|import)\b|(?:facet|instance of)(?=[ \t]+[\w-]+[ \t]*\{))/,
	      lookbehind: true
	    },
	    component: {
	      pattern: /[\w-]+(?=[ \t]*\{)/,
	      alias: 'variable'
	    },
	    property: /[\w.-]+(?=[ \t]*:)/,
	    value: {
	      pattern: /(=[ \t]*(?![ \t]))[^,;]+/,
	      lookbehind: true,
	      alias: 'attr-value'
	    },
	    optional: {
	      pattern: /\(optional\)/,
	      alias: 'builtin'
	    },
	    wildcard: {
	      pattern: /(\.)\*/,
	      lookbehind: true,
	      alias: 'operator'
	    },
	    punctuation: /[{},.;:=]/
	  };
	}
	return roboconf_1;
}

var robotframework_1;
var hasRequiredRobotframework;

function requireRobotframework () {
	if (hasRequiredRobotframework) return robotframework_1;
	hasRequiredRobotframework = 1;

	robotframework_1 = robotframework;
	robotframework.displayName = 'robotframework';
	robotframework.aliases = [];
	function robotframework(Prism) {
(function (Prism) {
	    var comment = {
	      pattern: /(^[ \t]*| {2}|\t)#.*/m,
	      lookbehind: true,
	      greedy: true
	    };
	    var variable = {
	      pattern: /((?:^|[^\\])(?:\\{2})*)[$@&%]\{(?:[^{}\r\n]|\{[^{}\r\n]*\})*\}/,
	      lookbehind: true,
	      inside: {
	        punctuation: /^[$@&%]\{|\}$/
	      }
	    };
	    function createSection(name, inside) {
	      var extendecInside = {};
	      extendecInside['section-header'] = {
	        pattern: /^ ?\*{3}.+?\*{3}/,
	        alias: 'keyword'
	      }; // copy inside tokens
	      for (var token in inside) {
	        extendecInside[token] = inside[token];
	      }
	      extendecInside['tag'] = {
	        pattern: /([\r\n](?: {2}|\t)[ \t]*)\[[-\w]+\]/,
	        lookbehind: true,
	        inside: {
	          punctuation: /\[|\]/
	        }
	      };
	      extendecInside['variable'] = variable;
	      extendecInside['comment'] = comment;
	      return {
	        pattern: RegExp(
	          /^ ?\*{3}[ \t]*<name>[ \t]*\*{3}(?:.|[\r\n](?!\*{3}))*/.source.replace(
	            /<name>/g,
	            function () {
	              return name
	            }
	          ),
	          'im'
	        ),
	        alias: 'section',
	        inside: extendecInside
	      }
	    }
	    var docTag = {
	      pattern:
	        /(\[Documentation\](?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
	      lookbehind: true,
	      alias: 'string'
	    };
	    var testNameLike = {
	      pattern: /([\r\n] ?)(?!#)(?:\S(?:[ \t]\S)*)+/,
	      lookbehind: true,
	      alias: 'function',
	      inside: {
	        variable: variable
	      }
	    };
	    var testPropertyLike = {
	      pattern: /([\r\n](?: {2}|\t)[ \t]*)(?!\[|\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
	      lookbehind: true,
	      inside: {
	        variable: variable
	      }
	    };
	    Prism.languages['robotframework'] = {
	      settings: createSection('Settings', {
	        documentation: {
	          pattern:
	            /([\r\n] ?Documentation(?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
	          lookbehind: true,
	          alias: 'string'
	        },
	        property: {
	          pattern: /([\r\n] ?)(?!\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
	          lookbehind: true
	        }
	      }),
	      variables: createSection('Variables'),
	      'test-cases': createSection('Test Cases', {
	        'test-name': testNameLike,
	        documentation: docTag,
	        property: testPropertyLike
	      }),
	      keywords: createSection('Keywords', {
	        'keyword-name': testNameLike,
	        documentation: docTag,
	        property: testPropertyLike
	      }),
	      tasks: createSection('Tasks', {
	        'task-name': testNameLike,
	        documentation: docTag,
	        property: testPropertyLike
	      }),
	      comment: comment
	    };
	    Prism.languages.robot = Prism.languages['robotframework'];
	  })(Prism);
	}
	return robotframework_1;
}

var rust_1;
var hasRequiredRust;

function requireRust () {
	if (hasRequiredRust) return rust_1;
	hasRequiredRust = 1;

	rust_1 = rust;
	rust.displayName = 'rust';
	rust.aliases = [];
	function rust(Prism) {
(function (Prism) {
	    var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
	    for (var i = 0; i < 2; i++) {
	      // support 4 levels of nested comments
	      multilineComment = multilineComment.replace(/<self>/g, function () {
	        return multilineComment
	      });
	    }
	    multilineComment = multilineComment.replace(/<self>/g, function () {
	      return /[^\s\S]/.source
	    });
	    Prism.languages.rust = {
	      comment: [
	        {
	          pattern: RegExp(/(^|[^\\])/.source + multilineComment),
	          lookbehind: true,
	          greedy: true
	        },
	        {
	          pattern: /(^|[^\\:])\/\/.*/,
	          lookbehind: true,
	          greedy: true
	        }
	      ],
	      string: {
	        pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
	        greedy: true
	      },
	      char: {
	        pattern:
	          /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
	        greedy: true
	      },
	      attribute: {
	        pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
	        greedy: true,
	        alias: 'attr-name',
	        inside: {
	          string: null // see below
	        }
	      },
	      // Closure params should not be confused with bitwise OR |
	      'closure-params': {
	        pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          'closure-punctuation': {
	            pattern: /^\||\|$/,
	            alias: 'punctuation'
	          },
	          rest: null // see below
	        }
	      },
	      'lifetime-annotation': {
	        pattern: /'\w+/,
	        alias: 'symbol'
	      },
	      'fragment-specifier': {
	        pattern: /(\$\w+:)[a-z]+/,
	        lookbehind: true,
	        alias: 'punctuation'
	      },
	      variable: /\$\w+/,
	      'function-definition': {
	        pattern: /(\bfn\s+)\w+/,
	        lookbehind: true,
	        alias: 'function'
	      },
	      'type-definition': {
	        pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
	        lookbehind: true,
	        alias: 'class-name'
	      },
	      'module-declaration': [
	        {
	          pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
	          lookbehind: true,
	          alias: 'namespace'
	        },
	        {
	          pattern:
	            /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
	          lookbehind: true,
	          alias: 'namespace',
	          inside: {
	            punctuation: /::/
	          }
	        }
	      ],
	      keyword: [
	        // https://github.com/rust-lang/reference/blob/master/src/keywords.md
	        /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/, // primitives and str
	        // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
	        /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
	      ],
	      // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
	      // and Rust's naming conventions recommend snake_case anyway.
	      // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
	      function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
	      macro: {
	        pattern: /\b\w+!/,
	        alias: 'property'
	      },
	      constant: /\b[A-Z_][A-Z_\d]+\b/,
	      'class-name': /\b[A-Z]\w*\b/,
	      namespace: {
	        pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
	        inside: {
	          punctuation: /::/
	        }
	      },
	      // Hex, oct, bin, dec numbers with visual separators and type suffix
	      number:
	        /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
	      boolean: /\b(?:false|true)\b/,
	      punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
	      operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
	    };
	    Prism.languages.rust['closure-params'].inside.rest = Prism.languages.rust;
	    Prism.languages.rust['attribute'].inside['string'] =
	      Prism.languages.rust['string'];
	  })(Prism);
	}
	return rust_1;
}

var sas_1;
var hasRequiredSas;

function requireSas () {
	if (hasRequiredSas) return sas_1;
	hasRequiredSas = 1;

	sas_1 = sas;
	sas.displayName = 'sas';
	sas.aliases = [];
	function sas(Prism) {
(function (Prism) {
	    var stringPattern = /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))/.source;
	    var number = /\b(?:\d[\da-f]*x|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i;
	    var numericConstant = {
	      pattern: RegExp(stringPattern + '[bx]'),
	      alias: 'number'
	    };
	    var macroVariable = {
	      pattern: /&[a-z_]\w*/i
	    };
	    var macroKeyword = {
	      pattern:
	        /((?:^|\s|=|\())%(?:ABORT|BY|CMS|COPY|DISPLAY|DO|ELSE|END|EVAL|GLOBAL|GO|GOTO|IF|INC|INCLUDE|INDEX|INPUT|KTRIM|LENGTH|LET|LIST|LOCAL|PUT|QKTRIM|QSCAN|QSUBSTR|QSYSFUNC|QUPCASE|RETURN|RUN|SCAN|SUBSTR|SUPERQ|SYMDEL|SYMEXIST|SYMGLOBL|SYMLOCAL|SYSCALL|SYSEVALF|SYSEXEC|SYSFUNC|SYSGET|SYSRPUT|THEN|TO|TSO|UNQUOTE|UNTIL|UPCASE|WHILE|WINDOW)\b/i,
	      lookbehind: true,
	      alias: 'keyword'
	    };
	    var step = {
	      pattern: /(^|\s)(?:proc\s+\w+|data(?!=)|quit|run)\b/i,
	      alias: 'keyword',
	      lookbehind: true
	    };
	    var comment = [
	      /\/\*[\s\S]*?\*\//,
	      {
	        pattern: /(^[ \t]*|;\s*)\*[^;]*;/m,
	        lookbehind: true
	      }
	    ];
	    var string = {
	      pattern: RegExp(stringPattern),
	      greedy: true
	    };
	    var punctuation = /[$%@.(){}\[\];,\\]/;
	    var func = {
	      pattern: /%?\b\w+(?=\()/,
	      alias: 'keyword'
	    };
	    var args = {
	      function: func,
	      'arg-value': {
	        pattern: /(=\s*)[A-Z\.]+/i,
	        lookbehind: true
	      },
	      operator: /=/,
	      'macro-variable': macroVariable,
	      arg: {
	        pattern: /[A-Z]+/i,
	        alias: 'keyword'
	      },
	      number: number,
	      'numeric-constant': numericConstant,
	      punctuation: punctuation,
	      string: string
	    };
	    var format = {
	      pattern: /\b(?:format|put)\b=?[\w'$.]+/i,
	      inside: {
	        keyword: /^(?:format|put)(?==)/i,
	        equals: /=/,
	        format: {
	          pattern: /(?:\w|\$\d)+\.\d?/,
	          alias: 'number'
	        }
	      }
	    };
	    var altformat = {
	      pattern: /\b(?:format|put)\s+[\w']+(?:\s+[$.\w]+)+(?=;)/i,
	      inside: {
	        keyword: /^(?:format|put)/i,
	        format: {
	          pattern: /[\w$]+\.\d?/,
	          alias: 'number'
	        }
	      }
	    };
	    var globalStatements = {
	      pattern:
	        /((?:^|\s)=?)(?:catname|checkpoint execute_always|dm|endsas|filename|footnote|%include|libname|%list|lock|missing|options|page|resetline|%run|sasfile|skip|sysecho|title\d?)\b/i,
	      lookbehind: true,
	      alias: 'keyword'
	    };
	    var submitStatement = {
	      pattern: /(^|\s)(?:submit(?:\s+(?:load|norun|parseonly))?|endsubmit)\b/i,
	      lookbehind: true,
	      alias: 'keyword'
	    };
	    var actionSets =
	      /aStore|accessControl|aggregation|audio|autotune|bayesianNetClassifier|bioMedImage|boolRule|builtins|cardinality|cdm|clustering|conditionalRandomFields|configuration|copula|countreg|dataDiscovery|dataPreprocess|dataSciencePilot|dataStep|decisionTree|deduplication|deepLearn|deepNeural|deepRnn|ds2|ecm|entityRes|espCluster|explainModel|factmac|fastKnn|fcmpact|fedSql|freqTab|gVarCluster|gam|gleam|graphSemiSupLearn|hiddenMarkovModel|hyperGroup|ica|image|iml|kernalPca|langModel|ldaTopic|loadStreams|mbc|mixed|mlTools|modelPublishing|network|neuralNet|nmf|nonParametricBayes|nonlinear|optNetwork|optimization|panel|pca|percentile|phreg|pls|qkb|qlim|quantreg|recommend|regression|reinforcementLearn|robustPca|ruleMining|sampling|sandwich|sccasl|search(?:Analytics)?|sentimentAnalysis|sequence|session(?:Prop)?|severity|simSystem|simple|smartData|sparkEmbeddedProcess|sparseML|spatialreg|spc|stabilityMonitoring|svDataDescription|svm|table|text(?:Filters|Frequency|Mining|Parse|Rule(?:Develop|Score)|Topic|Util)|timeData|transpose|tsInfo|tsReconcile|uniTimeSeries|varReduce/
	        .source;
	    var casActions = {
	      pattern: RegExp(
	        /(^|\s)(?:action\s+)?(?:<act>)\.[a-z]+\b[^;]+/.source.replace(
	          /<act>/g,
	          function () {
	            return actionSets
	          }
	        ),
	        'i'
	      ),
	      lookbehind: true,
	      inside: {
	        keyword: RegExp(
	          /(?:<act>)\.[a-z]+\b/.source.replace(/<act>/g, function () {
	            return actionSets
	          }),
	          'i'
	        ),
	        action: {
	          pattern: /(?:action)/i,
	          alias: 'keyword'
	        },
	        comment: comment,
	        function: func,
	        'arg-value': args['arg-value'],
	        operator: args.operator,
	        argument: args.arg,
	        number: number,
	        'numeric-constant': numericConstant,
	        punctuation: punctuation,
	        string: string
	      }
	    };
	    var keywords = {
	      pattern:
	        /((?:^|\s)=?)(?:after|analysis|and|array|barchart|barwidth|begingraph|by|call|cas|cbarline|cfill|class(?:lev)?|close|column|computed?|contains|continue|data(?==)|define|delete|describe|document|do\s+over|do|dol|drop|dul|else|end(?:comp|source)?|entryTitle|eval(?:uate)?|exec(?:ute)?|exit|file(?:name)?|fill(?:attrs)?|flist|fnc|function(?:list)?|global|goto|group(?:by)?|headline|headskip|histogram|if|infile|keep|keylabel|keyword|label|layout|leave|legendlabel|length|libname|loadactionset|merge|midpoints|_?null_|name|noobs|nowd|ods|options|or|otherwise|out(?:put)?|over(?:lay)?|plot|print|put|raise|ranexp|rannor|rbreak|retain|return|select|session|sessref|set|source|statgraph|sum|summarize|table|temp|terminate|then\s+do|then|title\d?|to|var|when|where|xaxisopts|y2axisopts|yaxisopts)\b/i,
	      lookbehind: true
	    };
	    Prism.languages.sas = {
	      datalines: {
	        pattern: /^([ \t]*)(?:cards|(?:data)?lines);[\s\S]+?^[ \t]*;/im,
	        lookbehind: true,
	        alias: 'string',
	        inside: {
	          keyword: {
	            pattern: /^(?:cards|(?:data)?lines)/i
	          },
	          punctuation: /;/
	        }
	      },
	      'proc-sql': {
	        pattern:
	          /(^proc\s+(?:fed)?sql(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
	        lookbehind: true,
	        inside: {
	          sql: {
	            pattern: RegExp(
	              /^[ \t]*(?:select|alter\s+table|(?:create|describe|drop)\s+(?:index|table(?:\s+constraints)?|view)|create\s+unique\s+index|insert\s+into|update)(?:<str>|[^;"'])+;/.source.replace(
	                /<str>/g,
	                function () {
	                  return stringPattern
	                }
	              ),
	              'im'
	            ),
	            alias: 'language-sql',
	            inside: Prism.languages.sql
	          },
	          'global-statements': globalStatements,
	          'sql-statements': {
	            pattern:
	              /(^|\s)(?:disconnect\s+from|begin|commit|exec(?:ute)?|reset|rollback|validate)\b/i,
	            lookbehind: true,
	            alias: 'keyword'
	          },
	          number: number,
	          'numeric-constant': numericConstant,
	          punctuation: punctuation,
	          string: string
	        }
	      },
	      'proc-groovy': {
	        pattern:
	          /(^proc\s+groovy(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
	        lookbehind: true,
	        inside: {
	          comment: comment,
	          groovy: {
	            pattern: RegExp(
	              /(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
	                /<str>/g,
	                function () {
	                  return stringPattern
	                }
	              ),
	              'im'
	            ),
	            lookbehind: true,
	            alias: 'language-groovy',
	            inside: Prism.languages.groovy
	          },
	          keyword: keywords,
	          'submit-statement': submitStatement,
	          'global-statements': globalStatements,
	          number: number,
	          'numeric-constant': numericConstant,
	          punctuation: punctuation,
	          string: string
	        }
	      },
	      'proc-lua': {
	        pattern:
	          /(^proc\s+lua(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
	        lookbehind: true,
	        inside: {
	          comment: comment,
	          lua: {
	            pattern: RegExp(
	              /(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
	                /<str>/g,
	                function () {
	                  return stringPattern
	                }
	              ),
	              'im'
	            ),
	            lookbehind: true,
	            alias: 'language-lua',
	            inside: Prism.languages.lua
	          },
	          keyword: keywords,
	          'submit-statement': submitStatement,
	          'global-statements': globalStatements,
	          number: number,
	          'numeric-constant': numericConstant,
	          punctuation: punctuation,
	          string: string
	        }
	      },
	      'proc-cas': {
	        pattern:
	          /(^proc\s+cas(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|quit|data);|(?![\s\S]))/im,
	        lookbehind: true,
	        inside: {
	          comment: comment,
	          'statement-var': {
	            pattern: /((?:^|\s)=?)saveresult\s[^;]+/im,
	            lookbehind: true,
	            inside: {
	              statement: {
	                pattern: /^saveresult\s+\S+/i,
	                inside: {
	                  keyword: /^(?:saveresult)/i
	                }
	              },
	              rest: args
	            }
	          },
	          'cas-actions': casActions,
	          statement: {
	            pattern:
	              /((?:^|\s)=?)(?:default|(?:un)?set|on|output|upload)[^;]+/im,
	            lookbehind: true,
	            inside: args
	          },
	          step: step,
	          keyword: keywords,
	          function: func,
	          format: format,
	          altformat: altformat,
	          'global-statements': globalStatements,
	          number: number,
	          'numeric-constant': numericConstant,
	          punctuation: punctuation,
	          string: string
	        }
	      },
	      'proc-args': {
	        pattern: RegExp(
	          /(^proc\s+\w+\s+)(?!\s)(?:[^;"']|<str>)+;/.source.replace(
	            /<str>/g,
	            function () {
	              return stringPattern
	            }
	          ),
	          'im'
	        ),
	        lookbehind: true,
	        inside: args
	      },
	      /*Special keywords within macros*/
	      'macro-keyword': macroKeyword,
	      'macro-variable': macroVariable,
	      'macro-string-functions': {
	        pattern:
	          /((?:^|\s|=))%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)\(.*?(?:[^%]\))/i,
	        lookbehind: true,
	        inside: {
	          function: {
	            pattern: /%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)/i,
	            alias: 'keyword'
	          },
	          'macro-keyword': macroKeyword,
	          'macro-variable': macroVariable,
	          'escaped-char': {
	            pattern: /%['"()<>=¬^~;,#]/
	          },
	          punctuation: punctuation
	        }
	      },
	      'macro-declaration': {
	        pattern: /^%macro[^;]+(?=;)/im,
	        inside: {
	          keyword: /%macro/i
	        }
	      },
	      'macro-end': {
	        pattern: /^%mend[^;]+(?=;)/im,
	        inside: {
	          keyword: /%mend/i
	        }
	      },
	      /*%_zscore(headcir, _lhc, _mhc, _shc, headcz, headcpct, _Fheadcz); */
	      macro: {
	        pattern: /%_\w+(?=\()/,
	        alias: 'keyword'
	      },
	      input: {
	        pattern: /\binput\s[-\w\s/*.$&]+;/i,
	        inside: {
	          input: {
	            alias: 'keyword',
	            pattern: /^input/i
	          },
	          comment: comment,
	          number: number,
	          'numeric-constant': numericConstant
	        }
	      },
	      'options-args': {
	        pattern: /(^options)[-'"|/\\<>*+=:()\w\s]*(?=;)/im,
	        lookbehind: true,
	        inside: args
	      },
	      'cas-actions': casActions,
	      comment: comment,
	      function: func,
	      format: format,
	      altformat: altformat,
	      'numeric-constant': numericConstant,
	      datetime: {
	        // '1jan2013'd, '9:25:19pm't, '18jan2003:9:27:05am'dt
	        pattern: RegExp(stringPattern + '(?:dt?|t)'),
	        alias: 'number'
	      },
	      string: string,
	      step: step,
	      keyword: keywords,
	      // In SAS Studio syntax highlighting, these operators are styled like keywords
	      'operator-keyword': {
	        pattern: /\b(?:eq|ge|gt|in|le|lt|ne|not)\b/i,
	        alias: 'operator'
	      },
	      // Decimal (1.2e23), hexadecimal (0c1x)
	      number: number,
	      operator: /\*\*?|\|\|?|!!?|¦¦?|<[>=]?|>[<=]?|[-+\/=&]|[~¬^]=?/,
	      punctuation: punctuation
	    };
	  })(Prism);
	}
	return sas_1;
}

var sass_1;
var hasRequiredSass;

function requireSass () {
	if (hasRequiredSass) return sass_1;
	hasRequiredSass = 1;

	sass_1 = sass;
	sass.displayName = 'sass';
	sass.aliases = [];
	function sass(Prism) {
(function (Prism) {
	    Prism.languages.sass = Prism.languages.extend('css', {
	      // Sass comments don't need to be closed, only indented
	      comment: {
	        pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
	        lookbehind: true,
	        greedy: true
	      }
	    });
	    Prism.languages.insertBefore('sass', 'atrule', {
	      // We want to consume the whole line
	      'atrule-line': {
	        // Includes support for = and + shortcuts
	        pattern: /^(?:[ \t]*)[@+=].+/m,
	        greedy: true,
	        inside: {
	          atrule: /(?:@[\w-]+|[+=])/
	        }
	      }
	    });
	    delete Prism.languages.sass.atrule;
	    var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
	    var operator = [
	      /[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/,
	      {
	        pattern: /(\s)-(?=\s)/,
	        lookbehind: true
	      }
	    ];
	    Prism.languages.insertBefore('sass', 'property', {
	      // We want to consume the whole line
	      'variable-line': {
	        pattern: /^[ \t]*\$.+/m,
	        greedy: true,
	        inside: {
	          punctuation: /:/,
	          variable: variable,
	          operator: operator
	        }
	      },
	      // We want to consume the whole line
	      'property-line': {
	        pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
	        greedy: true,
	        inside: {
	          property: [
	            /[^:\s]+(?=\s*:)/,
	            {
	              pattern: /(:)[^:\s]+/,
	              lookbehind: true
	            }
	          ],
	          punctuation: /:/,
	          variable: variable,
	          operator: operator,
	          important: Prism.languages.sass.important
	        }
	      }
	    });
	    delete Prism.languages.sass.property;
	    delete Prism.languages.sass.important; // Now that whole lines for other patterns are consumed,
	    // what's left should be selectors
	    Prism.languages.insertBefore('sass', 'punctuation', {
	      selector: {
	        pattern:
	          /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
	        lookbehind: true,
	        greedy: true
	      }
	    });
	  })(Prism);
	}
	return sass_1;
}

var scala_1;
var hasRequiredScala;

function requireScala () {
	if (hasRequiredScala) return scala_1;
	hasRequiredScala = 1;
	var refractorJava = requireJava();
	scala_1 = scala;
	scala.displayName = 'scala';
	scala.aliases = [];
	function scala(Prism) {
	  Prism.register(refractorJava);
	  Prism.languages.scala = Prism.languages.extend('java', {
	    'triple-quoted-string': {
	      pattern: /"""[\s\S]*?"""/,
	      greedy: true,
	      alias: 'string'
	    },
	    string: {
	      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    keyword:
	      /<-|=>|\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\b/,
	    number:
	      /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
	    builtin:
	      /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
	    symbol: /'[^\d\s\\]\w*/
	  });
	  Prism.languages.insertBefore('scala', 'triple-quoted-string', {
	    'string-interpolation': {
	      pattern:
	        /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
	      greedy: true,
	      inside: {
	        id: {
	          pattern: /^\w+/,
	          greedy: true,
	          alias: 'function'
	        },
	        escape: {
	          pattern: /\\\$"|\$[$"]/,
	          greedy: true,
	          alias: 'symbol'
	        },
	        interpolation: {
	          pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
	          greedy: true,
	          inside: {
	            punctuation: /^\$\{?|\}$/,
	            expression: {
	              pattern: /[\s\S]+/,
	              inside: Prism.languages.scala
	            }
	          }
	        },
	        string: /[\s\S]+/
	      }
	    }
	  });
	  delete Prism.languages.scala['class-name'];
	  delete Prism.languages.scala['function'];
	}
	return scala_1;
}

var scss_1;
var hasRequiredScss;

function requireScss () {
	if (hasRequiredScss) return scss_1;
	hasRequiredScss = 1;

	scss_1 = scss;
	scss.displayName = 'scss';
	scss.aliases = [];
	function scss(Prism) {
	  Prism.languages.scss = Prism.languages.extend('css', {
	    comment: {
	      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
	      lookbehind: true
	    },
	    atrule: {
	      pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
	      inside: {
	        rule: /@[\w-]+/ // See rest below
	      }
	    },
	    // url, compassified
	    url: /(?:[-a-z]+-)?url(?=\()/i,
	    // CSS selector regex is not appropriate for Sass
	    // since there can be lot more things (var, @ directive, nesting..)
	    // a selector must start at the end of a property or after a brace (end of other rules or nesting)
	    // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
	    // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
	    // can "pass" as a selector- e.g: proper#{$erty})
	    // this one was hard to do, so please be careful if you edit this one :)
	    selector: {
	      // Initial look-ahead is used to prevent matching of blank selectors
	      pattern:
	        /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
	      inside: {
	        parent: {
	          pattern: /&/,
	          alias: 'important'
	        },
	        placeholder: /%[-\w]+/,
	        variable: /\$[-\w]+|#\{\$[-\w]+\}/
	      }
	    },
	    property: {
	      pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
	      inside: {
	        variable: /\$[-\w]+|#\{\$[-\w]+\}/
	      }
	    }
	  });
	  Prism.languages.insertBefore('scss', 'atrule', {
	    keyword: [
	      /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
	      {
	        pattern: /( )(?:from|through)(?= )/,
	        lookbehind: true
	      }
	    ]
	  });
	  Prism.languages.insertBefore('scss', 'important', {
	    // var and interpolated vars
	    variable: /\$[-\w]+|#\{\$[-\w]+\}/
	  });
	  Prism.languages.insertBefore('scss', 'function', {
	    'module-modifier': {
	      pattern: /\b(?:as|hide|show|with)\b/i,
	      alias: 'keyword'
	    },
	    placeholder: {
	      pattern: /%[-\w]+/,
	      alias: 'selector'
	    },
	    statement: {
	      pattern: /\B!(?:default|optional)\b/i,
	      alias: 'keyword'
	    },
	    boolean: /\b(?:false|true)\b/,
	    null: {
	      pattern: /\bnull\b/,
	      alias: 'keyword'
	    },
	    operator: {
	      pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
	      lookbehind: true
	    }
	  });
	  Prism.languages.scss['atrule'].inside.rest = Prism.languages.scss;
	}
	return scss_1;
}

var shellSession_1;
var hasRequiredShellSession;

function requireShellSession () {
	if (hasRequiredShellSession) return shellSession_1;
	hasRequiredShellSession = 1;
	var refractorBash = bash_1;
	shellSession_1 = shellSession;
	shellSession.displayName = 'shellSession';
	shellSession.aliases = [];
	function shellSession(Prism) {
	  Prism.register(refractorBash)
	  ;(function (Prism) {
	    // CAREFUL!
	    // The following patterns are concatenated, so the group referenced by a back reference is non-obvious!
	    var strings = [
	      // normal string
	      /"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/.source,
	      /'[^']*'/.source,
	      /\$'(?:[^'\\]|\\[\s\S])*'/.source, // here doc
	      // 2 capturing groups
	      /<<-?\s*(["']?)(\w+)\1\s[\s\S]*?[\r\n]\2/.source
	    ].join('|');
	    Prism.languages['shell-session'] = {
	      command: {
	        pattern: RegExp(
	          // user info
	          /^/.source +
	            '(?:' + // <user> ":" ( <path> )?
	            (/[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+(?::[^\0-\x1F$#%*?"<>:;|]+)?/
	              .source +
	              '|' + // <path>
	              // Since the path pattern is quite general, we will require it to start with a special character to
	              // prevent false positives.
	              /[/~.][^\0-\x1F$#%*?"<>@:;|]*/.source) +
	            ')?' + // shell symbol
	            /[$#%](?=\s)/.source + // bash command
	            /(?:[^\\\r\n \t'"<$]|[ \t](?:(?!#)|#.*$)|\\(?:[^\r]|\r\n?)|\$(?!')|<(?!<)|<<str>>)+/.source.replace(
	              /<<str>>/g,
	              function () {
	                return strings
	              }
	            ),
	          'm'
	        ),
	        greedy: true,
	        inside: {
	          info: {
	            // foo@bar:~/files$ exit
	            // foo@bar$ exit
	            // ~/files$ exit
	            pattern: /^[^#$%]+/,
	            alias: 'punctuation',
	            inside: {
	              user: /^[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+/,
	              punctuation: /:/,
	              path: /[\s\S]+/
	            }
	          },
	          bash: {
	            pattern: /(^[$#%]\s*)\S[\s\S]*/,
	            lookbehind: true,
	            alias: 'language-bash',
	            inside: Prism.languages.bash
	          },
	          'shell-symbol': {
	            pattern: /^[$#%]/,
	            alias: 'important'
	          }
	        }
	      },
	      output: /.(?:.*(?:[\r\n]|.$))*/
	    };
	    Prism.languages['sh-session'] = Prism.languages['shellsession'] =
	      Prism.languages['shell-session'];
	  })(Prism);
	}
	return shellSession_1;
}

var smali_1;
var hasRequiredSmali;

function requireSmali () {
	if (hasRequiredSmali) return smali_1;
	hasRequiredSmali = 1;

	smali_1 = smali;
	smali.displayName = 'smali';
	smali.aliases = [];
	function smali(Prism) {
	  // Test files for the parser itself:
	  // https://github.com/JesusFreke/smali/tree/master/smali/src/test/resources/LexerTest
	  Prism.languages.smali = {
	    comment: /#.*/,
	    string: {
	      pattern: /"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\(?:.|u[\da-fA-F]{4}))'/,
	      greedy: true
	    },
	    'class-name': {
	      pattern:
	        /(^|[^L])L(?:(?:\w+|`[^`\r\n]*`)\/)*(?:[\w$]+|`[^`\r\n]*`)(?=\s*;)/,
	      lookbehind: true,
	      inside: {
	        'class-name': {
	          pattern: /(^L|\/)(?:[\w$]+|`[^`\r\n]*`)$/,
	          lookbehind: true
	        },
	        namespace: {
	          pattern: /^(L)(?:(?:\w+|`[^`\r\n]*`)\/)+/,
	          lookbehind: true,
	          inside: {
	            punctuation: /\//
	          }
	        },
	        builtin: /^L/
	      }
	    },
	    builtin: [
	      {
	        // Reference: https://github.com/JesusFreke/smali/wiki/TypesMethodsAndFields#types
	        pattern: /([();\[])[BCDFIJSVZ]+/,
	        lookbehind: true
	      },
	      {
	        // e.g. .field mWifiOnUid:I
	        pattern: /([\w$>]:)[BCDFIJSVZ]/,
	        lookbehind: true
	      }
	    ],
	    keyword: [
	      {
	        pattern: /(\.end\s+)[\w-]+/,
	        lookbehind: true
	      },
	      {
	        pattern: /(^|[^\w.-])\.(?!\d)[\w-]+/,
	        lookbehind: true
	      },
	      {
	        pattern:
	          /(^|[^\w.-])(?:abstract|annotation|bridge|constructor|enum|final|interface|private|protected|public|runtime|static|synthetic|system|transient)(?![\w.-])/,
	        lookbehind: true
	      }
	    ],
	    function: {
	      pattern: /(^|[^\w.-])(?:\w+|<[\w$-]+>)(?=\()/,
	      lookbehind: true
	    },
	    field: {
	      pattern: /[\w$]+(?=:)/,
	      alias: 'variable'
	    },
	    register: {
	      pattern: /(^|[^\w.-])[vp]\d(?![\w.-])/,
	      lookbehind: true,
	      alias: 'variable'
	    },
	    boolean: {
	      pattern: /(^|[^\w.-])(?:false|true)(?![\w.-])/,
	      lookbehind: true
	    },
	    number: {
	      pattern:
	        /(^|[^/\w.-])-?(?:NAN|INFINITY|0x(?:[\dA-F]+(?:\.[\dA-F]*)?|\.[\dA-F]+)(?:p[+-]?[\dA-F]+)?|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)[dflst]?(?![\w.-])/i,
	      lookbehind: true
	    },
	    label: {
	      pattern: /(:)\w+/,
	      lookbehind: true,
	      alias: 'property'
	    },
	    operator: /->|\.\.|[\[=]/,
	    punctuation: /[{}(),;:]/
	  };
	}
	return smali_1;
}

var smalltalk_1;
var hasRequiredSmalltalk;

function requireSmalltalk () {
	if (hasRequiredSmalltalk) return smalltalk_1;
	hasRequiredSmalltalk = 1;

	smalltalk_1 = smalltalk;
	smalltalk.displayName = 'smalltalk';
	smalltalk.aliases = [];
	function smalltalk(Prism) {
	  Prism.languages.smalltalk = {
	    comment: {
	      pattern: /"(?:""|[^"])*"/,
	      greedy: true
	    },
	    char: {
	      pattern: /\$./,
	      greedy: true
	    },
	    string: {
	      pattern: /'(?:''|[^'])*'/,
	      greedy: true
	    },
	    symbol: /#[\da-z]+|#(?:-|([+\/\\*~<>=@%|&?!])\1?)|#(?=\()/i,
	    'block-arguments': {
	      pattern: /(\[\s*):[^\[|]*\|/,
	      lookbehind: true,
	      inside: {
	        variable: /:[\da-z]+/i,
	        punctuation: /\|/
	      }
	    },
	    'temporary-variables': {
	      pattern: /\|[^|]+\|/,
	      inside: {
	        variable: /[\da-z]+/i,
	        punctuation: /\|/
	      }
	    },
	    keyword: /\b(?:new|nil|self|super)\b/,
	    boolean: /\b(?:false|true)\b/,
	    number: [
	      /\d+r-?[\dA-Z]+(?:\.[\dA-Z]+)?(?:e-?\d+)?/,
	      /\b\d+(?:\.\d+)?(?:e-?\d+)?/
	    ],
	    operator: /[<=]=?|:=|~[~=]|\/\/?|\\\\|>[>=]?|[!^+\-*&|,@]/,
	    punctuation: /[.;:?\[\](){}]/
	  };
	}
	return smalltalk_1;
}

var smarty_1;
var hasRequiredSmarty;

function requireSmarty () {
	if (hasRequiredSmarty) return smarty_1;
	hasRequiredSmarty = 1;
	var refractorMarkupTemplating = requireMarkupTemplating();
	smarty_1 = smarty;
	smarty.displayName = 'smarty';
	smarty.aliases = [];
	function smarty(Prism) {
	  Prism.register(refractorMarkupTemplating)
	  ;(function (Prism) {
	    Prism.languages.smarty = {
	      comment: {
	        pattern: /^\{\*[\s\S]*?\*\}/,
	        greedy: true
	      },
	      'embedded-php': {
	        pattern: /^\{php\}[\s\S]*?\{\/php\}/,
	        greedy: true,
	        inside: {
	          smarty: {
	            pattern: /^\{php\}|\{\/php\}$/,
	            inside: null // see below
	          },
	          php: {
	            pattern: /[\s\S]+/,
	            alias: 'language-php',
	            inside: Prism.languages.php
	          }
	        }
	      },
	      string: [
	        {
	          pattern: /"(?:\\.|[^"\\\r\n])*"/,
	          greedy: true,
	          inside: {
	            interpolation: {
	              pattern: /\{[^{}]*\}|`[^`]*`/,
	              inside: {
	                'interpolation-punctuation': {
	                  pattern: /^[{`]|[`}]$/,
	                  alias: 'punctuation'
	                },
	                expression: {
	                  pattern: /[\s\S]+/,
	                  inside: null // see below
	                }
	              }
	            },
	            variable: /\$\w+/
	          }
	        },
	        {
	          pattern: /'(?:\\.|[^'\\\r\n])*'/,
	          greedy: true
	        }
	      ],
	      keyword: {
	        pattern: /(^\{\/?)[a-z_]\w*\b(?!\()/i,
	        lookbehind: true,
	        greedy: true
	      },
	      delimiter: {
	        pattern: /^\{\/?|\}$/,
	        greedy: true,
	        alias: 'punctuation'
	      },
	      number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
	      variable: [
	        /\$(?!\d)\w+/,
	        /#(?!\d)\w+#/,
	        {
	          pattern: /(\.|->|\w\s*=)(?!\d)\w+\b(?!\()/,
	          lookbehind: true
	        },
	        {
	          pattern: /(\[)(?!\d)\w+(?=\])/,
	          lookbehind: true
	        }
	      ],
	      function: {
	        pattern: /(\|\s*)@?[a-z_]\w*|\b[a-z_]\w*(?=\()/i,
	        lookbehind: true
	      },
	      'attr-name': /\b[a-z_]\w*(?=\s*=)/i,
	      boolean: /\b(?:false|no|off|on|true|yes)\b/,
	      punctuation: /[\[\](){}.,:`]|->/,
	      operator: [
	        /[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/,
	        /\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/,
	        /\b(?:and|eq|gt?e|gt|lt?e|lt|mod|neq?|not|or)\b/
	      ]
	    };
	    Prism.languages.smarty['embedded-php'].inside.smarty.inside =
	      Prism.languages.smarty;
	    Prism.languages.smarty.string[0].inside.interpolation.inside.expression.inside =
	      Prism.languages.smarty;
	    var string = /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/;
	    var smartyPattern = RegExp(
	      // comments
	      /\{\*[\s\S]*?\*\}/.source +
	        '|' + // php tags
	        /\{php\}[\s\S]*?\{\/php\}/.source +
	        '|' + // smarty blocks
	        /\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>)*\})*\})*\}/.source.replace(
	          /<str>/g,
	          function () {
	            return string.source
	          }
	        ),
	      'g'
	    ); // Tokenize all inline Smarty expressions
	    Prism.hooks.add('before-tokenize', function (env) {
	      var smartyLiteralStart = '{literal}';
	      var smartyLiteralEnd = '{/literal}';
	      var smartyLiteralMode = false;
	      Prism.languages['markup-templating'].buildPlaceholders(
	        env,
	        'smarty',
	        smartyPattern,
	        function (match) {
	          // Smarty tags inside {literal} block are ignored
	          if (match === smartyLiteralEnd) {
	            smartyLiteralMode = false;
	          }
	          if (!smartyLiteralMode) {
	            if (match === smartyLiteralStart) {
	              smartyLiteralMode = true;
	            }
	            return true
	          }
	          return false
	        }
	      );
	    }); // Re-insert the tokens after tokenizing
	    Prism.hooks.add('after-tokenize', function (env) {
	      Prism.languages['markup-templating'].tokenizePlaceholders(env, 'smarty');
	    });
	  })(Prism);
	}
	return smarty_1;
}

var sml_1;
var hasRequiredSml;

function requireSml () {
	if (hasRequiredSml) return sml_1;
	hasRequiredSml = 1;

	sml_1 = sml;
	sml.displayName = 'sml';
	sml.aliases = ['smlnj'];
	function sml(Prism) {
(function (Prism) {
	    var keywords =
	      /\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\b/i;
	    Prism.languages.sml = {
	      // allow one level of nesting
	      comment:
	        /\(\*(?:[^*(]|\*(?!\))|\((?!\*)|\(\*(?:[^*(]|\*(?!\))|\((?!\*))*\*\))*\*\)/,
	      string: {
	        pattern: /#?"(?:[^"\\]|\\.)*"/,
	        greedy: true
	      },
	      'class-name': [
	        {
	          // This is only an approximation since the real grammar is context-free
	          //
	          // Why the main loop so complex?
	          // The main loop is approximately the same as /(?:\s*(?:[*,]|->)\s*<TERMINAL>)*/ which is, obviously, a lot
	          // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be
	          // followed by a long identifier.
	          pattern: RegExp(
	            /((?:^|[^:]):\s*)<TERMINAL>(?:\s*(?:(?:\*|->)\s*<TERMINAL>|,\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\s+<LONG-ID>)))*/.source
	              .replace(/<NOT-LAST>/g, function () {
	                return /\s*(?:[*,]|->)/.source
	              })
	              .replace(/<TERMINAL>/g, function () {
	                return /(?:'[\w']*|<LONG-ID>|\((?:[^()]|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\})(?:\s+<LONG-ID>)*/
	                  .source
	              })
	              .replace(/<LONG-ID>/g, function () {
	                return /(?!<KEYWORD>)[a-z\d_][\w'.]*/.source
	              })
	              .replace(/<KEYWORD>/g, function () {
	                return keywords.source
	              }),
	            'i'
	          ),
	          lookbehind: true,
	          greedy: true,
	          inside: null // see below
	        },
	        {
	          pattern:
	            /((?:^|[^\w'])(?:datatype|exception|functor|signature|structure|type)\s+)[a-z_][\w'.]*/i,
	          lookbehind: true
	        }
	      ],
	      function: {
	        pattern: /((?:^|[^\w'])fun\s+)[a-z_][\w'.]*/i,
	        lookbehind: true
	      },
	      keyword: keywords,
	      variable: {
	        pattern: /(^|[^\w'])'[\w']*/,
	        lookbehind: true
	      },
	      number: /~?\b(?:\d+(?:\.\d+)?(?:e~?\d+)?|0x[\da-f]+)\b/i,
	      word: {
	        pattern: /\b0w(?:\d+|x[\da-f]+)\b/i,
	        alias: 'constant'
	      },
	      boolean: /\b(?:false|true)\b/i,
	      operator: /\.\.\.|:[>=:]|=>?|->|[<>]=?|[!+\-*/^#|@~]/,
	      punctuation: /[(){}\[\].:,;]/
	    };
	    Prism.languages.sml['class-name'][0].inside = Prism.languages.sml;
	    Prism.languages.smlnj = Prism.languages.sml;
	  })(Prism);
	}
	return sml_1;
}

var solidity_1;
var hasRequiredSolidity;

function requireSolidity () {
	if (hasRequiredSolidity) return solidity_1;
	hasRequiredSolidity = 1;

	solidity_1 = solidity;
	solidity.displayName = 'solidity';
	solidity.aliases = ['sol'];
	function solidity(Prism) {
	  Prism.languages.solidity = Prism.languages.extend('clike', {
	    'class-name': {
	      pattern:
	        /(\b(?:contract|enum|interface|library|new|struct|using)\s+)(?!\d)[\w$]+/,
	      lookbehind: true
	    },
	    keyword:
	      /\b(?:_|anonymous|as|assembly|assert|break|calldata|case|constant|constructor|continue|contract|default|delete|do|else|emit|enum|event|external|for|from|function|if|import|indexed|inherited|interface|internal|is|let|library|mapping|memory|modifier|new|payable|pragma|private|public|pure|require|returns?|revert|selfdestruct|solidity|storage|struct|suicide|switch|this|throw|using|var|view|while)\b/,
	    operator: /=>|->|:=|=:|\*\*|\+\+|--|\|\||&&|<<=?|>>=?|[-+*/%^&|<>!=]=?|[~?]/
	  });
	  Prism.languages.insertBefore('solidity', 'keyword', {
	    builtin:
	      /\b(?:address|bool|byte|u?int(?:8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?|string|bytes(?:[1-9]|[12]\d|3[0-2])?)\b/
	  });
	  Prism.languages.insertBefore('solidity', 'number', {
	    version: {
	      pattern: /([<>]=?|\^)\d+\.\d+\.\d+\b/,
	      lookbehind: true,
	      alias: 'number'
	    }
	  });
	  Prism.languages.sol = Prism.languages.solidity;
	}
	return solidity_1;
}

var solutionFile_1;
var hasRequiredSolutionFile;

function requireSolutionFile () {
	if (hasRequiredSolutionFile) return solutionFile_1;
	hasRequiredSolutionFile = 1;

	solutionFile_1 = solutionFile;
	solutionFile.displayName = 'solutionFile';
	solutionFile.aliases = [];
	function solutionFile(Prism) {
(function (Prism) {
	    var guid = {
	      // https://en.wikipedia.org/wiki/Universally_unique_identifier#Format
	      pattern: /\{[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}\}/i,
	      alias: 'constant',
	      inside: {
	        punctuation: /[{}]/
	      }
	    };
	    Prism.languages['solution-file'] = {
	      comment: {
	        pattern: /#.*/,
	        greedy: true
	      },
	      string: {
	        pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
	        greedy: true,
	        inside: {
	          guid: guid
	        }
	      },
	      object: {
	        // Foo
	        //   Bar("abs") = 9
	        //   EndBar
	        //   Prop = TRUE
	        // EndFoo
	        pattern:
	          /^([ \t]*)(?:([A-Z]\w*)\b(?=.*(?:\r\n?|\n)(?:\1[ \t].*(?:\r\n?|\n))*\1End\2(?=[ \t]*$))|End[A-Z]\w*(?=[ \t]*$))/m,
	        lookbehind: true,
	        greedy: true,
	        alias: 'keyword'
	      },
	      property: {
	        pattern: /^([ \t]*)(?!\s)[^\r\n"#=()]*[^\s"#=()](?=\s*=)/m,
	        lookbehind: true,
	        inside: {
	          guid: guid
	        }
	      },
	      guid: guid,
	      number: /\b\d+(?:\.\d+)*\b/,
	      boolean: /\b(?:FALSE|TRUE)\b/,
	      operator: /=/,
	      punctuation: /[(),]/
	    };
	    Prism.languages['sln'] = Prism.languages['solution-file'];
	  })(Prism);
	}
	return solutionFile_1;
}

var soy_1;
var hasRequiredSoy;

function requireSoy () {
	if (hasRequiredSoy) return soy_1;
	hasRequiredSoy = 1;
	var refractorMarkupTemplating = requireMarkupTemplating();
	soy_1 = soy;
	soy.displayName = 'soy';
	soy.aliases = [];
	function soy(Prism) {
	  Prism.register(refractorMarkupTemplating)
	  ;(function (Prism) {
	    var stringPattern = /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
	    var numberPattern = /\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-F]+\b/;
	    Prism.languages.soy = {
	      comment: [
	        /\/\*[\s\S]*?\*\//,
	        {
	          pattern: /(\s)\/\/.*/,
	          lookbehind: true,
	          greedy: true
	        }
	      ],
	      'command-arg': {
	        pattern:
	          /(\{+\/?\s*(?:alias|call|delcall|delpackage|deltemplate|namespace|template)\s+)\.?[\w.]+/,
	        lookbehind: true,
	        alias: 'string',
	        inside: {
	          punctuation: /\./
	        }
	      },
	      parameter: {
	        pattern: /(\{+\/?\s*@?param\??\s+)\.?[\w.]+/,
	        lookbehind: true,
	        alias: 'variable'
	      },
	      keyword: [
	        {
	          pattern:
	            /(\{+\/?[^\S\r\n]*)(?:\\[nrt]|alias|call|case|css|default|delcall|delpackage|deltemplate|else(?:if)?|fallbackmsg|for(?:each)?|if(?:empty)?|lb|let|literal|msg|namespace|nil|@?param\??|rb|sp|switch|template|xid)/,
	          lookbehind: true
	        },
	        /\b(?:any|as|attributes|bool|css|float|html|in|int|js|list|map|null|number|string|uri)\b/
	      ],
	      delimiter: {
	        pattern: /^\{+\/?|\/?\}+$/,
	        alias: 'punctuation'
	      },
	      property: /\w+(?==)/,
	      variable: {
	        pattern: /\$[^\W\d]\w*(?:\??(?:\.\w+|\[[^\]]+\]))*/,
	        inside: {
	          string: {
	            pattern: stringPattern,
	            greedy: true
	          },
	          number: numberPattern,
	          punctuation: /[\[\].?]/
	        }
	      },
	      string: {
	        pattern: stringPattern,
	        greedy: true
	      },
	      function: [
	        /\w+(?=\()/,
	        {
	          pattern: /(\|[^\S\r\n]*)\w+/,
	          lookbehind: true
	        }
	      ],
	      boolean: /\b(?:false|true)\b/,
	      number: numberPattern,
	      operator: /\?:?|<=?|>=?|==?|!=|[+*/%-]|\b(?:and|not|or)\b/,
	      punctuation: /[{}()\[\]|.,:]/
	    }; // Tokenize all inline Soy expressions
	    Prism.hooks.add('before-tokenize', function (env) {
	      var soyPattern = /\{\{.+?\}\}|\{.+?\}|\s\/\/.*|\/\*[\s\S]*?\*\//g;
	      var soyLitteralStart = '{literal}';
	      var soyLitteralEnd = '{/literal}';
	      var soyLitteralMode = false;
	      Prism.languages['markup-templating'].buildPlaceholders(
	        env,
	        'soy',
	        soyPattern,
	        function (match) {
	          // Soy tags inside {literal} block are ignored
	          if (match === soyLitteralEnd) {
	            soyLitteralMode = false;
	          }
	          if (!soyLitteralMode) {
	            if (match === soyLitteralStart) {
	              soyLitteralMode = true;
	            }
	            return true
	          }
	          return false
	        }
	      );
	    }); // Re-insert the tokens after tokenizing
	    Prism.hooks.add('after-tokenize', function (env) {
	      Prism.languages['markup-templating'].tokenizePlaceholders(env, 'soy');
	    });
	  })(Prism);
	}
	return soy_1;
}

var turtle_1;
var hasRequiredTurtle;

function requireTurtle () {
	if (hasRequiredTurtle) return turtle_1;
	hasRequiredTurtle = 1;

	turtle_1 = turtle;
	turtle.displayName = 'turtle';
	turtle.aliases = [];
	function turtle(Prism) {
	  Prism.languages.turtle = {
	    comment: {
	      pattern: /#.*/,
	      greedy: true
	    },
	    'multiline-string': {
	      pattern:
	        /"""(?:(?:""?)?(?:[^"\\]|\\.))*"""|'''(?:(?:''?)?(?:[^'\\]|\\.))*'''/,
	      greedy: true,
	      alias: 'string',
	      inside: {
	        comment: /#.*/
	      }
	    },
	    string: {
	      pattern: /"(?:[^\\"\r\n]|\\.)*"|'(?:[^\\'\r\n]|\\.)*'/,
	      greedy: true
	    },
	    url: {
	      pattern:
	        /<(?:[^\x00-\x20<>"{}|^`\\]|\\(?:u[\da-fA-F]{4}|U[\da-fA-F]{8}))*>/,
	      greedy: true,
	      inside: {
	        punctuation: /[<>]/
	      }
	    },
	    function: {
	      pattern:
	        /(?:(?![-.\d\xB7])[-.\w\xB7\xC0-\uFFFD]+)?:(?:(?![-.])(?:[-.:\w\xC0-\uFFFD]|%[\da-f]{2}|\\.)+)?/i,
	      inside: {
	        'local-name': {
	          pattern: /([^:]*:)[\s\S]+/,
	          lookbehind: true
	        },
	        prefix: {
	          pattern: /[\s\S]+/,
	          inside: {
	            punctuation: /:/
	          }
	        }
	      }
	    },
	    number: /[+-]?\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
	    punctuation: /[{}.,;()[\]]|\^\^/,
	    boolean: /\b(?:false|true)\b/,
	    keyword: [/(?:\ba|@prefix|@base)\b|=/, /\b(?:base|graph|prefix)\b/i],
	    tag: {
	      pattern: /@[a-z]+(?:-[a-z\d]+)*/i,
	      inside: {
	        punctuation: /@/
	      }
	    }
	  };
	  Prism.languages.trig = Prism.languages['turtle'];
	}
	return turtle_1;
}

var sparql_1;
var hasRequiredSparql;

function requireSparql () {
	if (hasRequiredSparql) return sparql_1;
	hasRequiredSparql = 1;
	var refractorTurtle = requireTurtle();
	sparql_1 = sparql;
	sparql.displayName = 'sparql';
	sparql.aliases = ['rq'];
	function sparql(Prism) {
	  Prism.register(refractorTurtle);
	  Prism.languages.sparql = Prism.languages.extend('turtle', {
	    boolean: /\b(?:false|true)\b/i,
	    variable: {
	      pattern: /[?$]\w+/,
	      greedy: true
	    }
	  });
	  Prism.languages.insertBefore('sparql', 'punctuation', {
	    keyword: [
	      /\b(?:A|ADD|ALL|AS|ASC|ASK|BNODE|BY|CLEAR|CONSTRUCT|COPY|CREATE|DATA|DEFAULT|DELETE|DESC|DESCRIBE|DISTINCT|DROP|EXISTS|FILTER|FROM|GROUP|HAVING|INSERT|INTO|LIMIT|LOAD|MINUS|MOVE|NAMED|NOT|NOW|OFFSET|OPTIONAL|ORDER|RAND|REDUCED|SELECT|SEPARATOR|SERVICE|SILENT|STRUUID|UNION|USING|UUID|VALUES|WHERE)\b/i,
	      /\b(?:ABS|AVG|BIND|BOUND|CEIL|COALESCE|CONCAT|CONTAINS|COUNT|DATATYPE|DAY|ENCODE_FOR_URI|FLOOR|GROUP_CONCAT|HOURS|IF|IRI|isBLANK|isIRI|isLITERAL|isNUMERIC|isURI|LANG|LANGMATCHES|LCASE|MAX|MD5|MIN|MINUTES|MONTH|REGEX|REPLACE|ROUND|sameTerm|SAMPLE|SECONDS|SHA1|SHA256|SHA384|SHA512|STR|STRAFTER|STRBEFORE|STRDT|STRENDS|STRLANG|STRLEN|STRSTARTS|SUBSTR|SUM|TIMEZONE|TZ|UCASE|URI|YEAR)\b(?=\s*\()/i,
	      /\b(?:BASE|GRAPH|PREFIX)\b/i
	    ]
	  });
	  Prism.languages.rq = Prism.languages.sparql;
	}
	return sparql_1;
}

var splunkSpl_1;
var hasRequiredSplunkSpl;

function requireSplunkSpl () {
	if (hasRequiredSplunkSpl) return splunkSpl_1;
	hasRequiredSplunkSpl = 1;

	splunkSpl_1 = splunkSpl;
	splunkSpl.displayName = 'splunkSpl';
	splunkSpl.aliases = [];
	function splunkSpl(Prism) {
	  Prism.languages['splunk-spl'] = {
	    comment: /`comment\("(?:\\.|[^\\"])*"\)`/,
	    string: {
	      pattern: /"(?:\\.|[^\\"])*"/,
	      greedy: true
	    },
	    // https://docs.splunk.com/Documentation/Splunk/7.3.0/SearchReference/ListOfSearchCommands
	    keyword:
	      /\b(?:abstract|accum|addcoltotals|addinfo|addtotals|analyzefields|anomalies|anomalousvalue|anomalydetection|append|appendcols|appendcsv|appendlookup|appendpipe|arules|associate|audit|autoregress|bin|bucket|bucketdir|chart|cluster|cofilter|collect|concurrency|contingency|convert|correlate|datamodel|dbinspect|dedup|delete|delta|diff|erex|eval|eventcount|eventstats|extract|fieldformat|fields|fieldsummary|filldown|fillnull|findtypes|folderize|foreach|format|from|gauge|gentimes|geom|geomfilter|geostats|head|highlight|history|iconify|input|inputcsv|inputlookup|iplocation|join|kmeans|kv|kvform|loadjob|localize|localop|lookup|makecontinuous|makemv|makeresults|map|mcollect|metadata|metasearch|meventcollect|mstats|multikv|multisearch|mvcombine|mvexpand|nomv|outlier|outputcsv|outputlookup|outputtext|overlap|pivot|predict|rangemap|rare|regex|relevancy|reltime|rename|replace|rest|return|reverse|rex|rtorder|run|savedsearch|script|scrub|search|searchtxn|selfjoin|sendemail|set|setfields|sichart|sirare|sistats|sitimechart|sitop|sort|spath|stats|strcat|streamstats|table|tags|tail|timechart|timewrap|top|transaction|transpose|trendline|tscollect|tstats|typeahead|typelearner|typer|union|uniq|untable|where|x11|xmlkv|xmlunescape|xpath|xyseries)\b/i,
	    'operator-word': {
	      pattern: /\b(?:and|as|by|not|or|xor)\b/i,
	      alias: 'operator'
	    },
	    function: /\b\w+(?=\s*\()/,
	    property: /\b\w+(?=\s*=(?!=))/,
	    date: {
	      // MM/DD/YYYY(:HH:MM:SS)?
	      pattern: /\b\d{1,2}\/\d{1,2}\/\d{1,4}(?:(?::\d{1,2}){3})?\b/,
	      alias: 'number'
	    },
	    number: /\b\d+(?:\.\d+)?\b/,
	    boolean: /\b(?:f|false|t|true)\b/i,
	    operator: /[<>=]=?|[-+*/%|]/,
	    punctuation: /[()[\],]/
	  };
	}
	return splunkSpl_1;
}

var sqf_1;
var hasRequiredSqf;

function requireSqf () {
	if (hasRequiredSqf) return sqf_1;
	hasRequiredSqf = 1;

	sqf_1 = sqf;
	sqf.displayName = 'sqf';
	sqf.aliases = [];
	function sqf(Prism) {
	  Prism.languages.sqf = Prism.languages.extend('clike', {
	    string: {
	      pattern: /"(?:(?:"")?[^"])*"(?!")|'(?:[^'])*'/,
	      greedy: true
	    },
	    keyword:
	      /\b(?:breakOut|breakTo|call|case|catch|default|do|echo|else|execFSM|execVM|exitWith|for|forEach|forEachMember|forEachMemberAgent|forEachMemberTeam|from|goto|if|nil|preprocessFile|preprocessFileLineNumbers|private|scopeName|spawn|step|switch|then|throw|to|try|while|with)\b/i,
	    boolean: /\b(?:false|true)\b/i,
	    function:
	      /\b(?:abs|accTime|acos|action|actionIDs|actionKeys|actionKeysImages|actionKeysNames|actionKeysNamesArray|actionName|actionParams|activateAddons|activatedAddons|activateKey|add3DENConnection|add3DENEventHandler|add3DENLayer|addAction|addBackpack|addBackpackCargo|addBackpackCargoGlobal|addBackpackGlobal|addCamShake|addCuratorAddons|addCuratorCameraArea|addCuratorEditableObjects|addCuratorEditingArea|addCuratorPoints|addEditorObject|addEventHandler|addForce|addForceGeneratorRTD|addGoggles|addGroupIcon|addHandgunItem|addHeadgear|addItem|addItemCargo|addItemCargoGlobal|addItemPool|addItemToBackpack|addItemToUniform|addItemToVest|addLiveStats|addMagazine|addMagazineAmmoCargo|addMagazineCargo|addMagazineCargoGlobal|addMagazineGlobal|addMagazinePool|addMagazines|addMagazineTurret|addMenu|addMenuItem|addMissionEventHandler|addMPEventHandler|addMusicEventHandler|addOwnedMine|addPlayerScores|addPrimaryWeaponItem|addPublicVariableEventHandler|addRating|addResources|addScore|addScoreSide|addSecondaryWeaponItem|addSwitchableUnit|addTeamMember|addToRemainsCollector|addTorque|addUniform|addVehicle|addVest|addWaypoint|addWeapon|addWeaponCargo|addWeaponCargoGlobal|addWeaponGlobal|addWeaponItem|addWeaponPool|addWeaponTurret|admin|agent|agents|AGLToASL|aimedAtTarget|aimPos|airDensityCurveRTD|airDensityRTD|airplaneThrottle|airportSide|AISFinishHeal|alive|all3DENEntities|allAirports|allControls|allCurators|allCutLayers|allDead|allDeadMen|allDisplays|allGroups|allMapMarkers|allMines|allMissionObjects|allow3DMode|allowCrewInImmobile|allowCuratorLogicIgnoreAreas|allowDamage|allowDammage|allowFileOperations|allowFleeing|allowGetIn|allowSprint|allPlayers|allSimpleObjects|allSites|allTurrets|allUnits|allUnitsUAV|allVariables|ammo|ammoOnPylon|animate|animateBay|animateDoor|animatePylon|animateSource|animationNames|animationPhase|animationSourcePhase|animationState|append|apply|armoryPoints|arrayIntersect|asin|ASLToAGL|ASLToATL|assert|assignAsCargo|assignAsCargoIndex|assignAsCommander|assignAsDriver|assignAsGunner|assignAsTurret|assignCurator|assignedCargo|assignedCommander|assignedDriver|assignedGunner|assignedItems|assignedTarget|assignedTeam|assignedVehicle|assignedVehicleRole|assignItem|assignTeam|assignToAirport|atan|atan2|atg|ATLToASL|attachedObject|attachedObjects|attachedTo|attachObject|attachTo|attackEnabled|backpack|backpackCargo|backpackContainer|backpackItems|backpackMagazines|backpackSpaceFor|behaviour|benchmark|binocular|blufor|boundingBox|boundingBoxReal|boundingCenter|briefingName|buildingExit|buildingPos|buldozer_EnableRoadDiag|buldozer_IsEnabledRoadDiag|buldozer_LoadNewRoads|buldozer_reloadOperMap|buttonAction|buttonSetAction|cadetMode|callExtension|camCommand|camCommit|camCommitPrepared|camCommitted|camConstuctionSetParams|camCreate|camDestroy|cameraEffect|cameraEffectEnableHUD|cameraInterest|cameraOn|cameraView|campaignConfigFile|camPreload|camPreloaded|camPrepareBank|camPrepareDir|camPrepareDive|camPrepareFocus|camPrepareFov|camPrepareFovRange|camPreparePos|camPrepareRelPos|camPrepareTarget|camSetBank|camSetDir|camSetDive|camSetFocus|camSetFov|camSetFovRange|camSetPos|camSetRelPos|camSetTarget|camTarget|camUseNVG|canAdd|canAddItemToBackpack|canAddItemToUniform|canAddItemToVest|cancelSimpleTaskDestination|canFire|canMove|canSlingLoad|canStand|canSuspend|canTriggerDynamicSimulation|canUnloadInCombat|canVehicleCargo|captive|captiveNum|cbChecked|cbSetChecked|ceil|channelEnabled|cheatsEnabled|checkAIFeature|checkVisibility|civilian|className|clear3DENAttribute|clear3DENInventory|clearAllItemsFromBackpack|clearBackpackCargo|clearBackpackCargoGlobal|clearForcesRTD|clearGroupIcons|clearItemCargo|clearItemCargoGlobal|clearItemPool|clearMagazineCargo|clearMagazineCargoGlobal|clearMagazinePool|clearOverlay|clearRadio|clearVehicleInit|clearWeaponCargo|clearWeaponCargoGlobal|clearWeaponPool|clientOwner|closeDialog|closeDisplay|closeOverlay|collapseObjectTree|collect3DENHistory|collectiveRTD|combatMode|commandArtilleryFire|commandChat|commander|commandFire|commandFollow|commandFSM|commandGetOut|commandingMenu|commandMove|commandRadio|commandStop|commandSuppressiveFire|commandTarget|commandWatch|comment|commitOverlay|compile|compileFinal|completedFSM|composeText|configClasses|configFile|configHierarchy|configName|configNull|configProperties|configSourceAddonList|configSourceMod|configSourceModList|confirmSensorTarget|connectTerminalToUAV|controlNull|controlsGroupCtrl|copyFromClipboard|copyToClipboard|copyWaypoints|cos|count|countEnemy|countFriendly|countSide|countType|countUnknown|create3DENComposition|create3DENEntity|createAgent|createCenter|createDialog|createDiaryLink|createDiaryRecord|createDiarySubject|createDisplay|createGearDialog|createGroup|createGuardedPoint|createLocation|createMarker|createMarkerLocal|createMenu|createMine|createMissionDisplay|createMPCampaignDisplay|createSimpleObject|createSimpleTask|createSite|createSoundSource|createTask|createTeam|createTrigger|createUnit|createVehicle|createVehicleCrew|createVehicleLocal|crew|ctAddHeader|ctAddRow|ctClear|ctCurSel|ctData|ctFindHeaderRows|ctFindRowHeader|ctHeaderControls|ctHeaderCount|ctRemoveHeaders|ctRemoveRows|ctrlActivate|ctrlAddEventHandler|ctrlAngle|ctrlAutoScrollDelay|ctrlAutoScrollRewind|ctrlAutoScrollSpeed|ctrlChecked|ctrlClassName|ctrlCommit|ctrlCommitted|ctrlCreate|ctrlDelete|ctrlEnable|ctrlEnabled|ctrlFade|ctrlHTMLLoaded|ctrlIDC|ctrlIDD|ctrlMapAnimAdd|ctrlMapAnimClear|ctrlMapAnimCommit|ctrlMapAnimDone|ctrlMapCursor|ctrlMapMouseOver|ctrlMapScale|ctrlMapScreenToWorld|ctrlMapWorldToScreen|ctrlModel|ctrlModelDirAndUp|ctrlModelScale|ctrlParent|ctrlParentControlsGroup|ctrlPosition|ctrlRemoveAllEventHandlers|ctrlRemoveEventHandler|ctrlScale|ctrlSetActiveColor|ctrlSetAngle|ctrlSetAutoScrollDelay|ctrlSetAutoScrollRewind|ctrlSetAutoScrollSpeed|ctrlSetBackgroundColor|ctrlSetChecked|ctrlSetDisabledColor|ctrlSetEventHandler|ctrlSetFade|ctrlSetFocus|ctrlSetFont|ctrlSetFontH1|ctrlSetFontH1B|ctrlSetFontH2|ctrlSetFontH2B|ctrlSetFontH3|ctrlSetFontH3B|ctrlSetFontH4|ctrlSetFontH4B|ctrlSetFontH5|ctrlSetFontH5B|ctrlSetFontH6|ctrlSetFontH6B|ctrlSetFontHeight|ctrlSetFontHeightH1|ctrlSetFontHeightH2|ctrlSetFontHeightH3|ctrlSetFontHeightH4|ctrlSetFontHeightH5|ctrlSetFontHeightH6|ctrlSetFontHeightSecondary|ctrlSetFontP|ctrlSetFontPB|ctrlSetFontSecondary|ctrlSetForegroundColor|ctrlSetModel|ctrlSetModelDirAndUp|ctrlSetModelScale|ctrlSetPixelPrecision|ctrlSetPosition|ctrlSetScale|ctrlSetStructuredText|ctrlSetText|ctrlSetTextColor|ctrlSetTextColorSecondary|ctrlSetTextSecondary|ctrlSetTooltip|ctrlSetTooltipColorBox|ctrlSetTooltipColorShade|ctrlSetTooltipColorText|ctrlShow|ctrlShown|ctrlText|ctrlTextHeight|ctrlTextSecondary|ctrlTextWidth|ctrlType|ctrlVisible|ctRowControls|ctRowCount|ctSetCurSel|ctSetData|ctSetHeaderTemplate|ctSetRowTemplate|ctSetValue|ctValue|curatorAddons|curatorCamera|curatorCameraArea|curatorCameraAreaCeiling|curatorCoef|curatorEditableObjects|curatorEditingArea|curatorEditingAreaType|curatorMouseOver|curatorPoints|curatorRegisteredObjects|curatorSelected|curatorWaypointCost|current3DENOperation|currentChannel|currentCommand|currentMagazine|currentMagazineDetail|currentMagazineDetailTurret|currentMagazineTurret|currentMuzzle|currentNamespace|currentTask|currentTasks|currentThrowable|currentVisionMode|currentWaypoint|currentWeapon|currentWeaponMode|currentWeaponTurret|currentZeroing|cursorObject|cursorTarget|customChat|customRadio|cutFadeOut|cutObj|cutRsc|cutText|damage|date|dateToNumber|daytime|deActivateKey|debriefingText|debugFSM|debugLog|deg|delete3DENEntities|deleteAt|deleteCenter|deleteCollection|deleteEditorObject|deleteGroup|deleteGroupWhenEmpty|deleteIdentity|deleteLocation|deleteMarker|deleteMarkerLocal|deleteRange|deleteResources|deleteSite|deleteStatus|deleteTeam|deleteVehicle|deleteVehicleCrew|deleteWaypoint|detach|detectedMines|diag_activeMissionFSMs|diag_activeScripts|diag_activeSQFScripts|diag_activeSQSScripts|diag_captureFrame|diag_captureFrameToFile|diag_captureSlowFrame|diag_codePerformance|diag_drawMode|diag_dynamicSimulationEnd|diag_enable|diag_enabled|diag_fps|diag_fpsMin|diag_frameNo|diag_lightNewLoad|diag_list|diag_log|diag_logSlowFrame|diag_mergeConfigFile|diag_recordTurretLimits|diag_setLightNew|diag_tickTime|diag_toggle|dialog|diarySubjectExists|didJIP|didJIPOwner|difficulty|difficultyEnabled|difficultyEnabledRTD|difficultyOption|direction|directSay|disableAI|disableCollisionWith|disableConversation|disableDebriefingStats|disableMapIndicators|disableNVGEquipment|disableRemoteSensors|disableSerialization|disableTIEquipment|disableUAVConnectability|disableUserInput|displayAddEventHandler|displayCtrl|displayNull|displayParent|displayRemoveAllEventHandlers|displayRemoveEventHandler|displaySetEventHandler|dissolveTeam|distance|distance2D|distanceSqr|distributionRegion|do3DENAction|doArtilleryFire|doFire|doFollow|doFSM|doGetOut|doMove|doorPhase|doStop|doSuppressiveFire|doTarget|doWatch|drawArrow|drawEllipse|drawIcon|drawIcon3D|drawLine|drawLine3D|drawLink|drawLocation|drawPolygon|drawRectangle|drawTriangle|driver|drop|dynamicSimulationDistance|dynamicSimulationDistanceCoef|dynamicSimulationEnabled|dynamicSimulationSystemEnabled|east|edit3DENMissionAttributes|editObject|editorSetEventHandler|effectiveCommander|emptyPositions|enableAI|enableAIFeature|enableAimPrecision|enableAttack|enableAudioFeature|enableAutoStartUpRTD|enableAutoTrimRTD|enableCamShake|enableCaustics|enableChannel|enableCollisionWith|enableCopilot|enableDebriefingStats|enableDiagLegend|enableDynamicSimulation|enableDynamicSimulationSystem|enableEndDialog|enableEngineArtillery|enableEnvironment|enableFatigue|enableGunLights|enableInfoPanelComponent|enableIRLasers|enableMimics|enablePersonTurret|enableRadio|enableReload|enableRopeAttach|enableSatNormalOnDetail|enableSaving|enableSentences|enableSimulation|enableSimulationGlobal|enableStamina|enableStressDamage|enableTeamSwitch|enableTraffic|enableUAVConnectability|enableUAVWaypoints|enableVehicleCargo|enableVehicleSensor|enableWeaponDisassembly|endl|endLoadingScreen|endMission|engineOn|enginesIsOnRTD|enginesPowerRTD|enginesRpmRTD|enginesTorqueRTD|entities|environmentEnabled|estimatedEndServerTime|estimatedTimeLeft|evalObjectArgument|everyBackpack|everyContainer|exec|execEditorScript|exp|expectedDestination|exportJIPMessages|eyeDirection|eyePos|face|faction|fadeMusic|fadeRadio|fadeSound|fadeSpeech|failMission|fillWeaponsFromPool|find|findCover|findDisplay|findEditorObject|findEmptyPosition|findEmptyPositionReady|findIf|findNearestEnemy|finishMissionInit|finite|fire|fireAtTarget|firstBackpack|flag|flagAnimationPhase|flagOwner|flagSide|flagTexture|fleeing|floor|flyInHeight|flyInHeightASL|fog|fogForecast|fogParams|forceAddUniform|forceAtPositionRTD|forcedMap|forceEnd|forceFlagTexture|forceFollowRoad|forceGeneratorRTD|forceMap|forceRespawn|forceSpeed|forceWalk|forceWeaponFire|forceWeatherChange|forgetTarget|format|formation|formationDirection|formationLeader|formationMembers|formationPosition|formationTask|formatText|formLeader|freeLook|fromEditor|fuel|fullCrew|gearIDCAmmoCount|gearSlotAmmoCount|gearSlotData|get3DENActionState|get3DENAttribute|get3DENCamera|get3DENConnections|get3DENEntity|get3DENEntityID|get3DENGrid|get3DENIconsVisible|get3DENLayerEntities|get3DENLinesVisible|get3DENMissionAttribute|get3DENMouseOver|get3DENSelected|getAimingCoef|getAllEnvSoundControllers|getAllHitPointsDamage|getAllOwnedMines|getAllSoundControllers|getAmmoCargo|getAnimAimPrecision|getAnimSpeedCoef|getArray|getArtilleryAmmo|getArtilleryComputerSettings|getArtilleryETA|getAssignedCuratorLogic|getAssignedCuratorUnit|getBackpackCargo|getBleedingRemaining|getBurningValue|getCameraViewDirection|getCargoIndex|getCenterOfMass|getClientState|getClientStateNumber|getCompatiblePylonMagazines|getConnectedUAV|getContainerMaxLoad|getCursorObjectParams|getCustomAimCoef|getDammage|getDescription|getDir|getDirVisual|getDLCAssetsUsage|getDLCAssetsUsageByName|getDLCs|getDLCUsageTime|getEditorCamera|getEditorMode|getEditorObjectScope|getElevationOffset|getEngineTargetRpmRTD|getEnvSoundController|getFatigue|getFieldManualStartPage|getForcedFlagTexture|getFriend|getFSMVariable|getFuelCargo|getGroupIcon|getGroupIconParams|getGroupIcons|getHideFrom|getHit|getHitIndex|getHitPointDamage|getItemCargo|getMagazineCargo|getMarkerColor|getMarkerPos|getMarkerSize|getMarkerType|getMass|getMissionConfig|getMissionConfigValue|getMissionDLCs|getMissionLayerEntities|getMissionLayers|getModelInfo|getMousePosition|getMusicPlayedTime|getNumber|getObjectArgument|getObjectChildren|getObjectDLC|getObjectMaterials|getObjectProxy|getObjectTextures|getObjectType|getObjectViewDistance|getOxygenRemaining|getPersonUsedDLCs|getPilotCameraDirection|getPilotCameraPosition|getPilotCameraRotation|getPilotCameraTarget|getPlateNumber|getPlayerChannel|getPlayerScores|getPlayerUID|getPlayerUIDOld|getPos|getPosASL|getPosASLVisual|getPosASLW|getPosATL|getPosATLVisual|getPosVisual|getPosWorld|getPylonMagazines|getRelDir|getRelPos|getRemoteSensorsDisabled|getRepairCargo|getResolution|getRotorBrakeRTD|getShadowDistance|getShotParents|getSlingLoad|getSoundController|getSoundControllerResult|getSpeed|getStamina|getStatValue|getSuppression|getTerrainGrid|getTerrainHeightASL|getText|getTotalDLCUsageTime|getTrimOffsetRTD|getUnitLoadout|getUnitTrait|getUserMFDText|getUserMFDValue|getVariable|getVehicleCargo|getWeaponCargo|getWeaponSway|getWingsOrientationRTD|getWingsPositionRTD|getWPPos|glanceAt|globalChat|globalRadio|goggles|group|groupChat|groupFromNetId|groupIconSelectable|groupIconsVisible|groupId|groupOwner|groupRadio|groupSelectedUnits|groupSelectUnit|grpNull|gunner|gusts|halt|handgunItems|handgunMagazine|handgunWeapon|handsHit|hasInterface|hasPilotCamera|hasWeapon|hcAllGroups|hcGroupParams|hcLeader|hcRemoveAllGroups|hcRemoveGroup|hcSelected|hcSelectGroup|hcSetGroup|hcShowBar|hcShownBar|headgear|hideBody|hideObject|hideObjectGlobal|hideSelection|hint|hintC|hintCadet|hintSilent|hmd|hostMission|htmlLoad|HUDMovementLevels|humidity|image|importAllGroups|importance|in|inArea|inAreaArray|incapacitatedState|independent|inflame|inflamed|infoPanel|infoPanelComponentEnabled|infoPanelComponents|infoPanels|inGameUISetEventHandler|inheritsFrom|initAmbientLife|inPolygon|inputAction|inRangeOfArtillery|insertEditorObject|intersect|is3DEN|is3DENMultiplayer|isAbleToBreathe|isAgent|isAimPrecisionEnabled|isArray|isAutoHoverOn|isAutonomous|isAutoStartUpEnabledRTD|isAutotest|isAutoTrimOnRTD|isBleeding|isBurning|isClass|isCollisionLightOn|isCopilotEnabled|isDamageAllowed|isDedicated|isDLCAvailable|isEngineOn|isEqualTo|isEqualType|isEqualTypeAll|isEqualTypeAny|isEqualTypeArray|isEqualTypeParams|isFilePatchingEnabled|isFlashlightOn|isFlatEmpty|isForcedWalk|isFormationLeader|isGroupDeletedWhenEmpty|isHidden|isInRemainsCollector|isInstructorFigureEnabled|isIRLaserOn|isKeyActive|isKindOf|isLaserOn|isLightOn|isLocalized|isManualFire|isMarkedForCollection|isMultiplayer|isMultiplayerSolo|isNil|isNull|isNumber|isObjectHidden|isObjectRTD|isOnRoad|isPipEnabled|isPlayer|isRealTime|isRemoteExecuted|isRemoteExecutedJIP|isServer|isShowing3DIcons|isSimpleObject|isSprintAllowed|isStaminaEnabled|isSteamMission|isStreamFriendlyUIEnabled|isStressDamageEnabled|isText|isTouchingGround|isTurnedOut|isTutHintsEnabled|isUAVConnectable|isUAVConnected|isUIContext|isUniformAllowed|isVehicleCargo|isVehicleRadarOn|isVehicleSensorEnabled|isWalking|isWeaponDeployed|isWeaponRested|itemCargo|items|itemsWithMagazines|join|joinAs|joinAsSilent|joinSilent|joinString|kbAddDatabase|kbAddDatabaseTargets|kbAddTopic|kbHasTopic|kbReact|kbRemoveTopic|kbTell|kbWasSaid|keyImage|keyName|knowsAbout|land|landAt|landResult|language|laserTarget|lbAdd|lbClear|lbColor|lbColorRight|lbCurSel|lbData|lbDelete|lbIsSelected|lbPicture|lbPictureRight|lbSelection|lbSetColor|lbSetColorRight|lbSetCurSel|lbSetData|lbSetPicture|lbSetPictureColor|lbSetPictureColorDisabled|lbSetPictureColorSelected|lbSetPictureRight|lbSetPictureRightColor|lbSetPictureRightColorDisabled|lbSetPictureRightColorSelected|lbSetSelectColor|lbSetSelectColorRight|lbSetSelected|lbSetText|lbSetTextRight|lbSetTooltip|lbSetValue|lbSize|lbSort|lbSortByValue|lbText|lbTextRight|lbValue|leader|leaderboardDeInit|leaderboardGetRows|leaderboardInit|leaderboardRequestRowsFriends|leaderboardRequestRowsGlobal|leaderboardRequestRowsGlobalAroundUser|leaderboardsRequestUploadScore|leaderboardsRequestUploadScoreKeepBest|leaderboardState|leaveVehicle|libraryCredits|libraryDisclaimers|lifeState|lightAttachObject|lightDetachObject|lightIsOn|lightnings|limitSpeed|linearConversion|lineBreak|lineIntersects|lineIntersectsObjs|lineIntersectsSurfaces|lineIntersectsWith|linkItem|list|listObjects|listRemoteTargets|listVehicleSensors|ln|lnbAddArray|lnbAddColumn|lnbAddRow|lnbClear|lnbColor|lnbColorRight|lnbCurSelRow|lnbData|lnbDeleteColumn|lnbDeleteRow|lnbGetColumnsPosition|lnbPicture|lnbPictureRight|lnbSetColor|lnbSetColorRight|lnbSetColumnsPos|lnbSetCurSelRow|lnbSetData|lnbSetPicture|lnbSetPictureColor|lnbSetPictureColorRight|lnbSetPictureColorSelected|lnbSetPictureColorSelectedRight|lnbSetPictureRight|lnbSetText|lnbSetTextRight|lnbSetValue|lnbSize|lnbSort|lnbSortByValue|lnbText|lnbTextRight|lnbValue|load|loadAbs|loadBackpack|loadFile|loadGame|loadIdentity|loadMagazine|loadOverlay|loadStatus|loadUniform|loadVest|local|localize|locationNull|locationPosition|lock|lockCameraTo|lockCargo|lockDriver|locked|lockedCargo|lockedDriver|lockedTurret|lockIdentity|lockTurret|lockWP|log|logEntities|logNetwork|logNetworkTerminate|lookAt|lookAtPos|magazineCargo|magazines|magazinesAllTurrets|magazinesAmmo|magazinesAmmoCargo|magazinesAmmoFull|magazinesDetail|magazinesDetailBackpack|magazinesDetailUniform|magazinesDetailVest|magazinesTurret|magazineTurretAmmo|mapAnimAdd|mapAnimClear|mapAnimCommit|mapAnimDone|mapCenterOnCamera|mapGridPosition|markAsFinishedOnSteam|markerAlpha|markerBrush|markerColor|markerDir|markerPos|markerShape|markerSize|markerText|markerType|max|members|menuAction|menuAdd|menuChecked|menuClear|menuCollapse|menuData|menuDelete|menuEnable|menuEnabled|menuExpand|menuHover|menuPicture|menuSetAction|menuSetCheck|menuSetData|menuSetPicture|menuSetValue|menuShortcut|menuShortcutText|menuSize|menuSort|menuText|menuURL|menuValue|min|mineActive|mineDetectedBy|missionConfigFile|missionDifficulty|missionName|missionNamespace|missionStart|missionVersion|modelToWorld|modelToWorldVisual|modelToWorldVisualWorld|modelToWorldWorld|modParams|moonIntensity|moonPhase|morale|move|move3DENCamera|moveInAny|moveInCargo|moveInCommander|moveInDriver|moveInGunner|moveInTurret|moveObjectToEnd|moveOut|moveTime|moveTo|moveToCompleted|moveToFailed|musicVolume|name|nameSound|nearEntities|nearestBuilding|nearestLocation|nearestLocations|nearestLocationWithDubbing|nearestObject|nearestObjects|nearestTerrainObjects|nearObjects|nearObjectsReady|nearRoads|nearSupplies|nearTargets|needReload|netId|netObjNull|newOverlay|nextMenuItemIndex|nextWeatherChange|nMenuItems|numberOfEnginesRTD|numberToDate|objectCurators|objectFromNetId|objectParent|objNull|objStatus|onBriefingGear|onBriefingGroup|onBriefingNotes|onBriefingPlan|onBriefingTeamSwitch|onCommandModeChanged|onDoubleClick|onEachFrame|onGroupIconClick|onGroupIconOverEnter|onGroupIconOverLeave|onHCGroupSelectionChanged|onMapSingleClick|onPlayerConnected|onPlayerDisconnected|onPreloadFinished|onPreloadStarted|onShowNewObject|onTeamSwitch|openCuratorInterface|openDLCPage|openDSInterface|openMap|openSteamApp|openYoutubeVideo|opfor|orderGetIn|overcast|overcastForecast|owner|param|params|parseNumber|parseSimpleArray|parseText|parsingNamespace|particlesQuality|pi|pickWeaponPool|pitch|pixelGrid|pixelGridBase|pixelGridNoUIScale|pixelH|pixelW|playableSlotsNumber|playableUnits|playAction|playActionNow|player|playerRespawnTime|playerSide|playersNumber|playGesture|playMission|playMove|playMoveNow|playMusic|playScriptedMission|playSound|playSound3D|position|positionCameraToWorld|posScreenToWorld|posWorldToScreen|ppEffectAdjust|ppEffectCommit|ppEffectCommitted|ppEffectCreate|ppEffectDestroy|ppEffectEnable|ppEffectEnabled|ppEffectForceInNVG|precision|preloadCamera|preloadObject|preloadSound|preloadTitleObj|preloadTitleRsc|primaryWeapon|primaryWeaponItems|primaryWeaponMagazine|priority|processDiaryLink|processInitCommands|productVersion|profileName|profileNamespace|profileNameSteam|progressLoadingScreen|progressPosition|progressSetPosition|publicVariable|publicVariableClient|publicVariableServer|pushBack|pushBackUnique|putWeaponPool|queryItemsPool|queryMagazinePool|queryWeaponPool|rad|radioChannelAdd|radioChannelCreate|radioChannelRemove|radioChannelSetCallSign|radioChannelSetLabel|radioVolume|rain|rainbow|random|rank|rankId|rating|rectangular|registeredTasks|registerTask|reload|reloadEnabled|remoteControl|remoteExec|remoteExecCall|remoteExecutedOwner|remove3DENConnection|remove3DENEventHandler|remove3DENLayer|removeAction|removeAll3DENEventHandlers|removeAllActions|removeAllAssignedItems|removeAllContainers|removeAllCuratorAddons|removeAllCuratorCameraAreas|removeAllCuratorEditingAreas|removeAllEventHandlers|removeAllHandgunItems|removeAllItems|removeAllItemsWithMagazines|removeAllMissionEventHandlers|removeAllMPEventHandlers|removeAllMusicEventHandlers|removeAllOwnedMines|removeAllPrimaryWeaponItems|removeAllWeapons|removeBackpack|removeBackpackGlobal|removeCuratorAddons|removeCuratorCameraArea|removeCuratorEditableObjects|removeCuratorEditingArea|removeDrawIcon|removeDrawLinks|removeEventHandler|removeFromRemainsCollector|removeGoggles|removeGroupIcon|removeHandgunItem|removeHeadgear|removeItem|removeItemFromBackpack|removeItemFromUniform|removeItemFromVest|removeItems|removeMagazine|removeMagazineGlobal|removeMagazines|removeMagazinesTurret|removeMagazineTurret|removeMenuItem|removeMissionEventHandler|removeMPEventHandler|removeMusicEventHandler|removeOwnedMine|removePrimaryWeaponItem|removeSecondaryWeaponItem|removeSimpleTask|removeSwitchableUnit|removeTeamMember|removeUniform|removeVest|removeWeapon|removeWeaponAttachmentCargo|removeWeaponCargo|removeWeaponGlobal|removeWeaponTurret|reportRemoteTarget|requiredVersion|resetCamShake|resetSubgroupDirection|resistance|resize|resources|respawnVehicle|restartEditorCamera|reveal|revealMine|reverse|reversedMouseY|roadAt|roadsConnectedTo|roleDescription|ropeAttachedObjects|ropeAttachedTo|ropeAttachEnabled|ropeAttachTo|ropeCreate|ropeCut|ropeDestroy|ropeDetach|ropeEndPosition|ropeLength|ropes|ropeUnwind|ropeUnwound|rotorsForcesRTD|rotorsRpmRTD|round|runInitScript|safeZoneH|safeZoneW|safeZoneWAbs|safeZoneX|safeZoneXAbs|safeZoneY|save3DENInventory|saveGame|saveIdentity|saveJoysticks|saveOverlay|saveProfileNamespace|saveStatus|saveVar|savingEnabled|say|say2D|say3D|score|scoreSide|screenshot|screenToWorld|scriptDone|scriptName|scriptNull|scudState|secondaryWeapon|secondaryWeaponItems|secondaryWeaponMagazine|select|selectBestPlaces|selectDiarySubject|selectedEditorObjects|selectEditorObject|selectionNames|selectionPosition|selectLeader|selectMax|selectMin|selectNoPlayer|selectPlayer|selectRandom|selectRandomWeighted|selectWeapon|selectWeaponTurret|sendAUMessage|sendSimpleCommand|sendTask|sendTaskResult|sendUDPMessage|serverCommand|serverCommandAvailable|serverCommandExecutable|serverName|serverTime|set|set3DENAttribute|set3DENAttributes|set3DENGrid|set3DENIconsVisible|set3DENLayer|set3DENLinesVisible|set3DENLogicType|set3DENMissionAttribute|set3DENMissionAttributes|set3DENModelsVisible|set3DENObjectType|set3DENSelected|setAccTime|setActualCollectiveRTD|setAirplaneThrottle|setAirportSide|setAmmo|setAmmoCargo|setAmmoOnPylon|setAnimSpeedCoef|setAperture|setApertureNew|setArmoryPoints|setAttributes|setAutonomous|setBehaviour|setBleedingRemaining|setBrakesRTD|setCameraInterest|setCamShakeDefParams|setCamShakeParams|setCamUseTI|setCaptive|setCenterOfMass|setCollisionLight|setCombatMode|setCompassOscillation|setConvoySeparation|setCuratorCameraAreaCeiling|setCuratorCoef|setCuratorEditingAreaType|setCuratorWaypointCost|setCurrentChannel|setCurrentTask|setCurrentWaypoint|setCustomAimCoef|setCustomWeightRTD|setDamage|setDammage|setDate|setDebriefingText|setDefaultCamera|setDestination|setDetailMapBlendPars|setDir|setDirection|setDrawIcon|setDriveOnPath|setDropInterval|setDynamicSimulationDistance|setDynamicSimulationDistanceCoef|setEditorMode|setEditorObjectScope|setEffectCondition|setEngineRpmRTD|setFace|setFaceAnimation|setFatigue|setFeatureType|setFlagAnimationPhase|setFlagOwner|setFlagSide|setFlagTexture|setFog|setForceGeneratorRTD|setFormation|setFormationTask|setFormDir|setFriend|setFromEditor|setFSMVariable|setFuel|setFuelCargo|setGroupIcon|setGroupIconParams|setGroupIconsSelectable|setGroupIconsVisible|setGroupId|setGroupIdGlobal|setGroupOwner|setGusts|setHideBehind|setHit|setHitIndex|setHitPointDamage|setHorizonParallaxCoef|setHUDMovementLevels|setIdentity|setImportance|setInfoPanel|setLeader|setLightAmbient|setLightAttenuation|setLightBrightness|setLightColor|setLightDayLight|setLightFlareMaxDistance|setLightFlareSize|setLightIntensity|setLightnings|setLightUseFlare|setLocalWindParams|setMagazineTurretAmmo|setMarkerAlpha|setMarkerAlphaLocal|setMarkerBrush|setMarkerBrushLocal|setMarkerColor|setMarkerColorLocal|setMarkerDir|setMarkerDirLocal|setMarkerPos|setMarkerPosLocal|setMarkerShape|setMarkerShapeLocal|setMarkerSize|setMarkerSizeLocal|setMarkerText|setMarkerTextLocal|setMarkerType|setMarkerTypeLocal|setMass|setMimic|setMousePosition|setMusicEffect|setMusicEventHandler|setName|setNameSound|setObjectArguments|setObjectMaterial|setObjectMaterialGlobal|setObjectProxy|setObjectTexture|setObjectTextureGlobal|setObjectViewDistance|setOvercast|setOwner|setOxygenRemaining|setParticleCircle|setParticleClass|setParticleFire|setParticleParams|setParticleRandom|setPilotCameraDirection|setPilotCameraRotation|setPilotCameraTarget|setPilotLight|setPiPEffect|setPitch|setPlateNumber|setPlayable|setPlayerRespawnTime|setPos|setPosASL|setPosASL2|setPosASLW|setPosATL|setPosition|setPosWorld|setPylonLoadOut|setPylonsPriority|setRadioMsg|setRain|setRainbow|setRandomLip|setRank|setRectangular|setRepairCargo|setRotorBrakeRTD|setShadowDistance|setShotParents|setSide|setSimpleTaskAlwaysVisible|setSimpleTaskCustomData|setSimpleTaskDescription|setSimpleTaskDestination|setSimpleTaskTarget|setSimpleTaskType|setSimulWeatherLayers|setSize|setSkill|setSlingLoad|setSoundEffect|setSpeaker|setSpeech|setSpeedMode|setStamina|setStaminaScheme|setStatValue|setSuppression|setSystemOfUnits|setTargetAge|setTaskMarkerOffset|setTaskResult|setTaskState|setTerrainGrid|setText|setTimeMultiplier|setTitleEffect|setToneMapping|setToneMappingParams|setTrafficDensity|setTrafficDistance|setTrafficGap|setTrafficSpeed|setTriggerActivation|setTriggerArea|setTriggerStatements|setTriggerText|setTriggerTimeout|setTriggerType|setType|setUnconscious|setUnitAbility|setUnitLoadout|setUnitPos|setUnitPosWeak|setUnitRank|setUnitRecoilCoefficient|setUnitTrait|setUnloadInCombat|setUserActionText|setUserMFDText|setUserMFDValue|setVariable|setVectorDir|setVectorDirAndUp|setVectorUp|setVehicleAmmo|setVehicleAmmoDef|setVehicleArmor|setVehicleCargo|setVehicleId|setVehicleInit|setVehicleLock|setVehiclePosition|setVehicleRadar|setVehicleReceiveRemoteTargets|setVehicleReportOwnPosition|setVehicleReportRemoteTargets|setVehicleTIPars|setVehicleVarName|setVelocity|setVelocityModelSpace|setVelocityTransformation|setViewDistance|setVisibleIfTreeCollapsed|setWantedRpmRTD|setWaves|setWaypointBehaviour|setWaypointCombatMode|setWaypointCompletionRadius|setWaypointDescription|setWaypointForceBehaviour|setWaypointFormation|setWaypointHousePosition|setWaypointLoiterRadius|setWaypointLoiterType|setWaypointName|setWaypointPosition|setWaypointScript|setWaypointSpeed|setWaypointStatements|setWaypointTimeout|setWaypointType|setWaypointVisible|setWeaponReloadingTime|setWind|setWindDir|setWindForce|setWindStr|setWingForceScaleRTD|setWPPos|show3DIcons|showChat|showCinemaBorder|showCommandingMenu|showCompass|showCuratorCompass|showGPS|showHUD|showLegend|showMap|shownArtilleryComputer|shownChat|shownCompass|shownCuratorCompass|showNewEditorObject|shownGPS|shownHUD|shownMap|shownPad|shownRadio|shownScoretable|shownUAVFeed|shownWarrant|shownWatch|showPad|showRadio|showScoretable|showSubtitles|showUAVFeed|showWarrant|showWatch|showWaypoint|showWaypoints|side|sideAmbientLife|sideChat|sideEmpty|sideEnemy|sideFriendly|sideLogic|sideRadio|sideUnknown|simpleTasks|simulationEnabled|simulCloudDensity|simulCloudOcclusion|simulInClouds|simulWeatherSync|sin|size|sizeOf|skill|skillFinal|skipTime|sleep|sliderPosition|sliderRange|sliderSetPosition|sliderSetRange|sliderSetSpeed|sliderSpeed|slingLoadAssistantShown|soldierMagazines|someAmmo|sort|soundVolume|speaker|speed|speedMode|splitString|sqrt|squadParams|stance|startLoadingScreen|stop|stopEngineRTD|stopped|str|sunOrMoon|supportInfo|suppressFor|surfaceIsWater|surfaceNormal|surfaceType|swimInDepth|switchableUnits|switchAction|switchCamera|switchGesture|switchLight|switchMove|synchronizedObjects|synchronizedTriggers|synchronizedWaypoints|synchronizeObjectsAdd|synchronizeObjectsRemove|synchronizeTrigger|synchronizeWaypoint|systemChat|systemOfUnits|tan|targetKnowledge|targets|targetsAggregate|targetsQuery|taskAlwaysVisible|taskChildren|taskCompleted|taskCustomData|taskDescription|taskDestination|taskHint|taskMarkerOffset|taskNull|taskParent|taskResult|taskState|taskType|teamMember|teamMemberNull|teamName|teams|teamSwitch|teamSwitchEnabled|teamType|terminate|terrainIntersect|terrainIntersectASL|terrainIntersectAtASL|text|textLog|textLogFormat|tg|time|timeMultiplier|titleCut|titleFadeOut|titleObj|titleRsc|titleText|toArray|toFixed|toLower|toString|toUpper|triggerActivated|triggerActivation|triggerArea|triggerAttachedVehicle|triggerAttachObject|triggerAttachVehicle|triggerDynamicSimulation|triggerStatements|triggerText|triggerTimeout|triggerTimeoutCurrent|triggerType|turretLocal|turretOwner|turretUnit|tvAdd|tvClear|tvCollapse|tvCollapseAll|tvCount|tvCurSel|tvData|tvDelete|tvExpand|tvExpandAll|tvPicture|tvPictureRight|tvSetColor|tvSetCurSel|tvSetData|tvSetPicture|tvSetPictureColor|tvSetPictureColorDisabled|tvSetPictureColorSelected|tvSetPictureRight|tvSetPictureRightColor|tvSetPictureRightColorDisabled|tvSetPictureRightColorSelected|tvSetSelectColor|tvSetText|tvSetTooltip|tvSetValue|tvSort|tvSortByValue|tvText|tvTooltip|tvValue|type|typeName|typeOf|UAVControl|uiNamespace|uiSleep|unassignCurator|unassignItem|unassignTeam|unassignVehicle|underwater|uniform|uniformContainer|uniformItems|uniformMagazines|unitAddons|unitAimPosition|unitAimPositionVisual|unitBackpack|unitIsUAV|unitPos|unitReady|unitRecoilCoefficient|units|unitsBelowHeight|unlinkItem|unlockAchievement|unregisterTask|updateDrawIcon|updateMenuItem|updateObjectTree|useAIOperMapObstructionTest|useAISteeringComponent|useAudioTimeForMoves|userInputDisabled|vectorAdd|vectorCos|vectorCrossProduct|vectorDiff|vectorDir|vectorDirVisual|vectorDistance|vectorDistanceSqr|vectorDotProduct|vectorFromTo|vectorMagnitude|vectorMagnitudeSqr|vectorModelToWorld|vectorModelToWorldVisual|vectorMultiply|vectorNormalized|vectorUp|vectorUpVisual|vectorWorldToModel|vectorWorldToModelVisual|vehicle|vehicleCargoEnabled|vehicleChat|vehicleRadio|vehicleReceiveRemoteTargets|vehicleReportOwnPosition|vehicleReportRemoteTargets|vehicles|vehicleVarName|velocity|velocityModelSpace|verifySignature|vest|vestContainer|vestItems|vestMagazines|viewDistance|visibleCompass|visibleGPS|visibleMap|visiblePosition|visiblePositionASL|visibleScoretable|visibleWatch|waitUntil|waves|waypointAttachedObject|waypointAttachedVehicle|waypointAttachObject|waypointAttachVehicle|waypointBehaviour|waypointCombatMode|waypointCompletionRadius|waypointDescription|waypointForceBehaviour|waypointFormation|waypointHousePosition|waypointLoiterRadius|waypointLoiterType|waypointName|waypointPosition|waypoints|waypointScript|waypointsEnabledUAV|waypointShow|waypointSpeed|waypointStatements|waypointTimeout|waypointTimeoutCurrent|waypointType|waypointVisible|weaponAccessories|weaponAccessoriesCargo|weaponCargo|weaponDirection|weaponInertia|weaponLowered|weapons|weaponsItems|weaponsItemsCargo|weaponState|weaponsTurret|weightRTD|west|WFSideText|wind|windDir|windRTD|windStr|wingsForcesRTD|worldName|worldSize|worldToModel|worldToModelVisual|worldToScreen)\b/i,
	    number:
	      /(?:\$|\b0x)[\da-f]+\b|(?:\B\.\d+|\b\d+(?:\.\d+)?)(?:e[+-]?\d+)?\b/i,
	    operator: /##|>>|&&|\|\||[!=<>]=?|[-+*/%#^]|\b(?:and|mod|not|or)\b/i,
	    'magic-variable': {
	      pattern:
	        /\b(?:this|thisList|thisTrigger|_exception|_fnc_scriptName|_fnc_scriptNameParent|_forEachIndex|_this|_thisEventHandler|_thisFSM|_thisScript|_x)\b/i,
	      alias: 'keyword'
	    },
	    constant: /\bDIK(?:_[a-z\d]+)+\b/i
	  });
	  Prism.languages.insertBefore('sqf', 'string', {
	    macro: {
	      pattern: /(^[ \t]*)#[a-z](?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
	      lookbehind: true,
	      greedy: true,
	      alias: 'property',
	      inside: {
	        directive: {
	          pattern: /#[a-z]+\b/i,
	          alias: 'keyword'
	        },
	        comment: Prism.languages.sqf.comment
	      }
	    }
	  });
	  delete Prism.languages.sqf['class-name'];
	}
	return sqf_1;
}

var squirrel_1;
var hasRequiredSquirrel;

function requireSquirrel () {
	if (hasRequiredSquirrel) return squirrel_1;
	hasRequiredSquirrel = 1;

	squirrel_1 = squirrel;
	squirrel.displayName = 'squirrel';
	squirrel.aliases = [];
	function squirrel(Prism) {
	  Prism.languages.squirrel = Prism.languages.extend('clike', {
	    comment: [
	      Prism.languages.clike['comment'][0],
	      {
	        pattern: /(^|[^\\:])(?:\/\/|#).*/,
	        lookbehind: true,
	        greedy: true
	      }
	    ],
	    string: {
	      pattern: /(^|[^\\"'@])(?:@"(?:[^"]|"")*"(?!")|"(?:[^\\\r\n"]|\\.)*")/,
	      lookbehind: true,
	      greedy: true
	    },
	    'class-name': {
	      pattern: /(\b(?:class|enum|extends|instanceof)\s+)\w+(?:\.\w+)*/,
	      lookbehind: true,
	      inside: {
	        punctuation: /\./
	      }
	    },
	    keyword:
	      /\b(?:__FILE__|__LINE__|base|break|case|catch|class|clone|const|constructor|continue|default|delete|else|enum|extends|for|foreach|function|if|in|instanceof|local|null|resume|return|static|switch|this|throw|try|typeof|while|yield)\b/,
	    number: /\b(?:0x[0-9a-fA-F]+|\d+(?:\.(?:\d+|[eE][+-]?\d+))?)\b/,
	    operator: /\+\+|--|<=>|<[-<]|>>>?|&&?|\|\|?|[-+*/%!=<>]=?|[~^]|::?/,
	    punctuation: /[(){}\[\],;.]/
	  });
	  Prism.languages.insertBefore('squirrel', 'string', {
	    char: {
	      pattern: /(^|[^\\"'])'(?:[^\\']|\\(?:[xuU][0-9a-fA-F]{0,8}|[\s\S]))'/,
	      lookbehind: true,
	      greedy: true
	    }
	  });
	  Prism.languages.insertBefore('squirrel', 'operator', {
	    'attribute-punctuation': {
	      pattern: /<\/|\/>/,
	      alias: 'important'
	    },
	    lambda: {
	      pattern: /@(?=\()/,
	      alias: 'operator'
	    }
	  });
	}
	return squirrel_1;
}

var stan_1;
var hasRequiredStan;

function requireStan () {
	if (hasRequiredStan) return stan_1;
	hasRequiredStan = 1;

	stan_1 = stan;
	stan.displayName = 'stan';
	stan.aliases = [];
	function stan(Prism) {
(function (Prism) {
	    // https://mc-stan.org/docs/2_28/reference-manual/bnf-grammars.html
	    var higherOrderFunctions =
	      /\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\b/;
	    Prism.languages.stan = {
	      comment: /\/\/.*|\/\*[\s\S]*?\*\/|#(?!include).*/,
	      string: {
	        // String literals can contain spaces and any printable ASCII characters except for " and \
	        // https://mc-stan.org/docs/2_24/reference-manual/print-statements-section.html#string-literals
	        pattern: /"[\x20\x21\x23-\x5B\x5D-\x7E]*"/,
	        greedy: true
	      },
	      directive: {
	        pattern: /^([ \t]*)#include\b.*/m,
	        lookbehind: true,
	        alias: 'property'
	      },
	      'function-arg': {
	        pattern: RegExp(
	          '(' +
	            higherOrderFunctions.source +
	            /\s*\(\s*/.source +
	            ')' +
	            /[a-zA-Z]\w*/.source
	        ),
	        lookbehind: true,
	        alias: 'function'
	      },
	      constraint: {
	        pattern: /(\b(?:int|matrix|real|row_vector|vector)\s*)<[^<>]*>/,
	        lookbehind: true,
	        inside: {
	          expression: {
	            pattern: /(=\s*)\S(?:\S|\s+(?!\s))*?(?=\s*(?:>$|,\s*\w+\s*=))/,
	            lookbehind: true,
	            inside: null // see below
	          },
	          property: /\b[a-z]\w*(?=\s*=)/i,
	          operator: /=/,
	          punctuation: /^<|>$|,/
	        }
	      },
	      keyword: [
	        {
	          pattern:
	            /\bdata(?=\s*\{)|\b(?:functions|generated|model|parameters|quantities|transformed)\b/,
	          alias: 'program-block'
	        },
	        /\b(?:array|break|cholesky_factor_corr|cholesky_factor_cov|complex|continue|corr_matrix|cov_matrix|data|else|for|if|in|increment_log_prob|int|matrix|ordered|positive_ordered|print|real|reject|return|row_vector|simplex|target|unit_vector|vector|void|while)\b/, // these are functions that are known to take another function as their first argument.
	        higherOrderFunctions
	      ],
	      function: /\b[a-z]\w*(?=\s*\()/i,
	      number:
	        /(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:E[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
	      boolean: /\b(?:false|true)\b/,
	      operator: /<-|\.[*/]=?|\|\|?|&&|[!=<>+\-*/]=?|['^%~?:]/,
	      punctuation: /[()\[\]{},;]/
	    };
	    Prism.languages.stan.constraint.inside.expression.inside =
	      Prism.languages.stan;
	  })(Prism);
	}
	return stan_1;
}

var stylus_1;
var hasRequiredStylus;

function requireStylus () {
	if (hasRequiredStylus) return stylus_1;
	hasRequiredStylus = 1;

	stylus_1 = stylus;
	stylus.displayName = 'stylus';
	stylus.aliases = [];
	function stylus(Prism) {
(function (Prism) {
	    var unit = {
	      pattern: /(\b\d+)(?:%|[a-z]+)/,
	      lookbehind: true
	    }; // 123 -123 .123 -.123 12.3 -12.3
	    var number = {
	      pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
	      lookbehind: true
	    };
	    var inside = {
	      comment: {
	        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
	        lookbehind: true
	      },
	      url: {
	        pattern: /\burl\((["']?).*?\1\)/i,
	        greedy: true
	      },
	      string: {
	        pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
	        greedy: true
	      },
	      interpolation: null,
	      // See below
	      func: null,
	      // See below
	      important: /\B!(?:important|optional)\b/i,
	      keyword: {
	        pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
	        lookbehind: true
	      },
	      hexcode: /#[\da-f]{3,6}/i,
	      color: [
	        /\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i,
	        {
	          pattern:
	            /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
	          inside: {
	            unit: unit,
	            number: number,
	            function: /[\w-]+(?=\()/,
	            punctuation: /[(),]/
	          }
	        }
	      ],
	      entity: /\\[\da-f]{1,8}/i,
	      unit: unit,
	      boolean: /\b(?:false|true)\b/,
	      operator: [
	        // We want non-word chars around "-" because it is
	        // accepted in property names.
	        /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
	      ],
	      number: number,
	      punctuation: /[{}()\[\];:,]/
	    };
	    inside['interpolation'] = {
	      pattern: /\{[^\r\n}:]+\}/,
	      alias: 'variable',
	      inside: {
	        delimiter: {
	          pattern: /^\{|\}$/,
	          alias: 'punctuation'
	        },
	        rest: inside
	      }
	    };
	    inside['func'] = {
	      pattern: /[\w-]+\([^)]*\).*/,
	      inside: {
	        function: /^[^(]+/,
	        rest: inside
	      }
	    };
	    Prism.languages.stylus = {
	      'atrule-declaration': {
	        pattern: /(^[ \t]*)@.+/m,
	        lookbehind: true,
	        inside: {
	          atrule: /^@[\w-]+/,
	          rest: inside
	        }
	      },
	      'variable-declaration': {
	        pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
	        lookbehind: true,
	        inside: {
	          variable: /^\S+/,
	          rest: inside
	        }
	      },
	      statement: {
	        pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
	        lookbehind: true,
	        inside: {
	          keyword: /^\S+/,
	          rest: inside
	        }
	      },
	      // A property/value pair cannot end with a comma or a brace
	      // It cannot have indented content unless it ended with a semicolon
	      'property-declaration': {
	        pattern:
	          /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
	        lookbehind: true,
	        inside: {
	          property: {
	            pattern: /^[^\s:]+/,
	            inside: {
	              interpolation: inside.interpolation
	            }
	          },
	          rest: inside
	        }
	      },
	      // A selector can contain parentheses only as part of a pseudo-element
	      // It can span multiple lines.
	      // It must end with a comma or an accolade or have indented content.
	      selector: {
	        pattern:
	          /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
	        lookbehind: true,
	        inside: {
	          interpolation: inside.interpolation,
	          comment: inside.comment,
	          punctuation: /[{},]/
	        }
	      },
	      func: inside.func,
	      string: inside.string,
	      comment: {
	        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
	        lookbehind: true,
	        greedy: true
	      },
	      interpolation: inside.interpolation,
	      punctuation: /[{}()\[\];:.]/
	    };
	  })(Prism);
	}
	return stylus_1;
}

var swift_1;
var hasRequiredSwift;

function requireSwift () {
	if (hasRequiredSwift) return swift_1;
	hasRequiredSwift = 1;

	swift_1 = swift;
	swift.displayName = 'swift';
	swift.aliases = [];
	function swift(Prism) {
	  Prism.languages.swift = {
	    comment: {
	      // Nested comments are supported up to 2 levels
	      pattern:
	        /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
	      lookbehind: true,
	      greedy: true
	    },
	    'string-literal': [
	      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
	      {
	        pattern: RegExp(
	          /(^|[^"#])/.source +
	            '(?:' + // single-line string
	            /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/
	              .source +
	            '|' + // multi-line string
	            /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/
	              .source +
	            ')' +
	            /(?!["#])/.source
	        ),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          interpolation: {
	            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
	            lookbehind: true,
	            inside: null // see below
	          },
	          'interpolation-punctuation': {
	            pattern: /^\)|\\\($/,
	            alias: 'punctuation'
	          },
	          punctuation: /\\(?=[\r\n])/,
	          string: /[\s\S]+/
	        }
	      },
	      {
	        pattern: RegExp(
	          /(^|[^"#])(#+)/.source +
	            '(?:' + // single-line string
	            /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/
	              .source +
	            '|' + // multi-line string
	            /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source +
	            ')' +
	            '\\2'
	        ),
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          interpolation: {
	            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
	            lookbehind: true,
	            inside: null // see below
	          },
	          'interpolation-punctuation': {
	            pattern: /^\)|\\#+\($/,
	            alias: 'punctuation'
	          },
	          string: /[\s\S]+/
	        }
	      }
	    ],
	    directive: {
	      // directives with conditions
	      pattern: RegExp(
	        /#/.source +
	          '(?:' +
	          (/(?:elseif|if)\b/.source +
	            '(?:[ \t]*' + // This regex is a little complex. It's equivalent to this:
	            //   (?:![ \t]*)?(?:\b\w+\b(?:[ \t]*<round>)?|<round>)(?:[ \t]*(?:&&|\|\|))?
	            // where <round> is a general parentheses expression.
	            /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/
	              .source +
	            ')+') +
	          '|' +
	          /(?:else|endif)\b/.source +
	          ')'
	      ),
	      alias: 'property',
	      inside: {
	        'directive-name': /^#\w+/,
	        boolean: /\b(?:false|true)\b/,
	        number: /\b\d+(?:\.\d+)*\b/,
	        operator: /!|&&|\|\||[<>]=?/,
	        punctuation: /[(),]/
	      }
	    },
	    literal: {
	      pattern:
	        /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
	      alias: 'constant'
	    },
	    'other-directive': {
	      pattern: /#\w+\b/,
	      alias: 'property'
	    },
	    attribute: {
	      pattern: /@\w+/,
	      alias: 'atrule'
	    },
	    'function-definition': {
	      pattern: /(\bfunc\s+)\w+/,
	      lookbehind: true,
	      alias: 'function'
	    },
	    label: {
	      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
	      pattern:
	        /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
	      lookbehind: true,
	      alias: 'important'
	    },
	    keyword:
	      /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
	    boolean: /\b(?:false|true)\b/,
	    nil: {
	      pattern: /\bnil\b/,
	      alias: 'constant'
	    },
	    'short-argument': /\$\d+\b/,
	    omit: {
	      pattern: /\b_\b/,
	      alias: 'keyword'
	    },
	    number:
	      /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
	    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
	    'class-name': /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
	    function: /\b[a-z_]\w*(?=\s*\()/i,
	    constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
	    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
	    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
	    // This regex only supports ASCII operators.
	    operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
	    punctuation: /[{}[\]();,.:\\]/
	  };
	  Prism.languages.swift['string-literal'].forEach(function (rule) {
	    rule.inside['interpolation'].inside = Prism.languages.swift;
	  });
	}
	return swift_1;
}

var systemd_1;
var hasRequiredSystemd;

function requireSystemd () {
	if (hasRequiredSystemd) return systemd_1;
	hasRequiredSystemd = 1;

	systemd_1 = systemd;
	systemd.displayName = 'systemd';
	systemd.aliases = [];
	function systemd(Prism) {
(function (Prism) {
	    var comment = {
	      pattern: /^[;#].*/m,
	      greedy: true
	    };
	    var quotesSource = /"(?:[^\r\n"\\]|\\(?:[^\r]|\r\n?))*"(?!\S)/.source;
	    Prism.languages.systemd = {
	      comment: comment,
	      section: {
	        pattern: /^\[[^\n\r\[\]]*\](?=[ \t]*$)/m,
	        greedy: true,
	        inside: {
	          punctuation: /^\[|\]$/,
	          'section-name': {
	            pattern: /[\s\S]+/,
	            alias: 'selector'
	          }
	        }
	      },
	      key: {
	        pattern: /^[^\s=]+(?=[ \t]*=)/m,
	        greedy: true,
	        alias: 'attr-name'
	      },
	      value: {
	        // This pattern is quite complex because of two properties:
	        //  1) Quotes (strings) must be preceded by a space. Since we can't use lookbehinds, we have to "resolve"
	        //     the lookbehind. You will see this in the main loop where spaces are handled separately.
	        //  2) Line continuations.
	        //     After line continuations, empty lines and comments are ignored so we have to consume them.
	        pattern: RegExp(
	          /(=[ \t]*(?!\s))/.source + // the value either starts with quotes or not
	            '(?:' +
	            quotesSource +
	            '|(?=[^"\r\n]))' + // main loop
	            '(?:' +
	            (/[^\s\\]/.source + // handle spaces separately because of quotes
	              '|' +
	              '[ \t]+(?:(?![ \t"])|' +
	              quotesSource +
	              ')' + // line continuation
	              '|' +
	              /\\[\r\n]+(?:[#;].*[\r\n]+)*(?![#;])/.source) +
	            ')*'
	        ),
	        lookbehind: true,
	        greedy: true,
	        alias: 'attr-value',
	        inside: {
	          comment: comment,
	          quoted: {
	            pattern: RegExp(/(^|\s)/.source + quotesSource),
	            lookbehind: true,
	            greedy: true
	          },
	          punctuation: /\\$/m,
	          boolean: {
	            pattern: /^(?:false|no|off|on|true|yes)$/,
	            greedy: true
	          }
	        }
	      },
	      punctuation: /=/
	    };
	  })(Prism);
	}
	return systemd_1;
}

var t4Templating_1;
var hasRequiredT4Templating;

function requireT4Templating () {
	if (hasRequiredT4Templating) return t4Templating_1;
	hasRequiredT4Templating = 1;

	t4Templating_1 = t4Templating;
	t4Templating.displayName = 't4Templating';
	t4Templating.aliases = [];
	function t4Templating(Prism) {
(function (Prism) {
	    function createBlock(prefix, inside, contentAlias) {
	      return {
	        pattern: RegExp('<#' + prefix + '[\\s\\S]*?#>'),
	        alias: 'block',
	        inside: {
	          delimiter: {
	            pattern: RegExp('^<#' + prefix + '|#>$'),
	            alias: 'important'
	          },
	          content: {
	            pattern: /[\s\S]+/,
	            inside: inside,
	            alias: contentAlias
	          }
	        }
	      }
	    }
	    function createT4(insideLang) {
	      var grammar = Prism.languages[insideLang];
	      var className = 'language-' + insideLang;
	      return {
	        block: {
	          pattern: /<#[\s\S]+?#>/,
	          inside: {
	            directive: createBlock('@', {
	              'attr-value': {
	                pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/,
	                inside: {
	                  punctuation: /^=|^["']|["']$/
	                }
	              },
	              keyword: /\b\w+(?=\s)/,
	              'attr-name': /\b\w+/
	            }),
	            expression: createBlock('=', grammar, className),
	            'class-feature': createBlock('\\+', grammar, className),
	            standard: createBlock('', grammar, className)
	          }
	        }
	      }
	    }
	    Prism.languages['t4-templating'] = Object.defineProperty({}, 'createT4', {
	      value: createT4
	    });
	  })(Prism);
	}
	return t4Templating_1;
}

var t4Cs_1;
var hasRequiredT4Cs;

function requireT4Cs () {
	if (hasRequiredT4Cs) return t4Cs_1;
	hasRequiredT4Cs = 1;
	var refractorT4Templating = requireT4Templating();
	var refractorCsharp = requireCsharp();
	t4Cs_1 = t4Cs;
	t4Cs.displayName = 't4Cs';
	t4Cs.aliases = [];
	function t4Cs(Prism) {
	  Prism.register(refractorT4Templating);
	  Prism.register(refractorCsharp);
	  Prism.languages.t4 = Prism.languages['t4-cs'] =
	    Prism.languages['t4-templating'].createT4('csharp');
	}
	return t4Cs_1;
}

var vbnet_1;
var hasRequiredVbnet;

function requireVbnet () {
	if (hasRequiredVbnet) return vbnet_1;
	hasRequiredVbnet = 1;
	var refractorBasic = basic_1;
	vbnet_1 = vbnet;
	vbnet.displayName = 'vbnet';
	vbnet.aliases = [];
	function vbnet(Prism) {
	  Prism.register(refractorBasic);
	  Prism.languages.vbnet = Prism.languages.extend('basic', {
	    comment: [
	      {
	        pattern: /(?:!|REM\b).+/i,
	        inside: {
	          keyword: /^REM/i
	        }
	      },
	      {
	        pattern: /(^|[^\\:])'.*/,
	        lookbehind: true,
	        greedy: true
	      }
	    ],
	    string: {
	      pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
	      lookbehind: true,
	      greedy: true
	    },
	    keyword:
	      /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
	    punctuation: /[,;:(){}]/
	  });
	}
	return vbnet_1;
}

var t4Vb_1;
var hasRequiredT4Vb;

function requireT4Vb () {
	if (hasRequiredT4Vb) return t4Vb_1;
	hasRequiredT4Vb = 1;
	var refractorT4Templating = requireT4Templating();
	var refractorVbnet = requireVbnet();
	t4Vb_1 = t4Vb;
	t4Vb.displayName = 't4Vb';
	t4Vb.aliases = [];
	function t4Vb(Prism) {
	  Prism.register(refractorT4Templating);
	  Prism.register(refractorVbnet);
	  Prism.languages['t4-vb'] = Prism.languages['t4-templating'].createT4('vbnet');
	}
	return t4Vb_1;
}

var yaml_1;
var hasRequiredYaml;

function requireYaml () {
	if (hasRequiredYaml) return yaml_1;
	hasRequiredYaml = 1;

	yaml_1 = yaml;
	yaml.displayName = 'yaml';
	yaml.aliases = ['yml'];
	function yaml(Prism) {
(function (Prism) {
	    // https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property
	    // https://yaml.org/spec/1.2/spec.html#c-ns-alias-node
	    var anchorOrAlias = /[*&][^\s[\]{},]+/; // https://yaml.org/spec/1.2/spec.html#c-ns-tag-property
	    var tag =
	      /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/; // https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)
	    var properties =
	      '(?:' +
	      tag.source +
	      '(?:[ \t]+' +
	      anchorOrAlias.source +
	      ')?|' +
	      anchorOrAlias.source +
	      '(?:[ \t]+' +
	      tag.source +
	      ')?)'; // https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)
	    // This is a simplified version that doesn't support "#" and multiline keys
	    // All these long scarry character classes are simplified versions of YAML's characters
	    var plainKey =
	      /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(
	        /<PLAIN>/g,
	        function () {
	          return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/
	            .source
	        }
	      );
	    var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
	    /**
	     *
	     * @param {string} value
	     * @param {string} [flags]
	     * @returns {RegExp}
	     */
	    function createValuePattern(value, flags) {
	      flags = (flags || '').replace(/m/g, '') + 'm'; // add m flag
	      var pattern =
	        /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source
	          .replace(/<<prop>>/g, function () {
	            return properties
	          })
	          .replace(/<<value>>/g, function () {
	            return value
	          });
	      return RegExp(pattern, flags)
	    }
	    Prism.languages.yaml = {
	      scalar: {
	        pattern: RegExp(
	          /([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(
	            /<<prop>>/g,
	            function () {
	              return properties
	            }
	          )
	        ),
	        lookbehind: true,
	        alias: 'string'
	      },
	      comment: /#.*/,
	      key: {
	        pattern: RegExp(
	          /((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source
	            .replace(/<<prop>>/g, function () {
	              return properties
	            })
	            .replace(/<<key>>/g, function () {
	              return '(?:' + plainKey + '|' + string + ')'
	            })
	        ),
	        lookbehind: true,
	        greedy: true,
	        alias: 'atrule'
	      },
	      directive: {
	        pattern: /(^[ \t]*)%.+/m,
	        lookbehind: true,
	        alias: 'important'
	      },
	      datetime: {
	        pattern: createValuePattern(
	          /\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/
	            .source
	        ),
	        lookbehind: true,
	        alias: 'number'
	      },
	      boolean: {
	        pattern: createValuePattern(/false|true/.source, 'i'),
	        lookbehind: true,
	        alias: 'important'
	      },
	      null: {
	        pattern: createValuePattern(/null|~/.source, 'i'),
	        lookbehind: true,
	        alias: 'important'
	      },
	      string: {
	        pattern: createValuePattern(string),
	        lookbehind: true,
	        greedy: true
	      },
	      number: {
	        pattern: createValuePattern(
	          /[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/
	            .source,
	          'i'
	        ),
	        lookbehind: true
	      },
	      tag: tag,
	      important: anchorOrAlias,
	      punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
	    };
	    Prism.languages.yml = Prism.languages.yaml;
	  })(Prism);
	}
	return yaml_1;
}

var tap_1;
var hasRequiredTap;

function requireTap () {
	if (hasRequiredTap) return tap_1;
	hasRequiredTap = 1;
	var refractorYaml = requireYaml();
	tap_1 = tap;
	tap.displayName = 'tap';
	tap.aliases = [];
	function tap(Prism) {
	  Prism.register(refractorYaml);
	  // https://en.wikipedia.org/wiki/Test_Anything_Protocol
	  Prism.languages.tap = {
	    fail: /not ok[^#{\n\r]*/,
	    pass: /ok[^#{\n\r]*/,
	    pragma: /pragma [+-][a-z]+/,
	    bailout: /bail out!.*/i,
	    version: /TAP version \d+/i,
	    plan: /\b\d+\.\.\d+(?: +#.*)?/,
	    subtest: {
	      pattern: /# Subtest(?:: .*)?/,
	      greedy: true
	    },
	    punctuation: /[{}]/,
	    directive: /#.*/,
	    yamlish: {
	      pattern: /(^[ \t]*)---[\s\S]*?[\r\n][ \t]*\.\.\.$/m,
	      lookbehind: true,
	      inside: Prism.languages.yaml,
	      alias: 'language-yaml'
	    }
	  };
	}
	return tap_1;
}

var tcl_1;
var hasRequiredTcl;

function requireTcl () {
	if (hasRequiredTcl) return tcl_1;
	hasRequiredTcl = 1;

	tcl_1 = tcl;
	tcl.displayName = 'tcl';
	tcl.aliases = [];
	function tcl(Prism) {
	  Prism.languages.tcl = {
	    comment: {
	      pattern: /(^|[^\\])#.*/,
	      lookbehind: true
	    },
	    string: {
	      pattern: /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"/,
	      greedy: true
	    },
	    variable: [
	      {
	        pattern: /(\$)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/,
	        lookbehind: true
	      },
	      {
	        pattern: /(\$)\{[^}]+\}/,
	        lookbehind: true
	      },
	      {
	        pattern: /(^[\t ]*set[ \t]+)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/m,
	        lookbehind: true
	      }
	    ],
	    function: {
	      pattern: /(^[\t ]*proc[ \t]+)\S+/m,
	      lookbehind: true
	    },
	    builtin: [
	      {
	        pattern:
	          /(^[\t ]*)(?:break|class|continue|error|eval|exit|for|foreach|if|proc|return|switch|while)\b/m,
	        lookbehind: true
	      },
	      /\b(?:else|elseif)\b/
	    ],
	    scope: {
	      pattern: /(^[\t ]*)(?:global|upvar|variable)\b/m,
	      lookbehind: true,
	      alias: 'constant'
	    },
	    keyword: {
	      pattern:
	        /(^[\t ]*|\[)(?:Safe_Base|Tcl|after|append|apply|array|auto_(?:execok|import|load|mkindex|qualify|reset)|automkindex_old|bgerror|binary|catch|cd|chan|clock|close|concat|dde|dict|encoding|eof|exec|expr|fblocked|fconfigure|fcopy|file(?:event|name)?|flush|gets|glob|history|http|incr|info|interp|join|lappend|lassign|lindex|linsert|list|llength|load|lrange|lrepeat|lreplace|lreverse|lsearch|lset|lsort|math(?:func|op)|memory|msgcat|namespace|open|package|parray|pid|pkg_mkIndex|platform|puts|pwd|re_syntax|read|refchan|regexp|registry|regsub|rename|scan|seek|set|socket|source|split|string|subst|tcl(?:_endOfWord|_findLibrary|startOf(?:Next|Previous)Word|test|vars|wordBreak(?:After|Before))|tell|time|tm|trace|unknown|unload|unset|update|uplevel|vwait)\b/m,
	      lookbehind: true
	    },
	    operator:
	      /!=?|\*\*?|==|&&?|\|\|?|<[=<]?|>[=>]?|[-+~\/%?^]|\b(?:eq|in|ne|ni)\b/,
	    punctuation: /[{}()\[\]]/
	  };
	}
	return tcl_1;
}

var textile_1;
var hasRequiredTextile;

function requireTextile () {
	if (hasRequiredTextile) return textile_1;
	hasRequiredTextile = 1;

	textile_1 = textile;
	textile.displayName = 'textile';
	textile.aliases = [];
	function textile(Prism) {
(function (Prism) {
	    // We don't allow for pipes inside parentheses
	    // to not break table pattern |(. foo |). bar |
	    var modifierRegex = /\([^|()\n]+\)|\[[^\]\n]+\]|\{[^}\n]+\}/.source; // Opening and closing parentheses which are not a modifier
	    // This pattern is necessary to prevent exponential backtracking
	    var parenthesesRegex = /\)|\((?![^|()\n]+\))/.source;
	    /**
	     * @param {string} source
	     * @param {string} [flags]
	     */
	    function withModifier(source, flags) {
	      return RegExp(
	        source
	          .replace(/<MOD>/g, function () {
	            return '(?:' + modifierRegex + ')'
	          })
	          .replace(/<PAR>/g, function () {
	            return '(?:' + parenthesesRegex + ')'
	          }),
	        flags || ''
	      )
	    }
	    var modifierTokens = {
	      css: {
	        pattern: /\{[^{}]+\}/,
	        inside: {
	          rest: Prism.languages.css
	        }
	      },
	      'class-id': {
	        pattern: /(\()[^()]+(?=\))/,
	        lookbehind: true,
	        alias: 'attr-value'
	      },
	      lang: {
	        pattern: /(\[)[^\[\]]+(?=\])/,
	        lookbehind: true,
	        alias: 'attr-value'
	      },
	      // Anything else is punctuation (the first pattern is for row/col spans inside tables)
	      punctuation: /[\\\/]\d+|\S/
	    };
	    var textile = (Prism.languages.textile = Prism.languages.extend('markup', {
	      phrase: {
	        pattern: /(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/,
	        lookbehind: true,
	        inside: {
	          // h1. Header 1
	          'block-tag': {
	            pattern: withModifier(/^[a-z]\w*(?:<MOD>|<PAR>|[<>=])*\./.source),
	            inside: {
	              modifier: {
	                pattern: withModifier(
	                  /(^[a-z]\w*)(?:<MOD>|<PAR>|[<>=])+(?=\.)/.source
	                ),
	                lookbehind: true,
	                inside: modifierTokens
	              },
	              tag: /^[a-z]\w*/,
	              punctuation: /\.$/
	            }
	          },
	          // # List item
	          // * List item
	          list: {
	            pattern: withModifier(/^[*#]+<MOD>*\s+\S.*/.source, 'm'),
	            inside: {
	              modifier: {
	                pattern: withModifier(/(^[*#]+)<MOD>+/.source),
	                lookbehind: true,
	                inside: modifierTokens
	              },
	              punctuation: /^[*#]+/
	            }
	          },
	          // | cell | cell | cell |
	          table: {
	            // Modifiers can be applied to the row: {color:red}.|1|2|3|
	            // or the cell: |{color:red}.1|2|3|
	            pattern: withModifier(
	              /^(?:(?:<MOD>|<PAR>|[<>=^~])+\.\s*)?(?:\|(?:(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.|(?!(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.))[^|]*)+\|/
	                .source,
	              'm'
	            ),
	            inside: {
	              modifier: {
	                // Modifiers for rows after the first one are
	                // preceded by a pipe and a line feed
	                pattern: withModifier(
	                  /(^|\|(?:\r?\n|\r)?)(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+(?=\.)/
	                    .source
	                ),
	                lookbehind: true,
	                inside: modifierTokens
	              },
	              punctuation: /\||^\./
	            }
	          },
	          inline: {
	            // eslint-disable-next-line regexp/no-super-linear-backtracking
	            pattern: withModifier(
	              /(^|[^a-zA-Z\d])(\*\*|__|\?\?|[*_%@+\-^~])<MOD>*.+?\2(?![a-zA-Z\d])/
	                .source
	            ),
	            lookbehind: true,
	            inside: {
	              // Note: superscripts and subscripts are not handled specifically
	              // *bold*, **bold**
	              bold: {
	                // eslint-disable-next-line regexp/no-super-linear-backtracking
	                pattern: withModifier(/(^(\*\*?)<MOD>*).+?(?=\2)/.source),
	                lookbehind: true
	              },
	              // _italic_, __italic__
	              italic: {
	                // eslint-disable-next-line regexp/no-super-linear-backtracking
	                pattern: withModifier(/(^(__?)<MOD>*).+?(?=\2)/.source),
	                lookbehind: true
	              },
	              // ??cite??
	              cite: {
	                // eslint-disable-next-line regexp/no-super-linear-backtracking
	                pattern: withModifier(/(^\?\?<MOD>*).+?(?=\?\?)/.source),
	                lookbehind: true,
	                alias: 'string'
	              },
	              // @code@
	              code: {
	                // eslint-disable-next-line regexp/no-super-linear-backtracking
	                pattern: withModifier(/(^@<MOD>*).+?(?=@)/.source),
	                lookbehind: true,
	                alias: 'keyword'
	              },
	              // +inserted+
	              inserted: {
	                // eslint-disable-next-line regexp/no-super-linear-backtracking
	                pattern: withModifier(/(^\+<MOD>*).+?(?=\+)/.source),
	                lookbehind: true
	              },
	              // -deleted-
	              deleted: {
	                // eslint-disable-next-line regexp/no-super-linear-backtracking
	                pattern: withModifier(/(^-<MOD>*).+?(?=-)/.source),
	                lookbehind: true
	              },
	              // %span%
	              span: {
	                // eslint-disable-next-line regexp/no-super-linear-backtracking
	                pattern: withModifier(/(^%<MOD>*).+?(?=%)/.source),
	                lookbehind: true
	              },
	              modifier: {
	                pattern: withModifier(
	                  /(^\*\*|__|\?\?|[*_%@+\-^~])<MOD>+/.source
	                ),
	                lookbehind: true,
	                inside: modifierTokens
	              },
	              punctuation: /[*_%?@+\-^~]+/
	            }
	          },
	          // [alias]http://example.com
	          'link-ref': {
	            pattern: /^\[[^\]]+\]\S+$/m,
	            inside: {
	              string: {
	                pattern: /(^\[)[^\]]+(?=\])/,
	                lookbehind: true
	              },
	              url: {
	                pattern: /(^\])\S+$/,
	                lookbehind: true
	              },
	              punctuation: /[\[\]]/
	            }
	          },
	          // "text":http://example.com
	          // "text":link-ref
	          link: {
	            // eslint-disable-next-line regexp/no-super-linear-backtracking
	            pattern: withModifier(
	              /"<MOD>*[^"]+":.+?(?=[^\w/]?(?:\s|$))/.source
	            ),
	            inside: {
	              text: {
	                // eslint-disable-next-line regexp/no-super-linear-backtracking
	                pattern: withModifier(/(^"<MOD>*)[^"]+(?=")/.source),
	                lookbehind: true
	              },
	              modifier: {
	                pattern: withModifier(/(^")<MOD>+/.source),
	                lookbehind: true,
	                inside: modifierTokens
	              },
	              url: {
	                pattern: /(:).+/,
	                lookbehind: true
	              },
	              punctuation: /[":]/
	            }
	          },
	          // !image.jpg!
	          // !image.jpg(Title)!:http://example.com
	          image: {
	            pattern: withModifier(
	              /!(?:<MOD>|<PAR>|[<>=])*(?![<>=])[^!\s()]+(?:\([^)]+\))?!(?::.+?(?=[^\w/]?(?:\s|$)))?/
	                .source
	            ),
	            inside: {
	              source: {
	                pattern: withModifier(
	                  /(^!(?:<MOD>|<PAR>|[<>=])*)(?![<>=])[^!\s()]+(?:\([^)]+\))?(?=!)/
	                    .source
	                ),
	                lookbehind: true,
	                alias: 'url'
	              },
	              modifier: {
	                pattern: withModifier(/(^!)(?:<MOD>|<PAR>|[<>=])+/.source),
	                lookbehind: true,
	                inside: modifierTokens
	              },
	              url: {
	                pattern: /(:).+/,
	                lookbehind: true
	              },
	              punctuation: /[!:]/
	            }
	          },
	          // Footnote[1]
	          footnote: {
	            pattern: /\b\[\d+\]/,
	            alias: 'comment',
	            inside: {
	              punctuation: /\[|\]/
	            }
	          },
	          // CSS(Cascading Style Sheet)
	          acronym: {
	            pattern: /\b[A-Z\d]+\([^)]+\)/,
	            inside: {
	              comment: {
	                pattern: /(\()[^()]+(?=\))/,
	                lookbehind: true
	              },
	              punctuation: /[()]/
	            }
	          },
	          // Prism(C)
	          mark: {
	            pattern: /\b\((?:C|R|TM)\)/,
	            alias: 'comment',
	            inside: {
	              punctuation: /[()]/
	            }
	          }
	        }
	      }
	    }));
	    var phraseInside = textile['phrase'].inside;
	    var nestedPatterns = {
	      inline: phraseInside['inline'],
	      link: phraseInside['link'],
	      image: phraseInside['image'],
	      footnote: phraseInside['footnote'],
	      acronym: phraseInside['acronym'],
	      mark: phraseInside['mark']
	    }; // Only allow alpha-numeric HTML tags, not XML tags
	    textile.tag.pattern =
	      /<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i; // Allow some nesting
	    var phraseInlineInside = phraseInside['inline'].inside;
	    phraseInlineInside['bold'].inside = nestedPatterns;
	    phraseInlineInside['italic'].inside = nestedPatterns;
	    phraseInlineInside['inserted'].inside = nestedPatterns;
	    phraseInlineInside['deleted'].inside = nestedPatterns;
	    phraseInlineInside['span'].inside = nestedPatterns; // Allow some styles inside table cells
	    var phraseTableInside = phraseInside['table'].inside;
	    phraseTableInside['inline'] = nestedPatterns['inline'];
	    phraseTableInside['link'] = nestedPatterns['link'];
	    phraseTableInside['image'] = nestedPatterns['image'];
	    phraseTableInside['footnote'] = nestedPatterns['footnote'];
	    phraseTableInside['acronym'] = nestedPatterns['acronym'];
	    phraseTableInside['mark'] = nestedPatterns['mark'];
	  })(Prism);
	}
	return textile_1;
}

var toml_1;
var hasRequiredToml;

function requireToml () {
	if (hasRequiredToml) return toml_1;
	hasRequiredToml = 1;

	toml_1 = toml;
	toml.displayName = 'toml';
	toml.aliases = [];
	function toml(Prism) {
(function (Prism) {
	    var key = /(?:[\w-]+|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*")/.source;
	    /**
	     * @param {string} pattern
	     */
	    function insertKey(pattern) {
	      return pattern.replace(/__/g, function () {
	        return key
	      })
	    }
	    Prism.languages.toml = {
	      comment: {
	        pattern: /#.*/,
	        greedy: true
	      },
	      table: {
	        pattern: RegExp(
	          insertKey(
	            /(^[\t ]*\[\s*(?:\[\s*)?)__(?:\s*\.\s*__)*(?=\s*\])/.source
	          ),
	          'm'
	        ),
	        lookbehind: true,
	        greedy: true,
	        alias: 'class-name'
	      },
	      key: {
	        pattern: RegExp(
	          insertKey(/(^[\t ]*|[{,]\s*)__(?:\s*\.\s*__)*(?=\s*=)/.source),
	          'm'
	        ),
	        lookbehind: true,
	        greedy: true,
	        alias: 'property'
	      },
	      string: {
	        pattern:
	          /"""(?:\\[\s\S]|[^\\])*?"""|'''[\s\S]*?'''|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*"/,
	        greedy: true
	      },
	      date: [
	        {
	          // Offset Date-Time, Local Date-Time, Local Date
	          pattern:
	            /\b\d{4}-\d{2}-\d{2}(?:[T\s]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)?\b/i,
	          alias: 'number'
	        },
	        {
	          // Local Time
	          pattern: /\b\d{2}:\d{2}:\d{2}(?:\.\d+)?\b/,
	          alias: 'number'
	        }
	      ],
	      number:
	        /(?:\b0(?:x[\da-zA-Z]+(?:_[\da-zA-Z]+)*|o[0-7]+(?:_[0-7]+)*|b[10]+(?:_[10]+)*))\b|[-+]?\b\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?\b|[-+]?\b(?:inf|nan)\b/,
	      boolean: /\b(?:false|true)\b/,
	      punctuation: /[.,=[\]{}]/
	    };
	  })(Prism);
	}
	return toml_1;
}

var tremor_1;
var hasRequiredTremor;

function requireTremor () {
	if (hasRequiredTremor) return tremor_1;
	hasRequiredTremor = 1;

	tremor_1 = tremor;
	tremor.displayName = 'tremor';
	tremor.aliases = [];
	function tremor(Prism) {
(function (Prism) {
	    Prism.languages.tremor = {
	      comment: {
	        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
	        lookbehind: true
	      },
	      'interpolated-string': null,
	      // see below
	      extractor: {
	        pattern: /\b[a-z_]\w*\|(?:[^\r\n\\|]|\\(?:\r\n|[\s\S]))*\|/i,
	        greedy: true,
	        inside: {
	          regex: {
	            pattern: /(^re)\|[\s\S]+/,
	            lookbehind: true
	          },
	          function: /^\w+/,
	          value: /\|[\s\S]+/
	        }
	      },
	      identifier: {
	        pattern: /`[^`]*`/,
	        greedy: true
	      },
	      function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())\b/,
	      keyword:
	        /\b(?:args|as|by|case|config|connect|connector|const|copy|create|default|define|deploy|drop|each|emit|end|erase|event|flow|fn|for|from|group|having|insert|into|intrinsic|let|links|match|merge|mod|move|of|operator|patch|pipeline|recur|script|select|set|sliding|state|stream|to|tumbling|update|use|when|where|window|with)\b/,
	      boolean: /\b(?:false|null|true)\b/i,
	      number:
	        /\b(?:0b[01_]*|0x[0-9a-fA-F_]*|\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee][+-]?[\d_]+)?)\b/,
	      'pattern-punctuation': {
	        pattern: /%(?=[({[])/,
	        alias: 'punctuation'
	      },
	      operator:
	        /[-+*\/%~!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?>?=?|(?:absent|and|not|or|present|xor)\b/,
	      punctuation: /::|[;\[\]()\{\},.:]/
	    };
	    var interpolationPattern =
	      /#\{(?:[^"{}]|\{[^{}]*\}|"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*")*\}/.source;
	    Prism.languages.tremor['interpolated-string'] = {
	      pattern: RegExp(
	        /(^|[^\\])/.source +
	          '(?:' +
	          '"""(?:' +
	          /[^"\\#]|\\[\s\S]|"(?!"")|#(?!\{)/.source +
	          '|' +
	          interpolationPattern +
	          ')*"""' +
	          '|' +
	          '"(?:' +
	          /[^"\\\r\n#]|\\(?:\r\n|[\s\S])|#(?!\{)/.source +
	          '|' +
	          interpolationPattern +
	          ')*"' +
	          ')'
	      ),
	      lookbehind: true,
	      greedy: true,
	      inside: {
	        interpolation: {
	          pattern: RegExp(interpolationPattern),
	          inside: {
	            punctuation: /^#\{|\}$/,
	            expression: {
	              pattern: /[\s\S]+/,
	              inside: Prism.languages.tremor
	            }
	          }
	        },
	        string: /[\s\S]+/
	      }
	    };
	    Prism.languages.troy = Prism.languages['tremor'];
	    Prism.languages.trickle = Prism.languages['tremor'];
	  })(Prism);
	}
	return tremor_1;
}

var tsx_1;
var hasRequiredTsx;

function requireTsx () {
	if (hasRequiredTsx) return tsx_1;
	hasRequiredTsx = 1;
	var refractorJsx = requireJsx();
	var refractorTypescript = requireTypescript();
	tsx_1 = tsx;
	tsx.displayName = 'tsx';
	tsx.aliases = [];
	function tsx(Prism) {
	  Prism.register(refractorJsx);
	  Prism.register(refractorTypescript)
	  ;(function (Prism) {
	    var typescript = Prism.util.clone(Prism.languages.typescript);
	    Prism.languages.tsx = Prism.languages.extend('jsx', typescript); // doesn't work with TS because TS is too complex
	    delete Prism.languages.tsx['parameter'];
	    delete Prism.languages.tsx['literal-property']; // This will prevent collisions between TSX tags and TS generic types.
	    // Idea by https://github.com/karlhorky
	    // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928
	    var tag = Prism.languages.tsx.tag;
	    tag.pattern = RegExp(
	      /(^|[^\w$]|(?=<\/))/.source + '(?:' + tag.pattern.source + ')',
	      tag.pattern.flags
	    );
	    tag.lookbehind = true;
	  })(Prism);
	}
	return tsx_1;
}

var tt2_1;
var hasRequiredTt2;

function requireTt2 () {
	if (hasRequiredTt2) return tt2_1;
	hasRequiredTt2 = 1;
	var refractorMarkupTemplating = requireMarkupTemplating();
	tt2_1 = tt2;
	tt2.displayName = 'tt2';
	tt2.aliases = [];
	function tt2(Prism) {
	  Prism.register(refractorMarkupTemplating)
	  ;(function (Prism) {
	    Prism.languages.tt2 = Prism.languages.extend('clike', {
	      comment: /#.*|\[%#[\s\S]*?%\]/,
	      keyword:
	        /\b(?:BLOCK|CALL|CASE|CATCH|CLEAR|DEBUG|DEFAULT|ELSE|ELSIF|END|FILTER|FINAL|FOREACH|GET|IF|IN|INCLUDE|INSERT|LAST|MACRO|META|NEXT|PERL|PROCESS|RAWPERL|RETURN|SET|STOP|SWITCH|TAGS|THROW|TRY|UNLESS|USE|WHILE|WRAPPER)\b/,
	      punctuation: /[[\]{},()]/
	    });
	    Prism.languages.insertBefore('tt2', 'number', {
	      operator: /=[>=]?|!=?|<=?|>=?|&&|\|\|?|\b(?:and|not|or)\b/,
	      variable: {
	        pattern: /\b[a-z]\w*(?:\s*\.\s*(?:\d+|\$?[a-z]\w*))*\b/i
	      }
	    });
	    Prism.languages.insertBefore('tt2', 'keyword', {
	      delimiter: {
	        pattern: /^(?:\[%|%%)-?|-?%\]$/,
	        alias: 'punctuation'
	      }
	    });
	    Prism.languages.insertBefore('tt2', 'string', {
	      'single-quoted-string': {
	        pattern: /'[^\\']*(?:\\[\s\S][^\\']*)*'/,
	        greedy: true,
	        alias: 'string'
	      },
	      'double-quoted-string': {
	        pattern: /"[^\\"]*(?:\\[\s\S][^\\"]*)*"/,
	        greedy: true,
	        alias: 'string',
	        inside: {
	          variable: {
	            pattern: /\$(?:[a-z]\w*(?:\.(?:\d+|\$?[a-z]\w*))*)/i
	          }
	        }
	      }
	    }); // The different types of TT2 strings "replace" the C-like standard string
	    delete Prism.languages.tt2.string;
	    Prism.hooks.add('before-tokenize', function (env) {
	      var tt2Pattern = /\[%[\s\S]+?%\]/g;
	      Prism.languages['markup-templating'].buildPlaceholders(
	        env,
	        'tt2',
	        tt2Pattern
	      );
	    });
	    Prism.hooks.add('after-tokenize', function (env) {
	      Prism.languages['markup-templating'].tokenizePlaceholders(env, 'tt2');
	    });
	  })(Prism);
	}
	return tt2_1;
}

var twig_1;
var hasRequiredTwig;

function requireTwig () {
	if (hasRequiredTwig) return twig_1;
	hasRequiredTwig = 1;
	var refractorMarkupTemplating = requireMarkupTemplating();
	twig_1 = twig;
	twig.displayName = 'twig';
	twig.aliases = [];
	function twig(Prism) {
	  Prism.register(refractorMarkupTemplating);
	  Prism.languages.twig = {
	    comment: /^\{#[\s\S]*?#\}$/,
	    'tag-name': {
	      pattern: /(^\{%-?\s*)\w+/,
	      lookbehind: true,
	      alias: 'keyword'
	    },
	    delimiter: {
	      pattern: /^\{[{%]-?|-?[%}]\}$/,
	      alias: 'punctuation'
	    },
	    string: {
	      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      inside: {
	        punctuation: /^['"]|['"]$/
	      }
	    },
	    keyword: /\b(?:even|if|odd)\b/,
	    boolean: /\b(?:false|null|true)\b/,
	    number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
	    operator: [
	      {
	        pattern:
	          /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
	        lookbehind: true
	      },
	      /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
	    ],
	    punctuation: /[()\[\]{}:.,]/
	  };
	  Prism.hooks.add('before-tokenize', function (env) {
	    if (env.language !== 'twig') {
	      return
	    }
	    var pattern = /\{(?:#[\s\S]*?#|%[\s\S]*?%|\{[\s\S]*?\})\}/g;
	    Prism.languages['markup-templating'].buildPlaceholders(env, 'twig', pattern);
	  });
	  Prism.hooks.add('after-tokenize', function (env) {
	    Prism.languages['markup-templating'].tokenizePlaceholders(env, 'twig');
	  });
	}
	return twig_1;
}

var typoscript_1;
var hasRequiredTyposcript;

function requireTyposcript () {
	if (hasRequiredTyposcript) return typoscript_1;
	hasRequiredTyposcript = 1;

	typoscript_1 = typoscript;
	typoscript.displayName = 'typoscript';
	typoscript.aliases = ['tsconfig'];
	function typoscript(Prism) {
(function (Prism) {
	    var keywords =
	      /\b(?:ACT|ACTIFSUB|CARRAY|CASE|CLEARGIF|COA|COA_INT|CONSTANTS|CONTENT|CUR|EDITPANEL|EFFECT|EXT|FILE|FLUIDTEMPLATE|FORM|FRAME|FRAMESET|GIFBUILDER|GMENU|GMENU_FOLDOUT|GMENU_LAYERS|GP|HMENU|HRULER|HTML|IENV|IFSUB|IMAGE|IMGMENU|IMGMENUITEM|IMGTEXT|IMG_RESOURCE|INCLUDE_TYPOSCRIPT|JSMENU|JSMENUITEM|LLL|LOAD_REGISTER|NO|PAGE|RECORDS|RESTORE_REGISTER|TEMPLATE|TEXT|TMENU|TMENUITEM|TMENU_LAYERS|USER|USER_INT|_GIFBUILDER|global|globalString|globalVar)\b/;
	    Prism.languages.typoscript = {
	      comment: [
	        {
	          // multiline comments /* */
	          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
	          lookbehind: true
	        },
	        {
	          // double-slash comments - ignored when backslashes or colon is found in front
	          // also ignored whenever directly after an equal-sign, because it would probably be an url without protocol
	          pattern: /(^|[^\\:= \t]|(?:^|[^= \t])[ \t]+)\/\/.*/,
	          lookbehind: true,
	          greedy: true
	        },
	        {
	          // hash comments - ignored when leading quote is found for hex colors in strings
	          pattern: /(^|[^"'])#.*/,
	          lookbehind: true,
	          greedy: true
	        }
	      ],
	      function: [
	        {
	          // old include style
	          pattern:
	            /<INCLUDE_TYPOSCRIPT:\s*source\s*=\s*(?:"[^"\r\n]*"|'[^'\r\n]*')\s*>/,
	          inside: {
	            string: {
	              pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
	              inside: {
	                keyword: keywords
	              }
	            },
	            keyword: {
	              pattern: /INCLUDE_TYPOSCRIPT/
	            }
	          }
	        },
	        {
	          // new include style
	          pattern: /@import\s*(?:"[^"\r\n]*"|'[^'\r\n]*')/,
	          inside: {
	            string: /"[^"\r\n]*"|'[^'\r\n]*'/
	          }
	        }
	      ],
	      string: {
	        pattern: /^([^=]*=[< ]?)(?:(?!\]\n).)*/,
	        lookbehind: true,
	        inside: {
	          function: /\{\$.*\}/,
	          // constants include
	          keyword: keywords,
	          number: /^\d+$/,
	          punctuation: /[,|:]/
	        }
	      },
	      keyword: keywords,
	      number: {
	        // special highlighting for indexes of arrays in tags
	        pattern: /\b\d+\s*[.{=]/,
	        inside: {
	          operator: /[.{=]/
	        }
	      },
	      tag: {
	        pattern: /\.?[-\w\\]+\.?/,
	        inside: {
	          punctuation: /\./
	        }
	      },
	      punctuation: /[{}[\];(),.:|]/,
	      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/
	    };
	    Prism.languages.tsconfig = Prism.languages.typoscript;
	  })(Prism);
	}
	return typoscript_1;
}

var unrealscript_1;
var hasRequiredUnrealscript;

function requireUnrealscript () {
	if (hasRequiredUnrealscript) return unrealscript_1;
	hasRequiredUnrealscript = 1;

	unrealscript_1 = unrealscript;
	unrealscript.displayName = 'unrealscript';
	unrealscript.aliases = ['uc', 'uscript'];
	function unrealscript(Prism) {
	  Prism.languages.unrealscript = {
	    comment: /\/\/.*|\/\*[\s\S]*?\*\//,
	    string: {
	      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	      greedy: true
	    },
	    category: {
	      pattern:
	        /(\b(?:(?:autoexpand|hide|show)categories|var)\s*\()[^()]+(?=\))/,
	      lookbehind: true,
	      greedy: true,
	      alias: 'property'
	    },
	    metadata: {
	      pattern: /(\w\s*)<\s*\w+\s*=[^<>|=\r\n]+(?:\|\s*\w+\s*=[^<>|=\r\n]+)*>/,
	      lookbehind: true,
	      greedy: true,
	      inside: {
	        property: /\b\w+(?=\s*=)/,
	        operator: /=/,
	        punctuation: /[<>|]/
	      }
	    },
	    macro: {
	      pattern: /`\w+/,
	      alias: 'property'
	    },
	    'class-name': {
	      pattern:
	        /(\b(?:class|enum|extends|interface|state(?:\(\))?|struct|within)\s+)\w+/,
	      lookbehind: true
	    },
	    keyword:
	      /\b(?:abstract|actor|array|auto|autoexpandcategories|bool|break|byte|case|class|classgroup|client|coerce|collapsecategories|config|const|continue|default|defaultproperties|delegate|dependson|deprecated|do|dontcollapsecategories|editconst|editinlinenew|else|enum|event|exec|export|extends|final|float|for|forcescriptorder|foreach|function|goto|guid|hidecategories|hidedropdown|if|ignores|implements|inherits|input|int|interface|iterator|latent|local|material|name|native|nativereplication|noexport|nontransient|noteditinlinenew|notplaceable|operator|optional|out|pawn|perobjectconfig|perobjectlocalized|placeable|postoperator|preoperator|private|protected|reliable|replication|return|server|showcategories|simulated|singular|state|static|string|struct|structdefault|structdefaultproperties|switch|texture|transient|travel|unreliable|until|var|vector|while|within)\b/,
	    function: /\b[a-z_]\w*(?=\s*\()/i,
	    boolean: /\b(?:false|true)\b/,
	    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
	    // https://docs.unrealengine.com/udk/Three/UnrealScriptExpressions.html
	    operator:
	      />>|<<|--|\+\+|\*\*|[-+*/~!=<>$@]=?|&&?|\|\|?|\^\^?|[?:%]|\b(?:ClockwiseFrom|Cross|Dot)\b/,
	    punctuation: /[()[\]{};,.]/
	  };
	  Prism.languages.uc = Prism.languages.uscript = Prism.languages.unrealscript;
	}
	return unrealscript_1;
}

var uorazor_1;
var hasRequiredUorazor;

function requireUorazor () {
	if (hasRequiredUorazor) return uorazor_1;
	hasRequiredUorazor = 1;

	uorazor_1 = uorazor;
	uorazor.displayName = 'uorazor';
	uorazor.aliases = [];
	function uorazor(Prism) {
	  Prism.languages.uorazor = {
	    'comment-hash': {
	      pattern: /#.*/,
	      alias: 'comment',
	      greedy: true
	    },
	    'comment-slash': {
	      pattern: /\/\/.*/,
	      alias: 'comment',
	      greedy: true
	    },
	    string: {
	      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	      inside: {
	        punctuation: /^['"]|['"]$/
	      },
	      greedy: true
	    },
	    'source-layers': {
	      pattern:
	        /\b(?:arms|backpack|blue|bracelet|cancel|clear|cloak|criminal|earrings|enemy|facialhair|friend|friendly|gloves|gray|grey|ground|hair|head|innerlegs|innertorso|innocent|lefthand|middletorso|murderer|neck|nonfriendly|onehandedsecondary|outerlegs|outertorso|pants|red|righthand|ring|self|shirt|shoes|talisman|waist)\b/i,
	      alias: 'function'
	    },
	    'source-commands': {
	      pattern:
	        /\b(?:alliance|attack|cast|clearall|clearignore|clearjournal|clearlist|clearsysmsg|createlist|createtimer|dclick|dclicktype|dclickvar|dress|dressconfig|drop|droprelloc|emote|getlabel|guild|gumpclose|gumpresponse|hotkey|ignore|lasttarget|lift|lifttype|menu|menuresponse|msg|org|organize|organizer|overhead|pause|poplist|potion|promptresponse|pushlist|removelist|removetimer|rename|restock|say|scav|scavenger|script|setability|setlasttarget|setskill|settimer|setvar|sysmsg|target|targetloc|targetrelloc|targettype|undress|unignore|unsetvar|useobject|useonce|useskill|usetype|virtue|wait|waitforgump|waitformenu|waitforprompt|waitforstat|waitforsysmsg|waitfortarget|walk|wfsysmsg|wft|whisper|yell)\b/,
	      alias: 'function'
	    },
	    'tag-name': {
	      pattern: /(^\{%-?\s*)\w+/,
	      lookbehind: true,
	      alias: 'keyword'
	    },
	    delimiter: {
	      pattern: /^\{[{%]-?|-?[%}]\}$/,
	      alias: 'punctuation'
	    },
	    function:
	      /\b(?:atlist|close|closest|count|counter|counttype|dead|dex|diffhits|diffmana|diffstam|diffweight|find|findbuff|finddebuff|findlayer|findtype|findtypelist|followers|gumpexists|hidden|hits|hp|hue|human|humanoid|ingump|inlist|insysmessage|insysmsg|int|invul|lhandempty|list|listexists|mana|maxhits|maxhp|maxmana|maxstam|maxweight|monster|mounted|name|next|noto|paralyzed|poisoned|position|prev|previous|queued|rand|random|rhandempty|skill|stam|str|targetexists|timer|timerexists|varexist|warmode|weight)\b/,
	    keyword:
	      /\b(?:and|as|break|continue|else|elseif|endfor|endif|endwhile|for|if|loop|not|or|replay|stop|while)\b/,
	    boolean: /\b(?:false|null|true)\b/,
	    number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
	    operator: [
	      {
	        pattern:
	          /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
	        lookbehind: true
	      },
	      /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
	    ],
	    punctuation: /[()\[\]{}:.,]/
	  };
	}
	return uorazor_1;
}

var uri_1;
var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri_1;
	hasRequiredUri = 1;

	uri_1 = uri;
	uri.displayName = 'uri';
	uri.aliases = ['url'];
	function uri(Prism) {
	  // https://tools.ietf.org/html/rfc3986#appendix-A
	  Prism.languages.uri = {
	    scheme: {
	      pattern: /^[a-z][a-z0-9+.-]*:/im,
	      greedy: true,
	      inside: {
	        'scheme-delimiter': /:$/
	      }
	    },
	    fragment: {
	      pattern: /#[\w\-.~!$&'()*+,;=%:@/?]*/,
	      inside: {
	        'fragment-delimiter': /^#/
	      }
	    },
	    query: {
	      pattern: /\?[\w\-.~!$&'()*+,;=%:@/?]*/,
	      inside: {
	        'query-delimiter': {
	          pattern: /^\?/,
	          greedy: true
	        },
	        'pair-delimiter': /[&;]/,
	        pair: {
	          pattern: /^[^=][\s\S]*/,
	          inside: {
	            key: /^[^=]+/,
	            value: {
	              pattern: /(^=)[\s\S]+/,
	              lookbehind: true
	            }
	          }
	        }
	      }
	    },
	    authority: {
	      pattern: RegExp(
	        /^\/\//.source + // [ userinfo "@" ]
	          /(?:[\w\-.~!$&'()*+,;=%:]*@)?/.source + // host
	          ('(?:' + // IP-literal
	            /\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]/
	              .source +
	            '|' + // IPv4address or registered name
	            /[\w\-.~!$&'()*+,;=%]*/.source +
	            ')') + // [ ":" port ]
	          /(?::\d*)?/.source,
	        'm'
	      ),
	      inside: {
	        'authority-delimiter': /^\/\//,
	        'user-info-segment': {
	          pattern: /^[\w\-.~!$&'()*+,;=%:]*@/,
	          inside: {
	            'user-info-delimiter': /@$/,
	            'user-info': /^[\w\-.~!$&'()*+,;=%:]+/
	          }
	        },
	        'port-segment': {
	          pattern: /:\d*$/,
	          inside: {
	            'port-delimiter': /^:/,
	            port: /^\d+/
	          }
	        },
	        host: {
	          pattern: /[\s\S]+/,
	          inside: {
	            'ip-literal': {
	              pattern: /^\[[\s\S]+\]$/,
	              inside: {
	                'ip-literal-delimiter': /^\[|\]$/,
	                'ipv-future': /^v[\s\S]+/,
	                'ipv6-address': /^[\s\S]+/
	              }
	            },
	            'ipv4-address':
	              /^(?:(?:[03-9]\d?|[12]\d{0,2})\.){3}(?:[03-9]\d?|[12]\d{0,2})$/
	          }
	        }
	      }
	    },
	    path: {
	      pattern: /^[\w\-.~!$&'()*+,;=%:@/]+/m,
	      inside: {
	        'path-separator': /\//
	      }
	    }
	  };
	  Prism.languages.url = Prism.languages.uri;
	}
	return uri_1;
}

var v_1;
var hasRequiredV;

function requireV () {
	if (hasRequiredV) return v_1;
	hasRequiredV = 1;

	v_1 = v;
	v.displayName = 'v';
	v.aliases = [];
	function v(Prism) {
(function (Prism) {
	    var interpolationExpr = {
	      pattern: /[\s\S]+/,
	      inside: null
	    };
	    Prism.languages.v = Prism.languages.extend('clike', {
	      string: {
	        pattern: /r?(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	        alias: 'quoted-string',
	        greedy: true,
	        inside: {
	          interpolation: {
	            pattern:
	              /((?:^|[^\\])(?:\\{2})*)\$(?:\{[^{}]*\}|\w+(?:\.\w+(?:\([^\(\)]*\))?|\[[^\[\]]+\])*)/,
	            lookbehind: true,
	            inside: {
	              'interpolation-variable': {
	                pattern: /^\$\w[\s\S]*$/,
	                alias: 'variable'
	              },
	              'interpolation-punctuation': {
	                pattern: /^\$\{|\}$/,
	                alias: 'punctuation'
	              },
	              'interpolation-expression': interpolationExpr
	            }
	          }
	        }
	      },
	      'class-name': {
	        pattern: /(\b(?:enum|interface|struct|type)\s+)(?:C\.)?\w+/,
	        lookbehind: true
	      },
	      keyword:
	        /(?:\b(?:__global|as|asm|assert|atomic|break|chan|const|continue|defer|else|embed|enum|fn|for|go(?:to)?|if|import|in|interface|is|lock|match|module|mut|none|or|pub|return|rlock|select|shared|sizeof|static|struct|type(?:of)?|union|unsafe)|\$(?:else|for|if)|#(?:flag|include))\b/,
	      number:
	        /\b(?:0x[a-f\d]+(?:_[a-f\d]+)*|0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?)\b/i,
	      operator:
	        /~|\?|[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\.?/,
	      builtin:
	        /\b(?:any(?:_float|_int)?|bool|byte(?:ptr)?|charptr|f(?:32|64)|i(?:8|16|64|128|nt)|rune|size_t|string|u(?:16|32|64|128)|voidptr)\b/
	    });
	    interpolationExpr.inside = Prism.languages.v;
	    Prism.languages.insertBefore('v', 'string', {
	      char: {
	        pattern: /`(?:\\`|\\?[^`]{1,2})`/,
	        // using {1,2} instead of `u` flag for compatibility
	        alias: 'rune'
	      }
	    });
	    Prism.languages.insertBefore('v', 'operator', {
	      attribute: {
	        pattern:
	          /(^[\t ]*)\[(?:deprecated|direct_array_access|flag|inline|live|ref_only|typedef|unsafe_fn|windows_stdcall)\]/m,
	        lookbehind: true,
	        alias: 'annotation',
	        inside: {
	          punctuation: /[\[\]]/,
	          keyword: /\w+/
	        }
	      },
	      generic: {
	        pattern: /<\w+>(?=\s*[\)\{])/,
	        inside: {
	          punctuation: /[<>]/,
	          'class-name': /\w+/
	        }
	      }
	    });
	    Prism.languages.insertBefore('v', 'function', {
	      'generic-function': {
	        // e.g. foo<T>( ...
	        pattern: /\b\w+\s*<\w+>(?=\()/,
	        inside: {
	          function: /^\w+/,
	          generic: {
	            pattern: /<\w+>/,
	            inside: Prism.languages.v.generic.inside
	          }
	        }
	      }
	    });
	  })(Prism);
	}
	return v_1;
}

var vala_1;
var hasRequiredVala;

function requireVala () {
	if (hasRequiredVala) return vala_1;
	hasRequiredVala = 1;

	vala_1 = vala;
	vala.displayName = 'vala';
	vala.aliases = [];
	function vala(Prism) {
	  Prism.languages.vala = Prism.languages.extend('clike', {
	    // Classes copied from prism-csharp
	    'class-name': [
	      {
	        // (Foo bar, Bar baz)
	        pattern: /\b[A-Z]\w*(?:\.\w+)*\b(?=(?:\?\s+|\*?\s+\*?)\w)/,
	        inside: {
	          punctuation: /\./
	        }
	      },
	      {
	        // [Foo]
	        pattern: /(\[)[A-Z]\w*(?:\.\w+)*\b/,
	        lookbehind: true,
	        inside: {
	          punctuation: /\./
	        }
	      },
	      {
	        // class Foo : Bar
	        pattern:
	          /(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,
	        lookbehind: true,
	        inside: {
	          punctuation: /\./
	        }
	      },
	      {
	        // class Foo
	        pattern:
	          /((?:\b(?:class|enum|interface|new|struct)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,
	        lookbehind: true,
	        inside: {
	          punctuation: /\./
	        }
	      }
	    ],
	    keyword:
	      /\b(?:abstract|as|assert|async|base|bool|break|case|catch|char|class|const|construct|continue|default|delegate|delete|do|double|dynamic|else|ensures|enum|errordomain|extern|finally|float|for|foreach|get|if|in|inline|int|int16|int32|int64|int8|interface|internal|is|lock|long|namespace|new|null|out|override|owned|params|private|protected|public|ref|requires|return|set|short|signal|sizeof|size_t|ssize_t|static|string|struct|switch|this|throw|throws|try|typeof|uchar|uint|uint16|uint32|uint64|uint8|ulong|unichar|unowned|ushort|using|value|var|virtual|void|volatile|weak|while|yield)\b/i,
	    function: /\b\w+(?=\s*\()/,
	    number:
	      /(?:\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?:f|u?l?)?/i,
	    operator:
	      /\+\+|--|&&|\|\||<<=?|>>=?|=>|->|~|[+\-*\/%&^|=!<>]=?|\?\??|\.\.\./,
	    punctuation: /[{}[\];(),.:]/,
	    constant: /\b[A-Z0-9_]+\b/
	  });
	  Prism.languages.insertBefore('vala', 'string', {
	    'raw-string': {
	      pattern: /"""[\s\S]*?"""/,
	      greedy: true,
	      alias: 'string'
	    },
	    'template-string': {
	      pattern: /@"[\s\S]*?"/,
	      greedy: true,
	      inside: {
	        interpolation: {
	          pattern: /\$(?:\([^)]*\)|[a-zA-Z]\w*)/,
	          inside: {
	            delimiter: {
	              pattern: /^\$\(?|\)$/,
	              alias: 'punctuation'
	            },
	            rest: Prism.languages.vala
	          }
	        },
	        string: /[\s\S]+/
	      }
	    }
	  });
	  Prism.languages.insertBefore('vala', 'keyword', {
	    regex: {
	      pattern:
	        /\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[imsx]{0,4}(?=\s*(?:$|[\r\n,.;})\]]))/,
	      greedy: true,
	      inside: {
	        'regex-source': {
	          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
	          lookbehind: true,
	          alias: 'language-regex',
	          inside: Prism.languages.regex
	        },
	        'regex-delimiter': /^\//,
	        'regex-flags': /^[a-z]+$/
	      }
	    }
	  });
	}
	return vala_1;
}

var velocity_1;
var hasRequiredVelocity;

function requireVelocity () {
	if (hasRequiredVelocity) return velocity_1;
	hasRequiredVelocity = 1;

	velocity_1 = velocity;
	velocity.displayName = 'velocity';
	velocity.aliases = [];
	function velocity(Prism) {
(function (Prism) {
	    Prism.languages.velocity = Prism.languages.extend('markup', {});
	    var velocity = {
	      variable: {
	        pattern:
	          /(^|[^\\](?:\\\\)*)\$!?(?:[a-z][\w-]*(?:\([^)]*\))?(?:\.[a-z][\w-]*(?:\([^)]*\))?|\[[^\]]+\])*|\{[^}]+\})/i,
	        lookbehind: true,
	        inside: {} // See below
	      },
	      string: {
	        pattern: /"[^"]*"|'[^']*'/,
	        greedy: true
	      },
	      number: /\b\d+\b/,
	      boolean: /\b(?:false|true)\b/,
	      operator:
	        /[=!<>]=?|[+*/%-]|&&|\|\||\.\.|\b(?:eq|g[et]|l[et]|n(?:e|ot))\b/,
	      punctuation: /[(){}[\]:,.]/
	    };
	    velocity.variable.inside = {
	      string: velocity['string'],
	      function: {
	        pattern: /([^\w-])[a-z][\w-]*(?=\()/,
	        lookbehind: true
	      },
	      number: velocity['number'],
	      boolean: velocity['boolean'],
	      punctuation: velocity['punctuation']
	    };
	    Prism.languages.insertBefore('velocity', 'comment', {
	      unparsed: {
	        pattern: /(^|[^\\])#\[\[[\s\S]*?\]\]#/,
	        lookbehind: true,
	        greedy: true,
	        inside: {
	          punctuation: /^#\[\[|\]\]#$/
	        }
	      },
	      'velocity-comment': [
	        {
	          pattern: /(^|[^\\])#\*[\s\S]*?\*#/,
	          lookbehind: true,
	          greedy: true,
	          alias: 'comment'
	        },
	        {
	          pattern: /(^|[^\\])##.*/,
	          lookbehind: true,
	          greedy: true,
	          alias: 'comment'
	        }
	      ],
	      directive: {
	        pattern:
	          /(^|[^\\](?:\\\\)*)#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})(?:\s*\((?:[^()]|\([^()]*\))*\))?/i,
	        lookbehind: true,
	        inside: {
	          keyword: {
	            pattern: /^#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})|\bin\b/,
	            inside: {
	              punctuation: /[{}]/
	            }
	          },
	          rest: velocity
	        }
	      },
	      variable: velocity['variable']
	    });
	    Prism.languages.velocity['tag'].inside['attr-value'].inside.rest =
	      Prism.languages.velocity;
	  })(Prism);
	}
	return velocity_1;
}

var verilog_1;
var hasRequiredVerilog;

function requireVerilog () {
	if (hasRequiredVerilog) return verilog_1;
	hasRequiredVerilog = 1;

	verilog_1 = verilog;
	verilog.displayName = 'verilog';
	verilog.aliases = [];
	function verilog(Prism) {
	  Prism.languages.verilog = {
	    comment: {
	      pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
	      greedy: true
	    },
	    string: {
	      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
	      greedy: true
	    },
	    'kernel-function': {
	      // support for any kernel function (ex: $display())
	      pattern: /\B\$\w+\b/,
	      alias: 'property'
	    },
	    // support for user defined constants (ex: `define)
	    constant: /\B`\w+\b/,
	    function: /\b\w+(?=\()/,
	    // support for verilog and system verilog keywords
	    keyword:
	      /\b(?:alias|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endsequence|endspecify|endtable|endtask|enum|event|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|import|incdir|include|initial|inout|input|inside|instance|int|integer|interface|intersect|join|join_any|join_none|large|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|new|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|release|repeat|return|rnmos|rpmos|rtran|rtranif0|rtranif1|scalared|sequence|shortint|shortreal|showcancelled|signed|small|solve|specify|specparam|static|string|strong0|strong1|struct|super|supply0|supply1|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unsigned|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b/,
	    // bold highlighting for all verilog and system verilog logic blocks
	    important: /\b(?:always|always_comb|always_ff|always_latch)\b(?: *@)?/,
	    // support for time ticks, vectors, and real numbers
	    number:
	      /\B##?\d+|(?:\b\d+)?'[odbh] ?[\da-fzx_?]+|\b(?:\d*[._])?\d+(?:e[-+]?\d+)?/i,
	    operator: /[-+{}^~%*\/?=!<>&|]+/,
	    punctuation: /[[\];(),.:]/
	  };
	}
	return verilog_1;
}

var vhdl_1;
var hasRequiredVhdl;

function requireVhdl () {
	if (hasRequiredVhdl) return vhdl_1;
	hasRequiredVhdl = 1;

	vhdl_1 = vhdl;
	vhdl.displayName = 'vhdl';
	vhdl.aliases = [];
	function vhdl(Prism) {
	  Prism.languages.vhdl = {
	    comment: /--.+/,
	    // support for all logic vectors
	    'vhdl-vectors': {
	      pattern: /\b[oxb]"[\da-f_]+"|"[01uxzwlh-]+"/i,
	      alias: 'number'
	    },
	    // support for operator overloading included
	    'quoted-function': {
	      pattern: /"\S+?"(?=\()/,
	      alias: 'function'
	    },
	    string: /"(?:[^\\"\r\n]|\\(?:\r\n|[\s\S]))*"/,
	    constant: /\b(?:library|use)\b/i,
	    // support for predefined attributes included
	    keyword:
	      /\b(?:'active|'ascending|'base|'delayed|'driving|'driving_value|'event|'high|'image|'instance_name|'last_active|'last_event|'last_value|'left|'leftof|'length|'low|'path_name|'pos|'pred|'quiet|'range|'reverse_range|'right|'rightof|'simple_name|'stable|'succ|'transaction|'val|'value|access|after|alias|all|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|new|next|null|of|on|open|others|out|package|port|postponed|procedure|process|pure|range|record|register|reject|report|return|select|severity|shared|signal|subtype|then|to|transport|type|unaffected|units|until|use|variable|wait|when|while|with)\b/i,
	    boolean: /\b(?:false|true)\b/i,
	    function: /\w+(?=\()/,
	    // decimal, based, physical, and exponential numbers supported
	    number: /'[01uxzwlh-]'|\b(?:\d+#[\da-f_.]+#|\d[\d_.]*)(?:e[-+]?\d+)?/i,
	    operator:
	      /[<>]=?|:=|[-+*/&=]|\b(?:abs|and|mod|nand|nor|not|or|rem|rol|ror|sla|sll|sra|srl|xnor|xor)\b/i,
	    punctuation: /[{}[\];(),.:]/
	  };
	}
	return vhdl_1;
}

var vim_1;
var hasRequiredVim;

function requireVim () {
	if (hasRequiredVim) return vim_1;
	hasRequiredVim = 1;

	vim_1 = vim;
	vim.displayName = 'vim';
	vim.aliases = [];
	function vim(Prism) {
	  Prism.languages.vim = {
	    string: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
	    comment: /".*/,
	    function: /\b\w+(?=\()/,
	    keyword:
	      /\b(?:N|Next|P|Print|X|XMLent|XMLns|ab|abbreviate|abc|abclear|abo|aboveleft|al|all|ar|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|args|argu|argument|as|ascii|b|bN|bNext|ba|bad|badd|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bo|botright|bp|bprevious|br|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|brewind|bro|browse|bufdo|buffer|buffers|bun|bunload|bw|bwipeout|c|cN|cNext|cNfcNfile|ca|cabbrev|cabc|cabclear|cad|caddb|caddbuffer|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cg|cgetb|cgetbuffer|cgete|cgetexpr|cgetfile|change|changes|chd|chdir|che|checkpath|checkt|checktime|cl|cla|clast|clist|clo|close|cmapc|cmapclear|cn|cnew|cnewer|cnext|cnf|cnfile|cnorea|cnoreabbrev|co|col|colder|colo|colorscheme|comc|comclear|comp|compiler|con|conf|confirm|continue|cope|copen|copy|cp|cpf|cpfile|cprevious|cq|cquit|cr|crewind|cu|cuna|cunabbrev|cunmap|cw|cwindow|d|debugg|debuggreedy|delc|delcommand|delete|delf|delfunction|delm|delmarks|di|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|e|earlier|echoe|echoerr|echom|echomsg|echon|edit|el|else|elsei|elseif|em|emenu|en|endf|endfo|endfor|endfun|endfunction|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fin|fina|finally|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|foldd|folddoc|folddoclosed|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|h|ha|hardcopy|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iu|iuna|iunabbrev|iunmap|j|join|ju|jumps|k|kee|keepalt|keepj|keepjumps|keepmarks|l|lN|lNext|lNf|lNfile|la|lad|laddb|laddbuffer|laddexpr|laddf|laddfile|lan|language|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|left|lefta|leftabove|let|lex|lexpr|lf|lfile|lfir|lfirst|lg|lgetb|lgetbuffer|lgete|lgetexpr|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|list|ll|lla|llast|lli|llist|lm|lmak|lmake|lmap|lmapc|lmapclear|ln|lne|lnew|lnewer|lnext|lnf|lnfile|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lp|lpf|lpfile|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|m|ma|mak|make|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkv|mkvie|mkview|mkvimrc|mod|mode|move|mz|mzf|mzfile|mzscheme|n|nbkey|new|next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|o|omapc|omapclear|on|only|open|opt|options|ou|ounmap|p|pc|pclose|pe|ped|pedit|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|print|prof|profd|profdel|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|ptN|ptNext|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|py|pyf|pyfile|python|q|qa|qall|quit|quita|quitall|r|read|rec|recover|red|redi|redir|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|ru|rub|ruby|rubyd|rubydo|rubyf|rubyfile|runtime|rv|rviminfo|sN|sNext|sa|sal|sall|san|sandbox|sargument|sav|saveas|sb|sbN|sbNext|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbp|sbprevious|sbr|sbrewind|sbuffer|scrip|scripte|scriptencoding|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sl|sla|slast|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|so|sor|sort|source|sp|spe|spelld|spelldump|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|split|spr|sprevious|sre|srewind|st|sta|stag|star|startg|startgreplace|startinsert|startr|startreplace|stj|stjump|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tN|tNext|ta|tab|tabN|tabNext|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabn|tabnew|tabnext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|u|una|unabbreviate|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|ve|verb|verbose|version|vert|vertical|vi|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|w|wN|wNext|wa|wall|wh|while|win|winc|wincmd|windo|winp|winpos|winsize|wn|wnext|wp|wprevious|wq|wqa|wqall|write|ws|wsverb|wv|wviminfo|x|xa|xall|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
	    builtin:
	      /\b(?:acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autocmd|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|t_AB|t_AF|t_AL|t_CS|t_CV|t_Ce|t_Co|t_Cs|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_IE|t_IS|t_K1|t_K3|t_K4|t_K5|t_K6|t_K7|t_K8|t_K9|t_KA|t_KB|t_KC|t_KD|t_KE|t_KF|t_KG|t_KH|t_KI|t_KJ|t_KK|t_KL|t_RI|t_RV|t_SI|t_Sb|t_Sf|t_WP|t_WS|t_ZH|t_ZR|t_al|t_bc|t_cd|t_ce|t_cl|t_cm|t_cs|t_da|t_db|t_dl|t_fs|t_k1|t_k2|t_k3|t_k4|t_k5|t_k6|t_k7|t_k8|t_k9|t_kB|t_kD|t_kI|t_kN|t_kP|t_kb|t_kd|t_ke|t_kh|t_kl|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_se|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_xs|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww)\b/,
	    number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
	    operator:
	      /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
	    punctuation: /[{}[\](),;:]/
	  };
	}
	return vim_1;
}

var visualBasic_1;
var hasRequiredVisualBasic;

function requireVisualBasic () {
	if (hasRequiredVisualBasic) return visualBasic_1;
	hasRequiredVisualBasic = 1;

	visualBasic_1 = visualBasic;
	visualBasic.displayName = 'visualBasic';
	visualBasic.aliases = [];
	function visualBasic(Prism) {
	  Prism.languages['visual-basic'] = {
	    comment: {
	      pattern: /(?:['‘’]|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,
	      inside: {
	        keyword: /^REM/i
	      }
	    },
	    directive: {
	      pattern:
	        /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:\b_[ \t]*(?:\r\n?|\n)|.)+/i,
	      alias: 'property',
	      greedy: true
	    },
	    string: {
	      pattern: /\$?["“”](?:["“”]{2}|[^"“”])*["“”]C?/i,
	      greedy: true
	    },
	    date: {
	      pattern:
	        /#[ \t]*(?:\d+([/-])\d+\1\d+(?:[ \t]+(?:\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?))?|\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?)[ \t]*#/i,
	      alias: 'number'
	    },
	    number:
	      /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:[FRD]|U?[ILS])?/i,
	    boolean: /\b(?:False|Nothing|True)\b/i,
	    keyword:
	      /\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Until|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Xor)\b/i,
	    operator: /[+\-*/\\^<=>&#@$%!]|\b_(?=[ \t]*[\r\n])/,
	    punctuation: /[{}().,:?]/
	  };
	  Prism.languages.vb = Prism.languages['visual-basic'];
	  Prism.languages.vba = Prism.languages['visual-basic'];
	}
	return visualBasic_1;
}

var warpscript_1;
var hasRequiredWarpscript;

function requireWarpscript () {
	if (hasRequiredWarpscript) return warpscript_1;
	hasRequiredWarpscript = 1;

	warpscript_1 = warpscript;
	warpscript.displayName = 'warpscript';
	warpscript.aliases = [];
	function warpscript(Prism) {
	  Prism.languages.warpscript = {
	    comment: /#.*|\/\/.*|\/\*[\s\S]*?\*\//,
	    string: {
	      pattern:
	        /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'|<'(?:[^\\']|'(?!>)|\\.)*'>/,
	      greedy: true
	    },
	    variable: /\$\S+/,
	    macro: {
	      pattern: /@\S+/,
	      alias: 'property'
	    },
	    // WarpScript doesn't have any keywords, these are all functions under the control category
	    // https://www.warp10.io/tags/control
	    keyword:
	      /\b(?:BREAK|CHECKMACRO|CONTINUE|CUDF|DEFINED|DEFINEDMACRO|EVAL|FAIL|FOR|FOREACH|FORSTEP|IFT|IFTE|MSGFAIL|NRETURN|RETHROW|RETURN|SWITCH|TRY|UDF|UNTIL|WHILE)\b/,
	    number:
	      /[+-]?\b(?:NaN|Infinity|\d+(?:\.\d*)?(?:[Ee][+-]?\d+)?|0x[\da-fA-F]+|0b[01]+)\b/,
	    boolean: /\b(?:F|T|false|true)\b/,
	    punctuation: /<%|%>|[{}[\]()]/,
	    // Some operators from the "operators" category
	    // https://www.warp10.io/tags/operators
	    operator:
	      /==|&&?|\|\|?|\*\*?|>>>?|<<|[<>!~]=?|[-/%^]|\+!?|\b(?:AND|NOT|OR)\b/
	  };
	}
	return warpscript_1;
}

var wasm_1;
var hasRequiredWasm;

function requireWasm () {
	if (hasRequiredWasm) return wasm_1;
	hasRequiredWasm = 1;

	wasm_1 = wasm;
	wasm.displayName = 'wasm';
	wasm.aliases = [];
	function wasm(Prism) {
	  Prism.languages.wasm = {
	    comment: [
	      /\(;[\s\S]*?;\)/,
	      {
	        pattern: /;;.*/,
	        greedy: true
	      }
	    ],
	    string: {
	      pattern: /"(?:\\[\s\S]|[^"\\])*"/,
	      greedy: true
	    },
	    keyword: [
	      {
	        pattern: /\b(?:align|offset)=/,
	        inside: {
	          operator: /=/
	        }
	      },
	      {
	        pattern:
	          /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
	        inside: {
	          punctuation: /\./
	        }
	      },
	      /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/
	    ],
	    variable: /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
	    number:
	      /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
	    punctuation: /[()]/
	  };
	}
	return wasm_1;
}

var webIdl_1;
var hasRequiredWebIdl;

function requireWebIdl () {
	if (hasRequiredWebIdl) return webIdl_1;
	hasRequiredWebIdl = 1;

	webIdl_1 = webIdl;
	webIdl.displayName = 'webIdl';
	webIdl.aliases = [];
	function webIdl(Prism) {
(function (Prism) {
	    var id = /(?:\B-|\b_|\b)[A-Za-z][\w-]*(?![\w-])/.source;
	    var type =
	      '(?:' +
	      /\b(?:unsigned\s+)?long\s+long(?![\w-])/.source +
	      '|' +
	      /\b(?:unrestricted|unsigned)\s+[a-z]+(?![\w-])/.source +
	      '|' +
	      /(?!(?:unrestricted|unsigned)\b)/.source +
	      id +
	      /(?:\s*<(?:[^<>]|<[^<>]*>)*>)?/.source +
	      ')' +
	      /(?:\s*\?)?/.source;
	    var typeInside = {};
	    Prism.languages['web-idl'] = {
	      comment: {
	        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
	        greedy: true
	      },
	      string: {
	        pattern: /"[^"]*"/,
	        greedy: true
	      },
	      namespace: {
	        pattern: RegExp(/(\bnamespace\s+)/.source + id),
	        lookbehind: true
	      },
	      'class-name': [
	        {
	          pattern:
	            /(^|[^\w-])(?:iterable|maplike|setlike)\s*<(?:[^<>]|<[^<>]*>)*>/,
	          lookbehind: true,
	          inside: typeInside
	        },
	        {
	          pattern: RegExp(
	            /(\b(?:attribute|const|deleter|getter|optional|setter)\s+)/.source +
	              type
	          ),
	          lookbehind: true,
	          inside: typeInside
	        },
	        {
	          // callback return type
	          pattern: RegExp(
	            '(' + /\bcallback\s+/.source + id + /\s*=\s*/.source + ')' + type
	          ),
	          lookbehind: true,
	          inside: typeInside
	        },
	        {
	          // typedef
	          pattern: RegExp(/(\btypedef\b\s*)/.source + type),
	          lookbehind: true,
	          inside: typeInside
	        },
	        {
	          pattern: RegExp(
	            /(\b(?:callback|dictionary|enum|interface(?:\s+mixin)?)\s+)(?!(?:interface|mixin)\b)/
	              .source + id
	          ),
	          lookbehind: true
	        },
	        {
	          // inheritance
	          pattern: RegExp(/(:\s*)/.source + id),
	          lookbehind: true
	        }, // includes and implements
	        RegExp(id + /(?=\s+(?:implements|includes)\b)/.source),
	        {
	          pattern: RegExp(/(\b(?:implements|includes)\s+)/.source + id),
	          lookbehind: true
	        },
	        {
	          // function return type, parameter types, and dictionary members
	          pattern: RegExp(
	            type +
	              '(?=' +
	              /\s*(?:\.{3}\s*)?/.source +
	              id +
	              /\s*[(),;=]/.source +
	              ')'
	          ),
	          inside: typeInside
	        }
	      ],
	      builtin:
	        /\b(?:ArrayBuffer|BigInt64Array|BigUint64Array|ByteString|DOMString|DataView|Float32Array|Float64Array|FrozenArray|Int16Array|Int32Array|Int8Array|ObservableArray|Promise|USVString|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray)\b/,
	      keyword: [
	        /\b(?:async|attribute|callback|const|constructor|deleter|dictionary|enum|getter|implements|includes|inherit|interface|mixin|namespace|null|optional|or|partial|readonly|required|setter|static|stringifier|typedef|unrestricted)\b/, // type keywords
	        /\b(?:any|bigint|boolean|byte|double|float|iterable|long|maplike|object|octet|record|sequence|setlike|short|symbol|undefined|unsigned|void)\b/
	      ],
	      boolean: /\b(?:false|true)\b/,
	      number: {
	        pattern:
	          /(^|[^\w-])-?(?:0x[0-9a-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|NaN|Infinity)(?![\w-])/i,
	        lookbehind: true
	      },
	      operator: /\.{3}|[=:?<>-]/,
	      punctuation: /[(){}[\].,;]/
	    };
	    for (var key in Prism.languages['web-idl']) {
	      if (key !== 'class-name') {
	        typeInside[key] = Prism.languages['web-idl'][key];
	      }
	    }
	    Prism.languages['webidl'] = Prism.languages['web-idl'];
	  })(Prism);
	}
	return webIdl_1;
}

var wiki_1;
var hasRequiredWiki;

function requireWiki () {
	if (hasRequiredWiki) return wiki_1;
	hasRequiredWiki = 1;

	wiki_1 = wiki;
	wiki.displayName = 'wiki';
	wiki.aliases = [];
	function wiki(Prism) {
	  Prism.languages.wiki = Prism.languages.extend('markup', {
	    'block-comment': {
	      pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
	      lookbehind: true,
	      alias: 'comment'
	    },
	    heading: {
	      pattern: /^(=+)[^=\r\n].*?\1/m,
	      inside: {
	        punctuation: /^=+|=+$/,
	        important: /.+/
	      }
	    },
	    emphasis: {
	      // TODO Multi-line
	      pattern: /('{2,5}).+?\1/,
	      inside: {
	        'bold-italic': {
	          pattern: /(''''').+?(?=\1)/,
	          lookbehind: true,
	          alias: ['bold', 'italic']
	        },
	        bold: {
	          pattern: /(''')[^'](?:.*?[^'])?(?=\1)/,
	          lookbehind: true
	        },
	        italic: {
	          pattern: /('')[^'](?:.*?[^'])?(?=\1)/,
	          lookbehind: true
	        },
	        punctuation: /^''+|''+$/
	      }
	    },
	    hr: {
	      pattern: /^-{4,}/m,
	      alias: 'punctuation'
	    },
	    url: [
	      /ISBN +(?:97[89][ -]?)?(?:\d[ -]?){9}[\dx]\b|(?:PMID|RFC) +\d+/i,
	      /\[\[.+?\]\]|\[.+?\]/
	    ],
	    variable: [
	      /__[A-Z]+__/, // FIXME Nested structures should be handled
	      // {{formatnum:{{#expr:{{{3}}}}}}}
	      /\{{3}.+?\}{3}/,
	      /\{\{.+?\}\}/
	    ],
	    symbol: [/^#redirect/im, /~{3,5}/],
	    // Handle table attrs:
	    // {|
	    // ! style="text-align:left;"| Item
	    // |}
	    'table-tag': {
	      pattern: /((?:^|[|!])[|!])[^|\r\n]+\|(?!\|)/m,
	      lookbehind: true,
	      inside: {
	        'table-bar': {
	          pattern: /\|$/,
	          alias: 'punctuation'
	        },
	        rest: Prism.languages.markup['tag'].inside
	      }
	    },
	    punctuation: /^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m
	  });
	  Prism.languages.insertBefore('wiki', 'tag', {
	    // Prevent highlighting inside <nowiki>, <source> and <pre> tags
	    nowiki: {
	      pattern: /<(nowiki|pre|source)\b[^>]*>[\s\S]*?<\/\1>/i,
	      inside: {
	        tag: {
	          pattern: /<(?:nowiki|pre|source)\b[^>]*>|<\/(?:nowiki|pre|source)>/i,
	          inside: Prism.languages.markup['tag'].inside
	        }
	      }
	    }
	  });
	}
	return wiki_1;
}

var wolfram_1;
var hasRequiredWolfram;

function requireWolfram () {
	if (hasRequiredWolfram) return wolfram_1;
	hasRequiredWolfram = 1;

	wolfram_1 = wolfram;
	wolfram.displayName = 'wolfram';
	wolfram.aliases = ['mathematica', 'wl', 'nb'];
	function wolfram(Prism) {
	  Prism.languages.wolfram = {
	    // Allow one level of nesting - note: regex taken from applescipt
	    comment: /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
	    string: {
	      pattern: /"(?:\\.|[^"\\\r\n])*"/,
	      greedy: true
	    },
	    keyword:
	      /\b(?:Abs|AbsArg|Accuracy|Block|Do|For|Function|If|Manipulate|Module|Nest|NestList|None|Return|Switch|Table|Which|While)\b/,
	    context: {
	      pattern: /\b\w+`+\w*/,
	      alias: 'class-name'
	    },
	    blank: {
	      pattern: /\b\w+_\b/,
	      alias: 'regex'
	    },
	    'global-variable': {
	      pattern: /\$\w+/,
	      alias: 'variable'
	    },
	    boolean: /\b(?:False|True)\b/,
	    number:
	      /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
	    operator:
	      /\/\.|;|=\.|\^=|\^:=|:=|<<|>>|<\||\|>|:>|\|->|->|<-|@@@|@@|@|\/@|=!=|===|==|=|\+|-|\^|\[\/-+%=\]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
	    punctuation: /[{}[\];(),.:]/
	  };
	  Prism.languages.mathematica = Prism.languages.wolfram;
	  Prism.languages.wl = Prism.languages.wolfram;
	  Prism.languages.nb = Prism.languages.wolfram;
	}
	return wolfram_1;
}

var wren_1;
var hasRequiredWren;

function requireWren () {
	if (hasRequiredWren) return wren_1;
	hasRequiredWren = 1;

	wren_1 = wren;
	wren.displayName = 'wren';
	wren.aliases = [];
	function wren(Prism) {
	  // https://wren.io/
	  Prism.languages.wren = {
	    // Multiline comments in Wren can have nested multiline comments
	    // Comments: // and /* */
	    comment: [
	      {
	        // support 3 levels of nesting
	        // regex: \/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\/
	        pattern:
	          /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*))*\*\/)*\*\/)*\*\//,
	        greedy: true
	      },
	      {
	        pattern: /(^|[^\\:])\/\/.*/,
	        lookbehind: true,
	        greedy: true
	      }
	    ],
	    // Triple quoted strings are multiline but cannot have interpolation (raw strings)
	    // Based on prism-python.js
	    'triple-quoted-string': {
	      pattern: /"""[\s\S]*?"""/,
	      greedy: true,
	      alias: 'string'
	    },
	    // see below
	    'string-literal': null,
	    // #!/usr/bin/env wren on the first line
	    hashbang: {
	      pattern: /^#!\/.+/,
	      greedy: true,
	      alias: 'comment'
	    },
	    // Attributes are special keywords to add meta data to classes
	    attribute: {
	      // #! attributes are stored in class properties
	      // #!myvar = true
	      // #attributes are not stored and dismissed at compilation
	      pattern: /#!?[ \t\u3000]*\w+/,
	      alias: 'keyword'
	    },
	    'class-name': [
	      {
	        // class definition
	        // class Meta {}
	        pattern: /(\bclass\s+)\w+/,
	        lookbehind: true
	      }, // A class must always start with an uppercase.
	      // File.read
	      /\b[A-Z][a-z\d_]*\b/
	    ],
	    // A constant can be a variable, class, property or method. Just named in all uppercase letters
	    constant: /\b[A-Z][A-Z\d_]*\b/,
	    null: {
	      pattern: /\bnull\b/,
	      alias: 'keyword'
	    },
	    keyword:
	      /\b(?:as|break|class|construct|continue|else|for|foreign|if|import|in|is|return|static|super|this|var|while)\b/,
	    boolean: /\b(?:false|true)\b/,
	    number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
	    // Functions can be Class.method()
	    function: /\b[a-z_]\w*(?=\s*[({])/i,
	    operator: /<<|>>|[=!<>]=?|&&|\|\||[-+*/%~^&|?:]|\.{2,3}/,
	    punctuation: /[\[\](){}.,;]/
	  };
	  Prism.languages.wren['string-literal'] = {
	    // A single quote string is multiline and can have interpolation (similar to JS backticks ``)
	    pattern:
	      /(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
	    lookbehind: true,
	    greedy: true,
	    inside: {
	      interpolation: {
	        // "%(interpolation)"
	        pattern:
	          /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
	        lookbehind: true,
	        inside: {
	          expression: {
	            pattern: /^(%\()[\s\S]+(?=\)$)/,
	            lookbehind: true,
	            inside: Prism.languages.wren
	          },
	          'interpolation-punctuation': {
	            pattern: /^%\(|\)$/,
	            alias: 'punctuation'
	          }
	        }
	      },
	      string: /[\s\S]+/
	    }
	  };
	}
	return wren_1;
}

var xeora_1;
var hasRequiredXeora;

function requireXeora () {
	if (hasRequiredXeora) return xeora_1;
	hasRequiredXeora = 1;

	xeora_1 = xeora;
	xeora.displayName = 'xeora';
	xeora.aliases = ['xeoracube'];
	function xeora(Prism) {
(function (Prism) {
	    Prism.languages.xeora = Prism.languages.extend('markup', {
	      constant: {
	        pattern: /\$(?:DomainContents|PageRenderDuration)\$/,
	        inside: {
	          punctuation: {
	            pattern: /\$/
	          }
	        }
	      },
	      variable: {
	        pattern: /\$@?(?:#+|[-+*~=^])?[\w.]+\$/,
	        inside: {
	          punctuation: {
	            pattern: /[$.]/
	          },
	          operator: {
	            pattern: /#+|[-+*~=^@]/
	          }
	        }
	      },
	      'function-inline': {
	        pattern:
	          /\$F:[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\$/,
	        inside: {
	          variable: {
	            pattern: /(?:[,|])@?(?:#+|[-+*~=^])?[\w.]+/,
	            inside: {
	              punctuation: {
	                pattern: /[,.|]/
	              },
	              operator: {
	                pattern: /#+|[-+*~=^@]/
	              }
	            }
	          },
	          punctuation: {
	            pattern: /\$\w:|[$:?.,|]/
	          }
	        },
	        alias: 'function'
	      },
	      'function-block': {
	        pattern:
	          /\$XF:\{[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\}:XF\$/,
	        inside: {
	          punctuation: {
	            pattern: /[$:{}?.,|]/
	          }
	        },
	        alias: 'function'
	      },
	      'directive-inline': {
	        pattern: /\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\/\w.]+\$/,
	        inside: {
	          punctuation: {
	            pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
	            inside: {
	              tag: {
	                pattern: /#\d/
	              }
	            }
	          }
	        },
	        alias: 'function'
	      },
	      'directive-block-open': {
	        pattern:
	          /\$\w+:\{|\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\w.]+:\{(?:![A-Z]+)?/,
	        inside: {
	          punctuation: {
	            pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
	            inside: {
	              tag: {
	                pattern: /#\d/
	              }
	            }
	          },
	          attribute: {
	            pattern: /![A-Z]+$/,
	            inside: {
	              punctuation: {
	                pattern: /!/
	              }
	            },
	            alias: 'keyword'
	          }
	        },
	        alias: 'function'
	      },
	      'directive-block-separator': {
	        pattern: /\}:[-\w.]+:\{/,
	        inside: {
	          punctuation: {
	            pattern: /[:{}]/
	          }
	        },
	        alias: 'function'
	      },
	      'directive-block-close': {
	        pattern: /\}:[-\w.]+\$/,
	        inside: {
	          punctuation: {
	            pattern: /[:{}$]/
	          }
	        },
	        alias: 'function'
	      }
	    });
	    Prism.languages.insertBefore(
	      'inside',
	      'punctuation',
	      {
	        variable: Prism.languages.xeora['function-inline'].inside['variable']
	      },
	      Prism.languages.xeora['function-block']
	    );
	    Prism.languages.xeoracube = Prism.languages.xeora;
	  })(Prism);
	}
	return xeora_1;
}

var xmlDoc_1;
var hasRequiredXmlDoc;

function requireXmlDoc () {
	if (hasRequiredXmlDoc) return xmlDoc_1;
	hasRequiredXmlDoc = 1;

	xmlDoc_1 = xmlDoc;
	xmlDoc.displayName = 'xmlDoc';
	xmlDoc.aliases = [];
	function xmlDoc(Prism) {
(function (Prism) {
	    /**
	     * If the given language is present, it will insert the given doc comment grammar token into it.
	     *
	     * @param {string} lang
	     * @param {any} docComment
	     */
	    function insertDocComment(lang, docComment) {
	      if (Prism.languages[lang]) {
	        Prism.languages.insertBefore(lang, 'comment', {
	          'doc-comment': docComment
	        });
	      }
	    }
	    var tag = Prism.languages.markup.tag;
	    var slashDocComment = {
	      pattern: /\/\/\/.*/,
	      greedy: true,
	      alias: 'comment',
	      inside: {
	        tag: tag
	      }
	    };
	    var tickDocComment = {
	      pattern: /'''.*/,
	      greedy: true,
	      alias: 'comment',
	      inside: {
	        tag: tag
	      }
	    };
	    insertDocComment('csharp', slashDocComment);
	    insertDocComment('fsharp', slashDocComment);
	    insertDocComment('vbnet', tickDocComment);
	  })(Prism);
	}
	return xmlDoc_1;
}

var xojo_1;
var hasRequiredXojo;

function requireXojo () {
	if (hasRequiredXojo) return xojo_1;
	hasRequiredXojo = 1;

	xojo_1 = xojo;
	xojo.displayName = 'xojo';
	xojo.aliases = [];
	function xojo(Prism) {
	  Prism.languages.xojo = {
	    comment: {
	      pattern: /(?:'|\/\/|Rem\b).+/i,
	      greedy: true
	    },
	    string: {
	      pattern: /"(?:""|[^"])*"/,
	      greedy: true
	    },
	    number: [/(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i, /&[bchou][a-z\d]+/i],
	    directive: {
	      pattern: /#(?:Else|ElseIf|Endif|If|Pragma)\b/i,
	      alias: 'property'
	    },
	    keyword:
	      /\b(?:AddHandler|App|Array|As(?:signs)?|Auto|Boolean|Break|By(?:Ref|Val)|Byte|Call|Case|Catch|CFStringRef|CGFloat|Class|Color|Const|Continue|CString|Currency|CurrentMethodName|Declare|Delegate|Dim|Do(?:uble|wnTo)?|Each|Else(?:If)?|End|Enumeration|Event|Exception|Exit|Extends|False|Finally|For|Function|Get|GetTypeInfo|Global|GOTO|If|Implements|In|Inherits|Int(?:8|16|32|64|eger|erface)?|Lib|Loop|Me|Module|Next|Nil|Object|Optional|OSType|ParamArray|Private|Property|Protected|PString|Ptr|Raise(?:Event)?|ReDim|RemoveHandler|Return|Select(?:or)?|Self|Set|Shared|Short|Single|Soft|Static|Step|String|Sub|Super|Text|Then|To|True|Try|Ubound|UInt(?:8|16|32|64|eger)?|Until|Using|Var(?:iant)?|Wend|While|WindowPtr|WString)\b/i,
	    operator:
	      /<[=>]?|>=?|[+\-*\/\\^=]|\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|WeakAddressOf|Xor)\b/i,
	    punctuation: /[.,;:()]/
	  };
	}
	return xojo_1;
}

var xquery_1;
var hasRequiredXquery;

function requireXquery () {
	if (hasRequiredXquery) return xquery_1;
	hasRequiredXquery = 1;

	xquery_1 = xquery;
	xquery.displayName = 'xquery';
	xquery.aliases = [];
	function xquery(Prism) {
(function (Prism) {
	    Prism.languages.xquery = Prism.languages.extend('markup', {
	      'xquery-comment': {
	        pattern: /\(:[\s\S]*?:\)/,
	        greedy: true,
	        alias: 'comment'
	      },
	      string: {
	        pattern: /(["'])(?:\1\1|(?!\1)[\s\S])*\1/,
	        greedy: true
	      },
	      extension: {
	        pattern: /\(#.+?#\)/,
	        alias: 'symbol'
	      },
	      variable: /\$[-\w:]+/,
	      axis: {
	        pattern:
	          /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,
	        lookbehind: true,
	        alias: 'operator'
	      },
	      'keyword-operator': {
	        pattern:
	          /(^|[^:-])\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\b(?=$|[^:-])/,
	        lookbehind: true,
	        alias: 'operator'
	      },
	      keyword: {
	        pattern:
	          /(^|[^:-])\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\b(?=$|[^:-])/,
	        lookbehind: true
	      },
	      function: /[\w-]+(?::[\w-]+)*(?=\s*\()/,
	      'xquery-element': {
	        pattern: /(element\s+)[\w-]+(?::[\w-]+)*/,
	        lookbehind: true,
	        alias: 'tag'
	      },
	      'xquery-attribute': {
	        pattern: /(attribute\s+)[\w-]+(?::[\w-]+)*/,
	        lookbehind: true,
	        alias: 'attr-name'
	      },
	      builtin: {
	        pattern:
	          /(^|[^:-])\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\b(?=$|[^:-])/,
	        lookbehind: true
	      },
	      number: /\b\d+(?:\.\d+)?(?:E[+-]?\d+)?/,
	      operator: [
	        /[+*=?|@]|\.\.?|:=|!=|<[=<]?|>[=>]?/,
	        {
	          pattern: /(\s)-(?=\s)/,
	          lookbehind: true
	        }
	      ],
	      punctuation: /[[\](){},;:/]/
	    });
	    Prism.languages.xquery.tag.pattern =
	      /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
	    Prism.languages.xquery['tag'].inside['attr-value'].pattern =
	      /=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/;
	    Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] =
	      /^="|"$/;
	    Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {
	      // Allow for two levels of nesting
	      pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
	      inside: Prism.languages.xquery,
	      alias: 'language-xquery'
	    }; // The following will handle plain text inside tags
	    var stringifyToken = function (token) {
	      if (typeof token === 'string') {
	        return token
	      }
	      if (typeof token.content === 'string') {
	        return token.content
	      }
	      return token.content.map(stringifyToken).join('')
	    };
	    var walkTokens = function (tokens) {
	      var openedTags = [];
	      for (var i = 0; i < tokens.length; i++) {
	        var token = tokens[i];
	        var notTagNorBrace = false;
	        if (typeof token !== 'string') {
	          if (
	            token.type === 'tag' &&
	            token.content[0] &&
	            token.content[0].type === 'tag'
	          ) {
	            // We found a tag, now find its kind
	            if (token.content[0].content[0].content === '</') {
	              // Closing tag
	              if (
	                openedTags.length > 0 &&
	                openedTags[openedTags.length - 1].tagName ===
	                  stringifyToken(token.content[0].content[1])
	              ) {
	                // Pop matching opening tag
	                openedTags.pop();
	              }
	            } else {
	              if (token.content[token.content.length - 1].content === '/>') ; else {
	                // Opening tag
	                openedTags.push({
	                  tagName: stringifyToken(token.content[0].content[1]),
	                  openedBraces: 0
	                });
	              }
	            }
	          } else if (
	            openedTags.length > 0 &&
	            token.type === 'punctuation' &&
	            token.content === '{' && // Ignore `{{`
	            (!tokens[i + 1] ||
	              tokens[i + 1].type !== 'punctuation' ||
	              tokens[i + 1].content !== '{') &&
	            (!tokens[i - 1] ||
	              tokens[i - 1].type !== 'plain-text' ||
	              tokens[i - 1].content !== '{')
	          ) {
	            // Here we might have entered an XQuery expression inside a tag
	            openedTags[openedTags.length - 1].openedBraces++;
	          } else if (
	            openedTags.length > 0 &&
	            openedTags[openedTags.length - 1].openedBraces > 0 &&
	            token.type === 'punctuation' &&
	            token.content === '}'
	          ) {
	            // Here we might have left an XQuery expression inside a tag
	            openedTags[openedTags.length - 1].openedBraces--;
	          } else if (token.type !== 'comment') {
	            notTagNorBrace = true;
	          }
	        }
	        if (notTagNorBrace || typeof token === 'string') {
	          if (
	            openedTags.length > 0 &&
	            openedTags[openedTags.length - 1].openedBraces === 0
	          ) {
	            // Here we are inside a tag, and not inside an XQuery expression.
	            // That's plain text: drop any tokens matched.
	            var plainText = stringifyToken(token); // And merge text with adjacent text
	            if (
	              i < tokens.length - 1 &&
	              (typeof tokens[i + 1] === 'string' ||
	                tokens[i + 1].type === 'plain-text')
	            ) {
	              plainText += stringifyToken(tokens[i + 1]);
	              tokens.splice(i + 1, 1);
	            }
	            if (
	              i > 0 &&
	              (typeof tokens[i - 1] === 'string' ||
	                tokens[i - 1].type === 'plain-text')
	            ) {
	              plainText = stringifyToken(tokens[i - 1]) + plainText;
	              tokens.splice(i - 1, 1);
	              i--;
	            }
	            if (/^\s+$/.test(plainText)) {
	              tokens[i] = plainText;
	            } else {
	              tokens[i] = new Prism.Token(
	                'plain-text',
	                plainText,
	                null,
	                plainText
	              );
	            }
	          }
	        }
	        if (token.content && typeof token.content !== 'string') {
	          walkTokens(token.content);
	        }
	      }
	    };
	    Prism.hooks.add('after-tokenize', function (env) {
	      if (env.language !== 'xquery') {
	        return
	      }
	      walkTokens(env.tokens);
	    });
	  })(Prism);
	}
	return xquery_1;
}

var yang_1;
var hasRequiredYang;

function requireYang () {
	if (hasRequiredYang) return yang_1;
	hasRequiredYang = 1;

	yang_1 = yang;
	yang.displayName = 'yang';
	yang.aliases = [];
	function yang(Prism) {
	  Prism.languages.yang = {
	    // https://tools.ietf.org/html/rfc6020#page-34
	    // http://www.yang-central.org/twiki/bin/view/Main/YangExamples
	    comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
	    string: {
	      pattern: /"(?:[^\\"]|\\.)*"|'[^']*'/,
	      greedy: true
	    },
	    keyword: {
	      pattern: /(^|[{};\r\n][ \t]*)[a-z_][\w.-]*/i,
	      lookbehind: true
	    },
	    namespace: {
	      pattern: /(\s)[a-z_][\w.-]*(?=:)/i,
	      lookbehind: true
	    },
	    boolean: /\b(?:false|true)\b/,
	    operator: /\+/,
	    punctuation: /[{};:]/
	  };
	}
	return yang_1;
}

var zig_1;
var hasRequiredZig;

function requireZig () {
	if (hasRequiredZig) return zig_1;
	hasRequiredZig = 1;

	zig_1 = zig;
	zig.displayName = 'zig';
	zig.aliases = [];
	function zig(Prism) {
(function (Prism) {
	    function literal(str) {
	      return function () {
	        return str
	      }
	    }
	    var keyword =
	      /\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\b/;
	    var IDENTIFIER = '\\b(?!' + keyword.source + ')(?!\\d)\\w+\\b';
	    var ALIGN = /align\s*\((?:[^()]|\([^()]*\))*\)/.source;
	    var PREFIX_TYPE_OP =
	      /(?:\?|\bpromise->|(?:\[[^[\]]*\]|\*(?!\*)|\*\*)(?:\s*<ALIGN>|\s*const\b|\s*volatile\b|\s*allowzero\b)*)/.source.replace(
	        /<ALIGN>/g,
	        literal(ALIGN)
	      );
	    var SUFFIX_EXPR =
	      /(?:\bpromise\b|(?:\berror\.)?<ID>(?:\.<ID>)*(?!\s+<ID>))/.source.replace(
	        /<ID>/g,
	        literal(IDENTIFIER)
	      );
	    var TYPE =
	      '(?!\\s)(?:!?\\s*(?:' + PREFIX_TYPE_OP + '\\s*)*' + SUFFIX_EXPR + ')+';
	    /*
	     * A simplified grammar for Zig compile time type literals:
	     *
	     * TypeExpr = ( "!"? PREFIX_TYPE_OP* SUFFIX_EXPR )+
	     *
	     * SUFFIX_EXPR = ( \b "promise" \b | ( \b "error" "." )? IDENTIFIER ( "." IDENTIFIER )* (?! \s+ IDENTIFIER ) )
	     *
	     * PREFIX_TYPE_OP = "?"
	     *                | \b "promise" "->"
	     *                | ( "[" [^\[\]]* "]" | "*" | "**" ) ( ALIGN | "const" \b | "volatile" \b | "allowzero" \b )*
	     *
	     * ALIGN = "align" "(" ( [^()] | "(" [^()]* ")" )* ")"
	     *
	     * IDENTIFIER = \b (?! KEYWORD ) [a-zA-Z_] \w* \b
	     *
	     */
	    Prism.languages.zig = {
	      comment: [
	        {
	          pattern: /\/\/[/!].*/,
	          alias: 'doc-comment'
	        },
	        /\/{2}.*/
	      ],
	      string: [
	        {
	          // "string" and c"string"
	          pattern: /(^|[^\\@])c?"(?:[^"\\\r\n]|\\.)*"/,
	          lookbehind: true,
	          greedy: true
	        },
	        {
	          // multiline strings and c-strings
	          pattern: /([\r\n])([ \t]+c?\\{2}).*(?:(?:\r\n?|\n)\2.*)*/,
	          lookbehind: true,
	          greedy: true
	        }
	      ],
	      char: {
	        // characters 'a', '\n', '\xFF', '\u{10FFFF}'
	        pattern:
	          /(^|[^\\])'(?:[^'\\\r\n]|[\uD800-\uDFFF]{2}|\\(?:.|x[a-fA-F\d]{2}|u\{[a-fA-F\d]{1,6}\}))'/,
	        lookbehind: true,
	        greedy: true
	      },
	      builtin: /\B@(?!\d)\w+(?=\s*\()/,
	      label: {
	        pattern:
	          /(\b(?:break|continue)\s*:\s*)\w+\b|\b(?!\d)\w+\b(?=\s*:\s*(?:\{|while\b))/,
	        lookbehind: true
	      },
	      'class-name': [
	        // const Foo = struct {};
	        /\b(?!\d)\w+(?=\s*=\s*(?:(?:extern|packed)\s+)?(?:enum|struct|union)\s*[({])/,
	        {
	          // const x: i32 = 9;
	          // var x: Bar;
	          // fn foo(x: bool, y: f32) void {}
	          pattern: RegExp(
	            /(:\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?[=;,)])|<TYPE>(?=\s*(?:<ALIGN>\s*)?\{)/.source
	              .replace(/<TYPE>/g, literal(TYPE))
	              .replace(/<ALIGN>/g, literal(ALIGN))
	          ),
	          lookbehind: true,
	          inside: null // see below
	        },
	        {
	          // extern fn foo(x: f64) f64; (optional alignment)
	          pattern: RegExp(
	            /(\)\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?;)/.source
	              .replace(/<TYPE>/g, literal(TYPE))
	              .replace(/<ALIGN>/g, literal(ALIGN))
	          ),
	          lookbehind: true,
	          inside: null // see below
	        }
	      ],
	      'builtin-type': {
	        pattern:
	          /\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\b/,
	        alias: 'keyword'
	      },
	      keyword: keyword,
	      function: /\b(?!\d)\w+(?=\s*\()/,
	      number:
	        /\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\d]+(?:\.[a-fA-F\d]*)?(?:[pP][+-]?[a-fA-F\d]+)?|\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\b/,
	      boolean: /\b(?:false|true)\b/,
	      operator:
	        /\.[*?]|\.{2,3}|[-=]>|\*\*|\+\+|\|\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,
	      punctuation: /[.:,;(){}[\]]/
	    };
	    Prism.languages.zig['class-name'].forEach(function (obj) {
	      if (obj.inside === null) {
	        obj.inside = Prism.languages.zig;
	      }
	    });
	  })(Prism);
	}
	return zig_1;
}

var refractor = core$1;

var refractor_1 = refractor;

refractor.register(abap_1);
refractor.register(abnf_1);
refractor.register(actionscript_1);
refractor.register(ada_1);
refractor.register(agda_1);
refractor.register(al_1);
refractor.register(antlr4_1);
refractor.register(apacheconf_1);
refractor.register(apex_1);
refractor.register(apl_1);
refractor.register(applescript_1);
refractor.register(aql_1);
refractor.register(arduino_1);
refractor.register(arff_1);
refractor.register(asciidoc_1);
refractor.register(asm6502_1);
refractor.register(asmatmel_1);
refractor.register(aspnet_1);
refractor.register(autohotkey_1);
refractor.register(autoit_1);
refractor.register(avisynth_1);
refractor.register(avroIdl_1);
refractor.register(bash_1);
refractor.register(basic_1);
refractor.register(batch_1);
refractor.register(bbcode_1);
refractor.register(bicep_1);
refractor.register(birb_1);
refractor.register(bison_1);
refractor.register(bnf_1);
refractor.register(brainfuck_1);
refractor.register(brightscript_1);
refractor.register(bro_1);
refractor.register(bsl_1);
refractor.register(c_1);
refractor.register(cfscript_1);
refractor.register(chaiscript_1);
refractor.register(cil_1);
refractor.register(clojure_1);
refractor.register(cmake_1);
refractor.register(requireCobol());
refractor.register(requireCoffeescript());
refractor.register(requireConcurnas());
refractor.register(requireCoq());
refractor.register(requireCpp());
refractor.register(requireCrystal());
refractor.register(requireCsharp());
refractor.register(requireCshtml());
refractor.register(requireCsp());
refractor.register(requireCssExtras());
refractor.register(requireCsv());
refractor.register(requireCypher());
refractor.register(requireD());
refractor.register(requireDart());
refractor.register(requireDataweave());
refractor.register(requireDax());
refractor.register(requireDhall());
refractor.register(requireDiff());
refractor.register(requireDjango());
refractor.register(requireDnsZoneFile());
refractor.register(requireDocker());
refractor.register(requireDot());
refractor.register(requireEbnf());
refractor.register(requireEditorconfig());
refractor.register(requireEiffel());
refractor.register(requireEjs());
refractor.register(requireElixir());
refractor.register(requireElm());
refractor.register(requireErb());
refractor.register(requireErlang());
refractor.register(requireEtlua());
refractor.register(requireExcelFormula());
refractor.register(requireFactor());
refractor.register(require_false());
refractor.register(requireFirestoreSecurityRules());
refractor.register(requireFlow());
refractor.register(requireFortran());
refractor.register(requireFsharp());
refractor.register(requireFtl());
refractor.register(requireGap());
refractor.register(requireGcode());
refractor.register(requireGdscript());
refractor.register(requireGedcom());
refractor.register(requireGherkin());
refractor.register(requireGit());
refractor.register(requireGlsl());
refractor.register(requireGml());
refractor.register(requireGn());
refractor.register(requireGoModule());
refractor.register(requireGo());
refractor.register(requireGraphql());
refractor.register(requireGroovy());
refractor.register(requireHaml());
refractor.register(requireHandlebars());
refractor.register(requireHaskell());
refractor.register(requireHaxe());
refractor.register(requireHcl());
refractor.register(requireHlsl());
refractor.register(requireHoon());
refractor.register(requireHpkp());
refractor.register(requireHsts());
refractor.register(requireHttp());
refractor.register(requireIchigojam());
refractor.register(requireIcon());
refractor.register(requireIcuMessageFormat());
refractor.register(requireIdris());
refractor.register(requireIecst());
refractor.register(requireIgnore());
refractor.register(requireInform7());
refractor.register(requireIni());
refractor.register(requireIo());
refractor.register(requireJ());
refractor.register(requireJava());
refractor.register(requireJavadoc());
refractor.register(requireJavadoclike());
refractor.register(requireJavastacktrace());
refractor.register(requireJexl());
refractor.register(requireJolie());
refractor.register(requireJq());
refractor.register(requireJsExtras());
refractor.register(requireJsTemplates());
refractor.register(requireJsdoc());
refractor.register(requireJson());
refractor.register(requireJson5());
refractor.register(requireJsonp());
refractor.register(requireJsstacktrace());
refractor.register(requireJsx());
refractor.register(requireJulia());
refractor.register(requireKeepalived());
refractor.register(requireKeyman());
refractor.register(requireKotlin());
refractor.register(requireKumir());
refractor.register(requireKusto());
refractor.register(requireLatex());
refractor.register(requireLatte());
refractor.register(requireLess());
refractor.register(requireLilypond());
refractor.register(requireLiquid());
refractor.register(requireLisp());
refractor.register(requireLivescript());
refractor.register(requireLlvm());
refractor.register(requireLog());
refractor.register(requireLolcode());
refractor.register(requireLua());
refractor.register(requireMagma());
refractor.register(requireMakefile());
refractor.register(requireMarkdown());
refractor.register(requireMarkupTemplating());
refractor.register(requireMatlab());
refractor.register(requireMaxscript());
refractor.register(requireMel());
refractor.register(requireMermaid());
refractor.register(requireMizar());
refractor.register(requireMongodb());
refractor.register(requireMonkey());
refractor.register(requireMoonscript());
refractor.register(requireN1ql());
refractor.register(requireN4js());
refractor.register(requireNand2tetrisHdl());
refractor.register(requireNaniscript());
refractor.register(requireNasm());
refractor.register(requireNeon());
refractor.register(requireNevod());
refractor.register(requireNginx());
refractor.register(requireNim());
refractor.register(requireNix());
refractor.register(requireNsis());
refractor.register(requireObjectivec());
refractor.register(requireOcaml());
refractor.register(requireOpencl());
refractor.register(requireOpenqasm());
refractor.register(requireOz());
refractor.register(requireParigp());
refractor.register(requireParser());
refractor.register(requirePascal());
refractor.register(requirePascaligo());
refractor.register(requirePcaxis());
refractor.register(requirePeoplecode());
refractor.register(requirePerl());
refractor.register(requirePhpExtras());
refractor.register(requirePhp());
refractor.register(requirePhpdoc());
refractor.register(requirePlsql());
refractor.register(requirePowerquery());
refractor.register(requirePowershell());
refractor.register(requireProcessing());
refractor.register(requireProlog());
refractor.register(requirePromql());
refractor.register(requireProperties());
refractor.register(requireProtobuf());
refractor.register(requirePsl());
refractor.register(requirePug());
refractor.register(requirePuppet());
refractor.register(requirePure());
refractor.register(requirePurebasic());
refractor.register(requirePurescript());
refractor.register(requirePython());
refractor.register(requireQ());
refractor.register(requireQml());
refractor.register(requireQore());
refractor.register(requireQsharp());
refractor.register(requireR());
refractor.register(requireRacket());
refractor.register(requireReason());
refractor.register(requireRegex());
refractor.register(requireRego());
refractor.register(requireRenpy());
refractor.register(requireRest());
refractor.register(requireRip());
refractor.register(requireRoboconf());
refractor.register(requireRobotframework());
refractor.register(requireRuby());
refractor.register(requireRust());
refractor.register(requireSas());
refractor.register(requireSass());
refractor.register(requireScala());
refractor.register(requireScheme());
refractor.register(requireScss());
refractor.register(requireShellSession());
refractor.register(requireSmali());
refractor.register(requireSmalltalk());
refractor.register(requireSmarty());
refractor.register(requireSml());
refractor.register(requireSolidity());
refractor.register(requireSolutionFile());
refractor.register(requireSoy());
refractor.register(requireSparql());
refractor.register(requireSplunkSpl());
refractor.register(requireSqf());
refractor.register(sql_1);
refractor.register(requireSquirrel());
refractor.register(requireStan());
refractor.register(requireStylus());
refractor.register(requireSwift());
refractor.register(requireSystemd());
refractor.register(requireT4Cs());
refractor.register(requireT4Templating());
refractor.register(requireT4Vb());
refractor.register(requireTap());
refractor.register(requireTcl());
refractor.register(requireTextile());
refractor.register(requireToml());
refractor.register(requireTremor());
refractor.register(requireTsx());
refractor.register(requireTt2());
refractor.register(requireTurtle());
refractor.register(requireTwig());
refractor.register(requireTypescript());
refractor.register(requireTyposcript());
refractor.register(requireUnrealscript());
refractor.register(requireUorazor());
refractor.register(requireUri());
refractor.register(requireV());
refractor.register(requireVala());
refractor.register(requireVbnet());
refractor.register(requireVelocity());
refractor.register(requireVerilog());
refractor.register(requireVhdl());
refractor.register(requireVim());
refractor.register(requireVisualBasic());
refractor.register(requireWarpscript());
refractor.register(requireWasm());
refractor.register(requireWebIdl());
refractor.register(requireWiki());
refractor.register(requireWolfram());
refractor.register(requireWren());
refractor.register(requireXeora());
refractor.register(requireXmlDoc());
refractor.register(requireXojo());
refractor.register(requireXquery());
refractor.register(requireYaml());
refractor.register(requireYang());
refractor.register(requireZig());

var highlighter = highlight$1(refractor_1, defaultStyle);
highlighter.supportedLanguages = supportedLanguages;
var SyntaxHighlighter = highlighter;

var oneDark = {
  "code[class*=\"language-\"]": {
    "background": "hsl(220, 13%, 18%)",
    "color": "hsl(220, 14%, 71%)",
    "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
    "fontFamily": "\"Fira Code\", \"Fira Mono\", Menlo, Consolas, \"DejaVu Sans Mono\", monospace",
    "direction": "ltr",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "2",
    "OTabSize": "2",
    "tabSize": "2",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none"
  },
  "pre[class*=\"language-\"]": {
    "background": "hsl(220, 13%, 18%)",
    "color": "hsl(220, 14%, 71%)",
    "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
    "fontFamily": "\"Fira Code\", \"Fira Mono\", Menlo, Consolas, \"DejaVu Sans Mono\", monospace",
    "direction": "ltr",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "2",
    "OTabSize": "2",
    "tabSize": "2",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none",
    "padding": "1em",
    "margin": "0.5em 0",
    "overflow": "auto",
    "borderRadius": "0.3em"
  },
  "code[class*=\"language-\"]::-moz-selection": {
    "background": "hsl(220, 13%, 28%)",
    "color": "inherit",
    "textShadow": "none"
  },
  "code[class*=\"language-\"] *::-moz-selection": {
    "background": "hsl(220, 13%, 28%)",
    "color": "inherit",
    "textShadow": "none"
  },
  "pre[class*=\"language-\"] *::-moz-selection": {
    "background": "hsl(220, 13%, 28%)",
    "color": "inherit",
    "textShadow": "none"
  },
  "code[class*=\"language-\"]::selection": {
    "background": "hsl(220, 13%, 28%)",
    "color": "inherit",
    "textShadow": "none"
  },
  "code[class*=\"language-\"] *::selection": {
    "background": "hsl(220, 13%, 28%)",
    "color": "inherit",
    "textShadow": "none"
  },
  "pre[class*=\"language-\"] *::selection": {
    "background": "hsl(220, 13%, 28%)",
    "color": "inherit",
    "textShadow": "none"
  },
  ":not(pre) > code[class*=\"language-\"]": {
    "padding": "0.2em 0.3em",
    "borderRadius": "0.3em",
    "whiteSpace": "normal"
  },
  "comment": {
    "color": "hsl(220, 10%, 40%)",
    "fontStyle": "italic"
  },
  "prolog": {
    "color": "hsl(220, 10%, 40%)"
  },
  "cdata": {
    "color": "hsl(220, 10%, 40%)"
  },
  "doctype": {
    "color": "hsl(220, 14%, 71%)"
  },
  "punctuation": {
    "color": "hsl(220, 14%, 71%)"
  },
  "entity": {
    "color": "hsl(220, 14%, 71%)",
    "cursor": "help"
  },
  "attr-name": {
    "color": "hsl(29, 54%, 61%)"
  },
  "class-name": {
    "color": "hsl(29, 54%, 61%)"
  },
  "boolean": {
    "color": "hsl(29, 54%, 61%)"
  },
  "constant": {
    "color": "hsl(29, 54%, 61%)"
  },
  "number": {
    "color": "hsl(29, 54%, 61%)"
  },
  "atrule": {
    "color": "hsl(29, 54%, 61%)"
  },
  "keyword": {
    "color": "hsl(286, 60%, 67%)"
  },
  "property": {
    "color": "hsl(355, 65%, 65%)"
  },
  "tag": {
    "color": "hsl(355, 65%, 65%)"
  },
  "symbol": {
    "color": "hsl(355, 65%, 65%)"
  },
  "deleted": {
    "color": "hsl(355, 65%, 65%)"
  },
  "important": {
    "color": "hsl(355, 65%, 65%)"
  },
  "selector": {
    "color": "hsl(95, 38%, 62%)"
  },
  "string": {
    "color": "hsl(95, 38%, 62%)"
  },
  "char": {
    "color": "hsl(95, 38%, 62%)"
  },
  "builtin": {
    "color": "hsl(95, 38%, 62%)"
  },
  "inserted": {
    "color": "hsl(95, 38%, 62%)"
  },
  "regex": {
    "color": "hsl(95, 38%, 62%)"
  },
  "attr-value": {
    "color": "hsl(95, 38%, 62%)"
  },
  "attr-value > .token.punctuation": {
    "color": "hsl(95, 38%, 62%)"
  },
  "variable": {
    "color": "hsl(207, 82%, 66%)"
  },
  "operator": {
    "color": "hsl(207, 82%, 66%)"
  },
  "function": {
    "color": "hsl(207, 82%, 66%)"
  },
  "url": {
    "color": "hsl(187, 47%, 55%)"
  },
  "attr-value > .token.punctuation.attr-equals": {
    "color": "hsl(220, 14%, 71%)"
  },
  "special-attr > .token.attr-value > .token.value.css": {
    "color": "hsl(220, 14%, 71%)"
  },
  ".language-css .token.selector": {
    "color": "hsl(355, 65%, 65%)"
  },
  ".language-css .token.property": {
    "color": "hsl(220, 14%, 71%)"
  },
  ".language-css .token.function": {
    "color": "hsl(187, 47%, 55%)"
  },
  ".language-css .token.url > .token.function": {
    "color": "hsl(187, 47%, 55%)"
  },
  ".language-css .token.url > .token.string.url": {
    "color": "hsl(95, 38%, 62%)"
  },
  ".language-css .token.important": {
    "color": "hsl(286, 60%, 67%)"
  },
  ".language-css .token.atrule .token.rule": {
    "color": "hsl(286, 60%, 67%)"
  },
  ".language-javascript .token.operator": {
    "color": "hsl(286, 60%, 67%)"
  },
  ".language-javascript .token.template-string > .token.interpolation > .token.interpolation-punctuation.punctuation": {
    "color": "hsl(5, 48%, 51%)"
  },
  ".language-json .token.operator": {
    "color": "hsl(220, 14%, 71%)"
  },
  ".language-json .token.null.keyword": {
    "color": "hsl(29, 54%, 61%)"
  },
  ".language-markdown .token.url": {
    "color": "hsl(220, 14%, 71%)"
  },
  ".language-markdown .token.url > .token.operator": {
    "color": "hsl(220, 14%, 71%)"
  },
  ".language-markdown .token.url-reference.url > .token.string": {
    "color": "hsl(220, 14%, 71%)"
  },
  ".language-markdown .token.url > .token.content": {
    "color": "hsl(207, 82%, 66%)"
  },
  ".language-markdown .token.url > .token.url": {
    "color": "hsl(187, 47%, 55%)"
  },
  ".language-markdown .token.url-reference.url": {
    "color": "hsl(187, 47%, 55%)"
  },
  ".language-markdown .token.blockquote.punctuation": {
    "color": "hsl(220, 10%, 40%)",
    "fontStyle": "italic"
  },
  ".language-markdown .token.hr.punctuation": {
    "color": "hsl(220, 10%, 40%)",
    "fontStyle": "italic"
  },
  ".language-markdown .token.code-snippet": {
    "color": "hsl(95, 38%, 62%)"
  },
  ".language-markdown .token.bold .token.content": {
    "color": "hsl(29, 54%, 61%)"
  },
  ".language-markdown .token.italic .token.content": {
    "color": "hsl(286, 60%, 67%)"
  },
  ".language-markdown .token.strike .token.content": {
    "color": "hsl(355, 65%, 65%)"
  },
  ".language-markdown .token.strike .token.punctuation": {
    "color": "hsl(355, 65%, 65%)"
  },
  ".language-markdown .token.list.punctuation": {
    "color": "hsl(355, 65%, 65%)"
  },
  ".language-markdown .token.title.important > .token.punctuation": {
    "color": "hsl(355, 65%, 65%)"
  },
  "bold": {
    "fontWeight": "bold"
  },
  "italic": {
    "fontStyle": "italic"
  },
  "namespace": {
    "Opacity": "0.8"
  },
  "token.tab:not(:empty):before": {
    "color": "hsla(220, 14%, 71%, 0.15)",
    "textShadow": "none"
  },
  "token.cr:before": {
    "color": "hsla(220, 14%, 71%, 0.15)",
    "textShadow": "none"
  },
  "token.lf:before": {
    "color": "hsla(220, 14%, 71%, 0.15)",
    "textShadow": "none"
  },
  "token.space:before": {
    "color": "hsla(220, 14%, 71%, 0.15)",
    "textShadow": "none"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item": {
    "marginRight": "0.4em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button": {
    "background": "hsl(220, 13%, 26%)",
    "color": "hsl(220, 9%, 55%)",
    "padding": "0.1em 0.4em",
    "borderRadius": "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a": {
    "background": "hsl(220, 13%, 26%)",
    "color": "hsl(220, 9%, 55%)",
    "padding": "0.1em 0.4em",
    "borderRadius": "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span": {
    "background": "hsl(220, 13%, 26%)",
    "color": "hsl(220, 9%, 55%)",
    "padding": "0.1em 0.4em",
    "borderRadius": "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:hover": {
    "background": "hsl(220, 13%, 28%)",
    "color": "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:focus": {
    "background": "hsl(220, 13%, 28%)",
    "color": "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:hover": {
    "background": "hsl(220, 13%, 28%)",
    "color": "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:focus": {
    "background": "hsl(220, 13%, 28%)",
    "color": "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:hover": {
    "background": "hsl(220, 13%, 28%)",
    "color": "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:focus": {
    "background": "hsl(220, 13%, 28%)",
    "color": "hsl(220, 14%, 71%)"
  },
  ".line-highlight.line-highlight": {
    "background": "hsla(220, 100%, 80%, 0.04)"
  },
  ".line-highlight.line-highlight:before": {
    "background": "hsl(220, 13%, 26%)",
    "color": "hsl(220, 14%, 71%)",
    "padding": "0.1em 0.6em",
    "borderRadius": "0.3em",
    "boxShadow": "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  ".line-highlight.line-highlight[data-end]:after": {
    "background": "hsl(220, 13%, 26%)",
    "color": "hsl(220, 14%, 71%)",
    "padding": "0.1em 0.6em",
    "borderRadius": "0.3em",
    "boxShadow": "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  "pre[id].linkable-line-numbers.linkable-line-numbers span.line-numbers-rows > span:hover:before": {
    "backgroundColor": "hsla(220, 100%, 80%, 0.04)"
  },
  ".line-numbers.line-numbers .line-numbers-rows": {
    "borderRightColor": "hsla(220, 14%, 71%, 0.15)"
  },
  ".command-line .command-line-prompt": {
    "borderRightColor": "hsla(220, 14%, 71%, 0.15)"
  },
  ".line-numbers .line-numbers-rows > span:before": {
    "color": "hsl(220, 14%, 45%)"
  },
  ".command-line .command-line-prompt > span:before": {
    "color": "hsl(220, 14%, 45%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-1": {
    "color": "hsl(355, 65%, 65%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-5": {
    "color": "hsl(355, 65%, 65%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-9": {
    "color": "hsl(355, 65%, 65%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-2": {
    "color": "hsl(95, 38%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-6": {
    "color": "hsl(95, 38%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-10": {
    "color": "hsl(95, 38%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-3": {
    "color": "hsl(207, 82%, 66%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-7": {
    "color": "hsl(207, 82%, 66%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-11": {
    "color": "hsl(207, 82%, 66%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-4": {
    "color": "hsl(286, 60%, 67%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-8": {
    "color": "hsl(286, 60%, 67%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-12": {
    "color": "hsl(286, 60%, 67%)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)": {
    "backgroundColor": "hsla(353, 100%, 66%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)": {
    "backgroundColor": "hsla(353, 100%, 66%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::-moz-selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::-moz-selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::-moz-selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::-moz-selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)": {
    "backgroundColor": "hsla(137, 100%, 55%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)": {
    "backgroundColor": "hsla(137, 100%, 55%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::-moz-selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::-moz-selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::-moz-selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::-moz-selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  ".prism-previewer.prism-previewer:before": {
    "borderColor": "hsl(224, 13%, 17%)"
  },
  ".prism-previewer-gradient.prism-previewer-gradient div": {
    "borderColor": "hsl(224, 13%, 17%)",
    "borderRadius": "0.3em"
  },
  ".prism-previewer-color.prism-previewer-color:before": {
    "borderRadius": "0.3em"
  },
  ".prism-previewer-easing.prism-previewer-easing:before": {
    "borderRadius": "0.3em"
  },
  ".prism-previewer.prism-previewer:after": {
    "borderTopColor": "hsl(224, 13%, 17%)"
  },
  ".prism-previewer-flipped.prism-previewer-flipped.after": {
    "borderBottomColor": "hsl(224, 13%, 17%)"
  },
  ".prism-previewer-angle.prism-previewer-angle:before": {
    "background": "hsl(219, 13%, 22%)"
  },
  ".prism-previewer-time.prism-previewer-time:before": {
    "background": "hsl(219, 13%, 22%)"
  },
  ".prism-previewer-easing.prism-previewer-easing": {
    "background": "hsl(219, 13%, 22%)"
  },
  ".prism-previewer-angle.prism-previewer-angle circle": {
    "stroke": "hsl(220, 14%, 71%)",
    "strokeOpacity": "1"
  },
  ".prism-previewer-time.prism-previewer-time circle": {
    "stroke": "hsl(220, 14%, 71%)",
    "strokeOpacity": "1"
  },
  ".prism-previewer-easing.prism-previewer-easing circle": {
    "stroke": "hsl(220, 14%, 71%)",
    "fill": "transparent"
  },
  ".prism-previewer-easing.prism-previewer-easing path": {
    "stroke": "hsl(220, 14%, 71%)"
  },
  ".prism-previewer-easing.prism-previewer-easing line": {
    "stroke": "hsl(220, 14%, 71%)"
  }
};

var oneLight = {
  "code[class*=\"language-\"]": {
    "background": "hsl(230, 1%, 98%)",
    "color": "hsl(230, 8%, 24%)",
    "fontFamily": "\"Fira Code\", \"Fira Mono\", Menlo, Consolas, \"DejaVu Sans Mono\", monospace",
    "direction": "ltr",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "2",
    "OTabSize": "2",
    "tabSize": "2",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none"
  },
  "pre[class*=\"language-\"]": {
    "background": "hsl(230, 1%, 98%)",
    "color": "hsl(230, 8%, 24%)",
    "fontFamily": "\"Fira Code\", \"Fira Mono\", Menlo, Consolas, \"DejaVu Sans Mono\", monospace",
    "direction": "ltr",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "2",
    "OTabSize": "2",
    "tabSize": "2",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none",
    "padding": "1em",
    "margin": "0.5em 0",
    "overflow": "auto",
    "borderRadius": "0.3em"
  },
  "code[class*=\"language-\"]::-moz-selection": {
    "background": "hsl(230, 1%, 90%)",
    "color": "inherit"
  },
  "code[class*=\"language-\"] *::-moz-selection": {
    "background": "hsl(230, 1%, 90%)",
    "color": "inherit"
  },
  "pre[class*=\"language-\"] *::-moz-selection": {
    "background": "hsl(230, 1%, 90%)",
    "color": "inherit"
  },
  "code[class*=\"language-\"]::selection": {
    "background": "hsl(230, 1%, 90%)",
    "color": "inherit"
  },
  "code[class*=\"language-\"] *::selection": {
    "background": "hsl(230, 1%, 90%)",
    "color": "inherit"
  },
  "pre[class*=\"language-\"] *::selection": {
    "background": "hsl(230, 1%, 90%)",
    "color": "inherit"
  },
  ":not(pre) > code[class*=\"language-\"]": {
    "padding": "0.2em 0.3em",
    "borderRadius": "0.3em",
    "whiteSpace": "normal"
  },
  "comment": {
    "color": "hsl(230, 4%, 64%)",
    "fontStyle": "italic"
  },
  "prolog": {
    "color": "hsl(230, 4%, 64%)"
  },
  "cdata": {
    "color": "hsl(230, 4%, 64%)"
  },
  "doctype": {
    "color": "hsl(230, 8%, 24%)"
  },
  "punctuation": {
    "color": "hsl(230, 8%, 24%)"
  },
  "entity": {
    "color": "hsl(230, 8%, 24%)",
    "cursor": "help"
  },
  "attr-name": {
    "color": "hsl(35, 99%, 36%)"
  },
  "class-name": {
    "color": "hsl(35, 99%, 36%)"
  },
  "boolean": {
    "color": "hsl(35, 99%, 36%)"
  },
  "constant": {
    "color": "hsl(35, 99%, 36%)"
  },
  "number": {
    "color": "hsl(35, 99%, 36%)"
  },
  "atrule": {
    "color": "hsl(35, 99%, 36%)"
  },
  "keyword": {
    "color": "hsl(301, 63%, 40%)"
  },
  "property": {
    "color": "hsl(5, 74%, 59%)"
  },
  "tag": {
    "color": "hsl(5, 74%, 59%)"
  },
  "symbol": {
    "color": "hsl(5, 74%, 59%)"
  },
  "deleted": {
    "color": "hsl(5, 74%, 59%)"
  },
  "important": {
    "color": "hsl(5, 74%, 59%)"
  },
  "selector": {
    "color": "hsl(119, 34%, 47%)"
  },
  "string": {
    "color": "hsl(119, 34%, 47%)"
  },
  "char": {
    "color": "hsl(119, 34%, 47%)"
  },
  "builtin": {
    "color": "hsl(119, 34%, 47%)"
  },
  "inserted": {
    "color": "hsl(119, 34%, 47%)"
  },
  "regex": {
    "color": "hsl(119, 34%, 47%)"
  },
  "attr-value": {
    "color": "hsl(119, 34%, 47%)"
  },
  "attr-value > .token.punctuation": {
    "color": "hsl(119, 34%, 47%)"
  },
  "variable": {
    "color": "hsl(221, 87%, 60%)"
  },
  "operator": {
    "color": "hsl(221, 87%, 60%)"
  },
  "function": {
    "color": "hsl(221, 87%, 60%)"
  },
  "url": {
    "color": "hsl(198, 99%, 37%)"
  },
  "attr-value > .token.punctuation.attr-equals": {
    "color": "hsl(230, 8%, 24%)"
  },
  "special-attr > .token.attr-value > .token.value.css": {
    "color": "hsl(230, 8%, 24%)"
  },
  ".language-css .token.selector": {
    "color": "hsl(5, 74%, 59%)"
  },
  ".language-css .token.property": {
    "color": "hsl(230, 8%, 24%)"
  },
  ".language-css .token.function": {
    "color": "hsl(198, 99%, 37%)"
  },
  ".language-css .token.url > .token.function": {
    "color": "hsl(198, 99%, 37%)"
  },
  ".language-css .token.url > .token.string.url": {
    "color": "hsl(119, 34%, 47%)"
  },
  ".language-css .token.important": {
    "color": "hsl(301, 63%, 40%)"
  },
  ".language-css .token.atrule .token.rule": {
    "color": "hsl(301, 63%, 40%)"
  },
  ".language-javascript .token.operator": {
    "color": "hsl(301, 63%, 40%)"
  },
  ".language-javascript .token.template-string > .token.interpolation > .token.interpolation-punctuation.punctuation": {
    "color": "hsl(344, 84%, 43%)"
  },
  ".language-json .token.operator": {
    "color": "hsl(230, 8%, 24%)"
  },
  ".language-json .token.null.keyword": {
    "color": "hsl(35, 99%, 36%)"
  },
  ".language-markdown .token.url": {
    "color": "hsl(230, 8%, 24%)"
  },
  ".language-markdown .token.url > .token.operator": {
    "color": "hsl(230, 8%, 24%)"
  },
  ".language-markdown .token.url-reference.url > .token.string": {
    "color": "hsl(230, 8%, 24%)"
  },
  ".language-markdown .token.url > .token.content": {
    "color": "hsl(221, 87%, 60%)"
  },
  ".language-markdown .token.url > .token.url": {
    "color": "hsl(198, 99%, 37%)"
  },
  ".language-markdown .token.url-reference.url": {
    "color": "hsl(198, 99%, 37%)"
  },
  ".language-markdown .token.blockquote.punctuation": {
    "color": "hsl(230, 4%, 64%)",
    "fontStyle": "italic"
  },
  ".language-markdown .token.hr.punctuation": {
    "color": "hsl(230, 4%, 64%)",
    "fontStyle": "italic"
  },
  ".language-markdown .token.code-snippet": {
    "color": "hsl(119, 34%, 47%)"
  },
  ".language-markdown .token.bold .token.content": {
    "color": "hsl(35, 99%, 36%)"
  },
  ".language-markdown .token.italic .token.content": {
    "color": "hsl(301, 63%, 40%)"
  },
  ".language-markdown .token.strike .token.content": {
    "color": "hsl(5, 74%, 59%)"
  },
  ".language-markdown .token.strike .token.punctuation": {
    "color": "hsl(5, 74%, 59%)"
  },
  ".language-markdown .token.list.punctuation": {
    "color": "hsl(5, 74%, 59%)"
  },
  ".language-markdown .token.title.important > .token.punctuation": {
    "color": "hsl(5, 74%, 59%)"
  },
  "bold": {
    "fontWeight": "bold"
  },
  "italic": {
    "fontStyle": "italic"
  },
  "namespace": {
    "Opacity": "0.8"
  },
  "token.tab:not(:empty):before": {
    "color": "hsla(230, 8%, 24%, 0.2)"
  },
  "token.cr:before": {
    "color": "hsla(230, 8%, 24%, 0.2)"
  },
  "token.lf:before": {
    "color": "hsla(230, 8%, 24%, 0.2)"
  },
  "token.space:before": {
    "color": "hsla(230, 8%, 24%, 0.2)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item": {
    "marginRight": "0.4em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button": {
    "background": "hsl(230, 1%, 90%)",
    "color": "hsl(230, 6%, 44%)",
    "padding": "0.1em 0.4em",
    "borderRadius": "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a": {
    "background": "hsl(230, 1%, 90%)",
    "color": "hsl(230, 6%, 44%)",
    "padding": "0.1em 0.4em",
    "borderRadius": "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span": {
    "background": "hsl(230, 1%, 90%)",
    "color": "hsl(230, 6%, 44%)",
    "padding": "0.1em 0.4em",
    "borderRadius": "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:hover": {
    "background": "hsl(230, 1%, 78%)",
    "color": "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:focus": {
    "background": "hsl(230, 1%, 78%)",
    "color": "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:hover": {
    "background": "hsl(230, 1%, 78%)",
    "color": "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:focus": {
    "background": "hsl(230, 1%, 78%)",
    "color": "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:hover": {
    "background": "hsl(230, 1%, 78%)",
    "color": "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:focus": {
    "background": "hsl(230, 1%, 78%)",
    "color": "hsl(230, 8%, 24%)"
  },
  ".line-highlight.line-highlight": {
    "background": "hsla(230, 8%, 24%, 0.05)"
  },
  ".line-highlight.line-highlight:before": {
    "background": "hsl(230, 1%, 90%)",
    "color": "hsl(230, 8%, 24%)",
    "padding": "0.1em 0.6em",
    "borderRadius": "0.3em",
    "boxShadow": "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  ".line-highlight.line-highlight[data-end]:after": {
    "background": "hsl(230, 1%, 90%)",
    "color": "hsl(230, 8%, 24%)",
    "padding": "0.1em 0.6em",
    "borderRadius": "0.3em",
    "boxShadow": "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  "pre[id].linkable-line-numbers.linkable-line-numbers span.line-numbers-rows > span:hover:before": {
    "backgroundColor": "hsla(230, 8%, 24%, 0.05)"
  },
  ".line-numbers.line-numbers .line-numbers-rows": {
    "borderRightColor": "hsla(230, 8%, 24%, 0.2)"
  },
  ".command-line .command-line-prompt": {
    "borderRightColor": "hsla(230, 8%, 24%, 0.2)"
  },
  ".line-numbers .line-numbers-rows > span:before": {
    "color": "hsl(230, 1%, 62%)"
  },
  ".command-line .command-line-prompt > span:before": {
    "color": "hsl(230, 1%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-1": {
    "color": "hsl(5, 74%, 59%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-5": {
    "color": "hsl(5, 74%, 59%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-9": {
    "color": "hsl(5, 74%, 59%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-2": {
    "color": "hsl(119, 34%, 47%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-6": {
    "color": "hsl(119, 34%, 47%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-10": {
    "color": "hsl(119, 34%, 47%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-3": {
    "color": "hsl(221, 87%, 60%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-7": {
    "color": "hsl(221, 87%, 60%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-11": {
    "color": "hsl(221, 87%, 60%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-4": {
    "color": "hsl(301, 63%, 40%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-8": {
    "color": "hsl(301, 63%, 40%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-12": {
    "color": "hsl(301, 63%, 40%)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)": {
    "backgroundColor": "hsla(353, 100%, 66%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)": {
    "backgroundColor": "hsla(353, 100%, 66%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::-moz-selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::-moz-selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::-moz-selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::-moz-selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::selection": {
    "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)": {
    "backgroundColor": "hsla(137, 100%, 55%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)": {
    "backgroundColor": "hsla(137, 100%, 55%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::-moz-selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::-moz-selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::-moz-selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::-moz-selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::selection": {
    "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
  },
  ".prism-previewer.prism-previewer:before": {
    "borderColor": "hsl(0, 0, 95%)"
  },
  ".prism-previewer-gradient.prism-previewer-gradient div": {
    "borderColor": "hsl(0, 0, 95%)",
    "borderRadius": "0.3em"
  },
  ".prism-previewer-color.prism-previewer-color:before": {
    "borderRadius": "0.3em"
  },
  ".prism-previewer-easing.prism-previewer-easing:before": {
    "borderRadius": "0.3em"
  },
  ".prism-previewer.prism-previewer:after": {
    "borderTopColor": "hsl(0, 0, 95%)"
  },
  ".prism-previewer-flipped.prism-previewer-flipped.after": {
    "borderBottomColor": "hsl(0, 0, 95%)"
  },
  ".prism-previewer-angle.prism-previewer-angle:before": {
    "background": "hsl(0, 0%, 100%)"
  },
  ".prism-previewer-time.prism-previewer-time:before": {
    "background": "hsl(0, 0%, 100%)"
  },
  ".prism-previewer-easing.prism-previewer-easing": {
    "background": "hsl(0, 0%, 100%)"
  },
  ".prism-previewer-angle.prism-previewer-angle circle": {
    "stroke": "hsl(230, 8%, 24%)",
    "strokeOpacity": "1"
  },
  ".prism-previewer-time.prism-previewer-time circle": {
    "stroke": "hsl(230, 8%, 24%)",
    "strokeOpacity": "1"
  },
  ".prism-previewer-easing.prism-previewer-easing circle": {
    "stroke": "hsl(230, 8%, 24%)",
    "fill": "transparent"
  },
  ".prism-previewer-easing.prism-previewer-easing path": {
    "stroke": "hsl(230, 8%, 24%)"
  },
  ".prism-previewer-easing.prism-previewer-easing line": {
    "stroke": "hsl(230, 8%, 24%)"
  }
};

var css$V = ".CodeSnippet_module_root__96cf727a {\n  padding: 0.5rem, 1rem;\n  position: relative;\n}\n.CodeSnippet_module_root__96cf727a .CodeSnippet_module_code__96cf727a {\n  font-family: monospace;\n  font-size: 1rem;\n}\n.CodeSnippet_module_root__96cf727a .CodeSnippet_module_copy__96cf727a {\n  position: absolute;\n  right: 1rem;\n  top: 0.5rem;\n  cursor: pointer;\n}\n.CodeSnippet_module_root__96cf727a .CodeSnippet_module_copy__96cf727a .CodeSnippet_module_icon__96cf727a {\n  width: 1.5rem;\n  height: 1.5rem;\n}\n.CodeSnippet_module_root__96cf727a .CodeSnippet_module_copy__96cf727a .CodeSnippet_module_icon__96cf727a.CodeSnippet_module_dark__96cf727a {\n  fill: var(--white);\n}\n.CodeSnippet_module_root__96cf727a .CodeSnippet_module_copy__96cf727a .CodeSnippet_module_icon__96cf727a.CodeSnippet_module_light__96cf727a {\n  fill: var(--black);\n}\n.CodeSnippet_module_root__96cf727a .CodeSnippet_module_copy__96cf727a .CodeSnippet_module_notCopied__96cf727a {\n  display: none;\n}\n.CodeSnippet_module_root__96cf727a .CodeSnippet_module_copy__96cf727a .CodeSnippet_module_copied__96cf727a {\n  position: absolute;\n  right: 1.375rem;\n  top: 2.188rem;\n  padding: 0.5rem;\n  border-radius: 0.25rem;\n  background-color: var(--highlight);\n  color: var(--grey10);\n}";
var modules_c548043f = {"root":"CodeSnippet_module_root__96cf727a","code":"CodeSnippet_module_code__96cf727a","copy":"CodeSnippet_module_copy__96cf727a","icon":"CodeSnippet_module_icon__96cf727a","dark":"CodeSnippet_module_dark__96cf727a","light":"CodeSnippet_module_light__96cf727a","notCopied":"CodeSnippet_module_notCopied__96cf727a","copied":"CodeSnippet_module_copied__96cf727a"};
n(css$V,{});

var CodeSnippet = function CodeSnippet(props) {
  var copy = props.copy,
    code = props.code,
    language = props.language,
    showLineNumbers = props.showLineNumbers,
    theme = props.theme,
    className = props.className;
  var _useState = React.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    copiedState = _useState2[0],
    setCopiedState = _useState2[1];
  setTimeout(function () {
    setCopiedState(false);
  }, 2.0 * 1000);
  var onCopy = function onCopy() {
    navigator.clipboard.writeText(code);
    setCopiedState(true);
  };
  var syntaxHighlighterProps = {
    showLineNumbers: showLineNumbers,
    language: language,
    wrapLines: true,
    wrapLongLines: true,
    codeTagProps: {
      className: classes(modules_c548043f.code, className)
    },
    style: theme === 'light' ? oneLight : oneDark
  };
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: modules_c548043f.root,
    children: [/*#__PURE__*/jsxRuntime.jsx(SyntaxHighlighter, _objectSpread2(_objectSpread2({}, syntaxHighlighterProps), {}, {
      children: code
    })), copy && /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: modules_c548043f.copy,
      onClick: onCopy,
      children: [/*#__PURE__*/jsxRuntime.jsx(Copy, {
        className: classes(modules_c548043f.icon, theme === 'dark' ? modules_c548043f.dark : modules_c548043f.light)
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: copiedState ? modules_c548043f.copied : modules_c548043f.notCopied,
        children: copiedState ? 'Copied' : ''
      })]
    })]
  });
};
CodeSnippet.propTypes = {
  copy: propTypes$1.exports.bool,
  code: propTypes$1.exports.string,
  language: propTypes$1.exports.string,
  showLineNumbers: propTypes$1.exports.bool,
  theme: propTypes$1.exports.string,
  className: propTypes$1.exports.string
};
CodeSnippet.defaultProps = {
  copy: true,
  code: '{}',
  language: 'json',
  showLineNumbers: false,
  theme: 'light',
  className: ''
};

var useRowFilter = function useRowFilter(props) {
  var _props$initialState = props.initialState,
    initialState = _props$initialState === void 0 ? {} : _props$initialState,
    _props$length = props.length,
    length = _props$length === void 0 ? 0 : _props$length,
    tableData = props.tableData;
  var _useState = React.useState(function () {
      return _toConsumableArray$1(Array(length).keys()).fill(initialState);
    }),
    _useState2 = _slicedToArray(_useState, 2),
    filters = _useState2[0],
    setFilters = _useState2[1];
  React.useEffect(function () {
    setFilters(_toConsumableArray$1(Array(length).keys()).fill(initialState));
  }, [initialState, length, tableData]);

  /**
   *
   * @param {number} index - row index
   * @param {string} name - filter name / column id
   * @param {Array} value - filter value / checked items
   */
  var applyFilter = function applyFilter(index, name) {
    var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    setFilters(function (prevFilters) {
      var newFilters = cloneDeep(prevFilters);
      newFilters.splice(index, 1, _objectSpread2(_objectSpread2({}, newFilters[index]), {}, _defineProperty$1({}, name, value)));
      return newFilters;
    });
  };
  return {
    filters: filters,
    applyFilter: applyFilter
  };
};

var useOutsideClickListener = function useOutsideClickListener(ref, callback) {
  React.useEffect(function () {
    var handleClickOutside = function handleClickOutside(event) {
      if (ref.current && !ref.current.contains(event.target)) {
        callback();
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return function () {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [ref]);
};

var useResize = function useResize(props) {
  var ref = props.ref,
    _props$styles = props.styles,
    styles = _props$styles === void 0 ? {} : _props$styles,
    enabled = props.enabled;
  var minWidth = styles.minWidth,
    maxWidth = styles.maxWidth,
    borderSize = styles.borderSize;
  React.useEffect(function () {
    if (enabled) {
      var _ref$current, _ref$current$getBound, _ref$current3;
      var mPos = null;
      var itemRect = ref === null || ref === void 0 ? void 0 : (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : (_ref$current$getBound = _ref$current.getBoundingClientRect) === null || _ref$current$getBound === void 0 ? void 0 : _ref$current$getBound.call(_ref$current);
      var resize = function resize(event) {
        var dX = event.x - mPos;
        // eslint-disable-next-line no-param-reassign
        var newWidth = parseInt(itemRect.width, 10) + dX;
        if (newWidth > minWidth && newWidth < maxWidth && ref.current != null) {
          ref.current.style.width = "".concat(newWidth, "px");
        }
      };
      var onMouseDown = function onMouseDown(evt) {
        if (itemRect.width - evt.offsetX < borderSize) {
          mPos = evt.x;
          document.addEventListener('mousemove', resize);
        }
      };
      var onMouseUp = function onMouseUp(evt) {
        var _ref$current2, _ref$current2$getBoun, _ref$current2$getBoun2;
        mPos = evt.x;
        itemRect.width = ref === null || ref === void 0 ? void 0 : (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : (_ref$current2$getBoun = _ref$current2.getBoundingClientRect) === null || _ref$current2$getBoun === void 0 ? void 0 : (_ref$current2$getBoun2 = _ref$current2$getBoun.call(_ref$current2)) === null || _ref$current2$getBoun2 === void 0 ? void 0 : _ref$current2$getBoun2.width;
        document.removeEventListener('mousemove', resize);
      };
      ref === null || ref === void 0 ? void 0 : (_ref$current3 = ref.current) === null || _ref$current3 === void 0 ? void 0 : _ref$current3.addEventListener('mousedown', onMouseDown, false);
      document.documentElement.addEventListener('mouseup', onMouseUp, false);
      return function () {
        var _ref$current4, _ref$current4$removeE;
        ref === null || ref === void 0 ? void 0 : (_ref$current4 = ref.current) === null || _ref$current4 === void 0 ? void 0 : (_ref$current4$removeE = _ref$current4.removeEventListener) === null || _ref$current4$removeE === void 0 ? void 0 : _ref$current4$removeE.call(_ref$current4, 'mousedown', onMouseDown, false);
        document.documentElement.removeEventListener('mouseup', onMouseUp, false);
      };
    }
    return function () {};
  }, [enabled]);
};

var css$U = ".Header_module_container__26bf5a9c {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0rem 1.5625rem;\n}\n.Header_module_container__26bf5a9c .Header_module_title__26bf5a9c {\n  font-weight: 400;\n  font-size: 0.8rem;\n  color: var(--black);\n}\n.Header_module_container__26bf5a9c .Header_module_icon__26bf5a9c {\n  width: 1.5rem;\n  height: 1.5rem;\n  stroke: #181818;\n  cursor: pointer;\n}";
var modules_cf337dc1 = {"container":"Header_module_container__26bf5a9c","title":"Header_module_title__26bf5a9c","icon":"Header_module_icon__26bf5a9c"};
n(css$U,{});

var Header = function Header(props) {
  var selectedMonth = props.selectedMonth,
    onMonthChange = props.onMonthChange;
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: modules_cf337dc1.container,
    children: [/*#__PURE__*/jsxRuntime.jsx("div", {
      onClick: function onClick() {
        onMonthChange('prev');
      },
      className: modules_cf337dc1['left-arrow'],
      children: /*#__PURE__*/jsxRuntime.jsx(Chevron, {
        className: classes(modules_cf337dc1.icon),
        position: "left"
      })
    }), /*#__PURE__*/jsxRuntime.jsx("span", {
      className: modules_cf337dc1.title,
      children: "".concat(selectedMonth.month, " ").concat(selectedMonth.year)
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      onClick: function onClick() {
        onMonthChange('next');
      },
      className: modules_cf337dc1['right-arrow'],
      children: /*#__PURE__*/jsxRuntime.jsx(Chevron, {
        className: classes(modules_cf337dc1.icon),
        position: "right"
      })
    })]
  });
};

var css$T = ".Calender_module_root__5221cce4 {\n  padding: 1rem 0rem;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}";
var modules_3722b5cd = {"root":"Calender_module_root__5221cce4"};
n(css$T,{});

var css$S = ".Body_module_root__85b1b679 {\n  padding: 0.5rem 0.5rem;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  align-items: stretch;\n}";
var modules_e6b80d99 = {"root":"Body_module_root__85b1b679"};
n(css$S,{});

var css$R = ".Dates_module_dates__e964f6bf {\n  display: grid;\n  grid-template-columns: repeat(7, 1fr);\n  align-items: center;\n  flex-wrap: wrap;\n}\n.Dates_module_dates__e964f6bf div {\n  flex-basis: 14.28%;\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  margin-bottom: 0.25rem;\n  cursor: pointer;\n  align-self: center;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.Dates_module_dates__e964f6bf div .Dates_module_date__e964f6bf {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  text-align: center;\n  vertical-align: middle;\n  border-radius: 1.5rem;\n  height: 2.5rem;\n  width: 2.5rem;\n  font-weight: 400;\n  font-size: 0.875rem;\n  color: var(--black);\n}\n.Dates_module_dates__e964f6bf div .Dates_module_selected__e964f6bf {\n  background-color: var(--highlight);\n  color: var(--white);\n}\n.Dates_module_dates__e964f6bf div .Dates_module_unSelected__e964f6bf {\n  background-color: var(--white);\n  border-color: var(--highlight);\n  border-width: 0.125rem;\n  border-style: solid;\n  color: var(--black);\n}\n.Dates_module_dates__e964f6bf div .Dates_module_disabled__e964f6bf {\n  border-radius: 1.5rem;\n  color: var(--grey2);\n}\n.Dates_module_dates__e964f6bf div .Dates_module_diffMonth__e964f6bf {\n  opacity: 0.6;\n}\n.Dates_module_dates__e964f6bf div:hover .Dates_module_date__e964f6bf {\n  background: var(--background);\n  color: var(--highlight);\n  box-shadow: -2px -2px 4px rgba(166, 166, 166, 0.25), 2px 2px 4px rgba(166, 166, 166, 0.24);\n}\n.Dates_module_dates__e964f6bf div:hover .Dates_module_selected__e964f6bf {\n  background-color: var(--highlight);\n  color: var(--white);\n}\n.Dates_module_dates__e964f6bf div:hover .Dates_module_disabled__e964f6bf {\n  background: transparent;\n  box-shadow: none;\n  border-radius: 1.5rem;\n  color: var(--grey2);\n}\n.Dates_module_dates__e964f6bf .Dates_module_minInRange__e964f6bf {\n  background-color: var(--highlight);\n  border-radius: 1.5rem 0rem 0rem 1.5rem;\n}\n.Dates_module_dates__e964f6bf .Dates_module_minInRange__e964f6bf .Dates_module_date__e964f6bf {\n  color: var(--white);\n}\n.Dates_module_dates__e964f6bf .Dates_module_minInRange__e964f6bf:hover .Dates_module_date__e964f6bf {\n  background: var(--highlight);\n  color: var(--white);\n  box-shadow: -2px -2px 4px rgba(166, 166, 166, 0.25), 2px 2px 4px rgba(166, 166, 166, 0.24);\n}\n.Dates_module_dates__e964f6bf .Dates_module_maxInRange__e964f6bf {\n  background-color: var(--highlight);\n  border-radius: 0rem 1.5rem 1.5rem 0rem;\n}\n.Dates_module_dates__e964f6bf .Dates_module_maxInRange__e964f6bf .Dates_module_date__e964f6bf {\n  color: var(--white);\n}\n.Dates_module_dates__e964f6bf .Dates_module_maxInRange__e964f6bf:hover .Dates_module_date__e964f6bf {\n  background: var(--highlight);\n  color: var(--white);\n  box-shadow: -2px -2px 4px rgba(166, 166, 166, 0.25), 2px 2px 4px rgba(166, 166, 166, 0.24);\n}\n.Dates_module_dates__e964f6bf .Dates_module_midInRange__e964f6bf {\n  background: var(--background);\n  border-radius: 0rem;\n}\n.Dates_module_dates__e964f6bf .Dates_module_midInRange__e964f6bf .Dates_module_date__e964f6bf {\n  color: var(--highlight);\n}\n.Dates_module_dates__e964f6bf .Dates_module_midInRangeSelected__e964f6bf {\n  background: var(--background);\n  border-radius: 0rem;\n}\n.Dates_module_dates__e964f6bf .Dates_module_midInRangeSelected__e964f6bf .Dates_module_date__e964f6bf {\n  color: var(--white);\n}\n.Dates_module_dates__e964f6bf .Dates_module_firstHovered__e964f6bf {\n  background: var(--background);\n  border-radius: 0rem 1.5rem 1.5rem 0rem;\n}\n.Dates_module_dates__e964f6bf .Dates_module_firstHovered__e964f6bf .Dates_module_date__e964f6bf {\n  color: var(--highlight);\n}\n.Dates_module_dates__e964f6bf .Dates_module_lastHovered__e964f6bf {\n  background: var(--background);\n  border-radius: 1.5rem 0rem 0rem 1.5rem;\n}\n.Dates_module_dates__e964f6bf .Dates_module_lastHovered__e964f6bf .Dates_module_date__e964f6bf {\n  color: var(--highlight);\n}";
var modules_b02dadcc = {"dates":"Dates_module_dates__e964f6bf","date":"Dates_module_date__e964f6bf","selected":"Dates_module_selected__e964f6bf","unSelected":"Dates_module_unSelected__e964f6bf","disabled":"Dates_module_disabled__e964f6bf","diffMonth":"Dates_module_diffMonth__e964f6bf","minInRange":"Dates_module_minInRange__e964f6bf","maxInRange":"Dates_module_maxInRange__e964f6bf","midInRange":"Dates_module_midInRange__e964f6bf","midInRangeSelected":"Dates_module_midInRangeSelected__e964f6bf","first-hovered":"Dates_module_firstHovered__e964f6bf","last-hovered":"Dates_module_lastHovered__e964f6bf"};
n(css$R,{});

var getDatesOfLastWeekOfLastMonth = function getDatesOfLastWeekOfLastMonth(_ref) {
  var monthAsNumber = _ref.monthAsNumber,
    year = _ref.year,
    remainingDaysInFirstWeek = _ref.remainingDaysInFirstWeek;
  if (remainingDaysInFirstWeek === 0) {
    return [];
  }
  var month;
  var fullYear;
  if (monthAsNumber === 0) {
    month = 11;
    fullYear = year - 1;
  } else {
    month = monthAsNumber - 1;
    fullYear = year;
  }
  var _getDatesInAMonth = getDatesInAMonth({
      month: month,
      year: fullYear
    }),
    dateObj = _getDatesInAMonth.dateObj;
  return dateObj.slice(-remainingDaysInFirstWeek);
};
var getDatesOfFirstWeekOfNextMonth = function getDatesOfFirstWeekOfNextMonth(_ref2) {
  var monthAsNumber = _ref2.monthAsNumber,
    year = _ref2.year,
    remainingDaysInLastWeek = _ref2.remainingDaysInLastWeek;
  var month;
  var fullYear;
  if (monthAsNumber === 11) {
    month = 0;
    fullYear = year + 1;
  } else {
    month = monthAsNumber + 1;
    fullYear = year;
  }
  var _getDatesInAMonth2 = getDatesInAMonth({
      month: month,
      year: fullYear
    }),
    dateObj = _getDatesInAMonth2.dateObj;
  return dateObj.slice(0, remainingDaysInLastWeek);
};
var getDatesToDisplay = function getDatesToDisplay(_ref3) {
  var monthAsNumber = _ref3.monthAsNumber,
    year = _ref3.year,
    days = _ref3.days,
    dateObj = _ref3.dateObj;
  var _days = _slicedToArray(days, 1),
    firstDay = _days[0];
  var dates = [].concat(_toConsumableArray$1(getDatesOfLastWeekOfLastMonth({
    monthAsNumber: monthAsNumber,
    year: year,
    remainingDaysInFirstWeek: firstDay
  })), _toConsumableArray$1(dateObj), _toConsumableArray$1(getDatesOfFirstWeekOfNextMonth({
    monthAsNumber: monthAsNumber,
    year: year,
    remainingDaysInLastWeek: 7 - (days[days.length - 1] + 1)
  })));
  return dates;
};
var rangeSelection = function rangeSelection(_ref4) {
  var _MONTHS$date$getMonth, _selectedRange$unix, _selectedRange$dates, _selectedRange$unix3, _selectedRange$unix4, _selectedRange$unix5, _selectedRange$unix7;
  var selectedRange = _ref4.selectedRange,
    date = _ref4.date;
  var dateAsNumber = date === null || date === void 0 ? void 0 : date.getDate();
  var month = (_MONTHS$date$getMonth = MONTHS[date === null || date === void 0 ? void 0 : date.getMonth()]) === null || _MONTHS$date$getMonth === void 0 ? void 0 : _MONTHS$date$getMonth.substring(0, 3);
  var year = date === null || date === void 0 ? void 0 : date.getFullYear();
  if (((_selectedRange$unix = selectedRange.unix) === null || _selectedRange$unix === void 0 ? void 0 : _selectedRange$unix[0]) === getUnixTime(date)) {
    return {
      dates: [],
      unix: []
    };
  }
  if (((_selectedRange$dates = selectedRange.dates) === null || _selectedRange$dates === void 0 ? void 0 : _selectedRange$dates.length) < 2) {
    var _selectedRange$dates2, _selectedRange$unix2;
    if (((_selectedRange$dates2 = selectedRange.dates) === null || _selectedRange$dates2 === void 0 ? void 0 : _selectedRange$dates2.length) === 1 && isBefore(date, fromUnixTime((_selectedRange$unix2 = selectedRange.unix) === null || _selectedRange$unix2 === void 0 ? void 0 : _selectedRange$unix2[0]))) {
      return {
        dates: ["".concat(dateAsNumber, " ").concat(month, " ").concat(year)].concat(_toConsumableArray$1(selectedRange.dates)),
        unix: [getUnixTime(date)].concat(_toConsumableArray$1(selectedRange.unix))
      };
    }
    return {
      dates: [].concat(_toConsumableArray$1(selectedRange.dates), ["".concat(dateAsNumber, " ").concat(month, " ").concat(year)]),
      unix: [].concat(_toConsumableArray$1(selectedRange.unix), [getUnixTime(date)])
    };
  }
  if ((isBefore(date, fromUnixTime((_selectedRange$unix3 = selectedRange.unix) === null || _selectedRange$unix3 === void 0 ? void 0 : _selectedRange$unix3[1])) || isAfter(date, fromUnixTime((_selectedRange$unix4 = selectedRange.unix) === null || _selectedRange$unix4 === void 0 ? void 0 : _selectedRange$unix4[1]))) && isAfter(date, fromUnixTime((_selectedRange$unix5 = selectedRange.unix) === null || _selectedRange$unix5 === void 0 ? void 0 : _selectedRange$unix5[0]))) {
    var _selectedRange$dates3, _selectedRange$unix6;
    return {
      dates: [(_selectedRange$dates3 = selectedRange.dates) === null || _selectedRange$dates3 === void 0 ? void 0 : _selectedRange$dates3[0], "".concat(dateAsNumber, " ").concat(month, " ").concat(year)],
      unix: [(_selectedRange$unix6 = selectedRange.unix) === null || _selectedRange$unix6 === void 0 ? void 0 : _selectedRange$unix6[0], getUnixTime(date)]
    };
  }
  if (isBefore(date, fromUnixTime((_selectedRange$unix7 = selectedRange.unix) === null || _selectedRange$unix7 === void 0 ? void 0 : _selectedRange$unix7[0]))) {
    var _selectedRange$dates4, _selectedRange$unix8;
    return {
      dates: ["".concat(dateAsNumber, " ").concat(month, " ").concat(year), (_selectedRange$dates4 = selectedRange.dates) === null || _selectedRange$dates4 === void 0 ? void 0 : _selectedRange$dates4[1]],
      unix: [getUnixTime(date), (_selectedRange$unix8 = selectedRange.unix) === null || _selectedRange$unix8 === void 0 ? void 0 : _selectedRange$unix8[1]]
    };
  }
  return {
    dates: [],
    unix: []
  };
};

var Dates = function Dates(props) {
  var selectedMonth = props.selectedMonth,
    selectedDate = props.selectedDate,
    setSelectedDate = props.setSelectedDate,
    range = props.range,
    selectedRange = props.selectedRange,
    setSelectedRange = props.setSelectedRange,
    disabledDates = props.disabledDates,
    disableDatesBefore = props.disableDatesBefore;
  var monthAsNumber = selectedMonth.monthAsNumber,
    year = selectedMonth.year;
  var _useState = React.useState(function () {
      return [];
    }),
    _useState2 = _slicedToArray(_useState, 2),
    datesToDisplay = _useState2[0],
    setDatesToDisplay = _useState2[1];
  var _useState3 = React.useState(function () {
      return null;
    }),
    _useState4 = _slicedToArray(_useState3, 2),
    unSelectedDate = _useState4[0],
    setUnSelectedDate = _useState4[1];
  var _useState5 = React.useState(function () {
      return null;
    }),
    _useState6 = _slicedToArray(_useState5, 2),
    hoveredEndingDate = _useState6[0],
    setHoveredEndingDate = _useState6[1];
  var _useState7 = React.useState(function () {
      return getDatesInAMonth({
        month: monthAsNumber,
        year: year
      });
    }),
    _useState8 = _slicedToArray(_useState7, 2),
    datesInMonth = _useState8[0],
    setDatesInMonth = _useState8[1];
  var days = datesInMonth.days,
    dateObj = datesInMonth.dateObj;
  React.useEffect(function () {
    setDatesInMonth(getDatesInAMonth({
      month: monthAsNumber,
      year: year
    }));
    setUnSelectedDate(null);
  }, [selectedMonth]);
  React.useEffect(function () {
    setDatesToDisplay(getDatesToDisplay({
      monthAsNumber: monthAsNumber,
      year: year,
      days: days,
      dateObj: dateObj
    }));
  }, [days]);
  var dateSelection = function dateSelection(date) {
    if (range) {
      setHoveredEndingDate(null);
      setSelectedRange(rangeSelection({
        selectedMonth: selectedMonth,
        selectedRange: selectedRange,
        date: date
      }));
      return;
    }
    var dateAsNumber = date.getDate();
    if (selectedDate.date === dateAsNumber) {
      setSelectedDate({});
      setUnSelectedDate(date.toISOString());
      return;
    }
    setUnSelectedDate(null);
    setSelectedDate(_objectSpread2(_objectSpread2({}, selectedDate), {}, {
      month: selectedMonth.month,
      year: selectedMonth.year,
      date: dateAsNumber,
      unix: getUnixTime(date.setHours(23, 59, 59, 59))
    }));
  };
  var onMouseEnterADate = function onMouseEnterADate(date) {
    var _selectedRange$unix;
    if (range && ((_selectedRange$unix = selectedRange.unix) === null || _selectedRange$unix === void 0 ? void 0 : _selectedRange$unix.length) === 1) {
      setHoveredEndingDate(getUnixTime(date));
    }
  };
  var disabledBeforeDate = function disabledBeforeDate(date) {
    return (disableDatesBefore === null || disableDatesBefore === void 0 ? void 0 : disableDatesBefore.length) > 0 && isBefore(date, fromUnixTime(disableDatesBefore));
  };
  var disabledAfterDate = function disabledAfterDate(date) {
    var dObj = new Date();
    dObj.setDate(dObj.getDate() + 1);
    dObj.setHours(0, 0, 0, 0);
    return isAfter(date, dObj);
  };
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: modules_b02dadcc.dates,
    children: datesToDisplay.map(function (date) {
      var _selectedRange$unix2;
      var dateNumber = date === null || date === void 0 ? void 0 : date.getDate();
      var selectedSingleDate = isSameDay(fromUnixTime(selectedDate.unix), date);
      var _ref = (_selectedRange$unix2 = selectedRange.unix) !== null && _selectedRange$unix2 !== void 0 ? _selectedRange$unix2 : [],
        _ref2 = _slicedToArray(_ref, 2),
        firstItem = _ref2[0],
        lastItem = _ref2[1];
      var isFirstItem = isSameDay(fromUnixTime(firstItem), date);
      var isLastItem = isSameDay(fromUnixTime(lastItem), date);
      var isLastItemHovered = hoveredEndingDate === getUnixTime(date);
      var isFirstItemHovered = isBefore(date, fromUnixTime(firstItem)) && hoveredEndingDate === getUnixTime(date);
      var notSameMonth = date.getMonth() !== monthAsNumber;
      var isUnSelected = unSelectedDate === date.toISOString();
      var disabled = disabledDates.includes(date.toDateString()) || disabledBeforeDate(date) || disabledAfterDate(date);
      var isDisabled = disabled;
      var isHoveringBeforeSelectedDate = isBefore(fromUnixTime(hoveredEndingDate), fromUnixTime(firstItem));
      var isMidItem;
      if (hoveredEndingDate) {
        isMidItem = isBefore(date, fromUnixTime(hoveredEndingDate)) && isAfter(date, fromUnixTime(firstItem)) || isAfter(date, fromUnixTime(hoveredEndingDate)) && isBefore(date, fromUnixTime(firstItem));
      } else {
        isMidItem = isBefore(date, fromUnixTime(lastItem).setHours(0, 0, 0, 0)) && isAfter(date, fromUnixTime(firstItem).setHours(23, 59, 59, 59));
      }
      var parentClassNames = classes(isMidItem ? selectedSingleDate ? modules_b02dadcc.midInRangeSelected : modules_b02dadcc.midInRange : '', isFirstItem ? isHoveringBeforeSelectedDate ? modules_b02dadcc.maxInRange : modules_b02dadcc.minInRange : '', isLastItem ? modules_b02dadcc.maxInRange : '', isLastItemHovered ? modules_b02dadcc['first-hovered'] : '', isFirstItemHovered ? modules_b02dadcc['last-hovered'] : '');
      var childClassNames = classes(date ? modules_b02dadcc.date : '', selectedSingleDate ? modules_b02dadcc.selected : '', isUnSelected ? modules_b02dadcc.unSelected : '', notSameMonth ? modules_b02dadcc.diffMonth : '', isDisabled ? modules_b02dadcc.disabled : '');
      return /*#__PURE__*/jsxRuntime.jsx("div", {
        className: parentClassNames,
        onClick: function onClick() {
          if (!isDisabled) {
            dateSelection(date);
          }
        },
        onMouseEnter: function onMouseEnter() {
          onMouseEnterADate(date);
        },
        children: /*#__PURE__*/jsxRuntime.jsx("span", {
          className: childClassNames,
          children: dateNumber
        })
      }, date.toDateString());
    })
  });
};

var css$Q = ".Days_module_days__0d7923fd {\n  display: grid;\n  grid-template-columns: repeat(7, 1fr);\n  text-align: center;\n}\n.Days_module_days__0d7923fd span {\n  padding: 0.75rem 0.5rem;\n  font-weight: 500;\n  font-size: 0.875rem;\n  color: black;\n  flex-basis: 14.28%;\n}";
var modules_82c45006 = {"days":"Days_module_days__0d7923fd"};
n(css$Q,{});

var Days = function Days() {
  var daysInWeek = DAYS;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: modules_82c45006.days,
    children: daysInWeek.map(function (day) {
      return /*#__PURE__*/jsxRuntime.jsx("span", {
        children: day
      }, day);
    })
  });
};

var Body = function Body(props) {
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: modules_e6b80d99.root,
    children: [/*#__PURE__*/jsxRuntime.jsx(Days, {}), /*#__PURE__*/jsxRuntime.jsx(Dates, _objectSpread2({}, props))]
  });
};

var css$P = ".TextField_module_root__9cc1db47 {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: flex-start;\n  gap: 0.5rem;\n}\n.TextField_module_root__9cc1db47 label {\n  width: 100%;\n  max-width: 100%;\n  font-weight: 400;\n  font-size: 0.75rem;\n  line-height: 1.125rem;\n  letter-spacing: 0.32px;\n  color: var(--grey);\n  height: 100%;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47 {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0rem 0.5rem;\n  max-width: 100%;\n  width: 100%;\n  border-color: var(--grey4);\n  border-style: solid;\n  border-radius: 0.25rem;\n  height: 100%;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47 .TextField_module_icon__9cc1db47 {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47 > [data-elem*=component] {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47 > [data-elem=component2] {\n  flex: 1;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47 > [data-elem=component2] .TextField_module_input__9cc1db47 {\n  -moz-appearance: textfield;\n  flex: 1;\n  background-color: transparent;\n  border: none;\n  font-weight: 400;\n  font-size: 0.875rem;\n  line-height: 1.125rem;\n  letter-spacing: 0.16px;\n  color: var(--black);\n  width: 100%;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47 > [data-elem=component2] .TextField_module_input__9cc1db47::-webkit-outer-spin-button, .TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47 > [data-elem=component2] .TextField_module_input__9cc1db47::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47 > [data-elem=component2] .TextField_module_input__9cc1db47:focus {\n  outline: none;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47 > [data-elem=component2] .TextField_module_input__9cc1db47:disabled {\n  background: var(--grey9);\n  color: var(--grey3);\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47 > [data-elem=component2] .TextField_module_input__9cc1db47.TextField_module_sm__9cc1db47 {\n  padding: 0.5rem 0rem;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47 > [data-elem=component2] .TextField_module_input__9cc1db47.TextField_module_md__9cc1db47 {\n  padding: 0.688rem 0rem;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47 > [data-elem=component2] .TextField_module_input__9cc1db47.TextField_module_lg__9cc1db47 {\n  padding: 1rem 0rem;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47.TextField_module_typeTextarea__9cc1db47 {\n  padding: 0;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47.TextField_module_typeTextarea__9cc1db47 > [data-elem=component2] .TextField_module_input__9cc1db47 {\n  resize: vertical;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47.TextField_module_typeTextarea__9cc1db47 > [data-elem=component2] .TextField_module_input__9cc1db47.TextField_module_md__9cc1db47 {\n  padding: 0.313rem 0.75rem;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47.TextField_module_typeTextarea__9cc1db47 > [data-elem=component2] .TextField_module_input__9cc1db47.TextField_module_lg__9cc1db47 {\n  padding: 0.5rem 1rem;\n  font-size: 1rem;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47:focus-within {\n  border: 0.063rem solid var(--info);\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47:focus-within.TextField_module_feedbackError__9cc1db47 {\n  border-color: var(--error);\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47.TextField_module_borderDefault__9cc1db47 {\n  border-width: 0.063rem;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47.TextField_module_borderBottom__9cc1db47 {\n  border-width: 0rem 0rem 0.063rem 0rem;\n}\n.TextField_module_root__9cc1db47 label .TextField_module_inputWrapper__9cc1db47.TextField_module_borderNone__9cc1db47 {\n  border-width: 0rem;\n}\n.TextField_module_root__9cc1db47 .TextField_module_bottom__9cc1db47 {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: flex-start;\n  min-height: 2rem;\n  width: 100%;\n  gap: 1rem;\n  color: var(--grey3);\n  font-size: 0.75rem;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.TextField_module_root__9cc1db47 .TextField_module_bottom__9cc1db47 .TextField_module_feedback__9cc1db47 {\n  flex: 1;\n  margin-right: auto;\n}\n.TextField_module_root__9cc1db47 .TextField_module_bottom__9cc1db47 .TextField_module_feedback__9cc1db47.TextField_module_feedbackError__9cc1db47 {\n  color: var(--error);\n  fill: var(--error);\n}\n.TextField_module_root__9cc1db47 .TextField_module_bottom__9cc1db47 .TextField_module_feedback__9cc1db47.TextField_module_feedbackSuccess__9cc1db47 {\n  color: var(--success);\n  fill: var(--success);\n}\n.TextField_module_root__9cc1db47 .TextField_module_bottom__9cc1db47 .TextField_module_count__9cc1db47 {\n  text-align: right;\n  margin-left: auto;\n}\n.TextField_module_root__9cc1db47 .TextField_module_bottom__9cc1db47 .TextField_module_count__9cc1db47.TextField_module_exceeded__9cc1db47 {\n  color: var(--error);\n}";
var modules_c1d23762 = {"root":"TextField_module_root__9cc1db47","input-wrapper":"TextField_module_inputWrapper__9cc1db47","icon":"TextField_module_icon__9cc1db47","input":"TextField_module_input__9cc1db47","sm":"TextField_module_sm__9cc1db47","md":"TextField_module_md__9cc1db47","lg":"TextField_module_lg__9cc1db47","type-textarea":"TextField_module_typeTextarea__9cc1db47","feedback-error":"TextField_module_feedbackError__9cc1db47","border-default":"TextField_module_borderDefault__9cc1db47","border-bottom":"TextField_module_borderBottom__9cc1db47","border-none":"TextField_module_borderNone__9cc1db47","bottom":"TextField_module_bottom__9cc1db47","feedback":"TextField_module_feedback__9cc1db47","feedback-success":"TextField_module_feedbackSuccess__9cc1db47","count":"TextField_module_count__9cc1db47","exceeded":"TextField_module_exceeded__9cc1db47"};
n(css$P,{});

var TextField = /*#__PURE__*/React.forwardRef(function TextField(props, inputRef) {
  var _inputValue$length;
  var id = props.id,
    name = props.name,
    label = props.label,
    placeholder = props.placeholder,
    type = props.type,
    value = props.value,
    defaultValue = props.defaultValue,
    onBlur = props.onBlur,
    onChange = props.onChange,
    size = props.size,
    border = props.border,
    LeftComponent = props.LeftComponent,
    RightComponent = props.RightComponent,
    className = props.className,
    disabled = props.disabled,
    inputProps = props.inputProps,
    feedback = props.feedback,
    count = props.count,
    feedbackAndCount = props.feedbackAndCount,
    maxLength = props.maxLength,
    onKeyDown = props.onKeyDown;
  var _useRef = React.useRef(value !== undefined),
    isControlled = _useRef.current;

  // for uncontrolled input
  var _useState = React.useState(defaultValue),
    _useState2 = _slicedToArray(_useState, 2),
    uncontrolledValue = _useState2[0],
    setUncontrolledValue = _useState2[1];
  var handleChange = function handleChange(event) {
    var _inputHelper = inputHelper(event),
      fieldValue = _inputHelper.fieldValue;
    if (isControlled) {
      onChange(event, fieldValue);
    } else {
      setUncontrolledValue(fieldValue);
    }
  };
  var inputValue = isControlled ? value !== null && value !== void 0 ? value : '' : uncontrolledValue;
  var Input = /*#__PURE__*/React.createElement(type === 'textarea' ? 'textarea' : 'input', _objectSpread2(_objectSpread2({
    id: id,
    name: name,
    disabled: disabled,
    type: type,
    defaultValue: defaultValue,
    placeholder: placeholder
  }, maxLength !== null && {
    maxLength: maxLength
  }), {}, {
    onBlur: onBlur,
    onKeyDown: onKeyDown,
    'data-elem': 'input',
    ref: inputRef,
    value: inputValue,
    onChange: handleChange,
    className: classes(modules_c1d23762[size], modules_c1d23762.input)
  }, inputProps));
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(modules_c1d23762.root, className),
    children: [/*#__PURE__*/jsxRuntime.jsxs("label", {
      children: [label, /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
        className: classes(modules_c1d23762['input-wrapper'], modules_c1d23762["border-".concat(border)], modules_c1d23762["type-".concat(type)], feedback != null ? modules_c1d23762["feedback-".concat(feedback === null || feedback === void 0 ? void 0 : feedback.type)] : ''),
        component1: LeftComponent && /*#__PURE__*/jsxRuntime.jsx(LeftComponent, {}),
        component2: Input,
        component3: RightComponent && /*#__PURE__*/jsxRuntime.jsx(RightComponent, {})
      })]
    }), feedbackAndCount && /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: modules_c1d23762.bottom,
      children: [feedback != null && /*#__PURE__*/jsxRuntime.jsx("div", {
        "data-elem": "feedback",
        className: classes(modules_c1d23762.feedback, modules_c1d23762["feedback-".concat(feedback.type)]),
        children: feedback.text
      }), (count === null || count === void 0 ? void 0 : count.limit) != null && /*#__PURE__*/jsxRuntime.jsxs("div", {
        "data-elem": "count",
        className: classes(modules_c1d23762.count, (inputValue === null || inputValue === void 0 ? void 0 : inputValue.length) > count.limit ? modules_c1d23762.exceeded : ''),
        children: [(_inputValue$length = inputValue.length) !== null && _inputValue$length !== void 0 ? _inputValue$length : 0, "/", count.limit]
      })]
    })]
  });
});
TextField.propTypes = {
  id: propTypes$1.exports.string,
  name: propTypes$1.exports.string,
  disabled: propTypes$1.exports.bool,
  label: propTypes$1.exports.oneOfType([propTypes$1.exports.string, propTypes$1.exports.number]),
  placeholder: propTypes$1.exports.oneOfType([propTypes$1.exports.string, propTypes$1.exports.number]),
  type: propTypes$1.exports.oneOf(['text', 'email', 'password', 'number', 'textarea']),
  value: propTypes$1.exports.oneOfType([propTypes$1.exports.string, propTypes$1.exports.number]),
  defaultValue: propTypes$1.exports.string,
  onChange: propTypes$1.exports.func,
  size: propTypes$1.exports.oneOf(['sm', 'md', 'lg']),
  border: propTypes$1.exports.oneOf(['default', 'bottom', 'none']),
  LeftComponent: propTypes$1.exports.node,
  RightComponent: propTypes$1.exports.node,
  // eslint-disable-next-line react/forbid-prop-types
  inputProps: propTypes$1.exports.object,
  count: propTypes$1.exports.shape({
    limit: propTypes$1.exports.number
  }),
  feedback: propTypes$1.exports.shape({
    text: propTypes$1.exports.node,
    type: propTypes$1.exports.oneOf(['error', 'success', 'default'])
  }),
  feedbackAndCount: propTypes$1.exports.bool,
  maxLength: propTypes$1.exports.number,
  onKeyDown: propTypes$1.exports.func
};
TextField.defaultProps = {
  id: null,
  name: null,
  disabled: false,
  label: '',
  placeholder: '',
  type: 'text',
  value: undefined,
  defaultValue: '',
  onChange: function onChange() {},
  size: 'md',
  border: 'default',
  LeftComponent: null,
  RightComponent: null,
  inputProps: {},
  count: null,
  feedback: null,
  feedbackAndCount: false,
  maxLength: null,
  onKeyDown: function onKeyDown() {}
};

var css$O = ".CheckBox_module_root__82d23531 {\n  cursor: pointer;\n  gap: 10px;\n}\n.CheckBox_module_root__82d23531.CheckBox_module_positionLeft__82d23531 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n}\n.CheckBox_module_root__82d23531.CheckBox_module_positionRight__82d23531 {\n  display: flex;\n  flex-direction: row-reverse;\n  justify-content: flex-end;\n  align-items: center;\n}\n.CheckBox_module_root__82d23531 input[type=checkbox] {\n  opacity: 0;\n  z-index: 1;\n  position: absolute;\n  width: 1px;\n  height: 1px;\n}\n.CheckBox_module_root__82d23531.CheckBox_module_disabled__82d23531 {\n  cursor: default;\n}\n.CheckBox_module_root__82d23531 .CheckBox_module_icon__82d23531 {\n  display: inline-block;\n  border-radius: 0.375rem;\n}\n.CheckBox_module_root__82d23531 .CheckBox_module_icon__82d23531.CheckBox_module_iconSm__82d23531 {\n  width: 1rem;\n  height: 1rem;\n}\n.CheckBox_module_root__82d23531 .CheckBox_module_icon__82d23531.CheckBox_module_iconMd__82d23531 {\n  width: 1.25rem;\n  height: 1.25rem;\n}\n.CheckBox_module_root__82d23531 .CheckBox_module_icon__82d23531.CheckBox_module_iconLg__82d23531 {\n  width: 1.5rem;\n  height: 1.5rem;\n}\n.CheckBox_module_root__82d23531 input:focus + .CheckBox_module_icon__82d23531 {\n  box-shadow: 0px 0px 0px 8px rgba(15, 98, 254, 0.125);\n}\n.CheckBox_module_root__82d23531 [data-elem=label] {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}";
var modules_066398a2 = {"root":"CheckBox_module_root__82d23531","position-left":"CheckBox_module_positionLeft__82d23531","position-right":"CheckBox_module_positionRight__82d23531","disabled":"CheckBox_module_disabled__82d23531","icon":"CheckBox_module_icon__82d23531","icon-sm":"CheckBox_module_iconSm__82d23531","icon-md":"CheckBox_module_iconMd__82d23531","icon-lg":"CheckBox_module_iconLg__82d23531"};
n(css$O,{});

var Checkbox = function Checkbox(props) {
  // eslint-disable-next-line object-curly-newline
  var label = props.label,
    onChange = props.onChange,
    defaultChecked = props.defaultChecked,
    checked = props.checked,
    position = props.position,
    size = props.size,
    className = props.className,
    disabled = props.disabled;
  var _useRef = React.useRef(checked !== undefined),
    isControlled = _useRef.current;

  // for uncontrolled input
  var _useState = React.useState(defaultChecked),
    _useState2 = _slicedToArray(_useState, 2),
    uncontrolledChecked = _useState2[0],
    setUncontrolledChecked = _useState2[1];
  var handleChange = function handleChange(event) {
    var _inputHelper = inputHelper(event),
      fieldValue = _inputHelper.fieldValue;
    if (isControlled) {
      onChange(event, fieldValue);
    } else {
      setUncontrolledChecked(fieldValue);
    }
  };
  var isChecked = isControlled ? checked : uncontrolledChecked;
  return /*#__PURE__*/jsxRuntime.jsxs("label", {
    className: classes(modules_066398a2.root, modules_066398a2["position-".concat(position)], className, disabled ? modules_066398a2.disabled : ''),
    children: [/*#__PURE__*/jsxRuntime.jsx("input", _objectSpread2(_objectSpread2({
      disabled: disabled,
      type: "checkbox",
      defaultChecked: defaultChecked
    }, isControlled ? {
      checked: checked
    } : {}), {}, {
      onChange: handleChange
    })), isChecked ? /*#__PURE__*/jsxRuntime.jsx(CheckboxIcon.Checked, {
      "data-elem": "icon",
      className: classes(modules_066398a2["icon-".concat(size)], modules_066398a2.icon)
    }) : /*#__PURE__*/jsxRuntime.jsx(CheckboxIcon.UnChecked, {
      "data-elem": "icon",
      className: classes(modules_066398a2["icon-".concat(size)], modules_066398a2.icon)
    }), label && /*#__PURE__*/jsxRuntime.jsx("span", {
      "data-elem": "label",
      children: label
    })]
  });
};
Checkbox.propTypes = {
  disabled: propTypes$1.exports.bool,
  label: propTypes$1.exports.string,
  defaultChecked: propTypes$1.exports.bool,
  checked: propTypes$1.exports.bool,
  position: propTypes$1.exports.oneOf(['left', 'right']),
  size: propTypes$1.exports.oneOf(['sm', 'md', 'lg']),
  onChange: propTypes$1.exports.func
};
Checkbox.defaultProps = {
  disabled: false,
  label: null,
  defaultChecked: false,
  checked: undefined,
  position: 'right',
  size: 'sm',
  onChange: function onChange() {}
};

var css$N = ".Radio_module_root__0f04dc19 {\n  cursor: pointer;\n  gap: 10px;\n}\n.Radio_module_root__0f04dc19.Radio_module_positionLeft__0f04dc19 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n}\n.Radio_module_root__0f04dc19.Radio_module_positionRight__0f04dc19 {\n  display: flex;\n  flex-direction: row-reverse;\n  justify-content: flex-end;\n  align-items: center;\n}\n.Radio_module_root__0f04dc19.Radio_module_disabled__0f04dc19 {\n  cursor: default;\n}\n.Radio_module_root__0f04dc19 input[type=radio] {\n  opacity: 0;\n  z-index: 1;\n  position: absolute;\n  width: 1px;\n  height: 1px;\n}\n.Radio_module_root__0f04dc19 .Radio_module_icon__0f04dc19 {\n  display: inline-block;\n  border-radius: 50%;\n}\n.Radio_module_root__0f04dc19 .Radio_module_icon__0f04dc19.Radio_module_iconSm__0f04dc19 {\n  width: 1rem;\n  height: 1rem;\n}\n.Radio_module_root__0f04dc19 .Radio_module_icon__0f04dc19.Radio_module_iconMd__0f04dc19 {\n  width: 1.25rem;\n  height: 1.25rem;\n}\n.Radio_module_root__0f04dc19 .Radio_module_icon__0f04dc19.Radio_module_iconLg__0f04dc19 {\n  width: 1.5rem;\n  height: 2rem;\n}\n.Radio_module_root__0f04dc19 input:focus + .Radio_module_icon__0f04dc19 {\n  box-shadow: 0px 0px 0px 8px rgba(15, 98, 254, 0.125);\n}\n.Radio_module_root__0f04dc19 [data-elem=label] {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}";
var modules_3705961f = {"root":"Radio_module_root__0f04dc19","position-left":"Radio_module_positionLeft__0f04dc19","position-right":"Radio_module_positionRight__0f04dc19","disabled":"Radio_module_disabled__0f04dc19","icon":"Radio_module_icon__0f04dc19","icon-sm":"Radio_module_iconSm__0f04dc19","icon-md":"Radio_module_iconMd__0f04dc19","icon-lg":"Radio_module_iconLg__0f04dc19"};
n(css$N,{});

var Radio = function Radio(props) {
  // eslint-disable-next-line object-curly-newline
  var label = props.label,
    checked = props.checked,
    defaultChecked = props.defaultChecked,
    onChange = props.onChange,
    position = props.position,
    size = props.size,
    className = props.className,
    disabled = props.disabled;
  var _useRef = React.useRef(checked !== undefined),
    isControlled = _useRef.current;

  // for uncontrolled input
  var _useState = React.useState(defaultChecked),
    _useState2 = _slicedToArray(_useState, 2),
    uncontrolledChecked = _useState2[0],
    setUncontrolledChecked = _useState2[1];
  var handleChange = function handleChange(event) {
    var _inputHelper = inputHelper(event),
      fieldValue = _inputHelper.fieldValue;
    if (isControlled) {
      onChange(event, fieldValue);
    } else {
      setUncontrolledChecked(fieldValue);
    }
  };
  var isChecked = isControlled ? checked : uncontrolledChecked;
  return /*#__PURE__*/jsxRuntime.jsxs("label", {
    className: classes(modules_3705961f.root, modules_3705961f["position-".concat(position)], className, disabled ? modules_3705961f.disabled : ''),
    children: [/*#__PURE__*/jsxRuntime.jsx("input", {
      disabled: disabled,
      type: "radio",
      checked: isChecked,
      onChange: handleChange
    }), isChecked ? /*#__PURE__*/jsxRuntime.jsx(RadioIcon.Checked, {
      "data-elem": "icon",
      className: classes(modules_3705961f["icon-".concat(size)], modules_3705961f.icon)
    }) : /*#__PURE__*/jsxRuntime.jsx(RadioIcon.UnChecked, {
      "data-elem": "icon",
      className: classes(modules_3705961f["icon-".concat(size)], modules_3705961f.icon)
    }), label && /*#__PURE__*/jsxRuntime.jsx("span", {
      "data-elem": "label",
      children: label
    })]
  });
};
Radio.propTypes = {
  disabled: propTypes$1.exports.bool,
  label: propTypes$1.exports.string,
  checked: propTypes$1.exports.bool,
  defaultChecked: propTypes$1.exports.bool,
  position: propTypes$1.exports.oneOf(['left', 'right']),
  size: propTypes$1.exports.oneOf(['sm', 'md', 'lg']),
  onChange: propTypes$1.exports.func
};
Radio.defaultProps = {
  disabled: false,
  label: null,
  checked: undefined,
  defaultChecked: false,
  position: 'left',
  size: 'sm',
  onChange: function onChange() {}
};

var css$M = ".Dropdown_module_root__1ad8038e {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: flex-start;\n  gap: 0.5rem;\n  position: relative;\n  width: -webkit-fit-content;\n  width: -moz-fit-content;\n  width: fit-content;\n  max-width: 100%;\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_label__1ad8038e {\n  font-size: 0.75rem;\n  color: var(--grey);\n  width: auto;\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_header__1ad8038e {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  max-width: 100%;\n  position: relative;\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_header__1ad8038e .Dropdown_module_input__1ad8038e {\n  position: absolute;\n  opacity: 0;\n  width: 1px;\n  height: 1px;\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_header__1ad8038e .Dropdown_module_input__1ad8038e:focus + .Dropdown_module_select__1ad8038e {\n  border-color: var(--highlight);\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_header__1ad8038e .Dropdown_module_input__1ad8038e:focus + .Dropdown_module_select__1ad8038e.Dropdown_module_feedbackError__1ad8038e {\n  border-color: var(--error);\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_header__1ad8038e .Dropdown_module_select__1ad8038e {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  width: 25rem;\n  max-width: 100%;\n  gap: 0.5rem;\n  background: var(--white);\n  outline: none;\n  border: 1px solid var(--grey5);\n  border-radius: 0.25rem;\n  padding: 0.75rem 0.75rem 0.75rem 1rem;\n  cursor: pointer;\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_header__1ad8038e .Dropdown_module_select__1ad8038e .Dropdown_module_placeholder__1ad8038e {\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  color: var(--black);\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_header__1ad8038e .Dropdown_module_select__1ad8038e .Dropdown_module_icon__1ad8038e {\n  width: 1.5rem;\n  height: 1.5rem;\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_header__1ad8038e .Dropdown_module_select__1ad8038e.Dropdown_module_feedbackError__1ad8038e {\n  border-color: var(--error);\n}\n.Dropdown_module_root__1ad8038e.Dropdown_module_open__1ad8038e .Dropdown_module_header__1ad8038e {\n  border-color: var(--highlight);\n}\n.Dropdown_module_root__1ad8038e.Dropdown_module_disabled__1ad8038e .Dropdown_module_select__1ad8038e {\n  background: var(--grey10);\n  cursor: not-allowed;\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_bottom__1ad8038e {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: flex-start;\n  min-height: 2rem;\n  width: 100%;\n  gap: 1rem;\n  color: var(--grey3);\n  font-size: 0.75rem;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_bottom__1ad8038e .Dropdown_module_feedback__1ad8038e {\n  flex: 1;\n  margin-right: auto;\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_bottom__1ad8038e .Dropdown_module_feedback__1ad8038e.Dropdown_module_feedbackError__1ad8038e {\n  color: var(--error);\n  fill: var(--error);\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_bottom__1ad8038e .Dropdown_module_feedback__1ad8038e.Dropdown_module_feedbackSuccess__1ad8038e {\n  color: var(--success);\n  fill: var(--success);\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_bottom__1ad8038e .Dropdown_module_count__1ad8038e {\n  text-align: right;\n  margin-left: auto;\n}\n.Dropdown_module_root__1ad8038e .Dropdown_module_bottom__1ad8038e .Dropdown_module_count__1ad8038e.Dropdown_module_exceeded__1ad8038e {\n  color: var(--error);\n}\n\n.Dropdown_module_body__1ad8038e {\n  display: none;\n  position: absolute;\n  top: calc(100% + 0.5rem);\n  background: var(--white);\n  width: auto;\n  border: 0.063rem solid var(--grey5);\n  box-shadow: 0rem 0.5rem 1.25rem rgba(24, 24, 24, 0.08);\n  border-radius: 0.25rem;\n  padding: 1rem;\n  overflow-y: auto;\n  min-height: 4rem;\n  outline: none;\n}\n.Dropdown_module_body__1ad8038e .Dropdown_module_multiOptions__1ad8038e {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 0.5rem;\n  list-style: none;\n}\n.Dropdown_module_body__1ad8038e .Dropdown_module_multiApply__1ad8038e {\n  margin-top: 0.5rem;\n}\n.Dropdown_module_body__1ad8038e.Dropdown_module_open__1ad8038e {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n}";
var modules_1b90f5ea = {"root":"Dropdown_module_root__1ad8038e","label":"Dropdown_module_label__1ad8038e","header":"Dropdown_module_header__1ad8038e","input":"Dropdown_module_input__1ad8038e","select":"Dropdown_module_select__1ad8038e","feedback-error":"Dropdown_module_feedbackError__1ad8038e","placeholder":"Dropdown_module_placeholder__1ad8038e","icon":"Dropdown_module_icon__1ad8038e","open":"Dropdown_module_open__1ad8038e","disabled":"Dropdown_module_disabled__1ad8038e","bottom":"Dropdown_module_bottom__1ad8038e","feedback":"Dropdown_module_feedback__1ad8038e","feedback-success":"Dropdown_module_feedbackSuccess__1ad8038e","count":"Dropdown_module_count__1ad8038e","exceeded":"Dropdown_module_exceeded__1ad8038e","body":"Dropdown_module_body__1ad8038e","multi-options":"Dropdown_module_multiOptions__1ad8038e","multi-apply":"Dropdown_module_multiApply__1ad8038e"};
n(css$M,{});

var Dropdown = /*#__PURE__*/React.forwardRef(function Dropdown(props, inputRef) {
  var _selectedOptions$map, _ref2, _selectedOptions$;
  // eslint-disable-next-line object-curly-newline
  var className = props.className,
    popperClassName = props.popperClassName,
    value = props.value,
    onChange = props.onChange,
    onBlur = props.onBlur,
    children = props.children,
    label = props.label,
    placeholder = props.placeholder,
    multi = props.multi,
    disabled = props.disabled,
    id = props.id,
    name = props.name,
    feedback = props.feedback,
    formatter = props.formatter;
  var _useState = React.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    open = _useState2[0],
    setOpen = _useState2[1];
  var _useState3 = React.useState(null),
    _useState4 = _slicedToArray(_useState3, 2),
    activeIndex = _useState4[0],
    setActiveIndex = _useState4[1];
  var _useState5 = React.useState(0),
    _useState6 = _slicedToArray(_useState5, 2),
    selectedIndex = _useState6[0],
    setSelectedIndex = _useState6[1];
  var listItemsRef = React.useRef([]);
  var multiOptionsRef = React.useRef(null);
  var isControlled = value !== undefined;

  // for uncontrolled input
  var _useState7 = React.useState(value),
    _useState8 = _slicedToArray(_useState7, 2),
    uncontrolledValue = _useState8[0],
    setUncontrolledValue = _useState8[1];
  var _useFloating = useFloating({
      open: open,
      onOpenChange: setOpen,
      whileElementsMounted: autoUpdate,
      middleware: [offset(5), flip({
        padding: 8
      }), shift({
        padding: 8
      }), size({
        apply: function apply(_ref) {
          var rects = _ref.rects,
            availableHeight = _ref.availableHeight,
            elements = _ref.elements;
          Object.assign(elements.floating.style, {
            width: "".concat(rects.reference.width, "px"),
            minWidth: 'fit-content',
            maxHeight: "".concat(availableHeight, "px")
          });
        },
        padding: 8
      })]
    }),
    x = _useFloating.x,
    y = _useFloating.y,
    reference = _useFloating.reference,
    floating = _useFloating.floating,
    strategy = _useFloating.strategy,
    context = _useFloating.context;
  var _useInteractions = useInteractions([useClick(context, {
      enabled: !disabled
    }), useRole(context, {
      role: 'listbox'
    }), useListNavigation(context, {
      listRef: listItemsRef,
      activeIndex: activeIndex,
      selectedIndex: selectedIndex,
      onNavigate: setActiveIndex
    }), useDismiss(context)]),
    getReferenceProps = _useInteractions.getReferenceProps,
    getFloatingProps = _useInteractions.getFloatingProps,
    getItemProps = _useInteractions.getItemProps;
  var onSelect = function onSelect(child, selected) {
    return function (event) {
      var _itemValue$toString;
      if (event.currentTarget.getAttribute('data-elem') !== 'dropdown-item') {
        return;
      }
      var itemValue = child.props.value;
      var itemValueString = itemValue === null || itemValue === void 0 ? void 0 : (_itemValue$toString = itemValue.toString) === null || _itemValue$toString === void 0 ? void 0 : _itemValue$toString.call(itemValue);
      var index = event.currentTarget.getAttribute('data-index');

      // to support form libraries which require name and value on the event
      var nativeEvent = event.nativeEvent || event;
      var clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
      Object.defineProperty(clonedEvent, 'target', {
        writable: true,
        value: {
          value: itemValueString,
          name: name
        }
      });

      // if (elem === 'dropdown-item') {
      setSelectedIndex(parseInt(index, 10));
      if (multi) {
        // eslint-disable-next-line no-lonely-if
        if (selected === true) {
          setUncontrolledValue(uncontrolledValue.filter(function (val) {
            return val !== itemValueString;
          }));
        } else {
          setUncontrolledValue([].concat(_toConsumableArray$1(uncontrolledValue !== null && uncontrolledValue !== void 0 ? uncontrolledValue : []), [itemValueString]));
        }
        setActiveIndex(parseInt(index, 10));
      } else {
        if (isControlled) {
          onChange(clonedEvent, itemValueString.toString());
        } else {
          setUncontrolledValue(itemValueString.toString());
        }
        setActiveIndex(null);
        setOpen(false);
      }
      // }
    };
  };

  var onNavigate = function onNavigate(child, selected) {
    return function (event) {
      var selectKey = [' ', 'Spacebar', 'Enter'].includes(event.key);
      if (selectKey) {
        event.stopPropagation();
        onSelect(child, selected)(event);
      }
    };
  };
  React.useImperativeHandle(inputRef, function () {
    return {
      value: function value() {
        var _inputRef$current$val, _inputRef$current$val2, _inputRef$current$val3, _inputValue$;
        var inputValue = (_inputRef$current$val = (_inputRef$current$val2 = inputRef.current.value) === null || _inputRef$current$val2 === void 0 ? void 0 : (_inputRef$current$val3 = _inputRef$current$val2.split) === null || _inputRef$current$val3 === void 0 ? void 0 : _inputRef$current$val3.call(_inputRef$current$val2, ', ')) !== null && _inputRef$current$val !== void 0 ? _inputRef$current$val : [];
        if (multi) {
          return inputValue;
        }
        return (_inputValue$ = inputValue === null || inputValue === void 0 ? void 0 : inputValue[0]) !== null && _inputValue$ !== void 0 ? _inputValue$ : null;
      }
    };
  }, []);
  var childrenArray = React.Children.toArray(children);
  var selectedOptions = React.useMemo(function () {
    var inputValue = uncontrolledValue;
    if (isControlled && !multi) {
      inputValue = value;
    }
    var options = [];
    if (inputValue != null && inputValue !== '') {
      childrenArray === null || childrenArray === void 0 ? void 0 : childrenArray.forEach(function (child) {
        var _inputValue$indexOf, _inputValue, _inputValue$indexOf2, _child$props, _child$props$value, _child$props$value$to, _inputValue2, _child$props2, _child$props2$value, _child$props2$value$t;
        if (multi && ((_inputValue$indexOf = (_inputValue = inputValue) === null || _inputValue === void 0 ? void 0 : (_inputValue$indexOf2 = _inputValue.indexOf) === null || _inputValue$indexOf2 === void 0 ? void 0 : _inputValue$indexOf2.call(_inputValue, child === null || child === void 0 ? void 0 : (_child$props = child.props) === null || _child$props === void 0 ? void 0 : (_child$props$value = _child$props.value) === null || _child$props$value === void 0 ? void 0 : (_child$props$value$to = _child$props$value.toString) === null || _child$props$value$to === void 0 ? void 0 : _child$props$value$to.call(_child$props$value))) !== null && _inputValue$indexOf !== void 0 ? _inputValue$indexOf : -1) !== -1 || !multi && ((_inputValue2 = inputValue) === null || _inputValue2 === void 0 ? void 0 : _inputValue2.toString()) === (child === null || child === void 0 ? void 0 : (_child$props2 = child.props) === null || _child$props2 === void 0 ? void 0 : (_child$props2$value = _child$props2.value) === null || _child$props2$value === void 0 ? void 0 : (_child$props2$value$t = _child$props2$value.toString) === null || _child$props2$value$t === void 0 ? void 0 : _child$props2$value$t.call(_child$props2$value))) {
          var _child$props3, _child$props4, _child$props4$value, _child$props4$value$t;
          options.push({
            title: child === null || child === void 0 ? void 0 : (_child$props3 = child.props) === null || _child$props3 === void 0 ? void 0 : _child$props3.title,
            value: child === null || child === void 0 ? void 0 : (_child$props4 = child.props) === null || _child$props4 === void 0 ? void 0 : (_child$props4$value = _child$props4.value) === null || _child$props4$value === void 0 ? void 0 : (_child$props4$value$t = _child$props4$value.toString) === null || _child$props4$value$t === void 0 ? void 0 : _child$props4$value$t.call(_child$props4$value)
          });
        }
      });
    }
    return options;
  }, [value, uncontrolledValue, multi]);
  var items = childrenArray.map(function (child, index) {
    var _child$props6;
    var selected = false;
    if (selectedOptions.findIndex(function (option) {
      var _child$props5, _child$props5$value, _child$props5$value$t;
      return option.value === (child === null || child === void 0 ? void 0 : (_child$props5 = child.props) === null || _child$props5 === void 0 ? void 0 : (_child$props5$value = _child$props5.value) === null || _child$props5$value === void 0 ? void 0 : (_child$props5$value$t = _child$props5$value.toString) === null || _child$props5$value$t === void 0 ? void 0 : _child$props5$value$t.call(_child$props5$value));
    }) !== -1) {
      selected = true;
    }
    return /*#__PURE__*/React.cloneElement(child, _objectSpread2({}, getItemProps({
      key: child === null || child === void 0 ? void 0 : (_child$props6 = child.props) === null || _child$props6 === void 0 ? void 0 : _child$props6.value,
      onKeyDown: onNavigate(child, selected),
      onClick: onSelect(child, selected),
      onMouseEnter: function onMouseEnter() {
        setActiveIndex(index);
      },
      dataAttrs: {
        'data-index': index
      },
      selected: selected,
      tabIndex: activeIndex === index ? 0 : -1,
      ref: function ref(node) {
        listItemsRef.current[index] = node;
      }
    })));
  });
  var _useState9 = React.useState(false),
    _useState10 = _slicedToArray(_useState9, 2),
    pointer = _useState10[0],
    setPointer = _useState10[1];
  if (!open && pointer) {
    setPointer(false);
  }
  React.useLayoutEffect(function () {
    if (open && activeIndex != null && !pointer) {
      requestAnimationFrame(function () {
        var _listItemsRef$current;
        (_listItemsRef$current = listItemsRef.current[activeIndex]) === null || _listItemsRef$current === void 0 ? void 0 : _listItemsRef$current.scrollIntoView({
          block: 'nearest'
        });
      });
    }
  }, [open, activeIndex, pointer]);
  React.useEffect(function () {
    if (multi) {
      setUncontrolledValue(value);
    }
  }, [open, multi, value]);
  var onSelectAll = function onSelectAll(event, selected) {
    // to support form libraries which require name and value on the event
    var nativeEvent = event.nativeEvent || event;
    var clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    var itemValue = [];
    if (selected) {
      itemValue = childrenArray.map(function (child) {
        var _child$props7, _child$props7$value, _child$props7$value$t;
        return child === null || child === void 0 ? void 0 : (_child$props7 = child.props) === null || _child$props7 === void 0 ? void 0 : (_child$props7$value = _child$props7.value) === null || _child$props7$value === void 0 ? void 0 : (_child$props7$value$t = _child$props7$value.toString) === null || _child$props7$value$t === void 0 ? void 0 : _child$props7$value$t.call(_child$props7$value);
      });
    }
    Object.defineProperty(clonedEvent, 'target', {
      writable: true,
      value: {
        value: itemValue,
        name: name
      }
    });

    // eslint-disable-next-line no-lonely-if
    if (selected === true) {
      setUncontrolledValue(itemValue);
    } else {
      setUncontrolledValue(itemValue);
    }
    setActiveIndex(0);
  };
  var onApply = function onApply(event) {
    var nativeEvent = event.nativeEvent || event;
    var clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, 'target', {
      writable: true,
      value: {
        value: uncontrolledValue,
        name: name
      }
    });
    onChange(event, uncontrolledValue);
  };
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(className, modules_1b90f5ea.root, open ? modules_1b90f5ea.open : '', disabled ? modules_1b90f5ea.disabled : ''),
    children: [label && /*#__PURE__*/jsxRuntime.jsx("div", {
      "data-elem": "label",
      className: modules_1b90f5ea.label,
      children: /*#__PURE__*/jsxRuntime.jsx("span", {
        children: label
      })
    }), /*#__PURE__*/jsxRuntime.jsxs("div", _objectSpread2(_objectSpread2({
      "data-elem": "header",
      className: modules_1b90f5ea.header,
      ref: reference
    }, getReferenceProps()), {}, {
      children: [/*#__PURE__*/jsxRuntime.jsx("input", {
        id: id,
        name: name,
        ref: inputRef,
        disabled: disabled,
        tabIndex: 0,
        className: modules_1b90f5ea.input,
        onKeyDown: function onKeyDown(event) {
          var validKey = [' ', 'Spacebar', 'Enter'].includes(event.key);
          if (validKey) {
            setOpen(true);
          }
        },
        onBlur: onBlur,
        value: selectedOptions === null || selectedOptions === void 0 ? void 0 : (_selectedOptions$map = selectedOptions.map(function (option) {
          return option === null || option === void 0 ? void 0 : option.value;
        })) === null || _selectedOptions$map === void 0 ? void 0 : _selectedOptions$map.join(', ')
      }), /*#__PURE__*/jsxRuntime.jsxs("div", {
        "data-elem": "select",
        role: "button",
        className: classes(modules_1b90f5ea.select, feedback != null ? modules_1b90f5ea["feedback-".concat(feedback === null || feedback === void 0 ? void 0 : feedback.type)] : ''),
        children: [/*#__PURE__*/jsxRuntime.jsx("span", {
          "data-elem": "placeholder",
          className: modules_1b90f5ea.placeholder,
          children: (_ref2 = (selectedOptions === null || selectedOptions === void 0 ? void 0 : selectedOptions.length) > 1 ? formatter(selectedOptions.length) : selectedOptions === null || selectedOptions === void 0 ? void 0 : (_selectedOptions$ = selectedOptions[0]) === null || _selectedOptions$ === void 0 ? void 0 : _selectedOptions$.title) !== null && _ref2 !== void 0 ? _ref2 : placeholder
        }), /*#__PURE__*/jsxRuntime.jsx(Caret, {
          "data-elem": "icon",
          className: classes(modules_1b90f5ea.icon, modules_1b90f5ea['drop-icon'])
        })]
      })]
    })), /*#__PURE__*/jsxRuntime.jsx(Popper, {
      open: open,
      wrapperId: "dropdown-popper",
      children: open && /*#__PURE__*/jsxRuntime.jsx(FloatingFocusManager, {
        context: context,
        initialFocus: -1,
        modal: false,
        children: /*#__PURE__*/jsxRuntime.jsxs("ul", _objectSpread2(_objectSpread2({}, getFloatingProps({
          'data-elem': 'body',
          role: 'group',
          ref: floating,
          onKeyDown: function onKeyDown(event) {
            setPointer(false);
            if (event.key === 'Tab' && !multi) {
              setOpen(false);
            }
          },
          onPointerMove: function onPointerMove() {
            setPointer(true);
          },
          style: {
            position: strategy,
            top: y !== null && y !== void 0 ? y : 0,
            left: x !== null && x !== void 0 ? x : 0
          },
          className: classes(modules_1b90f5ea.body, popperClassName, open ? modules_1b90f5ea.open : '')
        })), {}, {
          children: [multi && /*#__PURE__*/jsxRuntime.jsxs("li", {
            ref: multiOptionsRef,
            className: modules_1b90f5ea['multi-options'],
            tabIndex: -1,
            children: [/*#__PURE__*/jsxRuntime.jsx(Checkbox, {
              label: "Select All",
              position: "left",
              checked: selectedOptions.length === childrenArray.length,
              onChange: onSelectAll
            }), ' ', /*#__PURE__*/jsxRuntime.jsx(Button, {
              blurOnClick: false,
              variant: "text",
              title: "Clear",
              size: "auto",
              color: "danger",
              onClick: function onClick(event) {
                var _multiOptionsRef$curr;
                multiOptionsRef === null || multiOptionsRef === void 0 ? void 0 : (_multiOptionsRef$curr = multiOptionsRef.current) === null || _multiOptionsRef$curr === void 0 ? void 0 : _multiOptionsRef$curr.focus();
                onSelectAll(event, false);
              }
            })]
          }), items, multi && /*#__PURE__*/jsxRuntime.jsx(Button, {
            className: modules_1b90f5ea['multi-apply'],
            title: "Apply",
            size: "auto",
            onClick: onApply
          })]
        }))
      })
    }), feedback != null && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: modules_1b90f5ea.bottom,
      children: /*#__PURE__*/jsxRuntime.jsx("div", {
        "data-elem": "feedback",
        className: classes(modules_1b90f5ea.feedback, modules_1b90f5ea["feedback-".concat(feedback.type)]),
        children: feedback.text
      })
    })]
  });
});
Dropdown.propTypes = {
  popperClassName: propTypes$1.exports.string,
  className: propTypes$1.exports.string,
  disabled: propTypes$1.exports.bool,
  label: propTypes$1.exports.string,
  value: propTypes$1.exports.oneOfType([propTypes$1.exports.string, propTypes$1.exports.arrayOf(propTypes$1.exports.string)]),
  placeholder: propTypes$1.exports.string,
  // search: PropTypes.bool,
  // max: PropTypes.number,
  multi: propTypes$1.exports.bool,
  onChange: propTypes$1.exports.func,
  onBlur: propTypes$1.exports.func,
  feedback: propTypes$1.exports.shape({
    text: propTypes$1.exports.node,
    type: propTypes$1.exports.oneOf(['error', 'success', 'default'])
  }),
  formatter: propTypes$1.exports.func
};
Dropdown.defaultProps = {
  popperClassName: '',
  className: '',
  disabled: false,
  label: null,
  value: undefined,
  placeholder: 'Select an option',
  // search: false,
  // max: null,
  multi: false,
  onChange: null,
  onBlur: null,
  feedback: null,
  formatter: function formatter(totalSelected) {
    return "".concat(totalSelected, " options selected");
  }
};

var css$L = ".DropdownItem_module_root__61492174 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  gap: 0.75rem;\n  width: 100%;\n  padding: 0.75rem 1rem;\n  border-radius: 0.25rem;\n  cursor: pointer;\n  color: var(--grey);\n  outline: none;\n}\n.DropdownItem_module_root__61492174 > .DropdownItem_module_input__61492174 {\n  cursor: pointer;\n}\n.DropdownItem_module_root__61492174:focus {\n  background: var(--grey6);\n}\n.DropdownItem_module_root__61492174.DropdownItem_module_selected__61492174 {\n  background: var(--info-bg);\n}";
var modules_bf949acd = {"root":"DropdownItem_module_root__61492174","input":"DropdownItem_module_input__61492174","selected":"DropdownItem_module_selected__61492174"};
n(css$L,{});

var DropdownItem = /*#__PURE__*/React.forwardRef(function DropdownItem(props, ref) {
  // eslint-disable-next-line object-curly-newline
  var title = props.title,
    value = props.value,
    variant = props.variant,
    selected = props.selected,
    onKeyDown = props.onKeyDown,
    onMouseEnter = props.onMouseEnter,
    onClick = props.onClick,
    dataAttrs = props.dataAttrs,
    className = props.className,
    tabIndex = props.tabIndex;
  var action = null;
  switch (variant) {
    case 'checkbox':
      action = /*#__PURE__*/jsxRuntime.jsx(Checkbox, {
        className: modules_bf949acd.input,
        checked: selected,
        disabled: true
      });
      break;
    case 'radio':
      action = /*#__PURE__*/jsxRuntime.jsx(Radio, {
        className: modules_bf949acd.input,
        checked: selected,
        disabled: true
      });
      break;
  }
  return /*#__PURE__*/jsxRuntime.jsxs("li", _objectSpread2(_objectSpread2({
    ref: ref,
    className: classes(className, modules_bf949acd.root, selected ? modules_bf949acd.selected : ''),
    "data-elem": "dropdown-item",
    "data-variant": variant,
    "data-value": value,
    "data-selected": selected,
    onClick: onClick,
    onMouseEnter: onMouseEnter
  }, _objectSpread2({}, dataAttrs)), {}, {
    tabIndex: tabIndex,
    role: "option",
    "aria-selected": selected,
    onKeyDown: onKeyDown,
    children: [action, /*#__PURE__*/jsxRuntime.jsx("span", {
      "data-elem": "title",
      children: title
    })]
  }));
});
DropdownItem.propTypes = {
  className: propTypes$1.exports.string,
  title: propTypes$1.exports.node,
  variant: propTypes$1.exports.oneOf(['default', 'checkbox', 'radio']),
  selected: propTypes$1.exports.bool,
  // eslint-disable-next-line react/forbid-prop-types
  dataAttrs: propTypes$1.exports.object
};
DropdownItem.defaultProps = {
  className: '',
  title: '',
  variant: 'default',
  dataAttrs: {},
  selected: false
};

var css$K = ".Switch_module_root__c9616649 {\n  cursor: pointer;\n  gap: 0.625rem;\n  position: relative;\n  height: 1.5rem;\n}\n.Switch_module_root__c9616649.Switch_module_disabled__c9616649 {\n  cursor: default;\n}\n.Switch_module_root__c9616649.Switch_module_positionLeft__c9616649 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n}\n.Switch_module_root__c9616649.Switch_module_positionRight__c9616649 {\n  display: flex;\n  flex-direction: row-reverse;\n  justify-content: flex-end;\n  align-items: center;\n}\n.Switch_module_root__c9616649 input[type=checkbox] {\n  opacity: 0;\n  z-index: 1;\n  position: absolute;\n  width: 1px;\n  height: 1px;\n}\n.Switch_module_root__c9616649 .Switch_module_pill__c9616649 {\n  position: relative;\n  width: 3rem;\n  height: 100%;\n  cursor: pointer;\n  background-color: var(--grey5);\n  transition: 0.4s;\n  border-radius: 0.75rem;\n}\n.Switch_module_root__c9616649 .Switch_module_pill__c9616649:before {\n  position: absolute;\n  content: \"\";\n  height: 1.25rem;\n  width: 1.25rem;\n  left: 0.125rem;\n  bottom: 0.125rem;\n  background-color: white;\n  transition: 0.4s;\n  border-radius: 50%;\n}\n.Switch_module_root__c9616649 input:checked + .Switch_module_pill__c9616649 {\n  background-color: var(--highlight);\n}\n.Switch_module_root__c9616649 input:checked + .Switch_module_pill__c9616649:before {\n  transform: translateX(1.5rem);\n}\n.Switch_module_root__c9616649 input:focus + .Switch_module_pill__c9616649::before {\n  box-shadow: 0px 0px 0px 8px rgba(15, 98, 254, 0.125);\n}\n.Switch_module_root__c9616649 [data-elem=label] {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}";
var modules_18a327ff = {"root":"Switch_module_root__c9616649","disabled":"Switch_module_disabled__c9616649","position-left":"Switch_module_positionLeft__c9616649","position-right":"Switch_module_positionRight__c9616649","pill":"Switch_module_pill__c9616649"};
n(css$K,{});

var Switch = function Switch(props) {
  // eslint-disable-next-line object-curly-newline
  var label = props.label,
    checked = props.checked,
    defaultChecked = props.defaultChecked,
    onChange = props.onChange,
    position = props.position,
    className = props.className,
    disabled = props.disabled;
  var _useRef = React.useRef(checked !== undefined),
    isControlled = _useRef.current;

  // for uncontrolled input
  var _useState = React.useState(defaultChecked),
    _useState2 = _slicedToArray(_useState, 2),
    uncontrolledChecked = _useState2[0],
    setUncontrolledChecked = _useState2[1];
  var handleChange = function handleChange(event) {
    var _inputHelper = inputHelper(event),
      fieldValue = _inputHelper.fieldValue;
    if (isControlled) {
      onChange(event, fieldValue);
    } else {
      setUncontrolledChecked(fieldValue);
    }
  };
  var isChecked = isControlled ? checked : uncontrolledChecked;
  return /*#__PURE__*/jsxRuntime.jsxs("label", {
    className: classes(modules_18a327ff.root, modules_18a327ff["position-".concat(position)], className, disabled ? modules_18a327ff.disabled : ''),
    children: [/*#__PURE__*/jsxRuntime.jsx("input", {
      disabled: disabled,
      type: "checkbox",
      checked: isChecked,
      onChange: handleChange
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: classes(modules_18a327ff.pill)
    }), label && /*#__PURE__*/jsxRuntime.jsx("span", {
      "data-elem": "label",
      children: label
    })]
  });
};
Switch.propTypes = {
  disabled: propTypes$1.exports.bool,
  label: propTypes$1.exports.string,
  checked: propTypes$1.exports.bool,
  defaultChecked: propTypes$1.exports.bool,
  position: propTypes$1.exports.oneOf(['left', 'right']),
  onChange: propTypes$1.exports.func
};
Switch.defaultProps = {
  disabled: false,
  label: null,
  checked: undefined,
  defaultChecked: false,
  position: 'left',
  onChange: function onChange() {}
};

var css$J = ".TimePicker_module_root__2dd24d9e {\n  width: 100%;\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  border-top: 1px solid var(--grey5);\n  border-bottom: 1px solid var(--grey5);\n}\n.TimePicker_module_root__2dd24d9e .TimePicker_module_input__2dd24d9e {\n  width: 5.125rem;\n}\n.TimePicker_module_root__2dd24d9e .TimePicker_module_input__2dd24d9e > label [data-elem=base-cell] {\n  border: none;\n}\n.TimePicker_module_root__2dd24d9e .TimePicker_module_input__2dd24d9e > label [data-elem=base-cell] [data-elem=component2] {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n}\n.TimePicker_module_root__2dd24d9e .TimePicker_module_input__2dd24d9e > label [data-elem=base-cell] [data-elem=component2] > input[data-elem=input] {\n  padding: 1rem 0rem;\n  text-align: center;\n  font-weight: 600;\n  font-size: 1.25rem;\n  line-height: 1.5rem;\n  color: var(--dark-grey);\n}\n.TimePicker_module_root__2dd24d9e .TimePicker_module_colon__2dd24d9e {\n  font-weight: 500;\n  font-size: 1.25rem;\n  line-height: 1.5rem;\n  color: var(--dark-grey);\n}\n.TimePicker_module_root__2dd24d9e .TimePicker_module_separator__2dd24d9e {\n  width: 0.0625rem;\n  height: 1.5625rem;\n  background-color: var(--grey5);\n}";
var modules_98a80317 = {"root":"TimePicker_module_root__2dd24d9e","input":"TimePicker_module_input__2dd24d9e","colon":"TimePicker_module_colon__2dd24d9e","separator":"TimePicker_module_separator__2dd24d9e"};
n(css$J,{});

var isValidUnit = function isValidUnit(_ref) {
  var type = _ref.type,
    value = _ref.value;
  if (type === 'hours') {
    if (value >= 0 && value < 13) {
      return true;
    }
    return false;
  }
  if (value >= 0 && value < 60) {
    return true;
  }
  return false;
};
var isValidMeridian = function isValidMeridian(meridian) {
  if (meridian === 'AM' || meridian === 'PM' || meridian === 'A' || meridian === 'P') {
    return true;
  }
  return false;
};
var focusInput = function focusInput(ref) {
  return ref === null || ref === void 0 ? void 0 : ref.current.focus();
};

var TimePicker = function TimePicker(props) {
  var className = props.className;
  var today = getDayInfo(new Date());
  var refs = {
    hours: React.useRef(),
    minutes: React.useRef(),
    seconds: React.useRef(),
    meridian: React.useRef()
  };
  var _useState = React.useState(props.value || {
      hours: doubleDigitted(today.hours),
      minutes: doubleDigitted(today.minutes),
      seconds: doubleDigitted(today.seconds),
      meridian: today.meridian
    }),
    _useState2 = _slicedToArray(_useState, 2),
    timePickerValue = _useState2[0],
    setTimePickerValue = _useState2[1];
  var hours = timePickerValue.hours,
    minutes = timePickerValue.minutes,
    seconds = timePickerValue.seconds,
    meridian = timePickerValue.meridian;
  React.useEffect(function () {
    props.onChange(timePickerValue);
  }, [timePickerValue]);
  var _onChange = function onChange(id, value, nextInput, focus) {
    if (value.length <= 2) {
      setTimePickerValue(_objectSpread2(_objectSpread2({}, timePickerValue), {}, _defineProperty$1({}, id, value)));
      if (focus && value && value.length === 2) {
        focusInput(nextInput);
      }
    }
  };
  var onBlur = function onBlur(event) {
    var target = event.target;
    var id = target.id,
      value = target.value;
    if (id === 'meridian' && !['AM', 'PM'].includes(value)) {
      setTimePickerValue(_objectSpread2(_objectSpread2({}, timePickerValue), {}, _defineProperty$1({}, id, 'AM')));
      return;
    }
    if (id === 'hours' && !Number(value) > 0) {
      setTimePickerValue(_objectSpread2(_objectSpread2({}, timePickerValue), {}, _defineProperty$1({}, id, '01')));
      return;
    }
    setTimePickerValue(_objectSpread2(_objectSpread2({}, timePickerValue), {}, _defineProperty$1({}, id, doubleDigitted(value))));
  };
  var _onKeyDown = function onKeyDown(event) {
    var keyCode = event.keyCode,
      target = event.target;
    var id = target.id,
      value = target.value;
    if (id === 'meridian' && keyCode === 40 || keyCode === 38) {
      setTimePickerValue(_objectSpread2(_objectSpread2({}, timePickerValue), {}, _defineProperty$1({}, id, value === 'PM' ? 'AM' : 'PM')));
    }
  };
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(modules_98a80317.root, className),
    children: [/*#__PURE__*/jsxRuntime.jsx(TextField, {
      className: modules_98a80317.input,
      placeholder: "00",
      value: hours,
      ref: refs.hours,
      type: "number",
      onBlur: onBlur,
      id: "hours",
      onChange: function onChange(event) {
        var target = event.target,
          nativeEvent = event.nativeEvent;
        var id = target.id,
          value = target.value;
        if (isValidUnit({
          type: 'hours',
          value: value
        })) {
          _onChange(id, value, refs.minutes, nativeEvent.data);
        }
      }
    }), /*#__PURE__*/jsxRuntime.jsx("span", {
      className: modules_98a80317.colon,
      children: ":"
    }), /*#__PURE__*/jsxRuntime.jsx(TextField, {
      className: modules_98a80317.input,
      placeholder: "00",
      value: minutes,
      id: "minutes",
      onBlur: onBlur,
      ref: refs.minutes,
      type: "number",
      onChange: function onChange(event) {
        var target = event.target,
          nativeEvent = event.nativeEvent;
        var id = target.id,
          value = target.value;
        if (isValidUnit({
          type: 'minutes',
          value: value
        })) {
          _onChange(id, value, refs.seconds, nativeEvent.data);
        }
      }
    }), /*#__PURE__*/jsxRuntime.jsx("span", {
      className: modules_98a80317.colon,
      children: ":"
    }), /*#__PURE__*/jsxRuntime.jsx(TextField, {
      className: modules_98a80317.input,
      placeholder: "00",
      type: "number",
      value: seconds,
      ref: refs.seconds,
      onBlur: onBlur,
      id: "seconds",
      onChange: function onChange(event) {
        var target = event.target,
          nativeEvent = event.nativeEvent;
        var id = target.id,
          value = target.value;
        if (isValidUnit({
          type: 'seconds',
          value: value
        })) {
          _onChange(id, value, refs.meridian, nativeEvent.data);
        }
      }
    }), /*#__PURE__*/jsxRuntime.jsx("span", {
      className: modules_98a80317.separator,
      children: "|"
    }), /*#__PURE__*/jsxRuntime.jsx(TextField, {
      className: modules_98a80317.input,
      placeholder: "--",
      value: meridian,
      onBlur: onBlur,
      ref: refs.meridian,
      id: "meridian",
      onKeyDown: function onKeyDown(e) {
        _onKeyDown(e);
      },
      onChange: function onChange(event) {
        var target = event.target;
        var id = target.id,
          value = target.value;
        if (!value || isValidMeridian(value.toUpperCase())) {
          _onChange(id, value.toUpperCase());
        }
      }
    })]
  });
};
TimePicker.propTypes = {
  className: propTypes$1.exports.string,
  onChange: propTypes$1.exports.func,
  value: propTypes$1.exports.shape({
    hours: propTypes$1.exports.string,
    minutes: propTypes$1.exports.string,
    seconds: propTypes$1.exports.string,
    meridian: propTypes$1.exports.string
  })
};
TimePicker.defaultProps = {
  className: '',
  onChange: function onChange() {},
  value: null
};

var css$I = ".Footer_module_root__0e6d72de {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  align-items: stretch;\n  margin-inline: 1rem;\n}\n.Footer_module_root__0e6d72de .Footer_module_apply__0e6d72de {\n  margin-top: 0.5rem;\n  width: 100%;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.Footer_module_root__0e6d72de .Footer_module_timePicker__0e6d72de {\n  margin-bottom: 1.25rem;\n}\n\n.Footer_module_selectedDate__0e6d72de {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  gap: 1.125rem;\n  background: var(--white);\n  border: 0.0625rem solid var(--grey4);\n  border-radius: 0.25rem;\n}\n.Footer_module_selectedDate__0e6d72de .Footer_module_date__0e6d72de {\n  font-weight: 500;\n  font-size: 0.875rem;\n  line-height: 1.3125rem;\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n}\n.Footer_module_selectedDate__0e6d72de .Footer_module_date__0e6d72de .Footer_module_cross__0e6d72de {\n  width: 1.5rem;\n  height: 1.5rem;\n}\n.Footer_module_selectedDate__0e6d72de .Footer_module_date__0e6d72de .Footer_module_value__0e6d72de {\n  font-weight: 400;\n  padding-right: 0.7rem;\n  border-right: 1px var(--grey3) solid;\n}\n\n.Footer_module_dateRanges__0e6d72de {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  align-items: stretch;\n  margin-top: 0.5rem;\n}\n.Footer_module_dateRanges__0e6d72de .Footer_module_dateRange__0e6d72de {\n  display: flex;\n  align-items: center;\n  padding: 0.875rem 1rem;\n  gap: 1.125rem;\n  cursor: pointer;\n}\n.Footer_module_dateRanges__0e6d72de .Footer_module_dateRange__0e6d72de:hover {\n  background-color: var(--background);\n}\n.Footer_module_dateRanges__0e6d72de .Footer_module_dateRange__0e6d72de span {\n  font-weight: 400;\n  font-size: 0.875rem;\n  line-height: 1.3125rem;\n  color: var(--black);\n}\n.Footer_module_dateRanges__0e6d72de .Footer_module_selected__0e6d72de {\n  background-color: var(--background);\n}";
var modules_b490bd5d = {"root":"Footer_module_root__0e6d72de","apply":"Footer_module_apply__0e6d72de","time-picker":"Footer_module_timePicker__0e6d72de","selected-date":"Footer_module_selectedDate__0e6d72de","date":"Footer_module_date__0e6d72de","cross":"Footer_module_cross__0e6d72de","value":"Footer_module_value__0e6d72de","date-ranges":"Footer_module_dateRanges__0e6d72de","date-range":"Footer_module_dateRange__0e6d72de","selected":"Footer_module_selected__0e6d72de"};
n(css$I,{});

var getDateAndUnixRange = function getDateAndUnixRange(duration) {
  var startingDate = sub$2(new Date(), duration);
  startingDate.setHours(0, 0, 0, 0);
  var endingDate = new Date();
  endingDate.setHours(0, 0, 0, 0);
  var dates = getDatesInStringFormat({
    startingDate: startingDate,
    endingDate: endingDate
  });
  var unix = [getUnixTime(startingDate), getUnixTime(endingDate)];
  return {
    dates: dates,
    unix: unix
  };
};
var dateRanges = function dateRanges() {
  var customRanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  if ((customRanges === null || customRanges === void 0 ? void 0 : customRanges.length) > 0) {
    return customRanges.map(function (range) {
      return {
        title: range.title,
        dateRange: getDateAndUnixRange(_defineProperty$1({}, range.type, [range.value]))
      };
    });
  }
  return [{
    title: 'Last 24 Hours',
    dateRange: getDateAndUnixRange({
      hours: 24
    })
  }, {
    title: 'Last 7 Days',
    dateRange: getDateAndUnixRange({
      days: 7
    })
  }, {
    title: 'Last 15 Days',
    dateRange: getDateAndUnixRange({
      days: 15
    })
  }, {
    title: 'Last 1 Month',
    dateRange: getDateAndUnixRange({
      months: 1
    })
  }];
};

var SelectedDateView = function SelectedDateView(props) {
  var value = props.value,
    action = props.action,
    Icon = props.icon;
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: modules_b490bd5d['selected-date'],
    children: [/*#__PURE__*/jsxRuntime.jsx(Calender$1, {}), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: modules_b490bd5d.date,
      children: [/*#__PURE__*/jsxRuntime.jsx("span", {
        className: classes(modules_b490bd5d.value),
        children: value
      }), /*#__PURE__*/jsxRuntime.jsx(Button, {
        size: "auto",
        variant: "text",
        onClick: action,
        leftComponent: Icon
      })]
    })]
  });
};
var Footer = function Footer(props) {
  var _props$selectedDate = props.selectedDate,
    selectedDate = _props$selectedDate === void 0 ? {} : _props$selectedDate,
    _props$selectedRange = props.selectedRange,
    selectedRange = _props$selectedRange === void 0 ? {} : _props$selectedRange,
    setSelectedDate = props.setSelectedDate,
    setSelectedRange = props.setSelectedRange,
    range = props.range,
    goToDate = props.goToDate,
    onApply = props.onApply,
    setFixedRange = props.setFixedRange,
    customRanges = props.customRanges;
  var date = selectedDate.date,
    month = selectedDate.month,
    year = selectedDate.year;
  var _selectedRange$dates = selectedRange.dates,
    dates = _selectedRange$dates === void 0 ? [] : _selectedRange$dates;
  var monthInShort = month === null || month === void 0 ? void 0 : month.substr(0, 3);
  var datesSelected = date || dates.length === 2;
  var selectFixedDateRange = function selectFixedDateRange(dateRange, title) {
    setSelectedRange(dateRange);
    setFixedRange(title);
  };
  var resetDate = function resetDate() {
    goToDate(getUnixTime(new Date()));
  };
  var clearRangeSelection = function clearRangeSelection() {
    setSelectedRange({});
  };
  var datePassed = fromUnixTime(selectedDate.unix);
  var onTimeChange = function onTimeChange(time) {
    var monthNumber = datePassed.getMonth();
    var hours = null;
    hours = time.hours;
    if (time.hours === '12') {
      hours = '00';
    }
    if (time.meridian === 'PM') {
      hours = 12 + parseInt(time.hours, 10);
    }
    var unix = getUnixTime(new Date(!Number.isNaN(selectedDate.year) ? selectedDate.year : getDayInfo(new Date()).year, !Number.isNaN(monthNumber) ? monthNumber : getDayInfo(new Date()).monthAsNumber, !Number.isNaN(selectedDate.date) ? selectedDate.date : getDayInfo(new Date()).dateAsNumber, Number(hours), Number(time.minutes), Number(time.seconds)));
    setSelectedDate(_objectSpread2(_objectSpread2({}, selectedDate), {}, {
      unix: unix
    }));
  };
  var getTimePickerValue = function getTimePickerValue() {
    if (datePassed.getDate()) {
      var _hours = ((datePassed.getHours() + 11) % 12 + 1).toString();
      var _minutes = datePassed.getMinutes().toString();
      var _seconds = datePassed.getSeconds().toString();
      var _meridian = datePassed.getHours() >= 12 ? 'PM' : 'AM';
      return {
        hours: doubleDigitted(_hours),
        minutes: doubleDigitted(_minutes),
        seconds: doubleDigitted(_seconds),
        meridian: _meridian
      };
    }
    var _getDayInfo = getDayInfo(new Date()),
      hours = _getDayInfo.hours;
    var _getDayInfo2 = getDayInfo(new Date()),
      minutes = _getDayInfo2.minutes;
    var _getDayInfo3 = getDayInfo(new Date()),
      seconds = _getDayInfo3.seconds;
    var meridian = getDayInfo(new Date()).hours >= 12 ? 'PM' : 'AM';
    return {
      hours: doubleDigitted(hours),
      minutes: doubleDigitted(minutes),
      seconds: doubleDigitted(seconds),
      meridian: meridian
    };
  };
  var timeValue = "".concat(getTimePickerValue().hours, ":").concat(getTimePickerValue().minutes, " ").concat(getTimePickerValue().meridian);
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: modules_b490bd5d.root,
    children: [!range && /*#__PURE__*/jsxRuntime.jsx(TimePicker, {
      value: getTimePickerValue(),
      onChange: onTimeChange,
      className: modules_b490bd5d['time-picker']
    }), datesSelected && (dates === null || dates === void 0 ? void 0 : dates.length) === 2 ? /*#__PURE__*/jsxRuntime.jsx(SelectedDateView, {
      range: true,
      value: "".concat(selectedRange.dates[0], " - ").concat(selectedRange.dates[1]),
      icon: function icon() {
        return /*#__PURE__*/jsxRuntime.jsx(Cross$1, {
          className: modules_b490bd5d.cross
        });
      },
      action: clearRangeSelection
    }) : datesSelected && /*#__PURE__*/jsxRuntime.jsx(SelectedDateView, {
      value: "".concat(doubleDigitted(date), " ").concat(monthInShort, " ").concat(year, " - ").concat(timeValue),
      icon: function icon() {
        return /*#__PURE__*/jsxRuntime.jsx(Reset, {});
      },
      action: resetDate
    }), range && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: modules_b490bd5d['date-ranges'],
      children: dateRanges(customRanges).map(function (_ref) {
        var _selectedRange$unix;
        var dateRange = _ref.dateRange,
          title = _ref.title;
        var selectedFixedDateRange = dateRange.unix.toString() === ((_selectedRange$unix = selectedRange.unix) === null || _selectedRange$unix === void 0 ? void 0 : _selectedRange$unix.toString());
        return /*#__PURE__*/jsxRuntime.jsxs("div", {
          className: classes(modules_b490bd5d['date-range'], selectedFixedDateRange ? modules_b490bd5d.selected : ''),
          onClick: function onClick() {
            selectFixedDateRange(dateRange, title);
          },
          children: [/*#__PURE__*/jsxRuntime.jsx(HalfShade, {}), /*#__PURE__*/jsxRuntime.jsx("span", {
            children: title
          })]
        }, title);
      })
    }), datesSelected && /*#__PURE__*/jsxRuntime.jsx(Button, {
      onClick: onApply,
      title: "Apply",
      className: modules_b490bd5d.apply
    })]
  });
};

var Calender = function Calender(props) {
  var range = props.range,
    selectedDate = props.selectedDate,
    setSelectedDate = props.setSelectedDate,
    selectedRange = props.selectedRange,
    setSelectedRange = props.setSelectedRange,
    onApply = props.onApply,
    disabledDates = props.disabledDates,
    disableDatesBefore = props.disableDatesBefore,
    value = props.value,
    setFixedRange = props.setFixedRange,
    customRanges = props.customRanges;
  var _getDayInfo = getDayInfo(new Date()),
    month = _getDayInfo.month,
    year = _getDayInfo.year,
    monthAsNumber = _getDayInfo.monthAsNumber,
    dayAsNumber = _getDayInfo.dayAsNumber;
  var _useState = React.useState({
      month: month,
      monthAsNumber: monthAsNumber,
      year: year,
      dayAsNumber: dayAsNumber
    }),
    _useState2 = _slicedToArray(_useState, 2),
    selectedMonth = _useState2[0],
    setSelectedMonth = _useState2[1];
  React.useEffect(function () {
    var _value$filter;
    if (range && (value === null || value === void 0 ? void 0 : (_value$filter = value.filter(Boolean)) === null || _value$filter === void 0 ? void 0 : _value$filter.length) > 0) {
      setSelectedRange({
        dates: getDatesInStringFormat({
          startingDate: fromUnixTime(value[0]),
          endingDate: fromUnixTime(value[1])
        }),
        unix: [value[0], value[1]]
      });
      var date = new Date();
      var dateAsNumber = date.getDate();
      var selectedDayInfo = getDayInfo(date);
      var selectedDateMonth = {
        month: selectedDayInfo.month,
        monthAsNumber: selectedDayInfo.monthAsNumber,
        year: selectedDayInfo.year,
        dayAsNumber: selectedDayInfo.dayAsNumber
      };
      setSelectedMonth({
        month: selectedDayInfo.month,
        monthAsNumber: selectedDayInfo.monthAsNumber,
        year: selectedDayInfo.year
      });
      setSelectedDate(_objectSpread2(_objectSpread2({}, selectedDate), {}, {
        month: selectedDateMonth.month,
        year: selectedDateMonth.year,
        date: dateAsNumber,
        unix: getUnixTime(date)
      }));
    } else if (!range && value) {
      var _date = fromUnixTime(value);
      var _dateAsNumber = _date.getDate();
      var _selectedDayInfo = getDayInfo(_date);
      var _selectedDateMonth = {
        month: _selectedDayInfo.month,
        monthAsNumber: _selectedDayInfo.monthAsNumber,
        year: _selectedDayInfo.year,
        dayAsNumber: _selectedDayInfo.dayAsNumber
      };
      setSelectedMonth({
        month: _selectedDayInfo.month,
        monthAsNumber: _selectedDayInfo.monthAsNumber,
        year: _selectedDayInfo.year
      });
      setSelectedDate(_objectSpread2(_objectSpread2({}, selectedDate), {}, {
        month: _selectedDateMonth.month,
        year: _selectedDateMonth.year,
        date: _dateAsNumber,
        unix: getUnixTime(_date)
      }));
    } else {
      var _date2 = new Date();
      if (!range && !isBefore(_date2, disableDatesBefore)) {
        var _dateAsNumber2 = _date2.getDate();
        setSelectedDate(_objectSpread2(_objectSpread2({}, selectedDate), {}, {
          month: selectedMonth.month,
          year: selectedMonth.year,
          date: _dateAsNumber2,
          unix: getUnixTime(_date2)
        }));
      }
    }
  }, []);
  var goToDate = function goToDate(unix) {
    var dayInfo = getDayInfo(new Date(unix * 1000));
    setSelectedMonth({
      month: dayInfo.month,
      monthAsNumber: dayInfo.monthAsNumber,
      year: dayInfo.year
    });
    setSelectedDate(_objectSpread2(_objectSpread2({}, selectedDate), {}, {
      month: dayInfo.month,
      year: dayInfo.year,
      date: dayInfo.dateAsNumber,
      unix: getUnixTime(new Date(unix * 1000))
    }));
  };
  var onMonthChange = function onMonthChange(switchSide) {
    if (switchSide === 'prev') {
      if (selectedMonth.monthAsNumber === 0) {
        var _previousMonth = FULL_MONTHS[11];
        setSelectedMonth({
          month: _previousMonth,
          monthAsNumber: 11,
          year: selectedMonth.year - 1
        });
        return;
      }
      var previousMonthNumber = selectedMonth.monthAsNumber - 1;
      var previousMonth = FULL_MONTHS[previousMonthNumber];
      setSelectedMonth({
        month: previousMonth,
        monthAsNumber: previousMonthNumber,
        year: selectedMonth.year
      });
      return;
    }
    if (switchSide === 'next') {
      if (selectedMonth.monthAsNumber === 11) {
        var _nextMonth = FULL_MONTHS[0];
        setSelectedMonth({
          month: _nextMonth,
          monthAsNumber: 0,
          year: selectedMonth.year + 1
        });
        return;
      }
      var nextMonthNumber = selectedMonth.monthAsNumber + 1;
      var nextMonth = FULL_MONTHS[nextMonthNumber];
      setSelectedMonth({
        month: nextMonth,
        monthAsNumber: nextMonthNumber,
        year: selectedMonth.year
      });
    }
  };
  var commonCalenderProps = {
    selectedDate: selectedDate,
    setSelectedDate: setSelectedDate,
    selectedRange: selectedRange,
    setSelectedRange: setSelectedRange,
    range: range
  };
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: modules_3722b5cd.root,
    children: [/*#__PURE__*/jsxRuntime.jsx(Header, {
      selectedMonth: selectedMonth,
      onMonthChange: onMonthChange
    }), /*#__PURE__*/jsxRuntime.jsx(Body, _objectSpread2(_objectSpread2({}, commonCalenderProps), {}, {
      selectedMonth: selectedMonth,
      disabledDates: disabledDates,
      disableDatesBefore: disableDatesBefore
    })), /*#__PURE__*/jsxRuntime.jsx(Footer, _objectSpread2(_objectSpread2({}, commonCalenderProps), {}, {
      onApply: onApply,
      goToDate: goToDate,
      customRanges: customRanges,
      setFixedRange: setFixedRange
    }))]
  });
};

var css$H = ".DatePicker_module_root__e3d435c2 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  gap: 0.5rem;\n  max-width: 100%;\n  overflow: visible;\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_label__e3d435c2 {\n  font-weight: 400;\n  font-size: 0.75rem;\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_label__e3d435c2.DatePicker_module_light__e3d435c2 {\n  color: var(--black);\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_label__e3d435c2.DatePicker_module_dark__e3d435c2 {\n  color: var(--white);\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  position: relative;\n  background: transparent;\n  border-radius: 0.25rem;\n  width: auto;\n  border: 0.0625rem solid;\n  padding: 0.75rem 1rem;\n  cursor: pointer;\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 > div {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  font-size: 0px;\n  letter-spacing: 0px;\n  word-spacing: 0px;\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_placeholder__e3d435c2 {\n  font-weight: 400;\n  font-size: 1rem;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  margin-left: 0.9375rem;\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_value__e3d435c2 {\n  font-weight: 400;\n  font-size: 1rem;\n  margin-left: 0.9375rem;\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_value__e3d435c2.DatePicker_module_light__e3d435c2 {\n  color: var(--black);\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_value__e3d435c2.DatePicker_module_dark__e3d435c2 {\n  color: var(--white);\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_value__e3d435c2 span {\n  max-width: 200px;\n  display: inline-block;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  font-weight: 500;\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_input__e3d435c2 {\n  display: none;\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_icon__e3d435c2 {\n  width: 1.25rem;\n  height: 1.25rem;\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_icon__e3d435c2.DatePicker_module_light__e3d435c2 > path {\n  fill: var(--dark-grey);\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_icon__e3d435c2.DatePicker_module_dark__e3d435c2 > path {\n  fill: var(--white);\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_down__e3d435c2 {\n  transform: rotate(270deg);\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_up__e3d435c2 {\n  transform: rotate(90deg);\n}\n.DatePicker_module_root__e3d435c2.DatePicker_module_dark__e3d435c2 .DatePicker_module_container__e3d435c2 {\n  border-color: var(--grey);\n}\n.DatePicker_module_root__e3d435c2.DatePicker_module_dark__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_placeholder__e3d435c2 {\n  color: var(--grey2);\n}\n.DatePicker_module_root__e3d435c2.DatePicker_module_light__e3d435c2 .DatePicker_module_container__e3d435c2 {\n  border-color: var(--grey4);\n}\n.DatePicker_module_root__e3d435c2.DatePicker_module_light__e3d435c2 .DatePicker_module_container__e3d435c2 .DatePicker_module_placeholder__e3d435c2 {\n  color: var(--grey);\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_disabled__e3d435c2 {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  position: relative;\n  background: var(--grey10);\n  border-radius: 0.25rem;\n  border: 0.0625rem solid var(--grey5);\n  padding: 0.75rem 1rem;\n  cursor: pointer;\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_disabled__e3d435c2 .DatePicker_module_downArrow__e3d435c2 {\n  transform: rotate(270deg);\n  fill: var(--grey3);\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_disabled__e3d435c2 .DatePicker_module_placeholder__e3d435c2 {\n  font-weight: 400;\n  font-size: 1rem;\n  color: var(--grey3);\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.DatePicker_module_root__e3d435c2.DatePicker_module_open__e3d435c2 {\n  border-color: var(--highlight);\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_error__e3d435c2 {\n  border: 0.0938rem solid var(--error);\n}\n.DatePicker_module_root__e3d435c2 .DatePicker_module_errorText__e3d435c2 {\n  font-weight: 400;\n  font-size: 0.75rem;\n  line-height: 0.9375rem;\n  color: var(--error);\n}\n\n.DatePicker_module_popper__e3d435c2 {\n  display: none;\n  background: var(--white);\n  border: 0.0625rem solid #d9d9d9;\n  box-shadow: -2px -2px 4px rgba(166, 166, 166, 0.25), 2px 2px 4px rgba(166, 166, 166, 0.24);\n  border-radius: 0.25rem;\n  overflow: auto;\n}\n.DatePicker_module_popper__e3d435c2.DatePicker_module_open__e3d435c2 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  position: absolute;\n}";
var modules_5b831cd1 = {"root":"DatePicker_module_root__e3d435c2","label":"DatePicker_module_label__e3d435c2","light":"DatePicker_module_light__e3d435c2","dark":"DatePicker_module_dark__e3d435c2","container":"DatePicker_module_container__e3d435c2","placeholder":"DatePicker_module_placeholder__e3d435c2","value":"DatePicker_module_value__e3d435c2","input":"DatePicker_module_input__e3d435c2","icon":"DatePicker_module_icon__e3d435c2","down":"DatePicker_module_down__e3d435c2","up":"DatePicker_module_up__e3d435c2","disabled":"DatePicker_module_disabled__e3d435c2","down-arrow":"DatePicker_module_downArrow__e3d435c2","open":"DatePicker_module_open__e3d435c2","error":"DatePicker_module_error__e3d435c2","error-text":"DatePicker_module_errorText__e3d435c2","popper":"DatePicker_module_popper__e3d435c2"};
n(css$H,{});

var isMaxRangeExceeded = function isMaxRangeExceeded(_ref) {
  var maxRange = _ref.maxRange,
    selectedRange = _ref.selectedRange;
  if (maxRange === null) {
    return false;
  }
  var value = maxRange.value,
    type = maxRange.type;
  var unix = selectedRange.unix;
  var _unix = _slicedToArray(unix, 2),
    firstDateInRange = _unix[0],
    secondDateInRange = _unix[1];
  var diffInMonth = differenceInMonths(fromUnixTime(secondDateInRange), fromUnixTime(firstDateInRange));
  var diffInDays = differenceInDays(fromUnixTime(secondDateInRange), fromUnixTime(firstDateInRange));
  if (type === 'months') {
    return diffInMonth <= value && diffInDays < value * 30;
  }
  if (type === 'days') {
    return diffInDays <= value;
  }
  return false;
};
var getDateRangeTag = function getDateRangeTag() {
  var dates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var _dates = _slicedToArray(dates, 2),
    startUnix = _dates[0],
    endUnix = _dates[1];
  var dayDifference = differenceInDays(fromUnixTime(endUnix), fromUnixTime(startUnix));
  var hourDifference = differenceInHours(fromUnixTime(endUnix), fromUnixTime(startUnix));
  if (hourDifference <= 24) {
    return 'hour';
  }
  if (dayDifference >= 30) {
    return 'month';
  }
  return 'day';
};

var DatePicker = function DatePicker(props) {
  var _value$filter;
  var placeholder = props.placeholder,
    label = props.label,
    range = props.range,
    onApply = props.onApply,
    disabledDates = props.disabledDates,
    maxRange = props.maxRange,
    value = props.value,
    disabled = props.disabled,
    className = props.className,
    disableDatesBefore = props.disableDatesBefore,
    theme = props.theme,
    onClear = props.onClear,
    customRanges = props.customRanges;
  var _useState = React.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    open = _useState2[0],
    setOpen = _useState2[1];
  var _useState3 = React.useState(function () {
      return {
        dates: [],
        unix: []
      };
    }),
    _useState4 = _slicedToArray(_useState3, 2),
    selectedRange = _useState4[0],
    setSelectedRange = _useState4[1];
  var _useState5 = React.useState(null),
    _useState6 = _slicedToArray(_useState5, 2),
    fixedRange = _useState6[0],
    setFixedRange = _useState6[1];
  var _useState7 = React.useState(function () {
      return '';
    }),
    _useState8 = _slicedToArray(_useState7, 2),
    selectedDate = _useState8[0],
    setSelectedDate = _useState8[1];
  var _useState9 = React.useState(function () {
      return '';
    }),
    _useState10 = _slicedToArray(_useState9, 2),
    error = _useState10[0],
    setError = _useState10[1];
  var datePickerRef = React.useRef();
  var displayValue = '';
  if (range && (value === null || value === void 0 ? void 0 : (_value$filter = value.filter(Boolean)) === null || _value$filter === void 0 ? void 0 : _value$filter.length) > 0) {
    var sDate = fromUnixTime(value[0]);
    var eDate = fromUnixTime(value[1]);
    var selectedFixedRange = dateRanges().find(function (rg) {
      var _rg$dateRange, _rg$dateRange$unix;
      return ((_rg$dateRange = rg.dateRange) === null || _rg$dateRange === void 0 ? void 0 : (_rg$dateRange$unix = _rg$dateRange.unix) === null || _rg$dateRange$unix === void 0 ? void 0 : _rg$dateRange$unix.toString()) === value.toString();
    });
    if (selectedFixedRange) {
      displayValue = selectedFixedRange.title;
    } else {
      var _sDate$getMonth$toStr, _eDate$getMonth$toStr;
      displayValue = " ".concat(sDate.getDate(), " ").concat(MONTHS[(_sDate$getMonth$toStr = sDate.getMonth().toString()) === null || _sDate$getMonth$toStr === void 0 ? void 0 : _sDate$getMonth$toStr.substring(0, 3)], " - ").concat(eDate.getDate(), " ").concat(MONTHS[(_eDate$getMonth$toStr = eDate.getMonth().toString()) === null || _eDate$getMonth$toStr === void 0 ? void 0 : _eDate$getMonth$toStr.substring(0, 3)], " ").concat(eDate.getFullYear());
    }
  }
  if (!range && value) {
    var _sDate$getMonth$toStr2;
    var _sDate = fromUnixTime(value);
    var timeValue = "".concat((_sDate.getHours() + 11) % 12 + 1, ":").concat(_sDate.getMinutes(), " ").concat(_sDate.getHours() >= 12 ? 'PM' : 'AM');
    displayValue = " ".concat(_sDate.getDate(), " ").concat(MONTHS[(_sDate$getMonth$toStr2 = _sDate.getMonth().toString()) === null || _sDate$getMonth$toStr2 === void 0 ? void 0 : _sDate$getMonth$toStr2.substring(0, 3)], " ").concat(_sDate.getFullYear(), " ").concat(timeValue);
  }
  if (fixedRange) {
    displayValue = fixedRange;
  }
  var _useFloating = useFloating({
      open: open,
      onOpenChange: setOpen,
      whileElementsMounted: autoUpdate,
      middleware: [size({
        apply: function apply(_ref) {
          var rects = _ref.rects,
            availableHeight = _ref.availableHeight,
            elements = _ref.elements;
          Object.assign(elements.floating.style, {
            width: "".concat(rects.reference.width, "px"),
            minWidth: 'fit-content',
            maxHeight: "".concat(availableHeight, "px")
          });
        },
        padding: 8
      }), offset(5), flip({
        padding: 8
      }), shift({
        padding: 8
      })]
    }),
    x = _useFloating.x,
    y = _useFloating.y,
    reference = _useFloating.reference,
    floating = _useFloating.floating,
    strategy = _useFloating.strategy,
    context = _useFloating.context;
  useOutsideClickListener(floating, function () {
    return setOpen(false);
  });
  var _useInteractions = useInteractions([useClick(context, {
      enabled: !disabled
    }), useDismiss(context)]),
    getReferenceProps = _useInteractions.getReferenceProps,
    getFloatingProps = _useInteractions.getFloatingProps;
  var apply = function apply() {
    var _selectedRange$dates;
    if (((_selectedRange$dates = selectedRange.dates) === null || _selectedRange$dates === void 0 ? void 0 : _selectedRange$dates.length) === 2) {
      if (maxRange !== null && !isMaxRangeExceeded({
        maxRange: maxRange,
        selectedRange: selectedRange
      })) {
        setError('Invalid range of dates');
        setOpen(false);
        return;
      }
      setError('');
      onApply(selectedRange.unix, fixedRange, getDateRangeTag(selectedRange.unix));
      setOpen(false);
    } else {
      onApply(selectedDate.unix);
      setOpen(false);
    }
  };
  var calenderProps = {
    selectedDate: selectedDate,
    setSelectedDate: setSelectedDate,
    selectedRange: selectedRange,
    setSelectedRange: setSelectedRange,
    range: range,
    onApply: function onApply() {
      apply();
    },
    disabledDates: disabledDates,
    disableDatesBefore: disableDatesBefore,
    value: value,
    setFixedRange: setFixedRange,
    customRanges: customRanges
  };
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(modules_5b831cd1.root, className, modules_5b831cd1[theme]),
    ref: datePickerRef,
    children: [label && /*#__PURE__*/jsxRuntime.jsx("span", {
      className: classes(modules_5b831cd1.label, modules_5b831cd1[theme]),
      children: label
    }), /*#__PURE__*/jsxRuntime.jsxs("div", _objectSpread2(_objectSpread2({
      "data-elem": "header",
      ref: reference,
      className: classes(modules_5b831cd1.container, disabled ? modules_5b831cd1.disabled : '', open ? modules_5b831cd1.open : '', error ? modules_5b831cd1.error : '', modules_5b831cd1[theme])
    }, getReferenceProps()), {}, {
      children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
        children: [/*#__PURE__*/jsxRuntime.jsx(Calender$1, {
          className: classes(modules_5b831cd1.icon, modules_5b831cd1[theme])
        }), !displayValue && /*#__PURE__*/jsxRuntime.jsx("span", {
          className: classes(modules_5b831cd1.placeholder, modules_5b831cd1[theme]),
          children: placeholder
        }), displayValue && /*#__PURE__*/jsxRuntime.jsx("div", {
          className: classes(modules_5b831cd1.value, modules_5b831cd1[theme]),
          children: /*#__PURE__*/jsxRuntime.jsx("span", {
            children: displayValue
          })
        })]
      }), /*#__PURE__*/jsxRuntime.jsx("input", {
        className: modules_5b831cd1.input,
        value: displayValue
      }), value ? /*#__PURE__*/jsxRuntime.jsx("div", {
        onClick: function onClick(event) {
          event.stopPropagation();
          onClear();
        },
        children: /*#__PURE__*/jsxRuntime.jsx(Cross$1, {
          className: classes(modules_5b831cd1.icon, modules_5b831cd1[theme])
        })
      }) : /*#__PURE__*/jsxRuntime.jsx(Chevron, {
        className: classes(modules_5b831cd1.icon, modules_5b831cd1[theme]),
        position: open ? 'bottom' : 'top'
      })]
    })), error && /*#__PURE__*/jsxRuntime.jsx("div", {
      className: modules_5b831cd1['error-text'],
      children: error
    }), /*#__PURE__*/jsxRuntime.jsx(Popper, {
      open: open,
      wrapperid: "datePicker-popper",
      children: open && /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2(_objectSpread2({}, getFloatingProps({
        role: 'group',
        ref: floating,
        onKeyDown: function onKeyDown(event) {
          if (event.key === 'Tab') {
            setOpen(false);
          }
        },
        style: {
          position: strategy,
          top: y !== null && y !== void 0 ? y : 0,
          left: x !== null && x !== void 0 ? x : 0
        }
      })), {}, {
        className: classes(modules_5b831cd1.popper, open ? modules_5b831cd1.open : ''),
        children: /*#__PURE__*/jsxRuntime.jsx(Calender, _objectSpread2({}, calenderProps))
      }))
    })]
  });
};
DatePicker.propTypes = {
  placeholder: propTypes$1.exports.string,
  label: propTypes$1.exports.string,
  range: propTypes$1.exports.bool,
  onApply: propTypes$1.exports.func,
  onClear: propTypes$1.exports.func,
  value: propTypes$1.exports.oneOfType([propTypes$1.exports.array, propTypes$1.exports.string]),
  disabled: propTypes$1.exports.bool,
  disabledDates: propTypes$1.exports.arrayOf(propTypes$1.exports.string),
  maxRange: propTypes$1.exports.shape({
    value: propTypes$1.exports.number,
    type: propTypes$1.exports.string
  }),
  className: propTypes$1.exports.string,
  disableDatesBefore: propTypes$1.exports.arrayOf(propTypes$1.exports.string),
  theme: propTypes$1.exports.string,
  defaultRangeSelection: propTypes$1.exports.arrayOf(propTypes$1.exports.number),
  customRanges: propTypes$1.exports.arrayOf(propTypes$1.exports.shape({
    title: propTypes$1.exports.string,
    type: propTypes$1.exports.string,
    value: propTypes$1.exports.string
  }))
};
DatePicker.defaultProps = {
  placeholder: '',
  label: '',
  range: false,
  onApply: null,
  disabled: false,
  disabledDates: [],
  maxRange: null,
  value: null,
  className: '',
  disableDatesBefore: [],
  theme: 'dark',
  customRanges: null,
  defaultRangeSelection: null,
  onClear: function onClear() {}
};

var css$G = ".HierarchyItem_module_root__5ef1c91d {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  flex: 1;\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  gap: 0.25rem;\n  min-height: 2rem;\n  height: auto;\n  padding: 0rem 0.5rem;\n  cursor: pointer;\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d > [data-elem=component1], .HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d > [data-elem=component3] {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d > [data-elem=component1] .HierarchyItem_module_expand__5ef1c91d, .HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d > [data-elem=component3] .HierarchyItem_module_expand__5ef1c91d {\n  padding: 0;\n  height: auto;\n  width: 1rem;\n  height: 1rem;\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d > [data-elem=component1] .HierarchyItem_module_expand__5ef1c91d .HierarchyItem_module_icon__5ef1c91d, .HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d > [data-elem=component3] .HierarchyItem_module_expand__5ef1c91d .HierarchyItem_module_icon__5ef1c91d {\n  transform: rotate(-90deg);\n  width: 1rem;\n  height: 1rem;\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d > [data-elem=component2] {\n  flex: 1 1 auto;\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d > [data-elem=component2] .HierarchyItem_module_title__5ef1c91d {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  width: 100%;\n  height: auto;\n  padding: 0.25rem 0rem;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d:hover {\n  background: var(--background);\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d:hover .HierarchyItem_module_icon__5ef1c91d,\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d:hover .HierarchyItem_module_title__5ef1c91d,\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_header__5ef1c91d:hover .HierarchyItem_module_title__5ef1c91d svg {\n  color: var(--highlight);\n  fill: var(--highlight);\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_body__5ef1c91d {\n  display: none;\n  flex: 1 0 auto;\n  padding: 0px 0rem 0px 0.25rem;\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_body__5ef1c91d > [data-elem=component1] {\n  flex: 0 0 1.6rem;\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_body__5ef1c91d > [data-elem=component1] .HierarchyItem_module_tail__5ef1c91d {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: center;\n  width: 1.6rem;\n  height: 100%;\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_body__5ef1c91d > [data-elem=component1] .HierarchyItem_module_tail__5ef1c91d::after {\n  content: \"\";\n  display: block;\n  margin: auto;\n  width: 1px;\n  flex: 1;\n  background: var(--grey1);\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_body__5ef1c91d > [data-elem=component2] {\n  flex: 1 0 auto;\n}\n.HierarchyItem_module_root__5ef1c91d .HierarchyItem_module_body__5ef1c91d > [data-elem=component2] .HierarchyItem_module_children__5ef1c91d {\n  flex: 1 0 auto;\n}\n.HierarchyItem_module_root__5ef1c91d.HierarchyItem_module_open__5ef1c91d > .HierarchyItem_module_header__5ef1c91d .HierarchyItem_module_expand__5ef1c91d .HierarchyItem_module_icon__5ef1c91d {\n  transform: none;\n}\n.HierarchyItem_module_root__5ef1c91d.HierarchyItem_module_open__5ef1c91d > .HierarchyItem_module_body__5ef1c91d {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: stretch;\n  gap: 0.25rem;\n  height: auto;\n}\n.HierarchyItem_module_root__5ef1c91d.HierarchyItem_module_active__5ef1c91d > .HierarchyItem_module_header__5ef1c91d {\n  background: var(--background);\n}\n.HierarchyItem_module_root__5ef1c91d.HierarchyItem_module_active__5ef1c91d > .HierarchyItem_module_header__5ef1c91d .HierarchyItem_module_icon__5ef1c91d,\n.HierarchyItem_module_root__5ef1c91d.HierarchyItem_module_active__5ef1c91d > .HierarchyItem_module_header__5ef1c91d .HierarchyItem_module_title__5ef1c91d,\n.HierarchyItem_module_root__5ef1c91d.HierarchyItem_module_active__5ef1c91d > .HierarchyItem_module_header__5ef1c91d .HierarchyItem_module_title__5ef1c91d svg {\n  color: var(--highlight);\n  fill: var(--highlight);\n}";
var modules_6d03d164 = {"root":"HierarchyItem_module_root__5ef1c91d","header":"HierarchyItem_module_header__5ef1c91d","expand":"HierarchyItem_module_expand__5ef1c91d","icon":"HierarchyItem_module_icon__5ef1c91d","title":"HierarchyItem_module_title__5ef1c91d","body":"HierarchyItem_module_body__5ef1c91d","tail":"HierarchyItem_module_tail__5ef1c91d","children":"HierarchyItem_module_children__5ef1c91d","open":"HierarchyItem_module_open__5ef1c91d","active":"HierarchyItem_module_active__5ef1c91d"};
n(css$G,{});

var HierarchyItem = function HierarchyItem(props) {
  var defaultOpen = props.defaultOpen,
    iconPlacement = props.iconPlacement,
    title = props.title,
    children = props.children,
    _onClick = props.onClick,
    onDoubleClick = props.onDoubleClick,
    active = props.active;
  var _useState = React.useState(defaultOpen),
    _useState2 = _slicedToArray(_useState, 2),
    open = _useState2[0],
    setOpen = _useState2[1];
  var icon = /*#__PURE__*/jsxRuntime.jsx(Button, {
    className: modules_6d03d164.expand,
    size: "auto",
    variant: "text",
    color: "default",
    onClick: function onClick() {
      setOpen(function (prevState) {
        var newState = !prevState;
        _onClick === null || _onClick === void 0 ? void 0 : _onClick(newState);
        onDoubleClick === null || onDoubleClick === void 0 ? void 0 : onDoubleClick(newState);
        return newState;
      });
    },
    leftComponent: function leftComponent() {
      return /*#__PURE__*/jsxRuntime.jsx(Caret, {
        className: modules_6d03d164.icon
      });
    }
  });
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(modules_6d03d164.root, open ? modules_6d03d164.open : '', active ? modules_6d03d164.active : ''),
    children: [/*#__PURE__*/jsxRuntime.jsx(BaseCell, {
      flexible: true,
      size: "auto",
      className: modules_6d03d164.header,
      component1: iconPlacement === 'left' && icon,
      component2: /*#__PURE__*/jsxRuntime.jsx(Button, {
        className: modules_6d03d164.title,
        flexible: true,
        size: "auto",
        variant: "text",
        color: "default",
        onClick: function onClick(event) {
          var detail = event.detail;

          // single click
          if (detail === 1) {
            _onClick === null || _onClick === void 0 ? void 0 : _onClick(open);
            // double click
          } else if (detail === 2) {
            setOpen(function (prevState) {
              var newState = !prevState;
              onDoubleClick === null || onDoubleClick === void 0 ? void 0 : onDoubleClick(newState);
              return newState;
            });
          }
        },
        leftComponent: function leftComponent() {
          return title;
        }
      }),
      component3: iconPlacement === 'right' && icon
    }), /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
      size: "auto",
      className: modules_6d03d164.body,
      component1: /*#__PURE__*/jsxRuntime.jsx("div", {
        className: modules_6d03d164.tail
      }),
      component2: /*#__PURE__*/jsxRuntime.jsx("div", {
        className: modules_6d03d164.children,
        children: children
      })
    })]
  });
};
HierarchyItem.propTypes = {
  iconPlacement: propTypes$1.exports.oneOf(['left', 'right', 'none']),
  title: propTypes$1.exports.node,
  defaultOpen: propTypes$1.exports.bool,
  onClick: propTypes$1.exports.func,
  active: propTypes$1.exports.bool
};
HierarchyItem.defaultProps = {
  iconPlacement: 'left',
  title: null,
  defaultOpen: false,
  onClick: function onClick() {},
  active: false
};

var css$F = ".HierarchyBrowser_module_root__649d3da2 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  width: 20rem;\n  position: relative;\n}\n.HierarchyBrowser_module_root__649d3da2 .HierarchyBrowser_module_header__649d3da2 {\n  padding: 0.5rem;\n  background: var(--dark-grey);\n  color: var(--white);\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.HierarchyBrowser_module_root__649d3da2 .HierarchyBrowser_module_body__649d3da2 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  overflow: auto;\n}\n.HierarchyBrowser_module_root__649d3da2 .HierarchyBrowser_module_item__649d3da2 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  gap: 0.25rem;\n}\n.HierarchyBrowser_module_root__649d3da2 .HierarchyBrowser_module_item__649d3da2 .HierarchyBrowser_module_itemIcon__649d3da2 {\n  width: 1rem;\n}\n.HierarchyBrowser_module_root__649d3da2::after {\n  position: absolute;\n  right: 0;\n  content: \"\";\n  width: 1px;\n  height: 100%;\n  background: var(--grey4);\n}\n.HierarchyBrowser_module_root__649d3da2.HierarchyBrowser_module_resizable__649d3da2:hover::after {\n  width: 3px;\n  cursor: col-resize;\n}";
var modules_5e29d515 = {"root":"HierarchyBrowser_module_root__649d3da2","header":"HierarchyBrowser_module_header__649d3da2","body":"HierarchyBrowser_module_body__649d3da2","item":"HierarchyBrowser_module_item__649d3da2","item-icon":"HierarchyBrowser_module_itemIcon__649d3da2","resizable":"HierarchyBrowser_module_resizable__649d3da2"};
n(css$F,{});

var Title = function Title(props) {
  var item = props.item;
  var Icon = null;
  switch (item.id) {
    case 'database':
    case 'schema':
    case 'object':
      Icon = Server;
      break;
  }
  return /*#__PURE__*/jsxRuntime.jsxs("span", {
    className: modules_5e29d515.item,
    children: [Icon && /*#__PURE__*/jsxRuntime.jsx(Icon, {
      className: modules_5e29d515['item-icon']
    }), /*#__PURE__*/jsxRuntime.jsx("span", {
      className: modules_5e29d515['item-title'],
      children: item === null || item === void 0 ? void 0 : item.title
    }), (item === null || item === void 0 ? void 0 : item.count) && /*#__PURE__*/jsxRuntime.jsxs("span", {
      className: modules_5e29d515['item-count'],
      children: ["(", item === null || item === void 0 ? void 0 : item.count, ")"]
    })]
  });
};
var HierarchyBrowser = function HierarchyBrowser(props) {
  var className = props.className,
    metadata = props.metadata,
    onItemClick = props.onItemClick,
    onItemDoubleClick = props.onItemDoubleClick,
    minWidth = props.minWidth,
    maxWidth = props.maxWidth,
    borderSize = props.borderSize,
    resizable = props.resizable,
    setItemProps = props.setItemProps,
    title = props.title;
  var browserRef = React.useRef(null);
  useResize({
    ref: browserRef,
    styles: {
      minWidth: minWidth,
      maxWidth: maxWidth !== null && maxWidth !== void 0 ? maxWidth : document.documentElement.getBoundingClientRect().width,
      borderSize: borderSize
    },
    enabled: resizable
  });
  var handleItemClick = function handleItemClick(item, pathString) {
    return function (open) {
      onItemClick(item, pathString, open);
    };
  };
  var handleItemDoubleClick = function handleItemDoubleClick(item, pathString) {
    return function (open) {
      onItemDoubleClick(item, pathString, open);
    };
  };
  var renderTree = function renderTree(data) {
    var _data$list$map, _data$list, _data$list$map2;
    var pathString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (data == null) {
      return null;
    }
    var hasChildren = (data === null || data === void 0 ? void 0 : data.list) === true || Array.isArray(data === null || data === void 0 ? void 0 : data.list);
    return /*#__PURE__*/jsxRuntime.jsx(HierarchyItem, _objectSpread2(_objectSpread2({
      title: /*#__PURE__*/jsxRuntime.jsx(Title, {
        item: data
      }),
      iconPlacement: hasChildren ? 'left' : 'none',
      onClick: handleItemClick(data, pathString),
      onDoubleClick: handleItemDoubleClick(data, pathString)
    }, setItemProps(data, pathString)), {}, {
      children: hasChildren && ((_data$list$map = (_data$list = data.list) === null || _data$list === void 0 ? void 0 : (_data$list$map2 = _data$list.map) === null || _data$list$map2 === void 0 ? void 0 : _data$list$map2.call(_data$list, function (item, idx) {
        return renderTree(item, "".concat(pathString).concat(pathString.length > 0 ? '.' : '', "list[").concat(idx, "]"));
      })) !== null && _data$list$map !== void 0 ? _data$list$map : [])
    }));
  };
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    ref: browserRef,
    className: classes(modules_5e29d515.root, className, resizable ? modules_5e29d515.resizable : ''),
    children: [/*#__PURE__*/jsxRuntime.jsx("div", {
      className: modules_5e29d515.header,
      "data-elem": "header",
      children: title
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: modules_5e29d515.body,
      "data-elem": "body",
      children: renderTree(metadata)
    })]
  });
};
HierarchyBrowser.propTypes = {
  className: propTypes$1.exports.string,
  metadata: propTypes$1.exports.objectOf({
    title: propTypes$1.exports.string,
    id: propTypes$1.exports.string,
    count: propTypes$1.exports.number,
    list: propTypes$1.exports.array
  }),
  onItemClick: propTypes$1.exports.func,
  onItemDoubleClick: propTypes$1.exports.func,
  borderSize: propTypes$1.exports.number,
  minWidth: propTypes$1.exports.number,
  maxWidth: propTypes$1.exports.number,
  resizable: propTypes$1.exports.bool,
  setItemProps: propTypes$1.exports.func,
  title: propTypes$1.exports.string
};
HierarchyBrowser.defaultProps = {
  className: '',
  metadata: {},
  onItemClick: function onItemClick() {},
  onItemDoubleClick: function onItemDoubleClick() {},
  borderSize: 4,
  minWidth: 220,
  maxWidth: null,
  resizable: false,
  setItemProps: function setItemProps() {
    return {};
  },
  title: 'Browser'
};

var css$E = ".BaseModal_module_root__2dd7477e {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  top: 50%;\n  left: 50%;\n  right: auto;\n  bottom: auto;\n  transform: translate(-50%, -50%);\n  max-height: 100%;\n  width: 50%;\n  position: fixed;\n  background: #ffffff;\n  box-shadow: 4px 4px 4px rgba(0, 0, 0, 0.13);\n  border-radius: 5px;\n  outline: none;\n}\n.BaseModal_module_root__2dd7477e .BaseModal_module_body__2dd7477e {\n  overflow-y: scroll;\n  padding: 0 15px;\n}\n.BaseModal_module_root__2dd7477e .BaseModal_module_header__2dd7477e,\n.BaseModal_module_root__2dd7477e .BaseModal_module_footer__2dd7477e {\n  padding: 1rem;\n}\n.BaseModal_module_root__2dd7477e .BaseModal_module_header__2dd7477e {\n  font-weight: 500;\n  font-size: 1.375rem;\n}\n.BaseModal_module_root__2dd7477e .BaseModal_module_footer__2dd7477e {\n  margin-top: auto;\n}\n.BaseModal_module_root__2dd7477e .BaseModal_module_close__2dd7477e {\n  position: absolute;\n  right: 0.5rem;\n  top: 0.5rem;\n}\n.BaseModal_module_root__2dd7477e .BaseModal_module_close__2dd7477e .BaseModal_module_icon__2dd7477e {\n  width: 1.5rem;\n  height: 1.5rem;\n  fill: var(--black);\n}";
var modules_f23ae002 = {"root":"BaseModal_module_root__2dd7477e","body":"BaseModal_module_body__2dd7477e","header":"BaseModal_module_header__2dd7477e","footer":"BaseModal_module_footer__2dd7477e","close":"BaseModal_module_close__2dd7477e","icon":"BaseModal_module_icon__2dd7477e"};
n(css$E,{});

var BaseModal = function BaseModal(props) {
  var className = props.className,
    popperClassName = props.popperClassName,
    renderHeader = props.renderHeader,
    children = props.children,
    renderFooter = props.renderFooter,
    toggle = props.toggle,
    open = props.open,
    noDismiss = props.noDismiss;
  var _useFloating = useFloating({
      open: open,
      onOpenChange: toggle
    }),
    floating = _useFloating.floating,
    context = _useFloating.context;
  var _useInteractions = useInteractions([useDismiss(context, {
      enabled: !noDismiss
    })]),
    getFloatingProps = _useInteractions.getFloatingProps;
  return /*#__PURE__*/jsxRuntime.jsx(Popper, {
    open: open,
    className: popperClassName,
    transparent: false,
    wrapperId: "base-modal-popper",
    children: open && /*#__PURE__*/jsxRuntime.jsx(FloatingFocusManager, {
      context: context,
      children: /*#__PURE__*/jsxRuntime.jsxs("div", _objectSpread2(_objectSpread2({}, getFloatingProps({
        className: classes(modules_f23ae002.root, className),
        ref: floating
      })), {}, {
        children: [renderHeader && /*#__PURE__*/jsxRuntime.jsx("div", {
          "data-elem": "header",
          className: modules_f23ae002.header,
          children: renderHeader
        }), /*#__PURE__*/jsxRuntime.jsx("div", {
          "data-elem": "body",
          className: modules_f23ae002.body,
          children: children
        }), renderFooter && /*#__PURE__*/jsxRuntime.jsx("div", {
          "data-elem": "footer",
          className: modules_f23ae002.footer,
          children: renderFooter
        }), /*#__PURE__*/jsxRuntime.jsx(Button, {
          size: "auto",
          variant: "text",
          "data-elem": "close",
          className: modules_f23ae002.close,
          onClick: function onClick() {
            toggle(false);
          },
          rightComponent: function rightComponent() {
            return /*#__PURE__*/jsxRuntime.jsx(Cross$1, {
              className: modules_f23ae002.icon
            });
          }
        })]
      }))
    })
  });
};
BaseModal.propTypes = {
  className: propTypes$1.exports.string,
  popperClassName: propTypes$1.exports.string,
  renderHeader: propTypes$1.exports.element,
  renderFooter: propTypes$1.exports.element,
  toggle: propTypes$1.exports.func,
  noDismiss: propTypes$1.exports.bool
};
BaseModal.defaultProps = {
  className: '',
  popperClassName: '',
  renderHeader: null,
  renderFooter: null,
  toggle: function toggle() {},
  noDismiss: false
};

var css$D = ".Dialog_module_root__2974a020 {\n  padding: 0.25rem 0px;\n  max-height: 14rem;\n  background: #ffffff;\n  border-radius: 0.25rem;\n}\n.Dialog_module_root__2974a020.Dialog_module_sm__2974a020 {\n  width: 21.25rem;\n}\n.Dialog_module_root__2974a020.Dialog_module_md__2974a020 {\n  width: 35rem;\n}\n.Dialog_module_root__2974a020 .Dialog_module_header__2974a020 {\n  font-weight: 600;\n  font-size: 0.875rem;\n  color: var(--black);\n}\n.Dialog_module_root__2974a020 .Dialog_module_footer__2974a020 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  align-items: center;\n  gap: 1rem;\n}\n.Dialog_module_root__2974a020 .Dialog_module_footer__2974a020 .Dialog_module_cancel__2974a020[data-elem=base-cell] {\n  display: flex;\n  color: var(--grey1);\n  border-radius: 0.25rem;\n  border: 1px solid var(--grey4);\n}\n.Dialog_module_root__2974a020 .Dialog_module_description__2974a020 {\n  padding: 0.5rem 0px;\n  font-size: 0.75rem;\n}";
var modules_ca1540aa = {"root":"Dialog_module_root__2974a020","sm":"Dialog_module_sm__2974a020","md":"Dialog_module_md__2974a020","header":"Dialog_module_header__2974a020","footer":"Dialog_module_footer__2974a020","cancel":"Dialog_module_cancel__2974a020","description":"Dialog_module_description__2974a020"};
n(css$D,{});

/* eslint-disable object-curly-newline */
var DialogBox = function DialogBox(props) {
  var open = props.open,
    heading = props.heading,
    description = props.description,
    action = props.action,
    variant = props.variant,
    onCancel = props.onCancel,
    onAction = props.onAction,
    size = props.size,
    className = props.className;
  return /*#__PURE__*/jsxRuntime.jsx(BaseModal, {
    open: open,
    toggle: onCancel,
    className: classes(className, modules_ca1540aa.root, modules_ca1540aa[size]),
    renderHeader: /*#__PURE__*/jsxRuntime.jsx("div", {
      className: modules_ca1540aa.header,
      children: /*#__PURE__*/jsxRuntime.jsx("p", {
        children: heading
      })
    }),
    renderFooter: /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: modules_ca1540aa.footer,
      children: [/*#__PURE__*/jsxRuntime.jsx(Button, {
        color: "default",
        variant: "outlined",
        className: modules_ca1540aa.cancel,
        onClick: onCancel,
        title: "Cancel"
      }), /*#__PURE__*/jsxRuntime.jsx(Button, {
        onClick: onAction,
        title: action,
        color: variant
      })]
    }),
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      className: modules_ca1540aa.description,
      children: description
    })
  });
};
DialogBox.propTypes = {
  className: propTypes$1.exports.string,
  heading: propTypes$1.exports.string,
  action: propTypes$1.exports.string,
  description: propTypes$1.exports.string,
  onCancel: propTypes$1.exports.func,
  onAction: propTypes$1.exports.func,
  variant: propTypes$1.exports.oneOf(['primary', 'success', 'danger', 'warning']),
  size: propTypes$1.exports.oneOf(['sm', 'md'])
};
DialogBox.defaultProps = {
  className: '',
  heading: 'selected row',
  action: '',
  description: 'description selected page',
  variant: 'danger',
  onCancel: function onCancel() {},
  onAction: function onAction() {},
  size: 'sm'
};

var css$C = ".PageHeader_module_root__c3aca516 {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: flex-start;\n  width: 100%;\n  background-color: transparent;\n  gap: 0.25rem;\n}\n.PageHeader_module_root__c3aca516.PageHeader_module_darkTheme__c3aca516 {\n  color: var(--white);\n}\n.PageHeader_module_root__c3aca516.PageHeader_module_darkTheme__c3aca516 .PageHeader_module_breadcrumb__c3aca516 [data-elem=breadcrumb-item-active] {\n  color: var(--white);\n}\n.PageHeader_module_root__c3aca516.PageHeader_module_lightTheme__c3aca516 {\n  color: var(--dark-grey);\n}\n.PageHeader_module_root__c3aca516 .PageHeader_module_description__c3aca516 {\n  color: var(--grey);\n}\n.PageHeader_module_root__c3aca516 .PageHeader_module_contents__c3aca516 {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  gap: 0.75rem;\n  width: 100%;\n}\n.PageHeader_module_root__c3aca516 .PageHeader_module_contents__c3aca516 .PageHeader_module_left__c3aca516,\n.PageHeader_module_root__c3aca516 .PageHeader_module_contents__c3aca516 .PageHeader_module_right__c3aca516 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  gap: 0.75rem;\n}\n.PageHeader_module_root__c3aca516 .PageHeader_module_contents__c3aca516 .PageHeader_module_left__c3aca516 {\n  overflow: hidden;\n}\n.PageHeader_module_root__c3aca516 .PageHeader_module_contents__c3aca516 .PageHeader_module_left__c3aca516 .PageHeader_module_title__c3aca516 {\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  font-size: 2.25rem;\n  font-weight: 600;\n  line-height: 3.375rem;\n}\n.PageHeader_module_root__c3aca516 .PageHeader_module_contents__c3aca516 .PageHeader_module_left__c3aca516 .PageHeader_module_chip__c3aca516 {\n  font-weight: 500;\n  background: var(--highlight);\n  color: var(--white);\n}\n.PageHeader_module_root__c3aca516 .PageHeader_module_description__c3aca516 {\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5rem;\n}\n\n.PageHeader_module_download__c3aca516,\n.PageHeader_module_calender__c3aca516 {\n  width: 1.5rem;\n  height: 1.5rem;\n}";
var modules_bdcbeaa5 = {"root":"PageHeader_module_root__c3aca516","dark-theme":"PageHeader_module_darkTheme__c3aca516","breadcrumb":"PageHeader_module_breadcrumb__c3aca516","light-theme":"PageHeader_module_lightTheme__c3aca516","description":"PageHeader_module_description__c3aca516","contents":"PageHeader_module_contents__c3aca516","left":"PageHeader_module_left__c3aca516","right":"PageHeader_module_right__c3aca516","title":"PageHeader_module_title__c3aca516","chip":"PageHeader_module_chip__c3aca516","download":"PageHeader_module_download__c3aca516","calender":"PageHeader_module_calender__c3aca516"};
n(css$C,{});

var PageHeader = function PageHeader(props) {
  var theme = props.theme,
    title = props.title,
    description = props.description,
    children = props.children,
    chipTitle = props.chipTitle,
    RightAction = props.rightAction,
    crumbsProps = props.crumbsProps;
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(modules_bdcbeaa5.root, modules_bdcbeaa5["".concat(theme, "-theme")]),
    children: [/*#__PURE__*/jsxRuntime.jsx("div", {
      className: modules_bdcbeaa5.breadcrumb,
      children: /*#__PURE__*/jsxRuntime.jsx(BreadCrumbs, _objectSpread2({}, _objectSpread2(_objectSpread2({}, crumbsProps), {}, {
        theme: theme,
        className: modules_bdcbeaa5.breadcrumb
      })))
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: modules_bdcbeaa5.contents,
      children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
        className: modules_bdcbeaa5.left,
        children: [/*#__PURE__*/jsxRuntime.jsx("div", {
          className: modules_bdcbeaa5.title,
          children: title
        }), chipTitle && /*#__PURE__*/jsxRuntime.jsx(Chip, {
          className: modules_bdcbeaa5.chip,
          size: "sm",
          title: chipTitle,
          radius: "ellipse",
          variant: "status"
        })]
      }), RightAction && /*#__PURE__*/jsxRuntime.jsx("div", {
        className: modules_bdcbeaa5.right,
        children: /*#__PURE__*/jsxRuntime.jsx(RightAction, {})
      })]
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      className: modules_bdcbeaa5.description,
      children: description
    }), children]
  });
};
PageHeader.propTypes = {
  title: propTypes$1.exports.string,
  description: propTypes$1.exports.string,
  theme: propTypes$1.exports.oneOf(['dark', 'light']),
  chipTitle: propTypes$1.exports.string,
  crumbsProps: propTypes$1.exports.shape(BreadCrumbs.propTypes),
  rightAction: propTypes$1.exports.node
};
PageHeader.defaultProps = {
  title: 'Page Header',
  description: '',
  theme: 'light',
  chipTitle: null,
  crumbsProps: {},
  rightAction: null
};

/* eslint-disable max-classes-per-file */
var Page = /*#__PURE__*/_createClass(function Page(_ref) {
  var number = _ref.number,
    _ref$active = _ref.active,
    active = _ref$active === void 0 ? false : _ref$active,
    _ref$ellipsis = _ref.ellipsis,
    ellipsis = _ref$ellipsis === void 0 ? false : _ref$ellipsis;
  _classCallCheck(this, Page);
  this.number = number;
  this.ellipsis = ellipsis;
  this.active = active;
});
var PaginationList = /*#__PURE__*/_createClass(function PaginationList(_ref2) {
  var curr = _ref2.curr,
    total = _ref2.total,
    _ref2$limit = _ref2.limit,
    limit = _ref2$limit === void 0 ? 7 : _ref2$limit;
  _classCallCheck(this, PaginationList);
  this.pages = getPagination(curr, total, limit);
});
function getPagination(curr, total, limit) {
  if (total <= limit) {
    return _toConsumableArray$1(Array(total).keys()).map(function (page) {
      return new Page({
        number: page + 1,
        active: page + 1 === curr
      });
    });
  }
  var pages = [new Page({
    number: 1
  })];
  if (curr - 1 <= limit - 3) {
    for (var i = 1; i <= limit - 3; i++) {
      pages.push(new Page({
        number: 1 + i,
        active: 1 + i === curr
      }));
      if (i === limit - 3) {
        pages.push(new Page({
          number: 1 + i + 1,
          ellipsis: true
        }));
      }
    }
  } else if (total - curr <= limit - 3) {
    for (var _i = limit - 3; _i > 0; _i--) {
      if (_i === limit - 3) {
        pages.push(new Page({
          number: total - _i - 1,
          ellipsis: true
        }));
      }
      pages.push(new Page({
        number: total - _i
      }));
    }
  } else {
    var mod = (curr - (limit - 2)) % (limit - 4) || limit - 4;
    var first = curr - (mod - 1);
    for (var _i2 = 0; _i2 < limit - 4; _i2++) {
      if (_i2 === 0) {
        pages.push(new Page({
          number: first + _i2 - 1,
          ellipsis: true
        }));
      }
      pages.push(new Page({
        number: first + _i2
      }));
      if (_i2 === limit - 4 - 1) {
        pages.push(new Page({
          number: first + _i2 + 1,
          ellipsis: true
        }));
      }
    }
  }
  pages.push(new Page({
    number: total
  }));
  return pages;
}

var css$B = ".Pagination_module_root__8f7084b9 {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: stretch;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n  gap: 0.75rem;\n  padding: 0.625rem 2.125rem;\n  background: var(--dark-grey);\n  margin-top: auto;\n  width: 100%;\n  height: 3.5rem;\n  overflow: auto;\n  transition-property: background-color, color, bottom, width;\n  transition-duration: 0.33s;\n  transition-timing-function: ease-out;\n}\n.Pagination_module_root__8f7084b9::-webkit-scrollbar {\n  display: none;\n}\n.Pagination_module_root__8f7084b9.Pagination_module_floating__8f7084b9 {\n  background: var(--dark-grey-o-85);\n  position: absolute;\n  border-radius: 6.25rem;\n  width: 82%;\n  bottom: 3rem;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9,\n.Pagination_module_root__8f7084b9 .Pagination_module_jumpToPage__8f7084b9,\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 {\n  display: none;\n  flex: 0 1 15%;\n  background-color: transparent;\n  padding: 0;\n  height: 100%;\n}\n@media (min-width: 992px) {\n  .Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n  }\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 > [data-elem=component2] {\n  flex: 0 1 auto;\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 .Pagination_module_rowSwitcherHandle__8f7084b9 {\n  gap: 0.75rem;\n  background-color: var(--grey);\n  padding: 0;\n  border-radius: 0.25rem;\n  height: 100%;\n  width: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 .Pagination_module_rowSwitcherHandle__8f7084b9 > [data-elem*=component] {\n  overflow: hidden;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 .Pagination_module_rowSwitcherHandle__8f7084b9 > [data-elem=component2] {\n  display: flex;\n  flex: 0 0 auto;\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 .Pagination_module_rowSwitcherHandle__8f7084b9 > [data-elem=component2]::before {\n  content: \"\";\n  margin: auto;\n  background: var(--white);\n  width: 0.5px;\n  height: 50%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 .Pagination_module_text__8f7084b9 {\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  height: 100%;\n  display: block;\n  padding: 0.5rem;\n  font-size: 0.875rem;\n  font-weight: 500;\n  color: var(--white);\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 .Pagination_module_dropdown__8f7084b9 {\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 .Pagination_module_dropdown__8f7084b9 > [data-elem=header] {\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 .Pagination_module_dropdown__8f7084b9 > [data-elem=header] > [data-elem=select] {\n  height: 2.375rem;\n  max-height: 100%;\n  width: auto;\n  min-width: -webkit-fit-content;\n  min-width: -moz-fit-content;\n  min-width: fit-content;\n  padding: 0.625rem;\n  background-color: var(--grey);\n  border: none;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 .Pagination_module_dropdown__8f7084b9 > [data-elem=header] > [data-elem=select] > [data-elem=placeholder] {\n  color: var(--white);\n  font-size: 0.875rem;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 .Pagination_module_dropdown__8f7084b9 > [data-elem=header] > [data-elem=select] > svg {\n  fill: var(--white);\n  width: 0.813rem;\n  height: 0.813rem;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_pageNumbers__8f7084b9 {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  gap: 1.25rem;\n  flex: 1 1 100%;\n}\n@media (min-width: 992px) {\n  .Pagination_module_root__8f7084b9 .Pagination_module_pageNumbers__8f7084b9 {\n    flex: 1 1 40%;\n  }\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_pageNumbers__8f7084b9 > .Pagination_module_button__8f7084b9.Pagination_module_disable__8f7084b9 {\n  pointer-events: none;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_pageNumbers__8f7084b9 > .Pagination_module_button__8f7084b9 [data-elem=title] {\n  color: var(--white);\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_pageNumbers__8f7084b9 > .Pagination_module_button__8f7084b9 .Pagination_module_icon__8f7084b9 {\n  width: 1.5rem;\n  height: 1.5rem;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_pageNumbers__8f7084b9 > .Pagination_module_pageSelect__8f7084b9 {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  gap: 0.625rem;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_pageNumbers__8f7084b9 > .Pagination_module_pageSelect__8f7084b9 .Pagination_module_number__8f7084b9 {\n  cursor: pointer;\n  border-radius: 50%;\n  background-color: #e0e0e0;\n  color: var(--black);\n  width: 2.313rem;\n  line-height: 2.313rem;\n  text-align: center;\n  font-size: 1rem;\n  border: 1px solid transparent;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_pageNumbers__8f7084b9 > .Pagination_module_pageSelect__8f7084b9 .Pagination_module_number__8f7084b9:not([data-active=true]) {\n  display: none;\n}\n@media (min-width: 768px) {\n  .Pagination_module_root__8f7084b9 .Pagination_module_pageNumbers__8f7084b9 > .Pagination_module_pageSelect__8f7084b9 .Pagination_module_number__8f7084b9:not([data-active=true]) {\n    display: block;\n  }\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_pageNumbers__8f7084b9 > .Pagination_module_pageSelect__8f7084b9 .Pagination_module_number__8f7084b9:hover {\n  border: 1px solid var(--highlight);\n  color: var(--highlight);\n  background: var(--background);\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_pageNumbers__8f7084b9 > .Pagination_module_pageSelect__8f7084b9 .Pagination_module_number__8f7084b9.Pagination_module_active__8f7084b9 {\n  background-color: var(--highlight);\n  color: var(--white);\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 {\n  display: none;\n  padding: 0;\n  flex: 0 1 30%;\n  background: transparent;\n}\n@media (min-width: 992px) {\n  .Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 {\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n  }\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 > [data-elem*=component] {\n  width: 100%;\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 > [data-elem*=component] > * {\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 > [data-elem*=component] > form {\n  width: -webkit-fit-content;\n  width: -moz-fit-content;\n  width: fit-content;\n  margin-left: auto;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 .Pagination_module_jumpToPage__8f7084b9 {\n  width: 100%;\n  background: transparent;\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: stretch;\n  gap: 0rem;\n  padding: 0;\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 .Pagination_module_jumpToPage__8f7084b9 > [data-elem*=component] {\n  overflow: hidden;\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 .Pagination_module_jumpToPage__8f7084b9 .Pagination_module_inputbox__8f7084b9 {\n  max-width: 100%;\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 .Pagination_module_jumpToPage__8f7084b9 .Pagination_module_inputbox__8f7084b9 > label {\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 .Pagination_module_jumpToPage__8f7084b9 .Pagination_module_inputbox__8f7084b9 > label > [data-elem=base-cell] {\n  border-radius: 0.313rem;\n  background-color: transparent;\n  color: var(--white);\n  border-color: var(--grey1);\n  border-radius: 0.25rem 0 0 0.25rem;\n  height: 100%;\n  width: 10rem;\n  flex: 1;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 .Pagination_module_jumpToPage__8f7084b9 .Pagination_module_inputbox__8f7084b9 > label > [data-elem=base-cell] .Pagination_module_icon__8f7084b9 {\n  width: 1.5rem;\n  height: 1.5rem;\n  fill: var(--grey1);\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 .Pagination_module_jumpToPage__8f7084b9 .Pagination_module_inputbox__8f7084b9 > label > [data-elem=base-cell] > [data-elem=component2] {\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 .Pagination_module_jumpToPage__8f7084b9 .Pagination_module_inputbox__8f7084b9 > label > [data-elem=base-cell] [data-elem=input] {\n  text-align: center;\n  color: var(--white);\n  background-color: transparent;\n  border: none;\n  height: 100%;\n  width: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 .Pagination_module_jumpToPage__8f7084b9 .Pagination_module_button__8f7084b9 {\n  border-radius: 0rem 0.25rem 0.25rem 0rem;\n  background-color: var(--grey1);\n  padding: 0.75rem 0.5rem;\n  height: 100%;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_form__8f7084b9 .Pagination_module_jumpToPage__8f7084b9 .Pagination_module_button__8f7084b9 .Pagination_module_icon__8f7084b9 {\n  width: 1.5rem;\n  height: 1.5rem;\n  fill: var(--white);\n  flex-shrink: 0;\n}\n.Pagination_module_root__8f7084b9 .Pagination_module_totalData__8f7084b9 {\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  display: none;\n  margin: auto;\n  color: var(--white);\n  flex: 0 1 15%;\n}\n@media (min-width: 992px) {\n  .Pagination_module_root__8f7084b9 .Pagination_module_totalData__8f7084b9 {\n    display: inline;\n  }\n}\n.Pagination_module_root__8f7084b9.Pagination_module_noTotalData__8f7084b9 .Pagination_module_rowSwitcher__8f7084b9 {\n  flex: 0 1 20%;\n}\n.Pagination_module_root__8f7084b9.Pagination_module_noTotalData__8f7084b9 .Pagination_module_jumpToPage__8f7084b9 {\n  flex: 1 1 60%;\n}\n.Pagination_module_root__8f7084b9.Pagination_module_noTotalData__8f7084b9 .Pagination_module_form__8f7084b9 {\n  flex: 0 1 20%;\n}";
var modules_a3d40e77 = {"root":"Pagination_module_root__8f7084b9","floating":"Pagination_module_floating__8f7084b9","row-switcher":"Pagination_module_rowSwitcher__8f7084b9","jump-to-page":"Pagination_module_jumpToPage__8f7084b9","form":"Pagination_module_form__8f7084b9","row-switcher-handle":"Pagination_module_rowSwitcherHandle__8f7084b9","text":"Pagination_module_text__8f7084b9","dropdown":"Pagination_module_dropdown__8f7084b9","page-numbers":"Pagination_module_pageNumbers__8f7084b9","button":"Pagination_module_button__8f7084b9","disable":"Pagination_module_disable__8f7084b9","icon":"Pagination_module_icon__8f7084b9","pageSelect":"Pagination_module_pageSelect__8f7084b9","number":"Pagination_module_number__8f7084b9","active":"Pagination_module_active__8f7084b9","inputbox":"Pagination_module_inputbox__8f7084b9","total-data":"Pagination_module_totalData__8f7084b9","no-total-data":"Pagination_module_noTotalData__8f7084b9"};
n(css$B,{});

var dropdownOptions = ['10', '25', '50', '100', '200', '250'];
var reducer = function reducer(state, _ref) {
  var type = _ref.type,
    payload = _ref.payload;
  switch (type) {
    case 'NEXT_PAGE':
      return _objectSpread2(_objectSpread2({}, state), {}, {
        currentPage: state.currentPage + 1
      });
    case 'PREV_PAGE':
      return _objectSpread2(_objectSpread2({}, state), {}, {
        currentPage: state.currentPage - 1
      });
    case 'SET_PAGE':
      return _objectSpread2(_objectSpread2({}, state), {}, {
        currentPage: payload
      });
    case 'SET_STEP':
      return _objectSpread2(_objectSpread2({}, state), {}, {
        step: payload
      });
    case 'SET_TOTAL_PAGES':
      return _objectSpread2(_objectSpread2({}, state), {}, {
        totalPages: payload
      });
    case 'SET_TOTAL_DATA':
      return _objectSpread2(_objectSpread2({}, state), {}, {
        totalData: payload
      });
    default:
      return state;
  }
};
var usePagination = function usePagination(props) {
  var _props$totalPages = props.totalPages,
    totalPages = _props$totalPages === void 0 ? null : _props$totalPages,
    _props$currentPage = props.currentPage,
    currentPage = _props$currentPage === void 0 ? null : _props$currentPage,
    _props$step = props.step,
    step = _props$step === void 0 ? 10 : _props$step,
    _props$totalData = props.totalData,
    totalData = _props$totalData === void 0 ? null : _props$totalData;
  var _useReducer = React.useReducer(reducer, {
      totalPages: totalPages,
      currentPage: currentPage,
      step: step,
      totalData: totalData
    }),
    _useReducer2 = _slicedToArray(_useReducer, 2),
    paginationState = _useReducer2[0],
    paginationDispatch = _useReducer2[1];
  React.useEffect(function () {
    if (paginationState.currentPage > totalPages && totalPages != null) {
      paginationDispatch({
        type: 'SET_PAGE',
        payload: totalPages
      });
    }
    if (paginationState.totalData !== totalData) {
      paginationDispatch({
        type: 'SET_TOTAL_DATA',
        payload: totalData
      });
    }
    paginationDispatch({
      type: 'SET_TOTAL_PAGES',
      payload: totalPages
    });
  }, [totalPages, totalData]);
  return [paginationState, paginationDispatch];
};
var Pagination = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var className = props.className,
    floating = props.floating,
    paginationState = props.paginationState,
    paginationDispatch = props.paginationDispatch,
    loading = props.loading;
  var totalPages = paginationState.totalPages,
    currentPage = paginationState.currentPage,
    step = paginationState.step,
    totalData = paginationState.totalData;
  var paginationList = new PaginationList({
    curr: currentPage,
    total: totalPages
  });
  var jumpPageRef = React.useRef(null);
  var mountedRef = React.useRef(false);
  var _onChange = function onChange(action) {
    paginationDispatch(action);
  };
  React.useEffect(function () {
    if (mountedRef.current) {
      props.onChange({
        currentPage: currentPage,
        step: step,
        totalPages: totalPages
      });
    }
  }, [currentPage, step]);
  React.useEffect(function () {
    mountedRef.current = true;
    return function () {
      mountedRef.current = false;
    };
  }, []);
  if (loading) {
    return null;
  }
  var showTotalData = totalData && (currentPage - 1) * step + 1 < totalData;
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    ref: ref,
    className: classes(modules_a3d40e77.root, className, floating ? modules_a3d40e77.floating : '', showTotalData ? '' : modules_a3d40e77['no-total-data']),
    children: [/*#__PURE__*/jsxRuntime.jsx(BaseCell, {
      size: "auto",
      flexible: true,
      className: modules_a3d40e77['row-switcher'],
      component2: /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
        size: "auto",
        flexible: true,
        className: modules_a3d40e77['row-switcher-handle'],
        component1: /*#__PURE__*/jsxRuntime.jsx("span", {
          title: "Rows per page",
          className: modules_a3d40e77.text,
          children: "Rows per page"
        }),
        component2: /*#__PURE__*/jsxRuntime.jsx(Dropdown, {
          className: modules_a3d40e77.dropdown,
          popperClassName: modules_a3d40e77['dropdown-popper'],
          value: step,
          placeholder: null,
          onChange: function onChange(e, newStep) {
            _onChange({
              type: 'SET_STEP',
              payload: newStep
            });
          },
          children: dropdownOptions.map(function (item) {
            return /*#__PURE__*/jsxRuntime.jsx(DropdownItem, {
              title: item,
              value: item
            }, item);
          })
        })
      })
    }), showTotalData && /*#__PURE__*/jsxRuntime.jsxs(Text, {
      variant: "b1",
      stroke: "medium",
      className: modules_a3d40e77['total-data'],
      attrs: {
        title: "".concat((currentPage - 1) * step + 1, "-").concat(currentPage * step, " of ").concat(totalData)
      },
      children: [(currentPage - 1) * step + 1, "-", currentPage === totalPages ? totalData : currentPage * step, " of ", totalData]
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: modules_a3d40e77['page-numbers'],
      children: [/*#__PURE__*/jsxRuntime.jsx(Button, {
        size: "auto",
        disabled: currentPage === 1,
        title: "Prev",
        onClick: function onClick() {
          _onChange({
            type: 'PREV_PAGE'
          });
        },
        className: classes(modules_a3d40e77.button),
        leftComponent: function leftComponent() {
          return /*#__PURE__*/jsxRuntime.jsx(Chevron, {
            className: modules_a3d40e77.icon,
            position: "left"
          });
        },
        variant: "text"
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: modules_a3d40e77.pageSelect,
        children: paginationList.pages.map(function (page) {
          var active = currentPage === page.number;
          return /*#__PURE__*/jsxRuntime.jsx("span", {
            title: "Page ".concat(page.number),
            onClick: function onClick() {
              _onChange({
                type: 'SET_PAGE',
                payload: page.number
              });
            },
            "data-active": active,
            className: classes(active ? modules_a3d40e77.active : '', modules_a3d40e77.number),
            children: page.ellipsis ? '...' : page.number
          }, page.number);
        })
      }), /*#__PURE__*/jsxRuntime.jsx(Button, {
        size: "auto",
        disabled: currentPage === totalPages,
        title: "Next",
        onClick: function onClick() {
          _onChange({
            type: 'NEXT_PAGE'
          });
        },
        className: classes(modules_a3d40e77.button),
        rightComponent: function rightComponent() {
          return /*#__PURE__*/jsxRuntime.jsx(Chevron, {
            className: modules_a3d40e77.icon,
            position: "right"
          });
        },
        variant: "text"
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
      flexible: true,
      className: modules_a3d40e77.form,
      component1: /*#__PURE__*/jsxRuntime.jsx("form", {
        onSubmit: function onSubmit(e) {
          var _jumpPageRef$current;
          e.preventDefault();
          _onChange({
            type: 'SET_PAGE',
            payload: parseInt(jumpPageRef === null || jumpPageRef === void 0 ? void 0 : (_jumpPageRef$current = jumpPageRef.current) === null || _jumpPageRef$current === void 0 ? void 0 : _jumpPageRef$current.value, 10)
          });
        },
        children: /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
          size: "auto",
          className: modules_a3d40e77['jump-to-page'],
          component1: /*#__PURE__*/jsxRuntime.jsx(TextField, {
            inputProps: {
              min: 1,
              max: totalPages,
              required: true,
              placeholder: 'Jump to Page'
            },
            ref: jumpPageRef,
            type: "number",
            className: modules_a3d40e77.inputbox,
            LeftComponent: function LeftComponent() {
              return /*#__PURE__*/jsxRuntime.jsx(SearchIcon, {
                className: modules_a3d40e77.icon
              });
            }
          }),
          component2: /*#__PURE__*/jsxRuntime.jsx(Button, {
            size: "auto",
            variant: "contained",
            className: modules_a3d40e77.button,
            rightComponent: function rightComponent() {
              return /*#__PURE__*/jsxRuntime.jsx(Arrow$1, {
                className: modules_a3d40e77.icon
              });
            }
          })
        })
      })
    })]
  });
});
Pagination.propTypes = {
  className: propTypes$1.exports.string,
  floating: propTypes$1.exports.bool,
  paginationState: propTypes$1.exports.shape({
    totalPages: propTypes$1.exports.number,
    currentPage: propTypes$1.exports.number,
    step: propTypes$1.exports.number
  }),
  paginationDispatch: propTypes$1.exports.func,
  onChange: propTypes$1.exports.func
};
Pagination.defaultProps = {
  className: '',
  floating: false,
  paginationState: {
    totalPages: null,
    currentPage: null,
    step: null
  },
  paginationDispatch: function paginationDispatch() {},
  onChange: function onChange() {}
};

var css$A = ".Stepper_module_root__7faf2abc {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: flex-start;\n  gap: 1rem;\n}";
var modules_bbfded44 = {"root":"Stepper_module_root__7faf2abc"};
n(css$A,{});

var css$z = ":root {\n  --white: #ffffff;\n  --black: #000000;\n  --dark-grey: #333333;\n  --dark-grey-o-85: rgba(51, 51, 51, 0.85);\n  --grey: #737373;\n  --grey1: #888888;\n  --grey2: #a6a6a6;\n  --grey3: #bbbbbb;\n  --grey4: #c4c4c4;\n  --grey5: #dddddd;\n  --grey6: #e8e8e8;\n  --grey7: #eeeeee;\n  --grey8: #f2f2f2;\n  --grey9: #eff0f0;\n  --grey10: #f7f7f7;\n  --skeleton: #e0e1e9;\n  --highlight: #0f62fe;\n  --dark-blue: #001833;\n  --background: #d0e2ff;\n  --menu-black: #191b1f;\n  --banyan-blue: #00037c;\n  --banyan-orange: #ff892a;\n  --banyan-pink: #ff1597;\n  --banyan-gradient: linear-gradient(\n  \t84.71deg,\n  \tvar(--banyan-pink) 0.48%,\n  \tvar(--banyan-orange) 99.57%\n  );\n  --error: #ff626a;\n  --error-bg: #fff1f1;\n  --error-outline: rgba(218, 30, 40, 0.08);\n  --success: #24a148;\n  --success-bg: #defbe6;\n  --success-outline: rgba(36, 161, 72, 0.08);\n  --warning: #f1c21b;\n  --warning-bg: #fff8e1;\n  --warning-outline: rgba(203, 160, 6, 0.08);\n  --info: #0043ce;\n  --info-bg: #edf5ff;\n  --info-outline: #2864db98;\n}";
var modules_dd21d9e9 = {"white":"--white","black":"--black","menu-black":"--menu-black","dark-grey":"--dark-grey","dark-grey-o-85":"--dark-grey-o-85","grey":"--grey","grey1":"--grey1","grey2":"--grey2","grey3":"--grey3","grey4":"--grey4","grey5":"--grey5","grey6":"--grey6","grey7":"--grey7","grey8":"--grey8","grey9":"--grey9","grey10":"--grey10","highlight":"--highlight","dark-blue":"--dark-blue","background":"--background","banyan-blue":"--banyan-blue","banyan-orange":"--banyan-orange","banyan-pink":"--banyan-pink","banyan-gradient":"--banyan-gradient","error":"--error","error-bg":"--error-bg","error-outline":"--error-outline","success":"--success","success-bg":"--success-bg","success-outline":"--success-outline","warning":"--warning","warning-bg":"--warning-bg","warning-outline":"--warning-outline","info":"--info","info-bg":"--info-bg","info-outline":"--info-outline"};
n(css$z,{});

var COLORS = Object.keys(modules_dd21d9e9).reduce(function (acc, curr) {
  acc[curr] = getCSSVariableValue(modules_dd21d9e9[curr]);
  return acc;
}, {});

var css$y = ".Step_module_root__94d74268 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: flex-start;\n  position: relative;\n  z-index: 1;\n  gap: 0.5rem;\n  flex: 1;\n  cursor: default;\n}\n.Step_module_root__94d74268:last-child {\n  flex: 0 1 auto;\n}\n.Step_module_root__94d74268:last-child .Step_module_title__94d74268::after {\n  display: none;\n}\n.Step_module_root__94d74268 .Step_module_left__94d74268 {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n  width: 1.5rem;\n  height: 1.5rem;\n  background: var(--white);\n  border: 0.063rem solid var(--grey2);\n  border-radius: 2rem;\n  font-size: 1rem;\n  color: var(--grey2);\n}\n.Step_module_root__94d74268 .Step_module_left__94d74268 .Step_module_icon__94d74268 {\n  width: 0.75rem;\n  height: 0.75rem;\n}\n.Step_module_root__94d74268 .Step_module_left__94d74268 .Step_module_icon__94d74268.Step_module_errorIcon__94d74268 {\n  fill: var(--error);\n}\n.Step_module_root__94d74268 .Step_module_left__94d74268 .Step_module_icon__94d74268.Step_module_completionIcon__94d74268 {\n  fill: var(--highlight);\n}\n.Step_module_root__94d74268 .Step_module_left__94d74268 .Step_module_icon__94d74268.Step_module_completionIcon__94d74268.Step_module_active__94d74268 {\n  fill: var(--white);\n}\n.Step_module_root__94d74268 .Step_module_left__94d74268 .Step_module_progress__94d74268 {\n  position: absolute;\n  z-index: -1;\n  inset: -0.3rem;\n  border-radius: 2rem;\n}\n.Step_module_root__94d74268 .Step_module_left__94d74268 .Step_module_progress__94d74268::after {\n  position: absolute;\n  content: \"\";\n  inset: 0.15rem;\n  background: white;\n  border-radius: 2rem;\n}\n.Step_module_root__94d74268 .Step_module_right__94d74268 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: flex-start;\n  flex: 1;\n}\n.Step_module_root__94d74268 .Step_module_right__94d74268 .Step_module_title__94d74268 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: flex-start;\n  gap: 0.75rem;\n  width: 100%;\n  font-size: 1rem;\n  color: var(--grey2);\n}\n.Step_module_root__94d74268 .Step_module_right__94d74268 .Step_module_title__94d74268::after {\n  content: \"\";\n  flex: 1;\n  min-width: 1.5rem;\n  border-bottom: 0.063rem solid;\n  margin-top: 0.75rem;\n  border-bottom-color: var(--grey2);\n}\n.Step_module_root__94d74268 .Step_module_right__94d74268 .Step_module_title__94d74268.Step_module_noTail__94d74268::after {\n  display: none;\n}\n.Step_module_root__94d74268 .Step_module_right__94d74268 .Step_module_description__94d74268 {\n  font-size: 0.75rem;\n  color: var(--grey2);\n}\n.Step_module_root__94d74268.Step_module_active__94d74268 .Step_module_left__94d74268 {\n  background: var(--highlight);\n  color: var(--white);\n}\n.Step_module_root__94d74268.Step_module_active__94d74268 .Step_module_left__94d74268, .Step_module_root__94d74268.Step_module_completed__94d74268 .Step_module_left__94d74268 {\n  border-color: var(--highlight);\n}\n.Step_module_root__94d74268.Step_module_active__94d74268 .Step_module_right__94d74268 .Step_module_title__94d74268, .Step_module_root__94d74268.Step_module_completed__94d74268 .Step_module_right__94d74268 .Step_module_title__94d74268 {\n  color: var(--black);\n}\n.Step_module_root__94d74268.Step_module_active__94d74268 .Step_module_right__94d74268 .Step_module_description__94d74268, .Step_module_root__94d74268.Step_module_completed__94d74268 .Step_module_right__94d74268 .Step_module_description__94d74268 {\n  color: var(--grey);\n}\n.Step_module_root__94d74268.Step_module_completed__94d74268 .Step_module_right__94d74268 .Step_module_title__94d74268::after {\n  border-bottom-color: var(--highlight);\n}\n.Step_module_root__94d74268.Step_module_error__94d74268 .Step_module_left__94d74268 {\n  background: var(--white);\n  border-color: var(--error);\n  color: var(--error);\n}\n.Step_module_root__94d74268.Step_module_error__94d74268 .Step_module_right__94d74268 .Step_module_title__94d74268 {\n  color: var(--error);\n}\n.Step_module_root__94d74268.Step_module_error__94d74268 .Step_module_right__94d74268 .Step_module_description__94d74268 {\n  color: rgba(var(--error), 0.6);\n}";
var modules_abbc385a = {"root":"Step_module_root__94d74268","title":"Step_module_title__94d74268","left":"Step_module_left__94d74268","icon":"Step_module_icon__94d74268","error-icon":"Step_module_errorIcon__94d74268","completion-icon":"Step_module_completionIcon__94d74268","active":"Step_module_active__94d74268","progress":"Step_module_progress__94d74268","right":"Step_module_right__94d74268","no-tail":"Step_module_noTail__94d74268","description":"Step_module_description__94d74268","completed":"Step_module_completed__94d74268","error":"Step_module_error__94d74268"};
n(css$y,{});

var Step = function Step(props) {
  var title = props.title,
    description = props.description,
    active = props.active,
    completion = props.completion,
    error = props.error,
    index = props.index,
    noTail = props.noTail;
  var display = /*#__PURE__*/jsxRuntime.jsx("span", {
    className: modules_abbc385a.text,
    children: index + 1
  });
  if (error === true) {
    display = /*#__PURE__*/jsxRuntime.jsx(Cross$1, {
      className: classes(modules_abbc385a.icon, modules_abbc385a['error-icon'])
    });
  } else if (completion === 1) {
    display = /*#__PURE__*/jsxRuntime.jsx(Tick, {
      className: classes(modules_abbc385a.icon, modules_abbc385a['completion-icon'], active ? modules_abbc385a.active : '')
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(modules_abbc385a.root, active ? modules_abbc385a.active : '', completion === 1 ? modules_abbc385a.completed : '', error ? modules_abbc385a.error : ''),
    children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
      className: modules_abbc385a.left,
      children: [display, active === true && completion > 0 && completion <= 1 && /*#__PURE__*/jsxRuntime.jsx("div", {
        className: modules_abbc385a.progress,
        style: {
          backgroundImage: "conic-gradient(".concat(COLORS.highlight, ", ").concat(completion * 100, "%, transparent 0%)")
        }
      })]
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: modules_abbc385a.right,
      children: [/*#__PURE__*/jsxRuntime.jsx("span", {
        className: classes(modules_abbc385a.title, noTail ? modules_abbc385a['no-tail'] : ''),
        children: title
      }), description != null && /*#__PURE__*/jsxRuntime.jsx("span", {
        className: modules_abbc385a.description,
        children: description
      })]
    })]
  });
};
Step.propTypes = {
  title: propTypes$1.exports.string.isRequired,
  description: propTypes$1.exports.string,
  active: propTypes$1.exports.bool,
  completion: propTypes$1.exports.number,
  error: propTypes$1.exports.bool,
  index: propTypes$1.exports.number,
  noTail: propTypes$1.exports.bool
};
Step.defaultProps = {
  description: '',
  active: false,
  completion: 0,
  error: false,
  index: 0,
  noTail: false
};

var Stepper = function Stepper(props) {
  var steps = props.steps;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: modules_bbfded44.root,
    children: steps.map(function (step, index) {
      return /*#__PURE__*/jsxRuntime.jsx(Step, _objectSpread2(_objectSpread2({}, step), {}, {
        index: index,
        total: steps.length
      }), "".concat(step.title, "-").concat(step.description));
    })
  });
};
Stepper.propTypes = {
  steps: propTypes$1.exports.arrayOf(propTypes$1.exports.shape({
    title: propTypes$1.exports.string.isRequired,
    description: propTypes$1.exports.string,
    active: propTypes$1.exports.bool,
    completion: propTypes$1.exports.number,
    error: propTypes$1.exports.bool
  }))
};
Stepper.defaultProps = {
  steps: []
};

var SIZE_MAP = {
  sm: 9.063,
  md: 15.625,
  lg: 21.875
};
var TableColumn = /*#__PURE__*/_createClass(function TableColumn(_ref) {
  var _ref$title = _ref.title,
    title = _ref$title === void 0 ? '' : _ref$title,
    _ref$id = _ref.id,
    id = _ref$id === void 0 ? '' : _ref$id,
    _ref$sort = _ref.sort,
    sort = _ref$sort === void 0 ? false : _ref$sort,
    _ref$size = _ref.size,
    size = _ref$size === void 0 ? 'md' : _ref$size,
    _ref$flexible = _ref.flexible,
    flexible = _ref$flexible === void 0 ? false : _ref$flexible,
    _ref$style = _ref.style,
    style = _ref$style === void 0 ? {} : _ref$style,
    _ref$multiLine = _ref.multiLine,
    multiLine = _ref$multiLine === void 0 ? false : _ref$multiLine,
    _ref$sticky = _ref.sticky,
    sticky = _ref$sticky === void 0 ? null : _ref$sticky;
  _classCallCheck(this, TableColumn);
  this.title = title;
  this.id = id;
  this.sort = sort;
  this.size = size;
  this.sizeInRem = SIZE_MAP[size];
  if (flexible === 'true' || flexible === true) {
    this.flexible = true;
  } else {
    this.flexible = false;
  }
  this.style = style;
  this.multiLine = multiLine;
  this.sticky = sticky;
});

var css$x = ".TableCell_module_root__ff5c86cb[data-elem=base-cell] {\n  background: var(--white);\n  border-bottom: 1px solid var(--grey4);\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell] > [data-elem*=component] {\n  overflow: hidden;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell] > [data-elem*=component] {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  flex: 1;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell] > [data-elem*=component] .TableCell_module_cellText__ff5c86cb {\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  display: inline-block;\n  width: 100%;\n  font-size: 0.875rem;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb {\n  background: var(--grey6);\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb .TableCell_module_cellText__ff5c86cb {\n  font-weight: 500;\n  color: var(--grey);\n  font-size: 0.75rem;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb.TableCell_module_sortable__ff5c86cb > [data-elem=component2] {\n  flex: 0 0 auto;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb.TableCell_module_sortable__ff5c86cb > [data-elem=component2] .TableCell_module_cellText__ff5c86cb {\n  width: auto;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb.TableCell_module_sortable__ff5c86cb > [data-elem=component3] {\n  flex: 0 0 auto;\n  margin-right: auto;\n  overflow: visible;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb.TableCell_module_sortable__ff5c86cb > [data-elem=component3] button.TableCell_module_sort__ff5c86cb {\n  height: auto;\n  background: transparent;\n  padding: 0;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb.TableCell_module_sortable__ff5c86cb > [data-elem=component3] .TableCell_module_sortIcon__ff5c86cb {\n  width: 1rem;\n  height: 1rem;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb.TableCell_module_sortable__ff5c86cb.TableCell_module_sortDefault__ff5c86cb > [data-elem=component3] {\n  visibility: hidden;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb.TableCell_module_sortable__ff5c86cb.TableCell_module_sortDefault__ff5c86cb > [data-elem=component3] .TableCell_module_sortIcon__ff5c86cb {\n  width: 1rem;\n  height: 1rem;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb.TableCell_module_sortable__ff5c86cb.TableCell_module_sortAsc__ff5c86cb > [data-elem=component3], .TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb.TableCell_module_sortable__ff5c86cb.TableCell_module_sortDesc__ff5c86cb > [data-elem=component3] {\n  visibility: visible;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb.TableCell_module_sortable__ff5c86cb.TableCell_module_sortAsc__ff5c86cb > [data-elem=component3] .TableCell_module_sortIcon__ff5c86cb, .TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb.TableCell_module_sortable__ff5c86cb.TableCell_module_sortDesc__ff5c86cb > [data-elem=component3] .TableCell_module_sortIcon__ff5c86cb {\n  fill: var(--highlight);\n  width: 1rem;\n  height: 1rem;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_headerCell__ff5c86cb.TableCell_module_sortable__ff5c86cb:hover > [data-elem=component3] {\n  visibility: visible;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_bodyCell__ff5c86cb .TableCell_module_cellText__ff5c86cb.TableCell_module_multiLine__ff5c86cb {\n  white-space: normal;\n  display: -webkit-box;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 2;\n  font-size: 0.75rem;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_stickyLeft__ff5c86cb {\n  box-shadow: -2px -2px 4px rgba(166, 166, 166, 0.25), 2px 2px 4px rgba(166, 166, 166, 0.24);\n  position: -webkit-sticky;\n  position: sticky;\n  left: 0;\n}\n.TableCell_module_root__ff5c86cb[data-elem=base-cell].TableCell_module_stickyRight__ff5c86cb {\n  box-shadow: -2px -2px 4px rgba(166, 166, 166, 0.25), 2px 2px 4px rgba(166, 166, 166, 0.24);\n  position: -webkit-sticky;\n  position: sticky;\n  right: 0;\n}";
var modules_7ba8d001 = {"root":"TableCell_module_root__ff5c86cb","cell-text":"TableCell_module_cellText__ff5c86cb","header-cell":"TableCell_module_headerCell__ff5c86cb","sortable":"TableCell_module_sortable__ff5c86cb","sort":"TableCell_module_sort__ff5c86cb","sort-icon":"TableCell_module_sortIcon__ff5c86cb","sort-default":"TableCell_module_sortDefault__ff5c86cb","sort-asc":"TableCell_module_sortAsc__ff5c86cb","sort-desc":"TableCell_module_sortDesc__ff5c86cb","body-cell":"TableCell_module_bodyCell__ff5c86cb","multi-line":"TableCell_module_multiLine__ff5c86cb","sticky-left":"TableCell_module_stickyLeft__ff5c86cb","sticky-right":"TableCell_module_stickyRight__ff5c86cb"};
n(css$x,{});

var SORT_ICONS = {
  asc: /*#__PURE__*/jsxRuntime.jsx(Sort, {
    className: modules_7ba8d001['sort-icon'],
    position: "az"
  }),
  desc: /*#__PURE__*/jsxRuntime.jsx(Sort, {
    className: modules_7ba8d001['sort-icon'],
    position: "za"
  }),
  "default": /*#__PURE__*/jsxRuntime.jsx(Sort, {
    className: modules_7ba8d001['sort-icon'],
    position: "az"
  })
};
var getNextSortState = function getNextSortState(currentSort) {
  var _asc$desc$default;
  return (_asc$desc$default = {
    asc: 'desc',
    desc: 'default',
    "default": 'asc'
  }) === null || _asc$desc$default === void 0 ? void 0 : _asc$desc$default[currentSort];
};

// eslint-disable-next-line prefer-arrow-callback
var TableCell = /*#__PURE__*/React.forwardRef(function TableCell(props, ref) {
  var id = props.id,
    className = props.className,
    size = props.size,
    flexible = props.flexible,
    rounded = props.rounded,
    component1 = props.component1,
    component3 = props.component3,
    RootDOM = props.RootDOM,
    attrs = props.attrs,
    radius = props.radius,
    style = props.style,
    multiLine = props.multiLine,
    type = props.type,
    cellContent = props.cellContent,
    cellTitle = props.cellTitle,
    sticky = props.sticky,
    sort = props.sort,
    onSort = props.onSort;
  return /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
    ref: ref,
    className: classes(modules_7ba8d001.root, className, modules_7ba8d001["".concat(type, "-cell")], modules_7ba8d001["sticky-".concat(sticky)], modules_7ba8d001["sort-".concat(sort)], sort != null ? modules_7ba8d001.sortable : ''),
    attrs: _objectSpread2({
      style: style
    }, attrs),
    size: size,
    flexible: flexible,
    rounded: rounded,
    component1: component1,
    component2: /*#__PURE__*/jsxRuntime.jsx("span", _objectSpread2(_objectSpread2({}, _objectSpread2(_objectSpread2({}, cellTitle != null ? {
      title: cellTitle
    } : {}), {}, {
      className: classes(modules_7ba8d001['cell-text'], multiLine ? modules_7ba8d001['multi-line'] : ''),
      style: style,
      'data-elem': 'text'
    })), {}, {
      children: [null, false, true].includes(cellContent) ? JSON.stringify(cellContent) : cellContent
    })),
    component3: type === 'header' && sort ? /*#__PURE__*/jsxRuntime.jsx(Button, {
      className: modules_7ba8d001.sort,
      size: "auto",
      onClick: function onClick() {
        onSort(id, getNextSortState(sort));
      },
      leftComponent: function leftComponent() {
        return SORT_ICONS[sort];
      }
    }) : component3,
    RootDOM: RootDOM,
    radius: radius
  });
});
TableCell.propTypes = _objectSpread2(_objectSpread2({}, BaseCell.propTypes), {}, {
  title: propTypes$1.exports.string,
  id: propTypes$1.exports.string,
  size: propTypes$1.exports.oneOf(['sm', 'md', 'lg']),
  flexible: propTypes$1.exports.bool,
  sort: propTypes$1.exports.oneOf(['default', 'asc', 'desc']),
  // eslint-disable-next-line react/forbid-prop-types
  style: propTypes$1.exports.object,
  multiLine: propTypes$1.exports.bool,
  sticky: propTypes$1.exports.oneOf(['left', 'right', 'none']),
  cellContent: propTypes$1.exports.node,
  cellTitle: propTypes$1.exports.string,
  onSort: propTypes$1.exports.func
});
TableCell.defaultProps = _objectSpread2(_objectSpread2({}, BaseCell.defaultProps), {}, {
  cellContent: null,
  cellTitle: null,
  RootDOM: 'td',
  onSort: function onSort() {}
});

var css$w = ".TableRow_module_root__f4710f2d {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n}\n.TableRow_module_root__f4710f2d.TableRow_module_headerRow__f4710f2d {\n  background: var(--grey6);\n}\n.TableRow_module_root__f4710f2d.TableRow_module_headerRow__f4710f2d > [data-elem=base-cell].TableRow_module_expandableCell__f4710f2d {\n  background: transparent;\n}\n.TableRow_module_root__f4710f2d.TableRow_module_headerRow__f4710f2d > [data-elem=base-cell].TableRow_module_expandableCell__f4710f2d > [data-elem=component2] {\n  width: 3rem;\n  visibility: hidden;\n}\n.TableRow_module_root__f4710f2d.TableRow_module_bodyRow__f4710f2d {\n  background: var(--white);\n}\n.TableRow_module_root__f4710f2d.TableRow_module_bodyRow__f4710f2d:hover > [data-elem=base-cell] {\n  background: var(--info-bg);\n}\n.TableRow_module_root__f4710f2d.TableRow_module_bodyRow__f4710f2d[data-active=true] > [data-elem=base-cell] {\n  background: var(--background);\n}\n.TableRow_module_root__f4710f2d > [data-elem=base-cell]:first-child {\n  padding-left: 1rem;\n}\n.TableRow_module_root__f4710f2d > [data-elem=base-cell]:last-child {\n  padding-right: 1rem;\n}\n.TableRow_module_root__f4710f2d.TableRow_module_rowHeightMd__f4710f2d > td[data-elem=base-cell] {\n  height: 3rem;\n}\n.TableRow_module_root__f4710f2d.TableRow_module_rowHeightLg__f4710f2d > td[data-elem=base-cell] {\n  height: 4rem;\n}\n.TableRow_module_root__f4710f2d > [data-elem=base-cell].TableRow_module_expandableCell__f4710f2d {\n  padding-left: 0.9rem;\n  padding-right: 0.1rem;\n  overflow: visible;\n}\n.TableRow_module_root__f4710f2d > [data-elem=base-cell].TableRow_module_expandableCell__f4710f2d > [data-elem=component2] {\n  overflow: visible;\n}\n.TableRow_module_root__f4710f2d > [data-elem=base-cell].TableRow_module_expandableCell__f4710f2d > [data-elem=component2] > [data-elem=text] {\n  overflow: visible;\n}\n.TableRow_module_root__f4710f2d button.TableRow_module_button__f4710f2d[data-elem=base-cell] .TableRow_module_icon__f4710f2d {\n  width: 1.5rem;\n  height: 1.5rem;\n}\n.TableRow_module_root__f4710f2d button.TableRow_module_button__f4710f2d[data-elem=base-cell]:disabled {\n  cursor: default;\n}\n.TableRow_module_root__f4710f2d button.TableRow_module_button__f4710f2d[data-elem=base-cell]:disabled .TableRow_module_icon__f4710f2d {\n  visibility: hidden;\n}\n.TableRow_module_root__f4710f2d .TableRow_module_expanded__f4710f2d .TableRow_module_button__f4710f2d .TableRow_module_icon__f4710f2d {\n  transform: rotate(180deg);\n}";
var modules_f6618a87 = {"root":"TableRow_module_root__f4710f2d","header-row":"TableRow_module_headerRow__f4710f2d","expandable-cell":"TableRow_module_expandableCell__f4710f2d","body-row":"TableRow_module_bodyRow__f4710f2d","row-height-md":"TableRow_module_rowHeightMd__f4710f2d","row-height-lg":"TableRow_module_rowHeightLg__f4710f2d","button":"TableRow_module_button__f4710f2d","icon":"TableRow_module_icon__f4710f2d","expanded":"TableRow_module_expanded__f4710f2d"};
n(css$w,{});

var TableRow = /*#__PURE__*/React.forwardRef(function BaseTable(props, ref) {
  var _headerData$map;
  var type = props.type,
    headerData = props.headerData,
    datum = props.datum,
    _index = props._index,
    customCells = props.customCells,
    className = props.className,
    setActiveId = props.setActiveId,
    Expandable = props.expandable,
    onSort = props.onSort,
    rowHeight = props.rowHeight;
  var _useState = React.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    expanded = _useState2[0],
    setExpanded = _useState2[1];
  var tableCells = headerData === null || headerData === void 0 ? void 0 : (_headerData$map = headerData.map) === null || _headerData$map === void 0 ? void 0 : _headerData$map.call(headerData, function (item) {
    var _getCustomCell;
    var cellContent = null;
    if (type === 'header') {
      cellContent = item.title;
    } else if (type === 'body') {
      cellContent = datum === null || datum === void 0 ? void 0 : datum[item.id];
    }
    var cellProps = _objectSpread2(_objectSpread2(_objectSpread2({}, props), item), {}, {
      _index: _index,
      setActiveId: setActiveId,
      key: item.id,
      datum: datum,
      cellContent: cellContent,
      cellTitle: cellContent,
      type: type,
      onSort: onSort,
      rowHeight: rowHeight
    });
    var getCustomCell = customCells === null || customCells === void 0 ? void 0 : customCells[type];
    var CustomCell = typeof getCustomCell === 'function' ? (_getCustomCell = getCustomCell()) === null || _getCustomCell === void 0 ? void 0 : _getCustomCell[item.id] : null;
    if (CustomCell != null) {
      // eslint-disable-next-line react/jsx-key
      return /*#__PURE__*/jsxRuntime.jsx(CustomCell, _objectSpread2({}, cellProps));
    }
    return (
      /*#__PURE__*/
      // eslint-disable-next-line react/jsx-key
      jsxRuntime.jsx(TableCell, _objectSpread2({}, cellProps))
    );
  });
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsxs("tr", {
      ref: ref,
      tabIndex: -1,
      "data-elem": "table-row",
      className: classes(className, modules_f6618a87.root, modules_f6618a87["".concat(type, "-row")], modules_f6618a87["row-height-".concat(rowHeight)], Expandable ? modules_f6618a87.expandable : ''),
      children: [Expandable && type === 'header' && /*#__PURE__*/jsxRuntime.jsx(TableCell, {
        className: classes(modules_f6618a87['expandable-cell'], expanded ? modules_f6618a87.expanded : ''),
        size: "auto",
        cellContent: null
      }), Expandable && type === 'body' && /*#__PURE__*/jsxRuntime.jsx(TableCell, {
        className: classes(modules_f6618a87['expandable-cell'], expanded ? modules_f6618a87.expanded : ''),
        size: "auto",
        cellContent: /*#__PURE__*/jsxRuntime.jsx(Button, {
          className: modules_f6618a87.button,
          size: "auto",
          variant: "text",
          disabled: !Expandable({
            datum: datum,
            index: _index
          }),
          onClick: function onClick() {
            setExpanded(function (prev) {
              return !prev;
            });
          },
          leftComponent: function leftComponent() {
            return /*#__PURE__*/jsxRuntime.jsx(Caret, {
              className: modules_f6618a87.icon
            });
          }
        })
      }), tableCells]
    }), Expandable && expanded && /*#__PURE__*/jsxRuntime.jsx("tr", {
      children: /*#__PURE__*/jsxRuntime.jsx(Expandable, {
        datum: datum,
        index: _index
      })
    })]
  });
});
TableRow.propTypes = {
  className: propTypes$1.exports.string,
  type: propTypes$1.exports.oneOf(['header', 'body']),
  datum: propTypes$1.exports.object,
  customCells: propTypes$1.exports.shape({
    header: propTypes$1.exports.func,
    body: propTypes$1.exports.func
  }),
  headerData: propTypes$1.exports.arrayOf(propTypes$1.exports.shape({
    title: propTypes$1.exports.string,
    id: propTypes$1.exports.string,
    size: propTypes$1.exports.oneOf(['sm', 'md', 'lg']),
    flexible: propTypes$1.exports.bool,
    sort: propTypes$1.exports.bool,
    style: propTypes$1.exports.object,
    multiLine: propTypes$1.exports.bool
  })),
  setActiveId: propTypes$1.exports.func,
  expandable: propTypes$1.exports.func,
  onSort: propTypes$1.exports.func,
  rowHeight: propTypes$1.exports.oneOf(['md', 'lg'])
};
TableRow.defaultProps = {
  className: '',
  type: 'body',
  datum: {},
  customCells: {
    header: null,
    body: null
  },
  headerData: [],
  setActiveId: function setActiveId() {},
  expandable: null,
  onSort: function onSort() {},
  rowHeight: 'md'
};

var css$v = ".TableBody_module_root__77e2990d {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n}";
var modules_82c0c387 = {"root":"TableBody_module_root__77e2990d"};
n(css$v,{});

/* eslint-disable no-underscore-dangle */
var TableBody = function TableBody(props) {
  var tableData = props.tableData,
    headerData = props.headerData,
    customCells = props.customCells,
    className = props.className,
    expandable = props.expandable,
    rowHeight = props.rowHeight;
  var listRef = React.useRef([]);
  return /*#__PURE__*/jsxRuntime.jsx("tbody", {
    "data-elem": "table-body",
    className: classes(modules_82c0c387.root, className),
    children: tableData === null || tableData === void 0 ? void 0 : tableData.map(function (datum, _index) {
      var key = datum === null || datum === void 0 ? void 0 : datum.uuid;
      var setActiveId = function setActiveId() {
        var reset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        if (reset) {
          listRef.current[_index].removeAttribute('data-active');
        } else {
          var _listRef$current;
          (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.forEach(function (elem) {
            elem.removeAttribute('data-active');
          });
          listRef.current[_index].setAttribute('data-active', true);
        }
      };
      return /*#__PURE__*/jsxRuntime.jsx(TableRow, {
        ref: function ref(node) {
          listRef.current[_index] = node;
        },
        datum: datum,
        headerData: headerData,
        customCells: customCells,
        _index: _index,
        setActiveId: setActiveId,
        expandable: expandable,
        rowHeight: rowHeight
      }, key);
    })
  });
};
TableBody.propTypes = {
  className: propTypes$1.exports.string,
  headerData: propTypes$1.exports.arrayOf(propTypes$1.exports.shape({
    title: propTypes$1.exports.string,
    id: propTypes$1.exports.string,
    size: propTypes$1.exports.oneOf(['sm', 'md', 'lg']),
    flexible: propTypes$1.exports.bool,
    sort: propTypes$1.exports.bool,
    style: propTypes$1.exports.object,
    multiLine: propTypes$1.exports.bool
  })),
  tableData: propTypes$1.exports.arrayOf(propTypes$1.exports.object),
  customCells: propTypes$1.exports.shape({
    header: propTypes$1.exports.object,
    body: propTypes$1.exports.object
  }),
  expandable: propTypes$1.exports.func,
  rowHeight: propTypes$1.exports.oneOf(['md', 'lg'])
};
TableBody.defaultProps = {
  className: '',
  headerData: [],
  tableData: [],
  customCells: {
    header: null,
    body: null
  },
  expandable: null,
  rowHeight: 'md'
};

var css$u = ".TableHeader_module_root__daf69a14 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n}";
var modules_3be98c28 = {"root":"TableHeader_module_root__daf69a14"};
n(css$u,{});

/* eslint-disable react/forbid-prop-types */
var TableHeader = function TableHeader(props) {
  var headerData = props.headerData,
    customCells = props.customCells,
    expandable = props.expandable,
    onSort = props.onSort,
    rowHeight = props.rowHeight;
  return /*#__PURE__*/jsxRuntime.jsx("thead", {
    "data-elem": "table-header",
    className: modules_3be98c28.root,
    children: /*#__PURE__*/jsxRuntime.jsx(TableRow, {
      type: "header",
      headerData: headerData,
      customCells: customCells,
      expandable: expandable,
      onSort: onSort,
      rowHeight: rowHeight
    })
  });
};
TableHeader.propTypes = {
  headerData: propTypes$1.exports.arrayOf(propTypes$1.exports.shape({
    title: propTypes$1.exports.string,
    id: propTypes$1.exports.string,
    size: propTypes$1.exports.oneOf(['sm', 'md', 'lg']),
    flexible: propTypes$1.exports.bool,
    sort: propTypes$1.exports.bool,
    style: propTypes$1.exports.object,
    multiLine: propTypes$1.exports.bool
  })),
  customCells: propTypes$1.exports.shape({
    header: propTypes$1.exports.func,
    body: propTypes$1.exports.func
  }),
  expandable: propTypes$1.exports.func,
  onSort: propTypes$1.exports.func,
  rowHeight: propTypes$1.exports.oneOf(['md', 'lg'])
};
TableHeader.defaultProps = {
  headerData: [],
  customCells: {
    header: null,
    body: null
  },
  expandable: null,
  onSort: function onSort() {},
  rowHeight: 'md'
};

var css$t = ".BaseTable_module_root__7a8d241c {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  background: var(--white);\n  overflow: auto;\n}";
var modules_f1817c60 = {"root":"BaseTable_module_root__7a8d241c"};
n(css$t,{});

var css$s = ".Skeleton_module_root__82b5c932 {\n  width: 100%;\n  height: 100%;\n  background: var(--grey6);\n  background-repeat: no-repeat;\n  background-size: cover;\n  display: inline-block;\n}\n.Skeleton_module_root__82b5c932.Skeleton_module_lightTheme__82b5c932 {\n  background-color: var(--skeleton);\n}\n.Skeleton_module_root__82b5c932.Skeleton_module_darkTheme__82b5c932 {\n  background-color: var(--grey2);\n  opacity: 0.2;\n}\n.Skeleton_module_root__82b5c932.Skeleton_module_animated__82b5c932 {\n  -webkit-animation-duration: 1.25s;\n          animation-duration: 1.25s;\n  animation-fill-mode: forwards;\n  animation-iteration-count: infinite;\n  animation-name: Skeleton_module_shimmer__82b5c932;\n  animation-timing-function: linear;\n  -webkit-animation-fill-mode: forwards;\n  -webkit-animation-iteration-count: infinite;\n  -webkit-animation-name: Skeleton_module_shimmer__82b5c932;\n  -webkit-animation-timing-function: linear;\n}\n.Skeleton_module_root__82b5c932.Skeleton_module_animated__82b5c932.Skeleton_module_lightTheme__82b5c932 {\n  background-image: linear-gradient(to right, var(--skeleton) 0%, var(--grey8) 20%, var(--skeleton) 40%, var(--skeleton) 100%);\n}\n.Skeleton_module_root__82b5c932.Skeleton_module_animated__82b5c932.Skeleton_module_darkTheme__82b5c932 {\n  background-image: linear-gradient(to right, var(--grey2) 0%, var(--grey4) 20%, var(--grey2) 40%, var(--grey2) 100%);\n}\n.Skeleton_module_root__82b5c932.Skeleton_module_text__82b5c932 {\n  height: 1.5rem;\n}\n.Skeleton_module_root__82b5c932.Skeleton_module_circle__82b5c932 {\n  border-radius: 50%;\n}\n.Skeleton_module_root__82b5c932.Skeleton_module_rounded__82b5c932 {\n  border-radius: 0.25rem;\n}\n.Skeleton_module_root__82b5c932.Skeleton_module_ellipse__82b5c932 {\n  border-radius: 1.5rem;\n}\n\n@keyframes Skeleton_module_shimmer__82b5c932 {\n  0% {\n    background-position: -50rem 0;\n  }\n  100% {\n    background-position: 50rem 0;\n  }\n}\n@-webkit-keyframes Skeleton_module_shimmer__82b5c932 {\n  0% {\n    background-position: -50rem 0;\n  }\n  100% {\n    background-position: 50rem 0;\n  }\n}";
var modules_37a5ff73$8 = {"root":"Skeleton_module_root__82b5c932","light-theme":"Skeleton_module_lightTheme__82b5c932","dark-theme":"Skeleton_module_darkTheme__82b5c932","animated":"Skeleton_module_animated__82b5c932","shimmer":"Skeleton_module_shimmer__82b5c932","text":"Skeleton_module_text__82b5c932","circle":"Skeleton_module_circle__82b5c932","rounded":"Skeleton_module_rounded__82b5c932","ellipse":"Skeleton_module_ellipse__82b5c932"};
n(css$s,{});

var Skeleton = function Skeleton(props) {
  var height = props.height,
    width = props.width,
    variant = props.variant,
    className = props.className,
    noAnimation = props.noAnimation,
    theme = props.theme,
    style = props.style;
  return /*#__PURE__*/jsxRuntime.jsx("span", {
    "data-elem": "skeleton",
    className: classes(className, modules_37a5ff73$8.root, modules_37a5ff73$8[variant], modules_37a5ff73$8["".concat(theme, "-theme")], noAnimation ? '' : modules_37a5ff73$8.animated),
    style: _objectSpread2({
      height: height,
      width: width
    }, style)
  });
};
Skeleton.propTypes = {
  className: propTypes$1.exports.string,
  theme: propTypes$1.exports.oneOf(['light', 'dark']),
  height: propTypes$1.exports.oneOfType([propTypes$1.exports.string, propTypes$1.exports.number]),
  width: propTypes$1.exports.oneOfType([propTypes$1.exports.string, propTypes$1.exports.number]),
  variant: propTypes$1.exports.oneOf(['circle', 'text', 'rounded', 'rectangle', 'ellipse']),
  noAnimation: propTypes$1.exports.bool,
  // eslint-disable-next-line react/forbid-prop-types
  style: propTypes$1.exports.object
};
Skeleton.defaultProps = {
  className: '',
  theme: 'dark',
  height: null,
  width: '100%',
  variant: 'text',
  noAnimation: false,
  style: {}
};

var css$r = ".Skeleton_module_row__f53f20f3 {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  gap: 1rem;\n  margin-bottom: 1rem;\n  padding: 0rem 0.5rem;\n}\n.Skeleton_module_row__f53f20f3.Skeleton_module_header__f53f20f3 {\n  height: 2rem;\n  background: var(--grey4);\n  border-radius: 0.25rem;\n}\n.Skeleton_module_row__f53f20f3.Skeleton_module_header__f53f20f3 .Skeleton_module_th__f53f20f3 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n}\n.Skeleton_module_row__f53f20f3.Skeleton_module_header__f53f20f3 .Skeleton_module_th__f53f20f3 .Skeleton_module_skeleton__f53f20f3 {\n  background: var(--grey8);\n}\n.Skeleton_module_row__f53f20f3 > .Skeleton_module_column__f53f20f3 {\n  width: 100%;\n}\n.Skeleton_module_row__f53f20f3 > .Skeleton_module_column__f53f20f3 .Skeleton_module_skeleton__f53f20f3 {\n  height: 1.5rem;\n}";
var modules_37a5ff73$7 = {"row":"Skeleton_module_row__f53f20f3","header":"Skeleton_module_header__f53f20f3","th":"Skeleton_module_th__f53f20f3","skeleton":"Skeleton_module_skeleton__f53f20f3","column":"Skeleton_module_column__f53f20f3"};
n(css$r,{});

var COLUMNS = _toConsumableArray$1(Array(4).keys()).map(function () {
  return Math.floor(Math.random() * 80 + 20);
});
var ROWS = _toConsumableArray$1(Array(10).keys());
var BaseTableSkeleton = function BaseTableSkeleton(_ref) {
  var theme = _ref.theme;
  return ROWS.map(function (row, rowIndex) {
    return /*#__PURE__*/jsxRuntime.jsx("div", {
      className: classes(modules_37a5ff73$7.row, rowIndex === 0 ? modules_37a5ff73$7.header : ''),
      children: COLUMNS.map(function (column, colIndex) {
        return /*#__PURE__*/jsxRuntime.jsx("div", {
          className: classes(modules_37a5ff73$7.column, rowIndex === 0 ? modules_37a5ff73$7.th : '', colIndex === 0 ? modules_37a5ff73$7.col1 : ''),
          children: /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
            width: rowIndex === 0 ? '60%' : '100%',
            variant: "rounded",
            className: modules_37a5ff73$7.skeleton,
            theme: theme
          })
        }, column);
      })
    }, row);
  });
};

/* eslint-disable react/forbid-prop-types */
var BaseTable = /*#__PURE__*/React.forwardRef(function BaseTable(props, ref) {
  var headerData = props.headerData,
    customCells = props.customCells,
    tableData = props.tableData,
    className = props.className,
    loading = props.loading,
    expandable = props.expandable,
    onSort = props.onSort,
    rowHeight = props.rowHeight,
    theme = props.theme;
  if (loading) {
    return /*#__PURE__*/jsxRuntime.jsx(BaseTableSkeleton, {
      theme: theme
    });
  }
  var transformedHeaderData = headerData.map(function (header) {
    return new TableColumn(header);
  });
  return /*#__PURE__*/jsxRuntime.jsxs("table", {
    ref: ref,
    "data-elem": "table",
    className: classes(className, modules_f1817c60.root),
    children: [/*#__PURE__*/jsxRuntime.jsx(TableHeader, {
      headerData: transformedHeaderData,
      customCells: customCells,
      expandable: expandable,
      onSort: onSort,
      rowHeight: rowHeight
    }), /*#__PURE__*/jsxRuntime.jsx(TableBody, {
      ref: ref,
      headerData: transformedHeaderData,
      customCells: customCells,
      tableData: tableData,
      expandable: expandable,
      rowHeight: rowHeight
    })]
  });
});
BaseTable.propTypes = {
  className: propTypes$1.exports.string,
  headerData: propTypes$1.exports.arrayOf(propTypes$1.exports.shape({
    title: propTypes$1.exports.string,
    id: propTypes$1.exports.string,
    size: propTypes$1.exports.oneOf(['sm', 'md', 'lg']),
    flexible: propTypes$1.exports.bool,
    sort: propTypes$1.exports.bool,
    style: propTypes$1.exports.object,
    multiLine: propTypes$1.exports.bool
  })),
  tableData: propTypes$1.exports.arrayOf(propTypes$1.exports.object),
  customCells: propTypes$1.exports.shape({
    header: propTypes$1.exports.func,
    body: propTypes$1.exports.func
  }),
  loading: propTypes$1.exports.bool,
  expandable: propTypes$1.exports.func,
  onSort: propTypes$1.exports.func,
  rowHeight: propTypes$1.exports.oneOf(['md', 'lg']),
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
BaseTable.defaultProps = {
  className: '',
  headerData: [],
  tableData: [],
  customCells: {
    header: null,
    body: null
  },
  loading: null,
  expandable: null,
  onSort: function onSort() {},
  rowHeight: 'md',
  theme: 'light'
};

var css$q = ".Skeleton_module_root__15c10a9b[data-elem=base-cell] {\n  align-items: flex-start;\n  width: 100%;\n}\n.Skeleton_module_root__15c10a9b[data-elem=base-cell] > [data-elem=component1] {\n  width: auto;\n}\n.Skeleton_module_root__15c10a9b[data-elem=base-cell] > [data-elem=component1] > [data-elem=skeleton] {\n  height: 1.5rem;\n  width: 1.5rem !important;\n}\n.Skeleton_module_root__15c10a9b[data-elem=base-cell] > [data-elem=component2] {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  gap: 1rem;\n  flex: 8;\n}\n.Skeleton_module_root__15c10a9b[data-elem=base-cell] > [data-elem=component2] > [data-elem=skeleton] {\n  max-width: 9rem;\n  height: 1.5rem;\n}";
var modules_37a5ff73$6 = {"root":"Skeleton_module_root__15c10a9b"};
n(css$q,{});

var CHIPS = _toConsumableArray$1(Array(5).keys());
var TableChipsSkeleton = function TableChipsSkeleton(_ref) {
  var theme = _ref.theme;
  return /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
    flexible: true,
    className: modules_37a5ff73$6.root,
    component1: /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
      variant: "circle",
      theme: theme
    }),
    component2: CHIPS.map(function (chip) {
      return /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
        variant: "ellipse",
        theme: theme
      }, chip);
    })
  });
};

var css$p = ".TableChips_module_root__8aa05365[data-elem=base-cell] {\n  padding: 0.5rem 1.5rem;\n  width: 100%;\n  background: var(--grey6);\n  border-radius: 0.25rem 0.25rem 0 0;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component1] .TableChips_module_back__8aa05365 {\n  height: 2rem;\n  width: 2rem;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component1] .TableChips_module_back__8aa05365 [data-elem=component1] .TableChips_module_icon__8aa05365 {\n  width: 1.5rem;\n  height: 1.5rem;\n  fill: var(--white);\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] {\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  height: 100%;\n  gap: 0.5rem;\n  overflow: auto hidden;\n  flex: 1;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2]::-webkit-scrollbar {\n  display: none;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365 {\n  background: var(--grey8);\n  border: 1px solid var(--grey4);\n  padding: 0.344rem 0.25rem;\n  height: 100%;\n  cursor: default;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365 .TableChips_module_chipIcon__8aa05365 {\n  width: 1rem;\n  height: 1rem;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365 > [data-elem=component2] {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  gap: 0.25rem;\n  height: 100%;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365 > [data-elem=component2] .TableChips_module_chipChild__8aa05365 {\n  height: 100%;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365 > [data-elem=component2] .TableChips_module_chipChild__8aa05365:not(:disabled) {\n  cursor: pointer;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365 > [data-elem=component2] .TableChips_module_chipChild__8aa05365:disabled {\n  cursor: default;\n  color: var(--info);\n  border-color: var(--info-outline);\n  background: var(--info-bg);\n  filter: none;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365 > [data-elem=component2] .TableChips_module_chipChild__8aa05365 > [data-elem=component2] > [data-elem=title] {\n  color: var(--dark-grey);\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365 > [data-elem=component2] .TableChips_module_chipChild__8aa05365 .TableChips_module_icon__8aa05365 {\n  width: 0.875rem;\n  height: 0.875rem;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365 > [data-elem=component3] {\n  height: 100%;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365.TableChips_module_disabled__8aa05365:hover {\n  border-color: var(--grey4);\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365.TableChips_module_disabled__8aa05365:hover > [data-elem=component2] .TableChips_module_label__8aa05365 {\n  color: var(--dark-grey);\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365.TableChips_module_disabled__8aa05365:hover > [data-elem=component2] .TableChips_module_chipChild__8aa05365 {\n  background: var(--info-bg);\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365.TableChips_module_disabled__8aa05365:hover > [data-elem=component2] .TableChips_module_chipChild__8aa05365 > [data-elem=component2] > [data-elem=title] {\n  color: var(--dark-grey);\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365.TableChips_module_disabled__8aa05365:hover > [data-elem=component2] .TableChips_module_chipChild__8aa05365 .TableChips_module_icon__8aa05365 {\n  width: 0.875rem;\n  height: 0.875rem;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365:hover {\n  border-color: var(--highlight);\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365:hover > [data-elem=component2] .TableChips_module_label__8aa05365 {\n  color: var(--highlight);\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365:hover > [data-elem=component2] .TableChips_module_chipChild__8aa05365 {\n  background: var(--background);\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365:hover > [data-elem=component2] .TableChips_module_chipChild__8aa05365 > [data-elem=component2] > [data-elem=title] {\n  color: var(--highlight);\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component2] .TableChips_module_chipParent__8aa05365:hover > [data-elem=component2] .TableChips_module_chipChild__8aa05365 .TableChips_module_icon__8aa05365 {\n  width: 0.875rem;\n  height: 0.875rem;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component3] {\n  height: 100%;\n}\n.TableChips_module_root__8aa05365[data-elem=base-cell] > [data-elem=component3] .TableChips_module_clear__8aa05365 {\n  height: 100%;\n}";
var modules_016d9b3e = {"root":"TableChips_module_root__8aa05365","back":"TableChips_module_back__8aa05365","icon":"TableChips_module_icon__8aa05365","chip-parent":"TableChips_module_chipParent__8aa05365","chip-icon":"TableChips_module_chipIcon__8aa05365","chip-child":"TableChips_module_chipChild__8aa05365","disabled":"TableChips_module_disabled__8aa05365","label":"TableChips_module_label__8aa05365","clear":"TableChips_module_clear__8aa05365"};
n(css$p,{});

var TableChip$1 = function TableChip(props) {
  var icon = props.icon,
    rightComponent = props.rightComponent,
    label = props.label,
    value = props.value,
    onRemove = props.onRemove,
    disabled = props.disabled;

  // component 1
  var Icon = icon;
  if (Icon) {
    Icon = /*#__PURE__*/jsxRuntime.jsx(Icon, {
      className: modules_016d9b3e['chip-icon']
    });
  } else {
    Icon = null;
  }

  // component 2
  var Title = /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsxs(Text, {
      className: modules_016d9b3e.label,
      variant: "b2",
      stroke: "medium",
      children: [label, " :"]
    }), typeof value === 'string' && value.length > 0 && /*#__PURE__*/jsxRuntime.jsx(Chip, {
      disabled: disabled,
      className: modules_016d9b3e['chip-child'],
      title: value,
      radius: "ellipse",
      color: "info",
      variant: "input",
      onClick: onRemove,
      rightComponent: !disabled && function () {
        return /*#__PURE__*/jsxRuntime.jsx(Close, {
          className: modules_016d9b3e.icon
        });
      }
    })]
  });

  // component 3
  var RightComponent = rightComponent;
  if (RightComponent) {
    RightComponent = /*#__PURE__*/jsxRuntime.jsx(RightComponent, {});
  } else {
    RightComponent = null;
  }
  return /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
    radius: "default",
    size: "auto",
    className: classes(modules_016d9b3e['chip-parent'], disabled ? modules_016d9b3e.disabled : ''),
    component1: Icon,
    component2: Title,
    component3: RightComponent,
    title: "".concat(label, " : ").concat(value)
  });
};
var TableChips = function TableChips(props) {
  var _chips$filter;
  // eslint-disable-next-line object-curly-newline
  var showBack = props.showBack,
    onBack = props.onBack,
    onClear = props.onClear,
    chips = props.chips,
    className = props.className,
    style = props.style,
    loading = props.loading,
    _onRemove = props.onRemove,
    theme = props.theme;
  if (loading) {
    return /*#__PURE__*/jsxRuntime.jsx(TableChipsSkeleton, {
      theme: theme
    });
  }
  var chipsDOM = chips === null || chips === void 0 ? void 0 : (_chips$filter = chips.filter(function (chip) {
    return (chip === null || chip === void 0 ? void 0 : chip.value) != null;
  })) === null || _chips$filter === void 0 ? void 0 : _chips$filter.map(function (chip, index) {
    return /*#__PURE__*/jsxRuntime.jsx(TableChip$1, _objectSpread2(_objectSpread2({}, chip), {}, {
      onRemove: function onRemove() {
        _onRemove(chip, index);
      }
    }), chip.key);
  });
  if ((chipsDOM === null || chipsDOM === void 0 ? void 0 : chipsDOM.length) > 0 || showBack) {
    return /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
      flexible: true,
      className: classes(className, modules_016d9b3e.root),
      attrs: {
        style: style
      },
      component1: showBack && /*#__PURE__*/jsxRuntime.jsx(Button, {
        size: "auto",
        radius: "round",
        className: modules_016d9b3e.back,
        leftComponent: function leftComponent() {
          return /*#__PURE__*/jsxRuntime.jsx(Arrow$1, {
            className: modules_016d9b3e.icon,
            position: "left"
          });
        },
        onClick: onBack
      }),
      component2: (chipsDOM === null || chipsDOM === void 0 ? void 0 : chipsDOM.length) > 0 ? chipsDOM : null,
      component3: (chipsDOM === null || chipsDOM === void 0 ? void 0 : chipsDOM.length) > 0 ? /*#__PURE__*/jsxRuntime.jsx(Button, {
        size: "auto",
        variant: "outlined",
        color: "danger",
        title: "Clear All",
        className: modules_016d9b3e.clear,
        onClick: onClear
      }) : ''
    });
  }
  return null;
};
TableChips.propTypes = {
  className: propTypes$1.exports.string,
  // eslint-disable-next-line react/forbid-prop-types
  style: propTypes$1.exports.object,
  showBack: propTypes$1.exports.bool,
  onBack: propTypes$1.exports.func,
  onClear: propTypes$1.exports.func,
  chips: propTypes$1.exports.arrayOf(propTypes$1.exports.shape({
    key: propTypes$1.exports.string,
    icon: propTypes$1.exports.func,
    label: propTypes$1.exports.oneOfType([propTypes$1.exports.number, propTypes$1.exports.string]),
    value: propTypes$1.exports.oneOfType([propTypes$1.exports.number, propTypes$1.exports.string]),
    disabled: propTypes$1.exports.bool,
    rightComponent: propTypes$1.exports.node
  })),
  loading: propTypes$1.exports.bool,
  onRemove: propTypes$1.exports.func,
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
TableChips.defaultProps = {
  className: '',
  style: {},
  showBack: false,
  onBack: function onBack() {},
  onClear: function onClear() {},
  chips: [],
  loading: null,
  onRemove: function onRemove() {},
  theme: 'light'
};

var TableChip = /*#__PURE__*/_createClass(function TableChip(_ref) {
  var _ref$key = _ref.key,
    key = _ref$key === void 0 ? '' : _ref$key,
    _ref$icon = _ref.icon,
    icon = _ref$icon === void 0 ? null : _ref$icon,
    _ref$label = _ref.label,
    label = _ref$label === void 0 ? '' : _ref$label,
    _ref$value = _ref.value,
    value = _ref$value === void 0 ? '' : _ref$value,
    _ref$disabled = _ref.disabled,
    disabled = _ref$disabled === void 0 ? false : _ref$disabled,
    _ref$rightComponent = _ref.rightComponent,
    rightComponent = _ref$rightComponent === void 0 ? null : _ref$rightComponent;
  _classCallCheck(this, TableChip);
  this.key = key;
  this.icon = icon;
  this.label = label;
  this.value = value;
  this.disabled = disabled;
  this.rightComponent = rightComponent;
});

var css$o = ".Popover_module_root__265e51dc {\n  box-shadow: -2px -2px 4px rgba(166, 166, 166, 0.25), 2px 2px 4px rgba(166, 166, 166, 0.24);\n  background-color: var(--white);\n  padding: 1rem;\n  border-radius: 0.25rem;\n}";
var modules_dfc4608f = {"root":"Popover_module_root__265e51dc"};
n(css$o,{});

var Popover = function Popover(props) {
  // eslint-disable-next-line object-curly-newline
  var children = props.children,
    anchorEl = props.anchorEl,
    open = props.open,
    setOpen = props.setOpen,
    className = props.className,
    transparent = props.transparent,
    onClose = props.onClose,
    placement = props.placement;
  var _useFloating = useFloating({
      open: open,
      onOpenChange: setOpen,
      placement: placement,
      whileElementsMounted: autoUpdate,
      middleware: [offset(5), shift(), flip({
        padding: 8
      }), size({
        apply: function apply(_ref) {
          var rects = _ref.rects,
            availableHeight = _ref.availableHeight,
            elements = _ref.elements;
          Object.assign(elements.floating.style, {
            width: "".concat(rects.reference.width, "px"),
            minWidth: 'fit-content',
            maxHeight: "".concat(availableHeight, "px")
          });
        },
        padding: 8
      })]
    }),
    x = _useFloating.x,
    y = _useFloating.y,
    reference = _useFloating.reference,
    floating = _useFloating.floating,
    strategy = _useFloating.strategy,
    context = _useFloating.context;
  var _useInteractions = useInteractions([useDismiss(context)]),
    getFloatingProps = _useInteractions.getFloatingProps;
  React.useEffect(function () {
    if (open === false) {
      onClose();
    }
  }, [open]);
  React.useLayoutEffect(function () {
    reference(anchorEl);
  }, [anchorEl]);
  return /*#__PURE__*/jsxRuntime.jsx(Popper, {
    open: open,
    wrapperId: "popover",
    transparent: transparent,
    children: /*#__PURE__*/jsxRuntime.jsx("div", _objectSpread2(_objectSpread2({}, getFloatingProps({
      ref: floating,
      style: {
        position: strategy,
        top: y !== null && y !== void 0 ? y : 0,
        left: x !== null && x !== void 0 ? x : 0
      },
      className: classes(modules_dfc4608f.root, className)
    })), {}, {
      children: children
    }))
  });
};
Popover.propTypes = {
  anchorEl: propTypes$1.exports.element,
  open: propTypes$1.exports.bool.isRequired,
  setOpen: propTypes$1.exports.func.isRequired,
  transparent: propTypes$1.exports.bool,
  onClose: propTypes$1.exports.func,
  placement: propTypes$1.exports.oneOf(['top', 'top-start', 'top-end', 'right', 'right-start', 'right-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', 'left-end'])
};
Popover.defaultProps = {
  anchorEl: null,
  transparent: true,
  onClose: function onClose() {},
  placement: 'bottom'
};

var css$n = ".Columns_module_popover__078e5868 {\n  height: 32rem;\n  padding: 0;\n  overflow: hidden;\n}\n\n.Columns_module_root__078e5868 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  position: relative;\n  height: 100%;\n  min-width: 18rem;\n  max-width: 100%;\n}\n.Columns_module_root__078e5868 .Columns_module_header__078e5868 {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  border-bottom: 1px solid var(--grey4);\n  padding: 0.75rem 2.5rem;\n}\n.Columns_module_root__078e5868 .Columns_module_header__078e5868 > [data-elem=component1] {\n  font-weight: 500;\n}\n.Columns_module_root__078e5868 .Columns_module_header__078e5868 > [data-elem=component2] .Columns_module_close__078e5868 {\n  height: auto;\n  padding: 0;\n}\n.Columns_module_root__078e5868 .Columns_module_header__078e5868 > [data-elem=component2] .Columns_module_close__078e5868 .Columns_module_icon__078e5868 {\n  width: 1rem;\n  height: 1rem;\n}\n.Columns_module_root__078e5868 .Columns_module_body__078e5868 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  gap: 0.5rem;\n  padding: 0.75rem 2.5rem;\n  max-height: 28rem;\n  overflow-y: auto;\n  flex: 1 1 auto;\n}\n.Columns_module_root__078e5868 .Columns_module_body__078e5868 .Columns_module_search__078e5868 {\n  position: -webkit-sticky;\n  position: sticky;\n  top: 0;\n}\n.Columns_module_root__078e5868 .Columns_module_body__078e5868 .Columns_module_columns__078e5868 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  gap: 0.5rem;\n  overflow-y: auto;\n}\n.Columns_module_root__078e5868 .Columns_module_body__078e5868 .Columns_module_columns__078e5868 .Columns_module_item__078e5868 {\n  height: 3rem;\n}\n.Columns_module_root__078e5868 .Columns_module_body__078e5868 .Columns_module_columns__078e5868 .Columns_module_item__078e5868 > [data-elem=title] {\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n}\n.Columns_module_root__078e5868 .Columns_module_footer__078e5868 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  align-items: center;\n  height: auto;\n  margin-top: auto;\n  padding: 0.5rem 2.5rem;\n  border-top: 1px solid var(--grey4);\n}\n.Columns_module_root__078e5868 .Columns_module_footer__078e5868 button.Columns_module_expand__078e5868 {\n  height: auto;\n  background: var(--grey8);\n  border: 1px solid var(--grey4);\n  color: var(--black);\n}\n.Columns_module_root__078e5868 .Columns_module_footer__078e5868 button.Columns_module_expand__078e5868 .Columns_module_icon__078e5868 {\n  width: 1.5rem;\n  height: 1.5rem;\n  transform: rotate(180deg);\n}\n.Columns_module_root__078e5868.Columns_module_expanded__078e5868 .Columns_module_body__078e5868 {\n  flex: 0 1 auto;\n}\n.Columns_module_root__078e5868.Columns_module_expanded__078e5868 .Columns_module_body__078e5868 .Columns_module_columns__078e5868 {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n}\n.Columns_module_root__078e5868.Columns_module_expanded__078e5868 .Columns_module_body__078e5868 .Columns_module_columns__078e5868 .Columns_module_item__078e5868 {\n  overflow: hidden;\n}\n.Columns_module_root__078e5868.Columns_module_expanded__078e5868 .Columns_module_footer__078e5868 button.Columns_module_expand__078e5868 .Columns_module_icon__078e5868 {\n  transform: none;\n}";
var modules_48c02c99 = {"popover":"Columns_module_popover__078e5868","root":"Columns_module_root__078e5868","header":"Columns_module_header__078e5868","close":"Columns_module_close__078e5868","icon":"Columns_module_icon__078e5868","body":"Columns_module_body__078e5868","search":"Columns_module_search__078e5868","columns":"Columns_module_columns__078e5868","item":"Columns_module_item__078e5868","footer":"Columns_module_footer__078e5868","expand":"Columns_module_expand__078e5868","expanded":"Columns_module_expanded__078e5868"};
n(css$n,{});

var Columns = function Columns(props) {
  var open = props.open,
    setOpen = props.setOpen,
    anchorEl = props.anchorEl,
    columns = props.columns,
    hiddenColumns = props.hiddenColumns,
    setHiddenColumns = props.setHiddenColumns;
  var _useState = React.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    expanded = _useState2[0],
    setExpanded = _useState2[1];
  var _useState3 = React.useState(null),
    _useState4 = _slicedToArray(_useState3, 2),
    search = _useState4[0],
    setSearch = _useState4[1];
  return /*#__PURE__*/jsxRuntime.jsx(Popover, {
    anchorEl: anchorEl,
    open: open,
    setOpen: setOpen,
    className: modules_48c02c99.popover,
    onClose: function onClose() {
      setSearch(null);
    },
    children: /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: classes(modules_48c02c99.root, expanded ? modules_48c02c99.expanded : ''),
      children: [/*#__PURE__*/jsxRuntime.jsx(BaseCell, {
        size: "auto",
        className: modules_48c02c99.header,
        component1: "Columns",
        component2: /*#__PURE__*/jsxRuntime.jsx(Button, {
          className: modules_48c02c99.close,
          size: "auto",
          radius: "round",
          variant: "text",
          leftComponent: function leftComponent() {
            return /*#__PURE__*/jsxRuntime.jsx(Cross$1, {
              className: modules_48c02c99.icon
            });
          },
          onClick: function onClick() {
            setOpen(false);
          }
        })
      }), /*#__PURE__*/jsxRuntime.jsxs("div", {
        className: modules_48c02c99.body,
        children: [/*#__PURE__*/jsxRuntime.jsx(TextField, {
          className: modules_48c02c99.search,
          placeholder: "Search",
          value: search,
          onChange: function onChange(e) {
            var _inputHelper = inputHelper(e),
              fieldValue = _inputHelper.fieldValue;
            setSearch(fieldValue);
          }
        }), /*#__PURE__*/jsxRuntime.jsx("div", {
          className: modules_48c02c99.columns,
          children: columns === null || columns === void 0 ? void 0 : columns.filter(function (col) {
            var _col$id;
            return (col === null || col === void 0 ? void 0 : (_col$id = col.id) === null || _col$id === void 0 ? void 0 : _col$id.toLowerCase().indexOf(search === null || search === void 0 ? void 0 : search.toLowerCase())) !== -1 && search != null && search !== '' || search == null || search === '';
          }).map(function (col) {
            var selected = [null, false, undefined].includes(hiddenColumns === null || hiddenColumns === void 0 ? void 0 : hiddenColumns[col === null || col === void 0 ? void 0 : col.id]);
            return /*#__PURE__*/jsxRuntime.jsx(DropdownItem, {
              className: modules_48c02c99.item,
              selected: selected,
              title: col.title,
              variant: "checkbox",
              onClick: function onClick() {
                if (selected) {
                  setHiddenColumns(_objectSpread2(_objectSpread2({}, hiddenColumns), {}, _defineProperty$1({}, col.id, true)));
                } else {
                  setHiddenColumns(_objectSpread2(_objectSpread2({}, hiddenColumns), {}, _defineProperty$1({}, col.id, false)));
                }
              }
            }, col.id);
          })
        })]
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: modules_48c02c99.footer,
        children: /*#__PURE__*/jsxRuntime.jsx(Button, {
          className: modules_48c02c99.expand,
          color: "default",
          title: expanded ? 'See Less' : 'See More',
          rightComponent: !expanded && function () {
            return /*#__PURE__*/jsxRuntime.jsx(AngleDouble, {
              className: modules_48c02c99.icon
            });
          },
          leftComponent: expanded && function () {
            return /*#__PURE__*/jsxRuntime.jsx(AngleDouble, {
              className: modules_48c02c99.icon
            });
          },
          onClick: function onClick() {
            setExpanded(function (prev) {
              return !prev;
            });
          }
        })
      })]
    })
  });
};

var css$m = ".TableFilters_module_root__53838cde[data-elem=base-cell] {\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n  overflow-x: auto;\n  padding: 0.5rem;\n  gap: 1.25rem;\n  width: 100%;\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell]::-webkit-scrollbar {\n  display: none;\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] .TableFilters_module_icon__53838cde {\n  width: 1.5rem;\n  height: 1.5rem;\n  flex-shrink: 0;\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] button.TableFilters_module_iconButton__53838cde {\n  height: 100%;\n  background: var(--grey8);\n  border: 1px solid var(--grey4);\n  color: var(--black);\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] > [data-elem*=component] {\n  height: 100%;\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] .TableFilters_module_left__53838cde,\n.TableFilters_module_root__53838cde[data-elem=base-cell] .TableFilters_module_center__53838cde,\n.TableFilters_module_root__53838cde[data-elem=base-cell] .TableFilters_module_right__53838cde {\n  height: 100%;\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] > [data-elem=component1] .TableFilters_module_left__53838cde {\n  gap: 1rem;\n  background: var(--grey8);\n  border: 1px solid var(--grey4);\n  color: var(--black);\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] > [data-elem=component1] .TableFilters_module_left__53838cde [data-elem=left] {\n  gap: 1rem;\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] > [data-elem=component1] .TableFilters_module_left__53838cde .TableFilters_module_icon__53838cde {\n  fill: var(--black);\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] > [data-elem=component1] .TableFilters_module_left__53838cde .TableFilters_module_filterValue__53838cde {\n  color: var(--white);\n  background: var(--highlight);\n  padding: 0.125rem 0.5rem;\n  border-radius: 50%;\n  font-size: 0.813rem;\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] > [data-elem=component2] {\n  flex: 1;\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] > [data-elem=component2] .TableFilters_module_center__53838cde {\n  width: 100%;\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] > [data-elem=component2] .TableFilters_module_center__53838cde [data-elem=base-cell] {\n  border-color: var(--grey4);\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] > [data-elem=component2] .TableFilters_module_center__53838cde [data-elem=base-cell]:focus-within {\n  outline: 1px solid var(--highlight);\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] > [data-elem=component2] .TableFilters_module_center__53838cde .TableFilters_module_icon__53838cde {\n  width: 1.25rem;\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] .TableFilters_module_right__53838cde {\n  width: auto;\n  padding: 0;\n  min-width: 0rem;\n  gap: 0.5rem;\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n}\n.TableFilters_module_root__53838cde[data-elem=base-cell] .TableFilters_module_right__53838cde > [data-elem*=component] {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n}";
var modules_a0fe63f9 = {"root":"TableFilters_module_root__53838cde","icon":"TableFilters_module_icon__53838cde","icon-button":"TableFilters_module_iconButton__53838cde","left":"TableFilters_module_left__53838cde","center":"TableFilters_module_center__53838cde","right":"TableFilters_module_right__53838cde","filter-value":"TableFilters_module_filterValue__53838cde"};
n(css$m,{});

var css$l = ".Skeleton_module_root__bdc934d4[data-elem=base-cell] {\n  width: 100%;\n  gap: 1.25rem;\n}\n.Skeleton_module_root__bdc934d4[data-elem=base-cell] > [data-elem=component1] {\n  flex: 1;\n}\n.Skeleton_module_root__bdc934d4[data-elem=base-cell] > [data-elem=component2] {\n  flex: 6;\n}\n.Skeleton_module_root__bdc934d4[data-elem=base-cell] > [data-elem=component3] {\n  flex: 3;\n}\n.Skeleton_module_root__bdc934d4[data-elem=base-cell] > [data-elem=component3] > [data-elem=base-cell] {\n  padding: 0;\n  align-items: flex-start;\n  height: auto;\n}\n.Skeleton_module_root__bdc934d4[data-elem=base-cell] > [data-elem=component3] > [data-elem=base-cell] > [data-elem*=component] {\n  flex: 1;\n}\n.Skeleton_module_root__bdc934d4[data-elem=base-cell] > [data-elem=component3] > [data-elem=base-cell] > [data-elem*=component] > [data-elem=skeleton] {\n  height: 1.5rem;\n}";
var modules_37a5ff73$5 = {"root":"Skeleton_module_root__bdc934d4"};
n(css$l,{});

var TableFiltersSkeleton = function TableFiltersSkeleton(_ref) {
  var theme = _ref.theme;
  return /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
    className: modules_37a5ff73$5.root,
    flexible: true,
    component1: /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
      className: modules_37a5ff73$5.filter,
      theme: theme
    }),
    component2: /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
      className: modules_37a5ff73$5.search,
      theme: theme
    }),
    component3: /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
      flexible: true,
      size: "auto",
      component1: /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
        className: modules_37a5ff73$5.columns,
        theme: theme
      }),
      component2: /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
        className: modules_37a5ff73$5.refresh,
        theme: theme
      }),
      component3: /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
        className: modules_37a5ff73$5.settings,
        theme: theme
      })
    })
  });
};

var TableFilters = function TableFilters(props) {
  var className = props.className,
    style = props.style,
    onRefresh = props.onRefresh,
    onSearch = props.onSearch,
    searchValue = props.searchValue,
    filterValue = props.filterValue,
    headerData = props.headerData,
    hiddenColumns = props.hiddenColumns,
    setHiddenColumns = props.setHiddenColumns,
    loading = props.loading,
    disabledFilterOptions = props.disabledFilterOptions,
    theme = props.theme;
  var _useState = React.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    openColumns = _useState2[0],
    setOpenColumns = _useState2[1];
  var _useState3 = React.useState(null),
    _useState4 = _slicedToArray(_useState3, 2),
    anchorEl = _useState4[0],
    setAnchorEl = _useState4[1];
  var disabledFilterButton = disabledFilterOptions.filterButton,
    disabledRefresh = disabledFilterOptions.refresh,
    disabledColumnFilter = disabledFilterOptions.columnFilter,
    disabledSettings = disabledFilterOptions.settings;
  var hideRightOptions = disabledColumnFilter && disabledRefresh && disabledSettings;
  if (loading) {
    return /*#__PURE__*/jsxRuntime.jsx(TableFiltersSkeleton, {
      theme: theme
    });
  }
  return /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
    flexible: true,
    className: classes(modules_a0fe63f9.root, className),
    attrs: {
      style: style
    },
    component1: !disabledFilterButton && /*#__PURE__*/jsxRuntime.jsx(Button, {
      className: modules_a0fe63f9.left,
      title: "Filter",
      variant: "outlined",
      leftComponent: function leftComponent() {
        return /*#__PURE__*/jsxRuntime.jsx(Filter, {
          className: modules_a0fe63f9.icon
        });
      },
      rightComponent: function rightComponent() {
        if (filterValue !== null && filterValue !== void 0 && filterValue.applied) {
          return /*#__PURE__*/jsxRuntime.jsx("div", {
            className: modules_a0fe63f9['filter-value'],
            children: filterValue === null || filterValue === void 0 ? void 0 : filterValue.applied
          });
        }
        return null;
      }
    }),
    component2: /*#__PURE__*/jsxRuntime.jsx(TextField, {
      className: modules_a0fe63f9.center,
      value: searchValue,
      onChange: onSearch,
      LeftComponent: function LeftComponent() {
        return /*#__PURE__*/jsxRuntime.jsx(MagnifyingGlass, {
          className: modules_a0fe63f9.icon
        });
      },
      placeholder: "Search"
    }),
    component3: !hideRightOptions && /*#__PURE__*/jsxRuntime.jsx(BaseCell, {
      flexible: true,
      className: modules_a0fe63f9.right,
      component1: !disabledColumnFilter && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [/*#__PURE__*/jsxRuntime.jsx(Button, {
          ref: function ref(el) {
            setAnchorEl(el);
          },
          size: "auto",
          className: modules_a0fe63f9['icon-button'],
          color: "default",
          leftComponent: function leftComponent() {
            return /*#__PURE__*/jsxRuntime.jsx(Columns$1, {
              className: modules_a0fe63f9.icon
            });
          },
          title: "Columns",
          onClick: function onClick() {
            setOpenColumns(function (prev) {
              return !prev;
            });
          }
        }), /*#__PURE__*/jsxRuntime.jsx(Columns, {
          anchorEl: anchorEl,
          open: openColumns,
          setOpen: setOpenColumns,
          columns: headerData,
          hiddenColumns: hiddenColumns,
          setHiddenColumns: setHiddenColumns
        })]
      }),
      component2: !disabledRefresh && /*#__PURE__*/jsxRuntime.jsx(Button, {
        size: "auto",
        className: modules_a0fe63f9['icon-button'],
        color: "default",
        title: "Refresh",
        onClick: onRefresh,
        leftComponent: function leftComponent() {
          return /*#__PURE__*/jsxRuntime.jsx(Refresh, {
            className: modules_a0fe63f9.icon
          });
        }
      }),
      component3: !disabledSettings && /*#__PURE__*/jsxRuntime.jsx(Button, {
        size: "auto",
        className: modules_a0fe63f9['icon-button'],
        color: "default",
        title: "Settings",
        leftComponent: function leftComponent() {
          return /*#__PURE__*/jsxRuntime.jsx(Settings, {
            className: modules_a0fe63f9.icon
          });
        }
      })
    })
  });
};
TableFilters.propTypes = {
  className: propTypes$1.exports.string,
  // eslint-disable-next-line react/forbid-prop-types
  style: propTypes$1.exports.object,
  onRefresh: propTypes$1.exports.func,
  onSearch: propTypes$1.exports.func,
  searchValue: propTypes$1.exports.string,
  filterValue: propTypes$1.exports.shape({
    applied: propTypes$1.exports.number
  }),
  loading: propTypes$1.exports.bool,
  disabledFilterOptions: propTypes$1.exports.shape({
    filterButton: propTypes$1.exports.bool,
    refresh: propTypes$1.exports.bool,
    columnFilter: propTypes$1.exports.bool,
    settings: propTypes$1.exports.bool
  }),
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
TableFilters.defaultProps = {
  className: '',
  style: {},
  onRefresh: function onRefresh() {},
  onSearch: function onSearch() {},
  searchValue: null,
  filterValue: {
    applied: null
  },
  loading: null,
  disabledFilterOptions: {
    filterButton: false,
    refresh: false,
    columnFilter: false,
    settings: false
  },
  theme: 'light'
};

var css$k = ".Table_module_root__d17cb64f {\n  position: relative;\n  border-style: solid;\n  border-color: var(--grey4);\n  border-width: 1px 1px 0px 1px;\n  border-radius: 0.25rem;\n  width: 100%;\n  max-width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.Table_module_root__d17cb64f .Table_module_table__d17cb64f {\n  height: calc(100% - 6rem);\n  padding-bottom: 3.5rem;\n}\n.Table_module_root__d17cb64f .Table_module_pagination__d17cb64f {\n  position: absolute;\n  bottom: 0;\n  left: 50%;\n  transform: translateX(-50%);\n}\n.Table_module_root__d17cb64f .Table_module_pagination__d17cb64f.Table_module_floating__d17cb64f {\n  bottom: 1rem;\n}\n.Table_module_root__d17cb64f .Table_module_chips__d17cb64f,\n.Table_module_root__d17cb64f .Table_module_filters__d17cb64f,\n.Table_module_root__d17cb64f .Table_module_table__d17cb64f > [data-elem=table-header] {\n  position: -webkit-sticky;\n  position: sticky;\n  z-index: 1;\n  top: 0;\n}";
var modules_2e8406c7 = {"root":"Table_module_root__d17cb64f","table":"Table_module_table__d17cb64f","pagination":"Table_module_pagination__d17cb64f","floating":"Table_module_floating__d17cb64f","chips":"Table_module_chips__d17cb64f","filters":"Table_module_filters__d17cb64f"};
n(css$k,{});

var INTERSECTION = 1;
var STEP = 0.05;
var THRESHOLD = [];
for (var i$1 = 0; i$1 < INTERSECTION; i$1 += STEP) {
  THRESHOLD.push(i$1);
}
var Table = function Table(props) {
  var _chipsData$chips;
  var className = props.className,
    headerData = props.headerData,
    tableData = props.tableData,
    uniqueKey = props.uniqueKey,
    activeData = props.activeData,
    setActiveData = props.setActiveData,
    customCells = props.customCells,
    chipsData = props.chipsData,
    filtersData = props.filtersData,
    paginationData = props.paginationData,
    loading = props.loading,
    disabledFilterOptions = props.disabledFilterOptions,
    onSort = props.onSort,
    rowHeight = props.rowHeight,
    theme = props.theme;
  var ref = React.useRef(null);
  var paginationRef = React.useRef(null);
  var _useState = React.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    floating = _useState2[0],
    setFloating = _useState2[1];
  var _useState3 = React.useState({}),
    _useState4 = _slicedToArray(_useState3, 2),
    hiddenColumns = _useState4[0],
    setHiddenColumns = _useState4[1];
  var visibileColumns = headerData.filter(function (header) {
    return [null, false, undefined].includes(hiddenColumns === null || hiddenColumns === void 0 ? void 0 : hiddenColumns[header === null || header === void 0 ? void 0 : header.id]);
  });

  // for pagination docking using intersection observer
  React.useEffect(function () {
    var tableElem = ref.current;
    if (tableElem && !loading) {
      var lastRow = tableElem.querySelector('[data-elem="table-body"] [data-elem="table-row"]:last-child');
      if (lastRow) {
        var lastRowHeight = parseInt(getComputedStyle(lastRow).height.slice(0, -2), 10);
        var handleIntersect = function handleIntersect(entries) {
          entries.forEach(function (entry) {
            var _entry$intersectionRe;
            // if the target is visibile
            if (entry.isIntersecting && entry.intersectionRatio >= INTERSECTION || (entry === null || entry === void 0 ? void 0 : (_entry$intersectionRe = entry.intersectionRect) === null || _entry$intersectionRe === void 0 ? void 0 : _entry$intersectionRe.height) >= lastRowHeight) {
              setFloating(false);
            } else {
              setFloating(true);
            }
          });
        };
        var options = {
          threshold: THRESHOLD
        };
        var observer = new IntersectionObserver(handleIntersect, options);
        observer.observe(lastRow);
      }
    }
  }, [tableData, loading]);

  // for dynamically resizing table vertically acc to provided addons
  React.useEffect(function () {
    var tableElem = ref.current;
    if (tableElem && !loading) {
      var totalAddons = [chipsData, filtersData].filter(Boolean).length;
      tableElem.style.height = "calc(100% - ".concat(totalAddons * 3, "rem)");
    }
  }, [chipsData, filtersData, loading]);

  // setting body and header min-width to allow horizontal sticky column beyond viewport width
  React.useEffect(function () {
    var tableElem = ref.current;
    if (tableElem && !loading) {
      var tableHeaderElem = tableElem.querySelector('[data-elem="table-header"]');
      var tableBodyElem = tableElem.querySelector('[data-elem="table-body"]');
      if (tableHeaderElem && tableBodyElem) {
        var minWidth = 0;
        visibileColumns.forEach(function (header) {
          minWidth += new TableColumn(header).sizeInRem;
        });
        tableHeaderElem.style.minWidth = "".concat(minWidth, "rem");
        tableBodyElem.style.minWidth = "".concat(minWidth, "rem");
      }
    }
  }, [hiddenColumns, headerData, loading]);

  // set the hidden columns state
  React.useEffect(function () {
    setHiddenColumns({});
  }, [headerData]);
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(modules_2e8406c7.root, className),
    children: [chipsData != null && ((chipsData === null || chipsData === void 0 ? void 0 : (_chipsData$chips = chipsData.chips) === null || _chipsData$chips === void 0 ? void 0 : _chipsData$chips.length) > 0 || (chipsData === null || chipsData === void 0 ? void 0 : chipsData.showBack) != null) && /*#__PURE__*/jsxRuntime.jsx(TableChips, _objectSpread2(_objectSpread2({
      className: modules_2e8406c7.chips
    }, chipsData), {}, {
      loading: loading,
      theme: theme
    })), filtersData != null && /*#__PURE__*/jsxRuntime.jsx(TableFilters, _objectSpread2(_objectSpread2({
      className: modules_2e8406c7.filters
    }, _objectSpread2(_objectSpread2({}, filtersData), {}, {
      disabledFilterOptions: disabledFilterOptions,
      headerData: headerData,
      hiddenColumns: hiddenColumns,
      setHiddenColumns: setHiddenColumns
    })), {}, {
      loading: loading,
      theme: theme
    })), /*#__PURE__*/jsxRuntime.jsx(BaseTable, {
      ref: ref,
      headerData: visibileColumns,
      tableData: tableData,
      uniqueKey: uniqueKey,
      activeData: activeData,
      setActiveData: setActiveData,
      customCells: customCells,
      className: modules_2e8406c7.table,
      onSort: onSort,
      rowHeight: rowHeight,
      loading: loading
    }), paginationData != null && /*#__PURE__*/jsxRuntime.jsx(Pagination, _objectSpread2(_objectSpread2({
      className: classes(modules_2e8406c7.pagination, floating ? modules_2e8406c7.floating : ''),
      ref: paginationRef
    }, paginationData), {}, {
      floating: floating,
      loading: loading
    }))]
  });
};
Table.propTypes = {
  className: propTypes$1.exports.string,
  headerData: propTypes$1.exports.arrayOf(propTypes$1.exports.shape({
    title: propTypes$1.exports.string,
    id: propTypes$1.exports.string,
    size: propTypes$1.exports.oneOf(['sm', 'md', 'lg']),
    flexible: propTypes$1.exports.bool,
    sort: propTypes$1.exports.bool,
    style: propTypes$1.exports.object,
    multiLine: propTypes$1.exports.bool
  })),
  tableData: propTypes$1.exports.arrayOf(propTypes$1.exports.object),
  uniqueKey: propTypes$1.exports.arrayOf(propTypes$1.exports.string),
  activeData: propTypes$1.exports.object,
  setActiveData: propTypes$1.exports.func,
  customCells: propTypes$1.exports.shape({
    header: propTypes$1.exports.func,
    body: propTypes$1.exports.func
  }),
  chipsData: propTypes$1.exports.shape(_objectSpread2({}, TableChips.propTypes)),
  filtersData: propTypes$1.exports.shape(_objectSpread2({}, TableFilters.propTypes)),
  paginationData: propTypes$1.exports.shape(_objectSpread2({}, Pagination.propTypes)),
  loading: propTypes$1.exports.bool,
  disabledFilterOptions: propTypes$1.exports.shape({
    filterButton: propTypes$1.exports.bool,
    refresh: propTypes$1.exports.bool,
    columnFilter: propTypes$1.exports.bool,
    settings: propTypes$1.exports.bool
  }),
  onSort: propTypes$1.exports.func,
  rowHeight: propTypes$1.exports.oneOf(['md', 'lg']),
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
Table.defaultProps = {
  className: '',
  headerData: [],
  tableData: [],
  uniqueKey: [],
  activeData: {},
  setActiveData: function setActiveData() {},
  customCells: {
    header: null,
    body: null
  },
  chipsData: null,
  filtersData: null,
  paginationData: null,
  loading: null,
  disabledFilterOptions: {
    filterButton: false,
    refresh: false,
    columnFilter: false,
    settings: false
  },
  onSort: function onSort() {},
  rowHeight: 'md',
  theme: 'light'
};

var css$j = ".Tabs_module_root__18f64bf7 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n}\n.Tabs_module_root__18f64bf7.Tabs_module_lightTheme__18f64bf7 > button.Tabs_module_tab__18f64bf7 {\n  border-color: var(--grey4);\n}\n.Tabs_module_root__18f64bf7.Tabs_module_lightTheme__18f64bf7 > button.Tabs_module_tab__18f64bf7 > [data-elem=component1] > .Tabs_module_icon__18f64bf7,\n.Tabs_module_root__18f64bf7.Tabs_module_lightTheme__18f64bf7 > button.Tabs_module_tab__18f64bf7 > [data-elem=component3] > .Tabs_module_icon__18f64bf7 {\n  fill: var(--black);\n}\n.Tabs_module_root__18f64bf7.Tabs_module_lightTheme__18f64bf7 > button.Tabs_module_tab__18f64bf7 > [data-elem=component2] {\n  color: var(--black);\n}\n.Tabs_module_root__18f64bf7.Tabs_module_lightTheme__18f64bf7 > button.Tabs_module_tab__18f64bf7:hover {\n  background: var(--info-bg);\n}\n.Tabs_module_root__18f64bf7.Tabs_module_darkTheme__18f64bf7 > button.Tabs_module_tab__18f64bf7 {\n  border-color: var(--grey);\n}\n.Tabs_module_root__18f64bf7.Tabs_module_darkTheme__18f64bf7 > button.Tabs_module_tab__18f64bf7 > [data-elem=component1] > .Tabs_module_icon__18f64bf7,\n.Tabs_module_root__18f64bf7.Tabs_module_darkTheme__18f64bf7 > button.Tabs_module_tab__18f64bf7 > [data-elem=component3] > .Tabs_module_icon__18f64bf7 {\n  fill: var(--white);\n}\n.Tabs_module_root__18f64bf7.Tabs_module_darkTheme__18f64bf7 > button.Tabs_module_tab__18f64bf7 > [data-elem=component2] {\n  color: var(--white);\n}\n.Tabs_module_root__18f64bf7.Tabs_module_darkTheme__18f64bf7 > button.Tabs_module_tab__18f64bf7:hover {\n  background: var(--dark-grey);\n}\n.Tabs_module_root__18f64bf7 > button.Tabs_module_tab__18f64bf7 {\n  padding: 0.75rem;\n  gap: 0.75rem;\n  border-bottom-width: 1px;\n  border-bottom-style: solid;\n}\n.Tabs_module_root__18f64bf7 > button.Tabs_module_tab__18f64bf7 > [data-elem=component1] > .Tabs_module_icon__18f64bf7,\n.Tabs_module_root__18f64bf7 > button.Tabs_module_tab__18f64bf7 > [data-elem=component3] > .Tabs_module_icon__18f64bf7 {\n  width: 1.5rem;\n  height: 1.5rem;\n}\n.Tabs_module_root__18f64bf7 > button.Tabs_module_tab__18f64bf7.Tabs_module_active__18f64bf7 {\n  border-bottom-width: 2px;\n  border-color: var(--highlight);\n}\n.Tabs_module_root__18f64bf7 > button.Tabs_module_tab__18f64bf7.Tabs_module_active__18f64bf7 > [data-elem=component1] > .Tabs_module_icon__18f64bf7,\n.Tabs_module_root__18f64bf7 > button.Tabs_module_tab__18f64bf7.Tabs_module_active__18f64bf7 > [data-elem=component3] > .Tabs_module_icon__18f64bf7 {\n  fill: var(--highlight);\n}\n.Tabs_module_root__18f64bf7 > button.Tabs_module_tab__18f64bf7.Tabs_module_active__18f64bf7 > [data-elem=component2] {\n  color: var(--highlight);\n}\n.Tabs_module_root__18f64bf7 > button.Tabs_module_tab__18f64bf7:hover > [data-elem=component1] > .Tabs_module_icon__18f64bf7,\n.Tabs_module_root__18f64bf7 > button.Tabs_module_tab__18f64bf7:hover > [data-elem=component3] > .Tabs_module_icon__18f64bf7 {\n  fill: var(--highlight);\n}\n.Tabs_module_root__18f64bf7 > button.Tabs_module_tab__18f64bf7:hover > [data-elem=component2] {\n  color: var(--highlight);\n}";
var modules_78ab5066 = {"root":"Tabs_module_root__18f64bf7","light-theme":"Tabs_module_lightTheme__18f64bf7","tab":"Tabs_module_tab__18f64bf7","icon":"Tabs_module_icon__18f64bf7","dark-theme":"Tabs_module_darkTheme__18f64bf7","active":"Tabs_module_active__18f64bf7"};
n(css$j,{});

var Tabs = function Tabs(props) {
  var tabs = props.tabs,
    selectedTab = props.selectedTab,
    setSelectedTab = props.setSelectedTab,
    theme = props.theme;
  var onTabClick = function onTabClick(id) {
    setSelectedTab(id);
  };
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: classes(modules_78ab5066.root, modules_78ab5066["".concat(theme, "-theme")]),
    children: tabs === null || tabs === void 0 ? void 0 : tabs.map(function (tab) {
      var id = tab.id,
        title = tab.title,
        LeftIcon = tab.leftIcon,
        RightIcon = tab.rightIcon;
      return /*#__PURE__*/jsxRuntime.jsx(Button, {
        size: "auto",
        color: "default",
        radius: "none",
        variant: "text",
        onClick: function onClick() {
          onTabClick(id);
        },
        title: title,
        className: classes(modules_78ab5066.tab, selectedTab === id ? modules_78ab5066.active : ''),
        leftComponent: LeftIcon && function () {
          return /*#__PURE__*/jsxRuntime.jsx(LeftIcon, {
            className: modules_78ab5066.icon
          });
        },
        rightComponent: RightIcon && function () {
          return /*#__PURE__*/jsxRuntime.jsx(RightIcon, {
            className: modules_78ab5066.icon
          });
        }
      }, id);
    })
  });
};
Tabs.propTypes = {
  tabs: propTypes$1.exports.arrayOf(propTypes$1.exports.string),
  selectedTab: propTypes$1.exports.string,
  setSelectedTab: propTypes$1.exports.func,
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
Tabs.defaultProps = {
  tabs: [],
  selectedTab: null,
  setSelectedTab: function setSelectedTab() {},
  theme: 'light'
};

function o(f){return r=>{f.forEach(n=>{typeof n=="function"?n(r):n!=null&&(n.current=r);});}}

var css$i = ".Tooltip_module_tooltip__04fbc763 {\n  text-align: center;\n  border-radius: 0.25rem;\n  min-width: auto;\n  max-width: 12rem;\n  padding: 0.375rem;\n  font-size: 0.875rem;\n  font-family: sans-serif;\n  line-height: 1;\n}\n.Tooltip_module_tooltip__04fbc763.Tooltip_module_light__04fbc763 {\n  color: var(--black);\n  background: var(--grey7);\n  border-color: var(--black);\n}\n.Tooltip_module_tooltip__04fbc763.Tooltip_module_light__04fbc763 .Tooltip_module_arrow__04fbc763 {\n  background: var(--grey7);\n}\n.Tooltip_module_tooltip__04fbc763.Tooltip_module_dark__04fbc763 {\n  color: var(--white);\n  background: var(--black);\n  border-color: var(--white);\n}\n.Tooltip_module_tooltip__04fbc763.Tooltip_module_dark__04fbc763 .Tooltip_module_arrow__04fbc763 {\n  background: var(--black);\n}\n.Tooltip_module_tooltip__04fbc763 .Tooltip_module_arrow__04fbc763 {\n  position: absolute;\n  width: 1rem;\n  height: 1rem;\n  z-index: -1;\n  pointer-events: none;\n  transform: rotate(45deg);\n}";
var modules_e4619b04 = {"tooltip":"Tooltip_module_tooltip__04fbc763","light":"Tooltip_module_light__04fbc763","arrow":"Tooltip_module_arrow__04fbc763","dark":"Tooltip_module_dark__04fbc763"};
n(css$i,{});

var Tooltip = /*#__PURE__*/React.forwardRef(function Tooltip(props, propRef) {
  var _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$arrow4;
  var children = props.children,
    position = props.position,
    content = props.content,
    variant = props.variant,
    className = props.className;
  var arrowEl = React.useRef(null);
  var _useState = React.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    open = _useState2[0],
    setOpen = _useState2[1];

  // eslint-disable-next-line object-curly-newline
  var _useFloating = useFloating({
      open: open,
      onOpenChange: setOpen,
      // strategy: 'fixed',
      placement: position,
      // Make sure the tooltip stays on the screen
      whileElementsMounted: autoUpdate,
      middleware: [offset(12), flip(), shift(), arrow({
        element: arrowEl
      })]
    }),
    x = _useFloating.x,
    y = _useFloating.y,
    reference = _useFloating.reference,
    floating = _useFloating.floating,
    strategy = _useFloating.strategy,
    context = _useFloating.context,
    middlewareData = _useFloating.middlewareData,
    placement = _useFloating.placement;

  // Event listeners to change the open state
  var hover = useHover(context, {
    move: true
  });
  var focus = useFocus(context);
  var dismiss = useDismiss(context);
  // Role props for screen readers
  var role = useRole(context, {
    role: 'tooltip'
  });

  // Merge all the interactions into prop getters
  var _useInteractions = useInteractions([hover, focus, dismiss, role]),
    getReferenceProps = _useInteractions.getReferenceProps,
    getFloatingProps = _useInteractions.getFloatingProps;
  var childrenRef = children.ref;
  var ref = React.useMemo(function () {
    return o([reference, childrenRef, propRef]);
  }, [reference, childrenRef]);
  var clonedChildren = /*#__PURE__*/React.cloneElement(children, getReferenceProps(_objectSpread2({
    ref: ref
  }, children.props)));
  var side = placement.split('-')[0];
  var staticSide = {
    top: 'bottom',
    right: 'left',
    bottom: 'top',
    left: 'right'
  }[side];
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [clonedChildren, /*#__PURE__*/jsxRuntime.jsx(Popper, {
      open: open && content != null,
      backdrop: false,
      wrapperId: "tooltip",
      children: /*#__PURE__*/jsxRuntime.jsxs("div", _objectSpread2(_objectSpread2({}, getFloatingProps({
        ref: floating,
        className: classes(modules_e4619b04.tooltip, modules_e4619b04[variant], className),
        style: {
          position: strategy,
          top: y !== null && y !== void 0 ? y : 0,
          left: x !== null && x !== void 0 ? x : 0,
          zIndex: 100
        }
      })), {}, {
        children: [/*#__PURE__*/jsxRuntime.jsx("div", {
          className: modules_e4619b04.arrow,
          ref: arrowEl,
          style: _defineProperty$1({
            left: (_middlewareData$arrow = middlewareData === null || middlewareData === void 0 ? void 0 : (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.x) !== null && _middlewareData$arrow !== void 0 ? _middlewareData$arrow : '',
            top: (_middlewareData$arrow3 = middlewareData === null || middlewareData === void 0 ? void 0 : (_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.y) !== null && _middlewareData$arrow3 !== void 0 ? _middlewareData$arrow3 : '',
            right: '',
            bottom: ''
          }, staticSide, '-0.5rem')
        }), content]
      }))
    })]
  });
});
Tooltip.propTypes = {
  variant: propTypes$1.exports.oneOf(['light', 'dark']),
  content: propTypes$1.exports.node,
  position: propTypes$1.exports.oneOf(['right', 'top', 'bottom', 'left']),
  className: propTypes$1.exports.string
};
Tooltip.defaultProps = {
  variant: 'light',
  content: null,
  position: 'top',
  className: ''
};

var css$h = ".BaseSidePanel_module_root__c7817916 {\n  max-height: 100%;\n  height: 100%;\n  display: flex;\n  width: 30%;\n  flex-direction: column;\n  top: 0;\n  background: #ffffff;\n  box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.12);\n  overflow-x: hidden;\n  transition: 0.5s;\n}\n.BaseSidePanel_module_root__c7817916.BaseSidePanel_module_close__c7817916 {\n  width: 0rem;\n}\n.BaseSidePanel_module_root__c7817916 .BaseSidePanel_module_body__c7817916 {\n  flex: 1;\n  overflow-y: auto;\n}";
var modules_c7321921 = {"root":"BaseSidePanel_module_root__c7817916","close":"BaseSidePanel_module_close__c7817916","body":"BaseSidePanel_module_body__c7817916"};
n(css$h,{});

var BaseSidePanel = function BaseSidePanel(props) {
  var className = props.className,
    renderHeader = props.renderHeader,
    children = props.children,
    renderFooter = props.renderFooter,
    open = props.open;
  var panelRef = React.useRef();
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    ref: panelRef,
    className: classes(modules_c7321921.root, open ? '' : modules_c7321921.close, className),
    children: [renderHeader && /*#__PURE__*/jsxRuntime.jsx("div", {
      "data-elem": "header",
      className: modules_c7321921.header,
      children: renderHeader
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      "data-elem": "body",
      className: modules_c7321921.body,
      children: children
    }), renderFooter && /*#__PURE__*/jsxRuntime.jsx("div", {
      "data-elem": "footer",
      className: modules_c7321921.footer,
      children: renderFooter
    })]
  });
};
BaseSidePanel.propTypes = {
  className: propTypes$1.exports.string,
  renderHeader: propTypes$1.exports.element,
  renderFooter: propTypes$1.exports.element,
  open: propTypes$1.exports.bool
};
BaseSidePanel.defaultProps = {
  className: '',
  renderHeader: null,
  renderFooter: null,
  open: false
};

var core = {};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$2 = function(d, b) {
    extendStatics$2 = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics$2(d, b);
};

function __extends$2(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics$2(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest$1(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
}
var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}

var tslib_es6 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __extends: __extends$2,
  get __assign () { return __assign; },
  __rest: __rest$1,
  __decorate: __decorate,
  __param: __param,
  __metadata: __metadata,
  __awaiter: __awaiter,
  __generator: __generator,
  __createBinding: __createBinding,
  __exportStar: __exportStar,
  __values: __values,
  __read: __read,
  __spread: __spread,
  __spreadArrays: __spreadArrays,
  __spreadArray: __spreadArray,
  __await: __await,
  __asyncGenerator: __asyncGenerator,
  __asyncDelegator: __asyncDelegator,
  __asyncValues: __asyncValues,
  __makeTemplateObject: __makeTemplateObject,
  __importStar: __importStar,
  __importDefault: __importDefault,
  __classPrivateFieldGet: __classPrivateFieldGet,
  __classPrivateFieldSet: __classPrivateFieldSet,
  __classPrivateFieldIn: __classPrivateFieldIn
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(tslib_es6);

var lib = {};

var sensorPool = {};

var id = {};

(function (exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = void 0;

	/**
	 * Created by hustcc on 18/6/9.
	 * Contract: i@hust.cc
	 */
	var id = 1;
	/**
	 * generate unique id in application
	 * @return {string}
	 */

	var _default = function _default() {
	  return "".concat(id++);
	};

	exports["default"] = _default;
} (id));

var sensors = {};

var object = {};

var debounce = {};

(function (exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = void 0;

	/**
	 * Created by hustcc on 18/6/9.
	 * Contract: i@hust.cc
	 */
	var _default = function _default(fn) {
	  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;
	  var timer = null;
	  return function () {
	    var _this = this;

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    clearTimeout(timer);
	    timer = setTimeout(function () {
	      fn.apply(_this, args);
	    }, delay);
	  };
	};

	exports["default"] = _default;
} (debounce));

var constant = {};

Object.defineProperty(constant, "__esModule", {
  value: true
});
constant.SensorTabIndex = constant.SensorClassName = constant.SizeSensorId = void 0;

/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */
var SizeSensorId = 'size-sensor-id';
constant.SizeSensorId = SizeSensorId;
var SensorClassName = 'size-sensor-object';
constant.SensorClassName = SensorClassName;
var SensorTabIndex = '-1';
constant.SensorTabIndex = SensorTabIndex;

Object.defineProperty(object, "__esModule", {
  value: true
});
object.createSensor = void 0;

var _debounce$1 = _interopRequireDefault$2(debounce);

var _constant$1 = constant;

function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */
var createSensor$2 = function createSensor(element) {
  var sensor = undefined; // callback

  var listeners = [];
  /**
   * create object DOM of sensor
   * @returns {HTMLObjectElement}
   */

  var newSensor = function newSensor() {
    // adjust style
    if (getComputedStyle(element).position === 'static') {
      element.style.position = 'relative';
    }

    var obj = document.createElement('object');

    obj.onload = function () {
      obj.contentDocument.defaultView.addEventListener('resize', resizeListener); // 直接触发一次 resize

      resizeListener();
    };

    obj.style.display = 'block';
    obj.style.position = 'absolute';
    obj.style.top = '0';
    obj.style.left = '0';
    obj.style.height = '100%';
    obj.style.width = '100%';
    obj.style.overflow = 'hidden';
    obj.style.pointerEvents = 'none';
    obj.style.zIndex = '-1';
    obj.style.opacity = '0';
    obj.setAttribute('class', _constant$1.SensorClassName);
    obj.setAttribute('tabindex', _constant$1.SensorTabIndex);
    obj.type = 'text/html'; // append into dom

    element.appendChild(obj); // for ie, should set data attribute delay, or will be white screen

    obj.data = 'about:blank';
    return obj;
  };
  /**
   * trigger listeners
   */


  var resizeListener = (0, _debounce$1["default"])(function () {
    // trigger all listener
    listeners.forEach(function (listener) {
      listener(element);
    });
  });
  /**
   * listen with one callback function
   * @param cb
   */

  var bind = function bind(cb) {
    // if not exist sensor, then create one
    if (!sensor) {
      sensor = newSensor();
    }

    if (listeners.indexOf(cb) === -1) {
      listeners.push(cb);
    }
  };
  /**
   * destroy all
   */


  var destroy = function destroy() {
    if (sensor && sensor.parentNode) {
      if (sensor.contentDocument) {
        // remote event
        sensor.contentDocument.defaultView.removeEventListener('resize', resizeListener);
      } // remove dom


      sensor.parentNode.removeChild(sensor); // initial variable

      sensor = undefined;
      listeners = [];
    }
  };
  /**
   * cancel listener bind
   * @param cb
   */


  var unbind = function unbind(cb) {
    var idx = listeners.indexOf(cb);

    if (idx !== -1) {
      listeners.splice(idx, 1);
    } // no listener, and sensor is exist
    // then destroy the sensor


    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };

  return {
    element: element,
    bind: bind,
    destroy: destroy,
    unbind: unbind
  };
};

object.createSensor = createSensor$2;

var resizeObserver = {};

Object.defineProperty(resizeObserver, "__esModule", {
  value: true
});
resizeObserver.createSensor = void 0;

var _debounce = _interopRequireDefault$1(debounce);

function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Created by hustcc on 18/7/5.
 * Contract: i@hust.cc
 */
var createSensor$1 = function createSensor(element) {
  var sensor = undefined; // callback

  var listeners = [];
  /**
   * trigger listeners
   */

  var resizeListener = (0, _debounce["default"])(function () {
    // trigger all
    listeners.forEach(function (listener) {
      listener(element);
    });
  });
  /**
   * create ResizeObserver sensor
   * @returns
   */

  var newSensor = function newSensor() {
    var s = new ResizeObserver(resizeListener); // listen element

    s.observe(element); // trigger once

    resizeListener();
    return s;
  };
  /**
   * listen with callback
   * @param cb
   */


  var bind = function bind(cb) {
    if (!sensor) {
      sensor = newSensor();
    }

    if (listeners.indexOf(cb) === -1) {
      listeners.push(cb);
    }
  };
  /**
   * destroy
   */


  var destroy = function destroy() {
    sensor.disconnect();
    listeners = [];
    sensor = undefined;
  };
  /**
   * cancel bind
   * @param cb
   */


  var unbind = function unbind(cb) {
    var idx = listeners.indexOf(cb);

    if (idx !== -1) {
      listeners.splice(idx, 1);
    } // no listener, and sensor is exist
    // then destroy the sensor


    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };

  return {
    element: element,
    bind: bind,
    destroy: destroy,
    unbind: unbind
  };
};

resizeObserver.createSensor = createSensor$1;

Object.defineProperty(sensors, "__esModule", {
  value: true
});
sensors.createSensor = void 0;

var _object = object;

var _resizeObserver = resizeObserver;

/**
 * Created by hustcc on 18/7/5.
 * Contract: i@hust.cc
 */

/**
 * sensor strategies
 */
// export const createSensor = createObjectSensor;
var createSensor = typeof ResizeObserver !== 'undefined' ? _resizeObserver.createSensor : _object.createSensor;
sensors.createSensor = createSensor;

Object.defineProperty(sensorPool, "__esModule", {
  value: true
});
sensorPool.removeSensor = sensorPool.getSensor = void 0;

var _id = _interopRequireDefault(id);

var _sensors = sensors;

var _constant = constant;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */

/**
 * all the sensor objects.
 * sensor pool
 */
var Sensors = {};
/**
 * get one sensor
 * @param element
 * @returns {*}
 */

var getSensor = function getSensor(element) {
  var sensorId = element.getAttribute(_constant.SizeSensorId); // 1. if the sensor exists, then use it

  if (sensorId && Sensors[sensorId]) {
    return Sensors[sensorId];
  } // 2. not exist, then create one


  var newId = (0, _id["default"])();
  element.setAttribute(_constant.SizeSensorId, newId);
  var sensor = (0, _sensors.createSensor)(element); // add sensor into pool

  Sensors[newId] = sensor;
  return sensor;
};
/**
 * 移除 sensor
 * @param sensor
 */


sensorPool.getSensor = getSensor;

var removeSensor = function removeSensor(sensor) {
  var sensorId = sensor.element.getAttribute(_constant.SizeSensorId); // remove attribute

  sensor.element.removeAttribute(_constant.SizeSensorId); // remove event, dom of the sensor used

  sensor.destroy(); // exist, then remove from pool

  if (sensorId && Sensors[sensorId]) {
    delete Sensors[sensorId];
  }
};

sensorPool.removeSensor = removeSensor;

Object.defineProperty(lib, "__esModule", {
  value: true
});
lib.ver = lib.clear = lib.bind = void 0;

var _sensorPool = sensorPool;

/**
 * Created by hustcc on 18/6/9.[高考时间]
 * Contract: i@hust.cc
 */

/**
 * bind an element with resize callback function
 * @param {*} element
 * @param {*} cb
 */
var bind$2 = function bind(element, cb) {
  var sensor = (0, _sensorPool.getSensor)(element); // listen with callback

  sensor.bind(cb); // return unbind function

  return function () {
    sensor.unbind(cb);
  };
};
/**
 * clear all the listener and sensor of an element
 * @param element
 */


lib.bind = bind$2;

var clear$1 = function clear(element) {
  var sensor = (0, _sensorPool.getSensor)(element);
  (0, _sensorPool.removeSensor)(sensor);
};

lib.clear = clear$1;
var ver = "1.0.1";
lib.ver = ver;

var pick$1 = {};

Object.defineProperty(pick$1, "__esModule", { value: true });
pick$1.pick = void 0;
/**
 * 保留 object 中的部分内容
 * @param obj
 * @param keys
 */
function pick(obj, keys) {
    var r = {};
    keys.forEach(function (key) {
        r[key] = obj[key];
    });
    return r;
}
pick$1.pick = pick;

var isFunction$2 = {};

Object.defineProperty(isFunction$2, "__esModule", { value: true });
isFunction$2.isFunction = void 0;
function isFunction$1(v) {
    return typeof v === 'function';
}
isFunction$2.isFunction = isFunction$1;

var isString$2 = {};

Object.defineProperty(isString$2, "__esModule", { value: true });
isString$2.isString = void 0;
function isString$1(v) {
    return typeof v === 'string';
}
isString$2.isString = isString$1;

var isEqual = {};

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual$1 = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

Object.defineProperty(isEqual, "__esModule", { value: true });
isEqual.isEqual = void 0;
var tslib_1$1 = require$$0;
var fast_deep_equal_1 = (0, tslib_1$1.__importDefault)(fastDeepEqual$1);
isEqual.isEqual = fast_deep_equal_1.default;

Object.defineProperty(core, "__esModule", { value: true });
var tslib_1 = require$$0;
var react_1 = (0, tslib_1.__importStar)(React);
var size_sensor_1 = lib;
var pick_1 = pick$1;
var is_function_1 = isFunction$2;
var is_string_1 = isString$2;
var is_equal_1 = isEqual;
/**
 * core component for echarts binding
 */
var EChartsReactCore = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(EChartsReactCore, _super);
    function EChartsReactCore(props) {
        var _this = _super.call(this, props) || this;
        _this.echarts = props.echarts;
        _this.ele = null;
        _this.isInitialResize = true;
        return _this;
    }
    EChartsReactCore.prototype.componentDidMount = function () {
        this.renderNewEcharts();
    };
    // update
    EChartsReactCore.prototype.componentDidUpdate = function (prevProps) {
        /**
         * if shouldSetOption return false, then return, not update echarts options
         * default is true
         */
        var shouldSetOption = this.props.shouldSetOption;
        if ((0, is_function_1.isFunction)(shouldSetOption) && !shouldSetOption(prevProps, this.props)) {
            return;
        }
        // 以下属性修改的时候，需要 dispose 之后再新建
        // 1. 切换 theme 的时候
        // 2. 修改 opts 的时候
        // 3. 修改 onEvents 的时候，这样可以取消所有之前绑定的事件 issue #151
        if (!(0, is_equal_1.isEqual)(prevProps.theme, this.props.theme) ||
            !(0, is_equal_1.isEqual)(prevProps.opts, this.props.opts) ||
            !(0, is_equal_1.isEqual)(prevProps.onEvents, this.props.onEvents)) {
            this.dispose();
            this.renderNewEcharts(); // 重建
            return;
        }
        // when these props are not isEqual, update echarts
        var pickKeys = ['option', 'notMerge', 'lazyUpdate', 'showLoading', 'loadingOption'];
        if (!(0, is_equal_1.isEqual)((0, pick_1.pick)(this.props, pickKeys), (0, pick_1.pick)(prevProps, pickKeys))) {
            this.updateEChartsOption();
        }
        /**
         * when style or class name updated, change size.
         */
        if (!(0, is_equal_1.isEqual)(prevProps.style, this.props.style) || !(0, is_equal_1.isEqual)(prevProps.className, this.props.className)) {
            this.resize();
        }
    };
    EChartsReactCore.prototype.componentWillUnmount = function () {
        this.dispose();
    };
    /**
     * return the echart object
     * 1. if exist, return the existed instance
     * 2. or new one instance
     */
    EChartsReactCore.prototype.getEchartsInstance = function () {
        return this.echarts.getInstanceByDom(this.ele) || this.echarts.init(this.ele, this.props.theme, this.props.opts);
    };
    /**
     * dispose echarts and clear size-sensor
     */
    EChartsReactCore.prototype.dispose = function () {
        if (this.ele) {
            try {
                (0, size_sensor_1.clear)(this.ele);
            }
            catch (e) {
                console.warn(e);
            }
            // dispose echarts instance
            this.echarts.dispose(this.ele);
        }
    };
    /**
     * render a new echarts instance
     */
    EChartsReactCore.prototype.renderNewEcharts = function () {
        var _this = this;
        var _a = this.props, onEvents = _a.onEvents, onChartReady = _a.onChartReady;
        // 1. new echarts instance
        var echartsInstance = this.updateEChartsOption();
        // 2. bind events
        this.bindEvents(echartsInstance, onEvents || {});
        // 3. on chart ready
        if ((0, is_function_1.isFunction)(onChartReady))
            onChartReady(echartsInstance);
        // 4. on resize
        if (this.ele) {
            (0, size_sensor_1.bind)(this.ele, function () {
                _this.resize();
            });
        }
    };
    // bind the events
    EChartsReactCore.prototype.bindEvents = function (instance, events) {
        function _bindEvent(eventName, func) {
            // ignore the event config which not satisfy
            if ((0, is_string_1.isString)(eventName) && (0, is_function_1.isFunction)(func)) {
                // binding event
                instance.on(eventName, function (param) {
                    func(param, instance);
                });
            }
        }
        // loop and bind
        for (var eventName in events) {
            if (Object.prototype.hasOwnProperty.call(events, eventName)) {
                _bindEvent(eventName, events[eventName]);
            }
        }
    };
    /**
     * render the echarts
     */
    EChartsReactCore.prototype.updateEChartsOption = function () {
        var _a = this.props, option = _a.option, _b = _a.notMerge, notMerge = _b === void 0 ? false : _b, _c = _a.lazyUpdate, lazyUpdate = _c === void 0 ? false : _c, showLoading = _a.showLoading, _d = _a.loadingOption, loadingOption = _d === void 0 ? null : _d;
        // 1. get or initial the echarts object
        var echartInstance = this.getEchartsInstance();
        // 2. set the echarts option
        echartInstance.setOption(option, notMerge, lazyUpdate);
        // 3. set loading mask
        if (showLoading)
            echartInstance.showLoading(loadingOption);
        else
            echartInstance.hideLoading();
        return echartInstance;
    };
    /**
     * resize wrapper
     */
    EChartsReactCore.prototype.resize = function () {
        // 1. get the echarts object
        var echartsInstance = this.getEchartsInstance();
        // 2. call echarts instance resize if not the initial resize
        // resize should not happen on first render as it will cancel initial echarts animations
        if (!this.isInitialResize) {
            try {
                echartsInstance.resize();
            }
            catch (e) {
                console.warn(e);
            }
        }
        // 3. update variable for future calls
        this.isInitialResize = false;
    };
    EChartsReactCore.prototype.render = function () {
        var _this = this;
        var _a = this.props, style = _a.style, _b = _a.className, className = _b === void 0 ? '' : _b;
        // default height = 300
        var newStyle = (0, tslib_1.__assign)({ height: 300 }, style);
        return (react_1.default.createElement("div", { ref: function (e) {
                _this.ele = e;
            }, style: newStyle, className: "echarts-for-react " + className }));
    };
    return EChartsReactCore;
}(react_1.PureComponent));
var _default = core.default = EChartsReactCore;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$1 = function(d, b) {
    extendStatics$1 = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics$1(d, b);
};

function __extends$1(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics$1(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var Browser = (function () {
    function Browser() {
        this.firefox = false;
        this.ie = false;
        this.edge = false;
        this.newEdge = false;
        this.weChat = false;
    }
    return Browser;
}());
var Env = (function () {
    function Env() {
        this.browser = new Browser();
        this.node = false;
        this.wxa = false;
        this.worker = false;
        this.svgSupported = false;
        this.touchEventsSupported = false;
        this.pointerEventsSupported = false;
        this.domSupported = false;
        this.transformSupported = false;
        this.transform3dSupported = false;
        this.hasGlobalWindow = typeof window !== 'undefined';
    }
    return Env;
}());
var env = new Env();
if (typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function') {
    env.wxa = true;
    env.touchEventsSupported = true;
}
else if (typeof document === 'undefined' && typeof self !== 'undefined') {
    env.worker = true;
}
else if (typeof navigator === 'undefined') {
    env.node = true;
    env.svgSupported = true;
}
else {
    detect(navigator.userAgent, env);
}
function detect(ua, env) {
    var browser = env.browser;
    var firefox = ua.match(/Firefox\/([\d.]+)/);
    var ie = ua.match(/MSIE\s([\d.]+)/)
        || ua.match(/Trident\/.+?rv:(([\d.]+))/);
    var edge = ua.match(/Edge?\/([\d.]+)/);
    var weChat = (/micromessenger/i).test(ua);
    if (firefox) {
        browser.firefox = true;
        browser.version = firefox[1];
    }
    if (ie) {
        browser.ie = true;
        browser.version = ie[1];
    }
    if (edge) {
        browser.edge = true;
        browser.version = edge[1];
        browser.newEdge = +edge[1].split('.')[0] > 18;
    }
    if (weChat) {
        browser.weChat = true;
    }
    env.svgSupported = typeof SVGRect !== 'undefined';
    env.touchEventsSupported = 'ontouchstart' in window && !browser.ie && !browser.edge;
    env.pointerEventsSupported = 'onpointerdown' in window
        && (browser.edge || (browser.ie && +browser.version >= 11));
    env.domSupported = typeof document !== 'undefined';
    var style = document.documentElement.style;
    env.transform3dSupported = ((browser.ie && 'transition' in style)
        || browser.edge
        || (('WebKitCSSMatrix' in window) && ('m11' in new WebKitCSSMatrix()))
        || 'MozPerspective' in style)
        && !('OTransition' in style);
    env.transformSupported = env.transform3dSupported
        || (browser.ie && +browser.version >= 9);
}
var env$1 = env;

var DEFAULT_FONT_SIZE = 12;
var DEFAULT_FONT_FAMILY = 'sans-serif';
var DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY;
var OFFSET = 20;
var SCALE = 100;
var defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function getTextWidthMap(mapStr) {
    var map = {};
    if (typeof JSON === 'undefined') {
        return map;
    }
    for (var i = 0; i < mapStr.length; i++) {
        var char = String.fromCharCode(i + 32);
        var size = (mapStr.charCodeAt(i) - OFFSET) / SCALE;
        map[char] = size;
    }
    return map;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
var platformApi = {
    createCanvas: function () {
        return typeof document !== 'undefined'
            && document.createElement('canvas');
    },
    measureText: (function () {
        var _ctx;
        var _cachedFont;
        return function (text, font) {
            if (!_ctx) {
                var canvas = platformApi.createCanvas();
                _ctx = canvas && canvas.getContext('2d');
            }
            if (_ctx) {
                if (_cachedFont !== font) {
                    _cachedFont = _ctx.font = font || DEFAULT_FONT;
                }
                return _ctx.measureText(text);
            }
            else {
                text = text || '';
                font = font || DEFAULT_FONT;
                var res = /^([0-9]*?)px$/.exec(font);
                var fontSize = +(res && res[1]) || DEFAULT_FONT_SIZE;
                var width = 0;
                if (font.indexOf('mono') >= 0) {
                    width = fontSize * text.length;
                }
                else {
                    for (var i = 0; i < text.length; i++) {
                        var preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i]];
                        width += preCalcWidth == null ? fontSize : (preCalcWidth * fontSize);
                    }
                }
                return { width: width };
            }
        };
    })(),
    loadImage: function (src, onload, onerror) {
        var image = new Image();
        image.onload = onload;
        image.onerror = onerror;
        image.src = src;
        return image;
    }
};
function setPlatformAPI(newPlatformApis) {
    for (var key in platformApi) {
        if (newPlatformApis[key]) {
            platformApi[key] = newPlatformApis[key];
        }
    }
}

var BUILTIN_OBJECT = reduce([
    'Function',
    'RegExp',
    'Date',
    'Error',
    'CanvasGradient',
    'CanvasPattern',
    'Image',
    'Canvas'
], function (obj, val) {
    obj['[object ' + val + ']'] = true;
    return obj;
}, {});
var TYPED_ARRAY = reduce([
    'Int8',
    'Uint8',
    'Uint8Clamped',
    'Int16',
    'Uint16',
    'Int32',
    'Uint32',
    'Float32',
    'Float64'
], function (obj, val) {
    obj['[object ' + val + 'Array]'] = true;
    return obj;
}, {});
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var ctorFunction = function () { }.constructor;
var protoFunction = ctorFunction ? ctorFunction.prototype : null;
var protoKey = '__proto__';
var idStart = 0x0907;
function guid() {
    return idStart++;
}
function logError() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (typeof console !== 'undefined') {
        console.error.apply(console, args);
    }
}
function clone$3(source) {
    if (source == null || typeof source !== 'object') {
        return source;
    }
    var result = source;
    var typeStr = objToString.call(source);
    if (typeStr === '[object Array]') {
        if (!isPrimitive(source)) {
            result = [];
            for (var i = 0, len = source.length; i < len; i++) {
                result[i] = clone$3(source[i]);
            }
        }
    }
    else if (TYPED_ARRAY[typeStr]) {
        if (!isPrimitive(source)) {
            var Ctor = source.constructor;
            if (Ctor.from) {
                result = Ctor.from(source);
            }
            else {
                result = new Ctor(source.length);
                for (var i = 0, len = source.length; i < len; i++) {
                    result[i] = source[i];
                }
            }
        }
    }
    else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
        result = {};
        for (var key in source) {
            if (source.hasOwnProperty(key) && key !== protoKey) {
                result[key] = clone$3(source[key]);
            }
        }
    }
    return result;
}
function merge$1(target, source, overwrite) {
    if (!isObject$3(source) || !isObject$3(target)) {
        return overwrite ? clone$3(source) : target;
    }
    for (var key in source) {
        if (source.hasOwnProperty(key) && key !== protoKey) {
            var targetProp = target[key];
            var sourceProp = source[key];
            if (isObject$3(sourceProp)
                && isObject$3(targetProp)
                && !isArray$1(sourceProp)
                && !isArray$1(targetProp)
                && !isDom(sourceProp)
                && !isDom(targetProp)
                && !isBuiltInObject(sourceProp)
                && !isBuiltInObject(targetProp)
                && !isPrimitive(sourceProp)
                && !isPrimitive(targetProp)) {
                merge$1(targetProp, sourceProp, overwrite);
            }
            else if (overwrite || !(key in target)) {
                target[key] = clone$3(source[key]);
            }
        }
    }
    return target;
}
function mergeAll(targetAndSources, overwrite) {
    var result = targetAndSources[0];
    for (var i = 1, len = targetAndSources.length; i < len; i++) {
        result = merge$1(result, targetAndSources[i], overwrite);
    }
    return result;
}
function extend$2(target, source) {
    if (Object.assign) {
        Object.assign(target, source);
    }
    else {
        for (var key in source) {
            if (source.hasOwnProperty(key) && key !== protoKey) {
                target[key] = source[key];
            }
        }
    }
    return target;
}
function defaults(target, source, overlay) {
    var keysArr = keys(source);
    for (var i = 0; i < keysArr.length; i++) {
        var key = keysArr[i];
        if ((overlay ? source[key] != null : target[key] == null)) {
            target[key] = source[key];
        }
    }
    return target;
}
var createCanvas = platformApi.createCanvas;
function indexOf(array, value) {
    if (array) {
        if (array.indexOf) {
            return array.indexOf(value);
        }
        for (var i = 0, len = array.length; i < len; i++) {
            if (array[i] === value) {
                return i;
            }
        }
    }
    return -1;
}
function inherits(clazz, baseClazz) {
    var clazzPrototype = clazz.prototype;
    function F() { }
    F.prototype = baseClazz.prototype;
    clazz.prototype = new F();
    for (var prop in clazzPrototype) {
        if (clazzPrototype.hasOwnProperty(prop)) {
            clazz.prototype[prop] = clazzPrototype[prop];
        }
    }
    clazz.prototype.constructor = clazz;
    clazz.superClass = baseClazz;
}
function mixin(target, source, override) {
    target = 'prototype' in target ? target.prototype : target;
    source = 'prototype' in source ? source.prototype : source;
    if (Object.getOwnPropertyNames) {
        var keyList = Object.getOwnPropertyNames(source);
        for (var i = 0; i < keyList.length; i++) {
            var key = keyList[i];
            if (key !== 'constructor') {
                if ((override ? source[key] != null : target[key] == null)) {
                    target[key] = source[key];
                }
            }
        }
    }
    else {
        defaults(target, source, override);
    }
}
function isArrayLike(data) {
    if (!data) {
        return false;
    }
    if (typeof data === 'string') {
        return false;
    }
    return typeof data.length === 'number';
}
function each$9(arr, cb, context) {
    if (!(arr && cb)) {
        return;
    }
    if (arr.forEach && arr.forEach === nativeForEach) {
        arr.forEach(cb, context);
    }
    else if (arr.length === +arr.length) {
        for (var i = 0, len = arr.length; i < len; i++) {
            cb.call(context, arr[i], i, arr);
        }
    }
    else {
        for (var key in arr) {
            if (arr.hasOwnProperty(key)) {
                cb.call(context, arr[key], key, arr);
            }
        }
    }
}
function map$1(arr, cb, context) {
    if (!arr) {
        return [];
    }
    if (!cb) {
        return slice(arr);
    }
    if (arr.map && arr.map === nativeMap) {
        return arr.map(cb, context);
    }
    else {
        var result = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            result.push(cb.call(context, arr[i], i, arr));
        }
        return result;
    }
}
function reduce(arr, cb, memo, context) {
    if (!(arr && cb)) {
        return;
    }
    for (var i = 0, len = arr.length; i < len; i++) {
        memo = cb.call(context, memo, arr[i], i, arr);
    }
    return memo;
}
function filter(arr, cb, context) {
    if (!arr) {
        return [];
    }
    if (!cb) {
        return slice(arr);
    }
    if (arr.filter && arr.filter === nativeFilter) {
        return arr.filter(cb, context);
    }
    else {
        var result = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            if (cb.call(context, arr[i], i, arr)) {
                result.push(arr[i]);
            }
        }
        return result;
    }
}
function find(arr, cb, context) {
    if (!(arr && cb)) {
        return;
    }
    for (var i = 0, len = arr.length; i < len; i++) {
        if (cb.call(context, arr[i], i, arr)) {
            return arr[i];
        }
    }
}
function keys(obj) {
    if (!obj) {
        return [];
    }
    if (Object.keys) {
        return Object.keys(obj);
    }
    var keyList = [];
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            keyList.push(key);
        }
    }
    return keyList;
}
function bindPolyfill(func, context) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    return function () {
        return func.apply(context, args.concat(nativeSlice.call(arguments)));
    };
}
var bind$1 = (protoFunction && isFunction(protoFunction.bind))
    ? protoFunction.call.bind(protoFunction.bind)
    : bindPolyfill;
function curry$1(func) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function () {
        return func.apply(this, args.concat(nativeSlice.call(arguments)));
    };
}
function isArray$1(value) {
    if (Array.isArray) {
        return Array.isArray(value);
    }
    return objToString.call(value) === '[object Array]';
}
function isFunction(value) {
    return typeof value === 'function';
}
function isString(value) {
    return typeof value === 'string';
}
function isStringSafe(value) {
    return objToString.call(value) === '[object String]';
}
function isNumber(value) {
    return typeof value === 'number';
}
function isObject$3(value) {
    var type = typeof value;
    return type === 'function' || (!!value && type === 'object');
}
function isBuiltInObject(value) {
    return !!BUILTIN_OBJECT[objToString.call(value)];
}
function isTypedArray(value) {
    return !!TYPED_ARRAY[objToString.call(value)];
}
function isDom(value) {
    return typeof value === 'object'
        && typeof value.nodeType === 'number'
        && typeof value.ownerDocument === 'object';
}
function isGradientObject(value) {
    return value.colorStops != null;
}
function isImagePatternObject(value) {
    return value.image != null;
}
function isRegExp(value) {
    return objToString.call(value) === '[object RegExp]';
}
function eqNaN(value) {
    return value !== value;
}
function retrieve() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    for (var i = 0, len = args.length; i < len; i++) {
        if (args[i] != null) {
            return args[i];
        }
    }
}
function retrieve2(value0, value1) {
    return value0 != null
        ? value0
        : value1;
}
function retrieve3(value0, value1, value2) {
    return value0 != null
        ? value0
        : value1 != null
            ? value1
            : value2;
}
function slice(arr) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return nativeSlice.apply(arr, args);
}
function normalizeCssArray$1(val) {
    if (typeof (val) === 'number') {
        return [val, val, val, val];
    }
    var len = val.length;
    if (len === 2) {
        return [val[0], val[1], val[0], val[1]];
    }
    else if (len === 3) {
        return [val[0], val[1], val[2], val[1]];
    }
    return val;
}
function assert(condition, message) {
    if (!condition) {
        throw new Error(message);
    }
}
function trim(str) {
    if (str == null) {
        return null;
    }
    else if (typeof str.trim === 'function') {
        return str.trim();
    }
    else {
        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    }
}
var primitiveKey = '__ec_primitive__';
function setAsPrimitive(obj) {
    obj[primitiveKey] = true;
}
function isPrimitive(obj) {
    return obj[primitiveKey];
}
var HashMap = (function () {
    function HashMap(obj) {
        this.data = {};
        var isArr = isArray$1(obj);
        this.data = {};
        var thisMap = this;
        (obj instanceof HashMap)
            ? obj.each(visit)
            : (obj && each$9(obj, visit));
        function visit(value, key) {
            isArr ? thisMap.set(value, key) : thisMap.set(key, value);
        }
    }
    HashMap.prototype.get = function (key) {
        return this.data.hasOwnProperty(key) ? this.data[key] : null;
    };
    HashMap.prototype.set = function (key, value) {
        return (this.data[key] = value);
    };
    HashMap.prototype.each = function (cb, context) {
        for (var key in this.data) {
            if (this.data.hasOwnProperty(key)) {
                cb.call(context, this.data[key], key);
            }
        }
    };
    HashMap.prototype.keys = function () {
        return keys(this.data);
    };
    HashMap.prototype.removeKey = function (key) {
        delete this.data[key];
    };
    return HashMap;
}());
function createHashMap(obj) {
    return new HashMap(obj);
}
function concatArray(a, b) {
    var newArray = new a.constructor(a.length + b.length);
    for (var i = 0; i < a.length; i++) {
        newArray[i] = a[i];
    }
    var offset = a.length;
    for (var i = 0; i < b.length; i++) {
        newArray[i + offset] = b[i];
    }
    return newArray;
}
function createObject(proto, properties) {
    var obj;
    if (Object.create) {
        obj = Object.create(proto);
    }
    else {
        var StyleCtor = function () { };
        StyleCtor.prototype = proto;
        obj = new StyleCtor();
    }
    if (properties) {
        extend$2(obj, properties);
    }
    return obj;
}
function disableUserSelect(dom) {
    var domStyle = dom.style;
    domStyle.webkitUserSelect = 'none';
    domStyle.userSelect = 'none';
    domStyle.webkitTapHighlightColor = 'rgba(0,0,0,0)';
    domStyle['-webkit-touch-callout'] = 'none';
}
function hasOwn(own, prop) {
    return own.hasOwnProperty(prop);
}
function noop$1() { }
var RADIAN_TO_DEGREE = 180 / Math.PI;

var util$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  guid: guid,
  logError: logError,
  clone: clone$3,
  merge: merge$1,
  mergeAll: mergeAll,
  extend: extend$2,
  defaults: defaults,
  createCanvas: createCanvas,
  indexOf: indexOf,
  inherits: inherits,
  mixin: mixin,
  isArrayLike: isArrayLike,
  each: each$9,
  map: map$1,
  reduce: reduce,
  filter: filter,
  find: find,
  keys: keys,
  bind: bind$1,
  curry: curry$1,
  isArray: isArray$1,
  isFunction: isFunction,
  isString: isString,
  isStringSafe: isStringSafe,
  isNumber: isNumber,
  isObject: isObject$3,
  isBuiltInObject: isBuiltInObject,
  isTypedArray: isTypedArray,
  isDom: isDom,
  isGradientObject: isGradientObject,
  isImagePatternObject: isImagePatternObject,
  isRegExp: isRegExp,
  eqNaN: eqNaN,
  retrieve: retrieve,
  retrieve2: retrieve2,
  retrieve3: retrieve3,
  slice: slice,
  normalizeCssArray: normalizeCssArray$1,
  assert: assert,
  trim: trim,
  setAsPrimitive: setAsPrimitive,
  isPrimitive: isPrimitive,
  HashMap: HashMap,
  createHashMap: createHashMap,
  concatArray: concatArray,
  createObject: createObject,
  disableUserSelect: disableUserSelect,
  hasOwn: hasOwn,
  noop: noop$1,
  RADIAN_TO_DEGREE: RADIAN_TO_DEGREE
});

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function create$1(x, y) {
    if (x == null) {
        x = 0;
    }
    if (y == null) {
        y = 0;
    }
    return [x, y];
}
function copy$1(out, v) {
    out[0] = v[0];
    out[1] = v[1];
    return out;
}
function clone$2(v) {
    return [v[0], v[1]];
}
function set$1(out, a, b) {
    out[0] = a;
    out[1] = b;
    return out;
}
function add(out, v1, v2) {
    out[0] = v1[0] + v2[0];
    out[1] = v1[1] + v2[1];
    return out;
}
function scaleAndAdd(out, v1, v2, a) {
    out[0] = v1[0] + v2[0] * a;
    out[1] = v1[1] + v2[1] * a;
    return out;
}
function sub(out, v1, v2) {
    out[0] = v1[0] - v2[0];
    out[1] = v1[1] - v2[1];
    return out;
}
function len(v) {
    return Math.sqrt(lenSquare(v));
}
var length = len;
function lenSquare(v) {
    return v[0] * v[0] + v[1] * v[1];
}
var lengthSquare = lenSquare;
function mul$1(out, v1, v2) {
    out[0] = v1[0] * v2[0];
    out[1] = v1[1] * v2[1];
    return out;
}
function div(out, v1, v2) {
    out[0] = v1[0] / v2[0];
    out[1] = v1[1] / v2[1];
    return out;
}
function dot(v1, v2) {
    return v1[0] * v2[0] + v1[1] * v2[1];
}
function scale$2(out, v, s) {
    out[0] = v[0] * s;
    out[1] = v[1] * s;
    return out;
}
function normalize$1(out, v) {
    var d = len(v);
    if (d === 0) {
        out[0] = 0;
        out[1] = 0;
    }
    else {
        out[0] = v[0] / d;
        out[1] = v[1] / d;
    }
    return out;
}
function distance(v1, v2) {
    return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0])
        + (v1[1] - v2[1]) * (v1[1] - v2[1]));
}
var dist$1 = distance;
function distanceSquare(v1, v2) {
    return (v1[0] - v2[0]) * (v1[0] - v2[0])
        + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
var distSquare = distanceSquare;
function negate(out, v) {
    out[0] = -v[0];
    out[1] = -v[1];
    return out;
}
function lerp$1(out, v1, v2, t) {
    out[0] = v1[0] + t * (v2[0] - v1[0]);
    out[1] = v1[1] + t * (v2[1] - v1[1]);
    return out;
}
function applyTransform$1(out, v, m) {
    var x = v[0];
    var y = v[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
}
function min$1(out, v1, v2) {
    out[0] = Math.min(v1[0], v2[0]);
    out[1] = Math.min(v1[1], v2[1]);
    return out;
}
function max$1(out, v1, v2) {
    out[0] = Math.max(v1[0], v2[0]);
    out[1] = Math.max(v1[1], v2[1]);
    return out;
}

var vector = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create: create$1,
  copy: copy$1,
  clone: clone$2,
  set: set$1,
  add: add,
  scaleAndAdd: scaleAndAdd,
  sub: sub,
  len: len,
  length: length,
  lenSquare: lenSquare,
  lengthSquare: lengthSquare,
  mul: mul$1,
  div: div,
  dot: dot,
  scale: scale$2,
  normalize: normalize$1,
  distance: distance,
  dist: dist$1,
  distanceSquare: distanceSquare,
  distSquare: distSquare,
  negate: negate,
  lerp: lerp$1,
  applyTransform: applyTransform$1,
  min: min$1,
  max: max$1
});

var Param = (function () {
    function Param(target, e) {
        this.target = target;
        this.topTarget = e && e.topTarget;
    }
    return Param;
}());
var Draggable = (function () {
    function Draggable(handler) {
        this.handler = handler;
        handler.on('mousedown', this._dragStart, this);
        handler.on('mousemove', this._drag, this);
        handler.on('mouseup', this._dragEnd, this);
    }
    Draggable.prototype._dragStart = function (e) {
        var draggingTarget = e.target;
        while (draggingTarget && !draggingTarget.draggable) {
            draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget;
        }
        if (draggingTarget) {
            this._draggingTarget = draggingTarget;
            draggingTarget.dragging = true;
            this._x = e.offsetX;
            this._y = e.offsetY;
            this.handler.dispatchToElement(new Param(draggingTarget, e), 'dragstart', e.event);
        }
    };
    Draggable.prototype._drag = function (e) {
        var draggingTarget = this._draggingTarget;
        if (draggingTarget) {
            var x = e.offsetX;
            var y = e.offsetY;
            var dx = x - this._x;
            var dy = y - this._y;
            this._x = x;
            this._y = y;
            draggingTarget.drift(dx, dy, e);
            this.handler.dispatchToElement(new Param(draggingTarget, e), 'drag', e.event);
            var dropTarget = this.handler.findHover(x, y, draggingTarget).target;
            var lastDropTarget = this._dropTarget;
            this._dropTarget = dropTarget;
            if (draggingTarget !== dropTarget) {
                if (lastDropTarget && dropTarget !== lastDropTarget) {
                    this.handler.dispatchToElement(new Param(lastDropTarget, e), 'dragleave', e.event);
                }
                if (dropTarget && dropTarget !== lastDropTarget) {
                    this.handler.dispatchToElement(new Param(dropTarget, e), 'dragenter', e.event);
                }
            }
        }
    };
    Draggable.prototype._dragEnd = function (e) {
        var draggingTarget = this._draggingTarget;
        if (draggingTarget) {
            draggingTarget.dragging = false;
        }
        this.handler.dispatchToElement(new Param(draggingTarget, e), 'dragend', e.event);
        if (this._dropTarget) {
            this.handler.dispatchToElement(new Param(this._dropTarget, e), 'drop', e.event);
        }
        this._draggingTarget = null;
        this._dropTarget = null;
    };
    return Draggable;
}());
var Draggable$1 = Draggable;

var Eventful = (function () {
    function Eventful(eventProcessors) {
        if (eventProcessors) {
            this._$eventProcessor = eventProcessors;
        }
    }
    Eventful.prototype.on = function (event, query, handler, context) {
        if (!this._$handlers) {
            this._$handlers = {};
        }
        var _h = this._$handlers;
        if (typeof query === 'function') {
            context = handler;
            handler = query;
            query = null;
        }
        if (!handler || !event) {
            return this;
        }
        var eventProcessor = this._$eventProcessor;
        if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
            query = eventProcessor.normalizeQuery(query);
        }
        if (!_h[event]) {
            _h[event] = [];
        }
        for (var i = 0; i < _h[event].length; i++) {
            if (_h[event][i].h === handler) {
                return this;
            }
        }
        var wrap = {
            h: handler,
            query: query,
            ctx: (context || this),
            callAtLast: handler.zrEventfulCallAtLast
        };
        var lastIndex = _h[event].length - 1;
        var lastWrap = _h[event][lastIndex];
        (lastWrap && lastWrap.callAtLast)
            ? _h[event].splice(lastIndex, 0, wrap)
            : _h[event].push(wrap);
        return this;
    };
    Eventful.prototype.isSilent = function (eventName) {
        var _h = this._$handlers;
        return !_h || !_h[eventName] || !_h[eventName].length;
    };
    Eventful.prototype.off = function (eventType, handler) {
        var _h = this._$handlers;
        if (!_h) {
            return this;
        }
        if (!eventType) {
            this._$handlers = {};
            return this;
        }
        if (handler) {
            if (_h[eventType]) {
                var newList = [];
                for (var i = 0, l = _h[eventType].length; i < l; i++) {
                    if (_h[eventType][i].h !== handler) {
                        newList.push(_h[eventType][i]);
                    }
                }
                _h[eventType] = newList;
            }
            if (_h[eventType] && _h[eventType].length === 0) {
                delete _h[eventType];
            }
        }
        else {
            delete _h[eventType];
        }
        return this;
    };
    Eventful.prototype.trigger = function (eventType) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!this._$handlers) {
            return this;
        }
        var _h = this._$handlers[eventType];
        var eventProcessor = this._$eventProcessor;
        if (_h) {
            var argLen = args.length;
            var len = _h.length;
            for (var i = 0; i < len; i++) {
                var hItem = _h[i];
                if (eventProcessor
                    && eventProcessor.filter
                    && hItem.query != null
                    && !eventProcessor.filter(eventType, hItem.query)) {
                    continue;
                }
                switch (argLen) {
                    case 0:
                        hItem.h.call(hItem.ctx);
                        break;
                    case 1:
                        hItem.h.call(hItem.ctx, args[0]);
                        break;
                    case 2:
                        hItem.h.call(hItem.ctx, args[0], args[1]);
                        break;
                    default:
                        hItem.h.apply(hItem.ctx, args);
                        break;
                }
            }
        }
        eventProcessor && eventProcessor.afterTrigger
            && eventProcessor.afterTrigger(eventType);
        return this;
    };
    Eventful.prototype.triggerWithContext = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!this._$handlers) {
            return this;
        }
        var _h = this._$handlers[type];
        var eventProcessor = this._$eventProcessor;
        if (_h) {
            var argLen = args.length;
            var ctx = args[argLen - 1];
            var len = _h.length;
            for (var i = 0; i < len; i++) {
                var hItem = _h[i];
                if (eventProcessor
                    && eventProcessor.filter
                    && hItem.query != null
                    && !eventProcessor.filter(type, hItem.query)) {
                    continue;
                }
                switch (argLen) {
                    case 0:
                        hItem.h.call(ctx);
                        break;
                    case 1:
                        hItem.h.call(ctx, args[0]);
                        break;
                    case 2:
                        hItem.h.call(ctx, args[0], args[1]);
                        break;
                    default:
                        hItem.h.apply(ctx, args.slice(1, argLen - 1));
                        break;
                }
            }
        }
        eventProcessor && eventProcessor.afterTrigger
            && eventProcessor.afterTrigger(type);
        return this;
    };
    return Eventful;
}());
var Eventful$1 = Eventful;

var LN2 = Math.log(2);
function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
    var cacheKey = rowMask + '-' + colMask;
    var fullRank = rows.length;
    if (detCache.hasOwnProperty(cacheKey)) {
        return detCache[cacheKey];
    }
    if (rank === 1) {
        var colStart = Math.round(Math.log(((1 << fullRank) - 1) & ~colMask) / LN2);
        return rows[rowStart][colStart];
    }
    var subRowMask = rowMask | (1 << rowStart);
    var subRowStart = rowStart + 1;
    while (rowMask & (1 << subRowStart)) {
        subRowStart++;
    }
    var sum = 0;
    for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
        var colTag = 1 << j;
        if (!(colTag & colMask)) {
            sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j]
                * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
            colLocalIdx++;
        }
    }
    detCache[cacheKey] = sum;
    return sum;
}
function buildTransformer(src, dest) {
    var mA = [
        [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],
        [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],
        [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],
        [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],
        [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],
        [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],
        [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],
        [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]
    ];
    var detCache = {};
    var det = determinant(mA, 8, 0, 0, 0, detCache);
    if (det === 0) {
        return;
    }
    var vh = [];
    for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
            vh[j] == null && (vh[j] = 0);
            vh[j] += ((i + j) % 2 ? -1 : 1)
                * determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache)
                / det * dest[i];
        }
    }
    return function (out, srcPointX, srcPointY) {
        var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
        out[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
        out[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
    };
}

var EVENT_SAVED_PROP = '___zrEVENTSAVED';
var _calcOut$1 = [];
function transformLocalCoord(out, elFrom, elTarget, inX, inY) {
    return transformCoordWithViewport(_calcOut$1, elFrom, inX, inY, true)
        && transformCoordWithViewport(out, elTarget, _calcOut$1[0], _calcOut$1[1]);
}
function transformCoordWithViewport(out, el, inX, inY, inverse) {
    if (el.getBoundingClientRect && env$1.domSupported && !isCanvasEl(el)) {
        var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
        var markers = prepareCoordMarkers(el, saved);
        var transformer = preparePointerTransformer(markers, saved, inverse);
        if (transformer) {
            transformer(out, inX, inY);
            return true;
        }
    }
    return false;
}
function prepareCoordMarkers(el, saved) {
    var markers = saved.markers;
    if (markers) {
        return markers;
    }
    markers = saved.markers = [];
    var propLR = ['left', 'right'];
    var propTB = ['top', 'bottom'];
    for (var i = 0; i < 4; i++) {
        var marker = document.createElement('div');
        var stl = marker.style;
        var idxLR = i % 2;
        var idxTB = (i >> 1) % 2;
        stl.cssText = [
            'position: absolute',
            'visibility: hidden',
            'padding: 0',
            'margin: 0',
            'border-width: 0',
            'user-select: none',
            'width:0',
            'height:0',
            propLR[idxLR] + ':0',
            propTB[idxTB] + ':0',
            propLR[1 - idxLR] + ':auto',
            propTB[1 - idxTB] + ':auto',
            ''
        ].join('!important;');
        el.appendChild(marker);
        markers.push(marker);
    }
    return markers;
}
function preparePointerTransformer(markers, saved, inverse) {
    var transformerName = inverse ? 'invTrans' : 'trans';
    var transformer = saved[transformerName];
    var oldSrcCoords = saved.srcCoords;
    var srcCoords = [];
    var destCoords = [];
    var oldCoordTheSame = true;
    for (var i = 0; i < 4; i++) {
        var rect = markers[i].getBoundingClientRect();
        var ii = 2 * i;
        var x = rect.left;
        var y = rect.top;
        srcCoords.push(x, y);
        oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
        destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
    }
    return (oldCoordTheSame && transformer)
        ? transformer
        : (saved.srcCoords = srcCoords,
            saved[transformerName] = inverse
                ? buildTransformer(destCoords, srcCoords)
                : buildTransformer(srcCoords, destCoords));
}
function isCanvasEl(el) {
    return el.nodeName.toUpperCase() === 'CANVAS';
}
var replaceReg = /([&<>"'])/g;
var replaceMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&#39;'
};
function encodeHTML(source) {
    return source == null
        ? ''
        : (source + '').replace(replaceReg, function (str, c) {
            return replaceMap[c];
        });
}

var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
var _calcOut = [];
var firefoxNotSupportOffsetXY = env$1.browser.firefox
    && +env$1.browser.version.split('.')[0] < 39;
function clientToLocal(el, e, out, calculate) {
    out = out || {};
    if (calculate) {
        calculateZrXY(el, e, out);
    }
    else if (firefoxNotSupportOffsetXY
        && e.layerX != null
        && e.layerX !== e.offsetX) {
        out.zrX = e.layerX;
        out.zrY = e.layerY;
    }
    else if (e.offsetX != null) {
        out.zrX = e.offsetX;
        out.zrY = e.offsetY;
    }
    else {
        calculateZrXY(el, e, out);
    }
    return out;
}
function calculateZrXY(el, e, out) {
    if (env$1.domSupported && el.getBoundingClientRect) {
        var ex = e.clientX;
        var ey = e.clientY;
        if (isCanvasEl(el)) {
            var box = el.getBoundingClientRect();
            out.zrX = ex - box.left;
            out.zrY = ey - box.top;
            return;
        }
        else {
            if (transformCoordWithViewport(_calcOut, el, ex, ey)) {
                out.zrX = _calcOut[0];
                out.zrY = _calcOut[1];
                return;
            }
        }
    }
    out.zrX = out.zrY = 0;
}
function getNativeEvent(e) {
    return e
        || window.event;
}
function normalizeEvent(el, e, calculate) {
    e = getNativeEvent(e);
    if (e.zrX != null) {
        return e;
    }
    var eventType = e.type;
    var isTouch = eventType && eventType.indexOf('touch') >= 0;
    if (!isTouch) {
        clientToLocal(el, e, e, calculate);
        var wheelDelta = getWheelDeltaMayPolyfill(e);
        e.zrDelta = wheelDelta ? wheelDelta / 120 : -(e.detail || 0) / 3;
    }
    else {
        var touch = eventType !== 'touchend'
            ? e.targetTouches[0]
            : e.changedTouches[0];
        touch && clientToLocal(el, touch, e, calculate);
    }
    var button = e.button;
    if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
        e.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
    }
    return e;
}
function getWheelDeltaMayPolyfill(e) {
    var rawWheelDelta = e.wheelDelta;
    if (rawWheelDelta) {
        return rawWheelDelta;
    }
    var deltaX = e.deltaX;
    var deltaY = e.deltaY;
    if (deltaX == null || deltaY == null) {
        return rawWheelDelta;
    }
    var delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
    var sign = deltaY > 0 ? -1
        : deltaY < 0 ? 1
            : deltaX > 0 ? -1
                : 1;
    return 3 * delta * sign;
}
function addEventListener(el, name, handler, opt) {
    el.addEventListener(name, handler, opt);
}
function removeEventListener(el, name, handler, opt) {
    el.removeEventListener(name, handler, opt);
}
var stop = function (e) {
    e.preventDefault();
    e.stopPropagation();
    e.cancelBubble = true;
};
function isMiddleOrRightButtonOnMouseUpDown(e) {
    return e.which === 2 || e.which === 3;
}

var GestureMgr = (function () {
    function GestureMgr() {
        this._track = [];
    }
    GestureMgr.prototype.recognize = function (event, target, root) {
        this._doTrack(event, target, root);
        return this._recognize(event);
    };
    GestureMgr.prototype.clear = function () {
        this._track.length = 0;
        return this;
    };
    GestureMgr.prototype._doTrack = function (event, target, root) {
        var touches = event.touches;
        if (!touches) {
            return;
        }
        var trackItem = {
            points: [],
            touches: [],
            target: target,
            event: event
        };
        for (var i = 0, len = touches.length; i < len; i++) {
            var touch = touches[i];
            var pos = clientToLocal(root, touch, {});
            trackItem.points.push([pos.zrX, pos.zrY]);
            trackItem.touches.push(touch);
        }
        this._track.push(trackItem);
    };
    GestureMgr.prototype._recognize = function (event) {
        for (var eventName in recognizers) {
            if (recognizers.hasOwnProperty(eventName)) {
                var gestureInfo = recognizers[eventName](this._track, event);
                if (gestureInfo) {
                    return gestureInfo;
                }
            }
        }
    };
    return GestureMgr;
}());
function dist(pointPair) {
    var dx = pointPair[1][0] - pointPair[0][0];
    var dy = pointPair[1][1] - pointPair[0][1];
    return Math.sqrt(dx * dx + dy * dy);
}
function center(pointPair) {
    return [
        (pointPair[0][0] + pointPair[1][0]) / 2,
        (pointPair[0][1] + pointPair[1][1]) / 2
    ];
}
var recognizers = {
    pinch: function (tracks, event) {
        var trackLen = tracks.length;
        if (!trackLen) {
            return;
        }
        var pinchEnd = (tracks[trackLen - 1] || {}).points;
        var pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
        if (pinchPre
            && pinchPre.length > 1
            && pinchEnd
            && pinchEnd.length > 1) {
            var pinchScale = dist(pinchEnd) / dist(pinchPre);
            !isFinite(pinchScale) && (pinchScale = 1);
            event.pinchScale = pinchScale;
            var pinchCenter = center(pinchEnd);
            event.pinchX = pinchCenter[0];
            event.pinchY = pinchCenter[1];
            return {
                type: 'pinch',
                target: tracks[0].target,
                event: event
            };
        }
    }
};

function create() {
    return [1, 0, 0, 1, 0, 0];
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
}
function copy(out, m) {
    out[0] = m[0];
    out[1] = m[1];
    out[2] = m[2];
    out[3] = m[3];
    out[4] = m[4];
    out[5] = m[5];
    return out;
}
function mul(out, m1, m2) {
    var out0 = m1[0] * m2[0] + m1[2] * m2[1];
    var out1 = m1[1] * m2[0] + m1[3] * m2[1];
    var out2 = m1[0] * m2[2] + m1[2] * m2[3];
    var out3 = m1[1] * m2[2] + m1[3] * m2[3];
    var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
    var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = out3;
    out[4] = out4;
    out[5] = out5;
    return out;
}
function translate(out, a, v) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4] + v[0];
    out[5] = a[5] + v[1];
    return out;
}
function rotate(out, a, rad) {
    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];
    var st = Math.sin(rad);
    var ct = Math.cos(rad);
    out[0] = aa * ct + ab * st;
    out[1] = -aa * st + ab * ct;
    out[2] = ac * ct + ad * st;
    out[3] = -ac * st + ct * ad;
    out[4] = ct * atx + st * aty;
    out[5] = ct * aty - st * atx;
    return out;
}
function scale$1(out, a, v) {
    var vx = v[0];
    var vy = v[1];
    out[0] = a[0] * vx;
    out[1] = a[1] * vy;
    out[2] = a[2] * vx;
    out[3] = a[3] * vy;
    out[4] = a[4] * vx;
    out[5] = a[5] * vy;
    return out;
}
function invert(out, a) {
    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];
    var det = aa * ad - ab * ac;
    if (!det) {
        return null;
    }
    det = 1.0 / det;
    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
}
function clone$1(a) {
    var b = create();
    copy(b, a);
    return b;
}

var matrix = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create: create,
  identity: identity,
  copy: copy,
  mul: mul,
  translate: translate,
  rotate: rotate,
  scale: scale$1,
  invert: invert,
  clone: clone$1
});

var Point = (function () {
    function Point(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }
    Point.prototype.copy = function (other) {
        this.x = other.x;
        this.y = other.y;
        return this;
    };
    Point.prototype.clone = function () {
        return new Point(this.x, this.y);
    };
    Point.prototype.set = function (x, y) {
        this.x = x;
        this.y = y;
        return this;
    };
    Point.prototype.equal = function (other) {
        return other.x === this.x && other.y === this.y;
    };
    Point.prototype.add = function (other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    };
    Point.prototype.scale = function (scalar) {
        this.x *= scalar;
        this.y *= scalar;
    };
    Point.prototype.scaleAndAdd = function (other, scalar) {
        this.x += other.x * scalar;
        this.y += other.y * scalar;
    };
    Point.prototype.sub = function (other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    };
    Point.prototype.dot = function (other) {
        return this.x * other.x + this.y * other.y;
    };
    Point.prototype.len = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    Point.prototype.lenSquare = function () {
        return this.x * this.x + this.y * this.y;
    };
    Point.prototype.normalize = function () {
        var len = this.len();
        this.x /= len;
        this.y /= len;
        return this;
    };
    Point.prototype.distance = function (other) {
        var dx = this.x - other.x;
        var dy = this.y - other.y;
        return Math.sqrt(dx * dx + dy * dy);
    };
    Point.prototype.distanceSquare = function (other) {
        var dx = this.x - other.x;
        var dy = this.y - other.y;
        return dx * dx + dy * dy;
    };
    Point.prototype.negate = function () {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    };
    Point.prototype.transform = function (m) {
        if (!m) {
            return;
        }
        var x = this.x;
        var y = this.y;
        this.x = m[0] * x + m[2] * y + m[4];
        this.y = m[1] * x + m[3] * y + m[5];
        return this;
    };
    Point.prototype.toArray = function (out) {
        out[0] = this.x;
        out[1] = this.y;
        return out;
    };
    Point.prototype.fromArray = function (input) {
        this.x = input[0];
        this.y = input[1];
    };
    Point.set = function (p, x, y) {
        p.x = x;
        p.y = y;
    };
    Point.copy = function (p, p2) {
        p.x = p2.x;
        p.y = p2.y;
    };
    Point.len = function (p) {
        return Math.sqrt(p.x * p.x + p.y * p.y);
    };
    Point.lenSquare = function (p) {
        return p.x * p.x + p.y * p.y;
    };
    Point.dot = function (p0, p1) {
        return p0.x * p1.x + p0.y * p1.y;
    };
    Point.add = function (out, p0, p1) {
        out.x = p0.x + p1.x;
        out.y = p0.y + p1.y;
    };
    Point.sub = function (out, p0, p1) {
        out.x = p0.x - p1.x;
        out.y = p0.y - p1.y;
    };
    Point.scale = function (out, p0, scalar) {
        out.x = p0.x * scalar;
        out.y = p0.y * scalar;
    };
    Point.scaleAndAdd = function (out, p0, p1, scalar) {
        out.x = p0.x + p1.x * scalar;
        out.y = p0.y + p1.y * scalar;
    };
    Point.lerp = function (out, p0, p1, t) {
        var onet = 1 - t;
        out.x = onet * p0.x + t * p1.x;
        out.y = onet * p0.y + t * p1.y;
    };
    return Point;
}());
var Point$1 = Point;

var mathMin$7 = Math.min;
var mathMax$7 = Math.max;
var lt = new Point$1();
var rb = new Point$1();
var lb = new Point$1();
var rt = new Point$1();
var minTv$1 = new Point$1();
var maxTv$1 = new Point$1();
var BoundingRect = (function () {
    function BoundingRect(x, y, width, height) {
        if (width < 0) {
            x = x + width;
            width = -width;
        }
        if (height < 0) {
            y = y + height;
            height = -height;
        }
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    BoundingRect.prototype.union = function (other) {
        var x = mathMin$7(other.x, this.x);
        var y = mathMin$7(other.y, this.y);
        if (isFinite(this.x) && isFinite(this.width)) {
            this.width = mathMax$7(other.x + other.width, this.x + this.width) - x;
        }
        else {
            this.width = other.width;
        }
        if (isFinite(this.y) && isFinite(this.height)) {
            this.height = mathMax$7(other.y + other.height, this.y + this.height) - y;
        }
        else {
            this.height = other.height;
        }
        this.x = x;
        this.y = y;
    };
    BoundingRect.prototype.applyTransform = function (m) {
        BoundingRect.applyTransform(this, this, m);
    };
    BoundingRect.prototype.calculateTransform = function (b) {
        var a = this;
        var sx = b.width / a.width;
        var sy = b.height / a.height;
        var m = create();
        translate(m, m, [-a.x, -a.y]);
        scale$1(m, m, [sx, sy]);
        translate(m, m, [b.x, b.y]);
        return m;
    };
    BoundingRect.prototype.intersect = function (b, mtv) {
        if (!b) {
            return false;
        }
        if (!(b instanceof BoundingRect)) {
            b = BoundingRect.create(b);
        }
        var a = this;
        var ax0 = a.x;
        var ax1 = a.x + a.width;
        var ay0 = a.y;
        var ay1 = a.y + a.height;
        var bx0 = b.x;
        var bx1 = b.x + b.width;
        var by0 = b.y;
        var by1 = b.y + b.height;
        var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
        if (mtv) {
            var dMin = Infinity;
            var dMax = 0;
            var d0 = Math.abs(ax1 - bx0);
            var d1 = Math.abs(bx1 - ax0);
            var d2 = Math.abs(ay1 - by0);
            var d3 = Math.abs(by1 - ay0);
            var dx = Math.min(d0, d1);
            var dy = Math.min(d2, d3);
            if (ax1 < bx0 || bx1 < ax0) {
                if (dx > dMax) {
                    dMax = dx;
                    if (d0 < d1) {
                        Point$1.set(maxTv$1, -d0, 0);
                    }
                    else {
                        Point$1.set(maxTv$1, d1, 0);
                    }
                }
            }
            else {
                if (dx < dMin) {
                    dMin = dx;
                    if (d0 < d1) {
                        Point$1.set(minTv$1, d0, 0);
                    }
                    else {
                        Point$1.set(minTv$1, -d1, 0);
                    }
                }
            }
            if (ay1 < by0 || by1 < ay0) {
                if (dy > dMax) {
                    dMax = dy;
                    if (d2 < d3) {
                        Point$1.set(maxTv$1, 0, -d2);
                    }
                    else {
                        Point$1.set(maxTv$1, 0, d3);
                    }
                }
            }
            else {
                if (dx < dMin) {
                    dMin = dx;
                    if (d2 < d3) {
                        Point$1.set(minTv$1, 0, d2);
                    }
                    else {
                        Point$1.set(minTv$1, 0, -d3);
                    }
                }
            }
        }
        if (mtv) {
            Point$1.copy(mtv, overlap ? minTv$1 : maxTv$1);
        }
        return overlap;
    };
    BoundingRect.prototype.contain = function (x, y) {
        var rect = this;
        return x >= rect.x
            && x <= (rect.x + rect.width)
            && y >= rect.y
            && y <= (rect.y + rect.height);
    };
    BoundingRect.prototype.clone = function () {
        return new BoundingRect(this.x, this.y, this.width, this.height);
    };
    BoundingRect.prototype.copy = function (other) {
        BoundingRect.copy(this, other);
    };
    BoundingRect.prototype.plain = function () {
        return {
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height
        };
    };
    BoundingRect.prototype.isFinite = function () {
        return isFinite(this.x)
            && isFinite(this.y)
            && isFinite(this.width)
            && isFinite(this.height);
    };
    BoundingRect.prototype.isZero = function () {
        return this.width === 0 || this.height === 0;
    };
    BoundingRect.create = function (rect) {
        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
    };
    BoundingRect.copy = function (target, source) {
        target.x = source.x;
        target.y = source.y;
        target.width = source.width;
        target.height = source.height;
    };
    BoundingRect.applyTransform = function (target, source, m) {
        if (!m) {
            if (target !== source) {
                BoundingRect.copy(target, source);
            }
            return;
        }
        if (m[1] < 1e-5 && m[1] > -1e-5 && m[2] < 1e-5 && m[2] > -1e-5) {
            var sx = m[0];
            var sy = m[3];
            var tx = m[4];
            var ty = m[5];
            target.x = source.x * sx + tx;
            target.y = source.y * sy + ty;
            target.width = source.width * sx;
            target.height = source.height * sy;
            if (target.width < 0) {
                target.x += target.width;
                target.width = -target.width;
            }
            if (target.height < 0) {
                target.y += target.height;
                target.height = -target.height;
            }
            return;
        }
        lt.x = lb.x = source.x;
        lt.y = rt.y = source.y;
        rb.x = rt.x = source.x + source.width;
        rb.y = lb.y = source.y + source.height;
        lt.transform(m);
        rt.transform(m);
        rb.transform(m);
        lb.transform(m);
        target.x = mathMin$7(lt.x, rb.x, lb.x, rt.x);
        target.y = mathMin$7(lt.y, rb.y, lb.y, rt.y);
        var maxX = mathMax$7(lt.x, rb.x, lb.x, rt.x);
        var maxY = mathMax$7(lt.y, rb.y, lb.y, rt.y);
        target.width = maxX - target.x;
        target.height = maxY - target.y;
    };
    return BoundingRect;
}());
var BoundingRect$1 = BoundingRect;

var SILENT = 'silent';
function makeEventPacket(eveType, targetInfo, event) {
    return {
        type: eveType,
        event: event,
        target: targetInfo.target,
        topTarget: targetInfo.topTarget,
        cancelBubble: false,
        offsetX: event.zrX,
        offsetY: event.zrY,
        gestureEvent: event.gestureEvent,
        pinchX: event.pinchX,
        pinchY: event.pinchY,
        pinchScale: event.pinchScale,
        wheelDelta: event.zrDelta,
        zrByTouch: event.zrByTouch,
        which: event.which,
        stop: stopEvent
    };
}
function stopEvent() {
    stop(this.event);
}
var EmptyProxy = (function (_super) {
    __extends(EmptyProxy, _super);
    function EmptyProxy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.handler = null;
        return _this;
    }
    EmptyProxy.prototype.dispose = function () { };
    EmptyProxy.prototype.setCursor = function () { };
    return EmptyProxy;
}(Eventful$1));
var HoveredResult = (function () {
    function HoveredResult(x, y) {
        this.x = x;
        this.y = y;
    }
    return HoveredResult;
}());
var handlerNames = [
    'click', 'dblclick', 'mousewheel', 'mouseout',
    'mouseup', 'mousedown', 'mousemove', 'contextmenu'
];
var tmpRect$1 = new BoundingRect$1(0, 0, 0, 0);
var Handler = (function (_super) {
    __extends(Handler, _super);
    function Handler(storage, painter, proxy, painterRoot, pointerSize) {
        var _this = _super.call(this) || this;
        _this._hovered = new HoveredResult(0, 0);
        _this.storage = storage;
        _this.painter = painter;
        _this.painterRoot = painterRoot;
        _this._pointerSize = pointerSize;
        proxy = proxy || new EmptyProxy();
        _this.proxy = null;
        _this.setHandlerProxy(proxy);
        _this._draggingMgr = new Draggable$1(_this);
        return _this;
    }
    Handler.prototype.setHandlerProxy = function (proxy) {
        if (this.proxy) {
            this.proxy.dispose();
        }
        if (proxy) {
            each$9(handlerNames, function (name) {
                proxy.on && proxy.on(name, this[name], this);
            }, this);
            proxy.handler = this;
        }
        this.proxy = proxy;
    };
    Handler.prototype.mousemove = function (event) {
        var x = event.zrX;
        var y = event.zrY;
        var isOutside = isOutsideBoundary(this, x, y);
        var lastHovered = this._hovered;
        var lastHoveredTarget = lastHovered.target;
        if (lastHoveredTarget && !lastHoveredTarget.__zr) {
            lastHovered = this.findHover(lastHovered.x, lastHovered.y);
            lastHoveredTarget = lastHovered.target;
        }
        var hovered = this._hovered = isOutside ? new HoveredResult(x, y) : this.findHover(x, y);
        var hoveredTarget = hovered.target;
        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');
        if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
            this.dispatchToElement(lastHovered, 'mouseout', event);
        }
        this.dispatchToElement(hovered, 'mousemove', event);
        if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
            this.dispatchToElement(hovered, 'mouseover', event);
        }
    };
    Handler.prototype.mouseout = function (event) {
        var eventControl = event.zrEventControl;
        if (eventControl !== 'only_globalout') {
            this.dispatchToElement(this._hovered, 'mouseout', event);
        }
        if (eventControl !== 'no_globalout') {
            this.trigger('globalout', { type: 'globalout', event: event });
        }
    };
    Handler.prototype.resize = function () {
        this._hovered = new HoveredResult(0, 0);
    };
    Handler.prototype.dispatch = function (eventName, eventArgs) {
        var handler = this[eventName];
        handler && handler.call(this, eventArgs);
    };
    Handler.prototype.dispose = function () {
        this.proxy.dispose();
        this.storage = null;
        this.proxy = null;
        this.painter = null;
    };
    Handler.prototype.setCursorStyle = function (cursorStyle) {
        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(cursorStyle);
    };
    Handler.prototype.dispatchToElement = function (targetInfo, eventName, event) {
        targetInfo = targetInfo || {};
        var el = targetInfo.target;
        if (el && el.silent) {
            return;
        }
        var eventKey = ('on' + eventName);
        var eventPacket = makeEventPacket(eventName, targetInfo, event);
        while (el) {
            el[eventKey]
                && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));
            el.trigger(eventName, eventPacket);
            el = el.__hostTarget ? el.__hostTarget : el.parent;
            if (eventPacket.cancelBubble) {
                break;
            }
        }
        if (!eventPacket.cancelBubble) {
            this.trigger(eventName, eventPacket);
            if (this.painter && this.painter.eachOtherLayer) {
                this.painter.eachOtherLayer(function (layer) {
                    if (typeof (layer[eventKey]) === 'function') {
                        layer[eventKey].call(layer, eventPacket);
                    }
                    if (layer.trigger) {
                        layer.trigger(eventName, eventPacket);
                    }
                });
            }
        }
    };
    Handler.prototype.findHover = function (x, y, exclude) {
        var list = this.storage.getDisplayList();
        var out = new HoveredResult(x, y);
        setHoverTarget(list, out, x, y, exclude);
        if (this._pointerSize && !out.target) {
            var candidates = [];
            var pointerSize = this._pointerSize;
            var targetSizeHalf = pointerSize / 2;
            var pointerRect = new BoundingRect$1(x - targetSizeHalf, y - targetSizeHalf, pointerSize, pointerSize);
            for (var i = list.length - 1; i >= 0; i--) {
                var el = list[i];
                if (el !== exclude
                    && !el.ignore
                    && !el.ignoreCoarsePointer
                    && (!el.parent || !el.parent.ignoreCoarsePointer)) {
                    tmpRect$1.copy(el.getBoundingRect());
                    if (el.transform) {
                        tmpRect$1.applyTransform(el.transform);
                    }
                    if (tmpRect$1.intersect(pointerRect)) {
                        candidates.push(el);
                    }
                }
            }
            if (candidates.length) {
                var rStep = 4;
                var thetaStep = Math.PI / 12;
                var PI2 = Math.PI * 2;
                for (var r = 0; r < targetSizeHalf; r += rStep) {
                    for (var theta = 0; theta < PI2; theta += thetaStep) {
                        var x1 = x + r * Math.cos(theta);
                        var y1 = y + r * Math.sin(theta);
                        setHoverTarget(candidates, out, x1, y1, exclude);
                        if (out.target) {
                            return out;
                        }
                    }
                }
            }
        }
        return out;
    };
    Handler.prototype.processGesture = function (event, stage) {
        if (!this._gestureMgr) {
            this._gestureMgr = new GestureMgr();
        }
        var gestureMgr = this._gestureMgr;
        stage === 'start' && gestureMgr.clear();
        var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
        stage === 'end' && gestureMgr.clear();
        if (gestureInfo) {
            var type = gestureInfo.type;
            event.gestureEvent = type;
            var res = new HoveredResult();
            res.target = gestureInfo.target;
            this.dispatchToElement(res, type, gestureInfo.event);
        }
    };
    return Handler;
}(Eventful$1));
each$9(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
    Handler.prototype[name] = function (event) {
        var x = event.zrX;
        var y = event.zrY;
        var isOutside = isOutsideBoundary(this, x, y);
        var hovered;
        var hoveredTarget;
        if (name !== 'mouseup' || !isOutside) {
            hovered = this.findHover(x, y);
            hoveredTarget = hovered.target;
        }
        if (name === 'mousedown') {
            this._downEl = hoveredTarget;
            this._downPoint = [event.zrX, event.zrY];
            this._upEl = hoveredTarget;
        }
        else if (name === 'mouseup') {
            this._upEl = hoveredTarget;
        }
        else if (name === 'click') {
            if (this._downEl !== this._upEl
                || !this._downPoint
                || dist$1(this._downPoint, [event.zrX, event.zrY]) > 4) {
                return;
            }
            this._downPoint = null;
        }
        this.dispatchToElement(hovered, name, event);
    };
});
function isHover(displayable, x, y) {
    if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
        var el = displayable;
        var isSilent = void 0;
        var ignoreClip = false;
        while (el) {
            if (el.ignoreClip) {
                ignoreClip = true;
            }
            if (!ignoreClip) {
                var clipPath = el.getClipPath();
                if (clipPath && !clipPath.contain(x, y)) {
                    return false;
                }
                if (el.silent) {
                    isSilent = true;
                }
            }
            var hostEl = el.__hostTarget;
            el = hostEl ? hostEl : el.parent;
        }
        return isSilent ? SILENT : true;
    }
    return false;
}
function setHoverTarget(list, out, x, y, exclude) {
    for (var i = list.length - 1; i >= 0; i--) {
        var el = list[i];
        var hoverCheckResult = void 0;
        if (el !== exclude
            && !el.ignore
            && (hoverCheckResult = isHover(el, x, y))) {
            !out.topTarget && (out.topTarget = el);
            if (hoverCheckResult !== SILENT) {
                out.target = el;
                break;
            }
        }
    }
}
function isOutsideBoundary(handlerInstance, x, y) {
    var painter = handlerInstance.painter;
    return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
}
var Handler$1 = Handler;

var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
function minRunLength(n) {
    var r = 0;
    while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
    }
    return n + r;
}
function makeAscendingRun(array, lo, hi, compare) {
    var runHi = lo + 1;
    if (runHi === hi) {
        return 1;
    }
    if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
            runHi++;
        }
        reverseRun(array, lo, runHi);
    }
    else {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
            runHi++;
        }
    }
    return runHi - lo;
}
function reverseRun(array, lo, hi) {
    hi--;
    while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
    }
}
function binaryInsertionSort(array, lo, hi, start, compare) {
    if (start === lo) {
        start++;
    }
    for (; start < hi; start++) {
        var pivot = array[start];
        var left = lo;
        var right = start;
        var mid;
        while (left < right) {
            mid = left + right >>> 1;
            if (compare(pivot, array[mid]) < 0) {
                right = mid;
            }
            else {
                left = mid + 1;
            }
        }
        var n = start - left;
        switch (n) {
            case 3:
                array[left + 3] = array[left + 2];
            case 2:
                array[left + 2] = array[left + 1];
            case 1:
                array[left + 1] = array[left];
                break;
            default:
                while (n > 0) {
                    array[left + n] = array[left + n - 1];
                    n--;
                }
        }
        array[left] = pivot;
    }
}
function gallopLeft(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;
    if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;
            if (offset <= 0) {
                offset = maxOffset;
            }
        }
        if (offset > maxOffset) {
            offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
    }
    else {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;
            if (offset <= 0) {
                offset = maxOffset;
            }
        }
        if (offset > maxOffset) {
            offset = maxOffset;
        }
        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
    }
    lastOffset++;
    while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        if (compare(value, array[start + m]) > 0) {
            lastOffset = m + 1;
        }
        else {
            offset = m;
        }
    }
    return offset;
}
function gallopRight(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;
    if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;
            if (offset <= 0) {
                offset = maxOffset;
            }
        }
        if (offset > maxOffset) {
            offset = maxOffset;
        }
        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
    }
    else {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;
            if (offset <= 0) {
                offset = maxOffset;
            }
        }
        if (offset > maxOffset) {
            offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
    }
    lastOffset++;
    while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        if (compare(value, array[start + m]) < 0) {
            offset = m;
        }
        else {
            lastOffset = m + 1;
        }
    }
    return offset;
}
function TimSort(array, compare) {
    var minGallop = DEFAULT_MIN_GALLOPING;
    var runStart;
    var runLength;
    var stackSize = 0;
    array.length;
    var tmp = [];
    runStart = [];
    runLength = [];
    function pushRun(_runStart, _runLength) {
        runStart[stackSize] = _runStart;
        runLength[stackSize] = _runLength;
        stackSize += 1;
    }
    function mergeRuns() {
        while (stackSize > 1) {
            var n = stackSize - 2;
            if ((n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1])
                || (n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1])) {
                if (runLength[n - 1] < runLength[n + 1]) {
                    n--;
                }
            }
            else if (runLength[n] > runLength[n + 1]) {
                break;
            }
            mergeAt(n);
        }
    }
    function forceMergeRuns() {
        while (stackSize > 1) {
            var n = stackSize - 2;
            if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
                n--;
            }
            mergeAt(n);
        }
    }
    function mergeAt(i) {
        var start1 = runStart[i];
        var length1 = runLength[i];
        var start2 = runStart[i + 1];
        var length2 = runLength[i + 1];
        runLength[i] = length1 + length2;
        if (i === stackSize - 3) {
            runStart[i + 1] = runStart[i + 2];
            runLength[i + 1] = runLength[i + 2];
        }
        stackSize--;
        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;
        if (length1 === 0) {
            return;
        }
        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
        if (length2 === 0) {
            return;
        }
        if (length1 <= length2) {
            mergeLow(start1, length1, start2, length2);
        }
        else {
            mergeHigh(start1, length1, start2, length2);
        }
    }
    function mergeLow(start1, length1, start2, length2) {
        var i = 0;
        for (i = 0; i < length1; i++) {
            tmp[i] = array[start1 + i];
        }
        var cursor1 = 0;
        var cursor2 = start2;
        var dest = start1;
        array[dest++] = array[cursor2++];
        if (--length2 === 0) {
            for (i = 0; i < length1; i++) {
                array[dest + i] = tmp[cursor1 + i];
            }
            return;
        }
        if (length1 === 1) {
            for (i = 0; i < length2; i++) {
                array[dest + i] = array[cursor2 + i];
            }
            array[dest + length2] = tmp[cursor1];
            return;
        }
        var _minGallop = minGallop;
        var count1;
        var count2;
        var exit;
        while (1) {
            count1 = 0;
            count2 = 0;
            exit = false;
            do {
                if (compare(array[cursor2], tmp[cursor1]) < 0) {
                    array[dest++] = array[cursor2++];
                    count2++;
                    count1 = 0;
                    if (--length2 === 0) {
                        exit = true;
                        break;
                    }
                }
                else {
                    array[dest++] = tmp[cursor1++];
                    count1++;
                    count2 = 0;
                    if (--length1 === 1) {
                        exit = true;
                        break;
                    }
                }
            } while ((count1 | count2) < _minGallop);
            if (exit) {
                break;
            }
            do {
                count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
                if (count1 !== 0) {
                    for (i = 0; i < count1; i++) {
                        array[dest + i] = tmp[cursor1 + i];
                    }
                    dest += count1;
                    cursor1 += count1;
                    length1 -= count1;
                    if (length1 <= 1) {
                        exit = true;
                        break;
                    }
                }
                array[dest++] = array[cursor2++];
                if (--length2 === 0) {
                    exit = true;
                    break;
                }
                count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
                if (count2 !== 0) {
                    for (i = 0; i < count2; i++) {
                        array[dest + i] = array[cursor2 + i];
                    }
                    dest += count2;
                    cursor2 += count2;
                    length2 -= count2;
                    if (length2 === 0) {
                        exit = true;
                        break;
                    }
                }
                array[dest++] = tmp[cursor1++];
                if (--length1 === 1) {
                    exit = true;
                    break;
                }
                _minGallop--;
            } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
            if (exit) {
                break;
            }
            if (_minGallop < 0) {
                _minGallop = 0;
            }
            _minGallop += 2;
        }
        minGallop = _minGallop;
        minGallop < 1 && (minGallop = 1);
        if (length1 === 1) {
            for (i = 0; i < length2; i++) {
                array[dest + i] = array[cursor2 + i];
            }
            array[dest + length2] = tmp[cursor1];
        }
        else if (length1 === 0) {
            throw new Error();
        }
        else {
            for (i = 0; i < length1; i++) {
                array[dest + i] = tmp[cursor1 + i];
            }
        }
    }
    function mergeHigh(start1, length1, start2, length2) {
        var i = 0;
        for (i = 0; i < length2; i++) {
            tmp[i] = array[start2 + i];
        }
        var cursor1 = start1 + length1 - 1;
        var cursor2 = length2 - 1;
        var dest = start2 + length2 - 1;
        var customCursor = 0;
        var customDest = 0;
        array[dest--] = array[cursor1--];
        if (--length1 === 0) {
            customCursor = dest - (length2 - 1);
            for (i = 0; i < length2; i++) {
                array[customCursor + i] = tmp[i];
            }
            return;
        }
        if (length2 === 1) {
            dest -= length1;
            cursor1 -= length1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;
            for (i = length1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
            }
            array[dest] = tmp[cursor2];
            return;
        }
        var _minGallop = minGallop;
        while (true) {
            var count1 = 0;
            var count2 = 0;
            var exit = false;
            do {
                if (compare(tmp[cursor2], array[cursor1]) < 0) {
                    array[dest--] = array[cursor1--];
                    count1++;
                    count2 = 0;
                    if (--length1 === 0) {
                        exit = true;
                        break;
                    }
                }
                else {
                    array[dest--] = tmp[cursor2--];
                    count2++;
                    count1 = 0;
                    if (--length2 === 1) {
                        exit = true;
                        break;
                    }
                }
            } while ((count1 | count2) < _minGallop);
            if (exit) {
                break;
            }
            do {
                count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
                if (count1 !== 0) {
                    dest -= count1;
                    cursor1 -= count1;
                    length1 -= count1;
                    customDest = dest + 1;
                    customCursor = cursor1 + 1;
                    for (i = count1 - 1; i >= 0; i--) {
                        array[customDest + i] = array[customCursor + i];
                    }
                    if (length1 === 0) {
                        exit = true;
                        break;
                    }
                }
                array[dest--] = tmp[cursor2--];
                if (--length2 === 1) {
                    exit = true;
                    break;
                }
                count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
                if (count2 !== 0) {
                    dest -= count2;
                    cursor2 -= count2;
                    length2 -= count2;
                    customDest = dest + 1;
                    customCursor = cursor2 + 1;
                    for (i = 0; i < count2; i++) {
                        array[customDest + i] = tmp[customCursor + i];
                    }
                    if (length2 <= 1) {
                        exit = true;
                        break;
                    }
                }
                array[dest--] = array[cursor1--];
                if (--length1 === 0) {
                    exit = true;
                    break;
                }
                _minGallop--;
            } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
            if (exit) {
                break;
            }
            if (_minGallop < 0) {
                _minGallop = 0;
            }
            _minGallop += 2;
        }
        minGallop = _minGallop;
        if (minGallop < 1) {
            minGallop = 1;
        }
        if (length2 === 1) {
            dest -= length1;
            cursor1 -= length1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;
            for (i = length1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
            }
            array[dest] = tmp[cursor2];
        }
        else if (length2 === 0) {
            throw new Error();
        }
        else {
            customCursor = dest - (length2 - 1);
            for (i = 0; i < length2; i++) {
                array[customCursor + i] = tmp[i];
            }
        }
    }
    return {
        mergeRuns: mergeRuns,
        forceMergeRuns: forceMergeRuns,
        pushRun: pushRun
    };
}
function sort(array, compare, lo, hi) {
    if (!lo) {
        lo = 0;
    }
    if (!hi) {
        hi = array.length;
    }
    var remaining = hi - lo;
    if (remaining < 2) {
        return;
    }
    var runLength = 0;
    if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
    }
    var ts = TimSort(array, compare);
    var minRun = minRunLength(remaining);
    do {
        runLength = makeAscendingRun(array, lo, hi, compare);
        if (runLength < minRun) {
            var force = remaining;
            if (force > minRun) {
                force = minRun;
            }
            binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
            runLength = force;
        }
        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
    } while (remaining !== 0);
    ts.forceMergeRuns();
}

var REDRAW_BIT = 1;
var STYLE_CHANGED_BIT = 2;
var SHAPE_CHANGED_BIT = 4;

var invalidZErrorLogged = false;
function logInvalidZError() {
    if (invalidZErrorLogged) {
        return;
    }
    invalidZErrorLogged = true;
    console.warn('z / z2 / zlevel of displayable is invalid, which may cause unexpected errors');
}
function shapeCompareFunc(a, b) {
    if (a.zlevel === b.zlevel) {
        if (a.z === b.z) {
            return a.z2 - b.z2;
        }
        return a.z - b.z;
    }
    return a.zlevel - b.zlevel;
}
var Storage = (function () {
    function Storage() {
        this._roots = [];
        this._displayList = [];
        this._displayListLen = 0;
        this.displayableSortFunc = shapeCompareFunc;
    }
    Storage.prototype.traverse = function (cb, context) {
        for (var i = 0; i < this._roots.length; i++) {
            this._roots[i].traverse(cb, context);
        }
    };
    Storage.prototype.getDisplayList = function (update, includeIgnore) {
        includeIgnore = includeIgnore || false;
        var displayList = this._displayList;
        if (update || !displayList.length) {
            this.updateDisplayList(includeIgnore);
        }
        return displayList;
    };
    Storage.prototype.updateDisplayList = function (includeIgnore) {
        this._displayListLen = 0;
        var roots = this._roots;
        var displayList = this._displayList;
        for (var i = 0, len = roots.length; i < len; i++) {
            this._updateAndAddDisplayable(roots[i], null, includeIgnore);
        }
        displayList.length = this._displayListLen;
        sort(displayList, shapeCompareFunc);
    };
    Storage.prototype._updateAndAddDisplayable = function (el, clipPaths, includeIgnore) {
        if (el.ignore && !includeIgnore) {
            return;
        }
        el.beforeUpdate();
        el.update();
        el.afterUpdate();
        var userSetClipPath = el.getClipPath();
        if (el.ignoreClip) {
            clipPaths = null;
        }
        else if (userSetClipPath) {
            if (clipPaths) {
                clipPaths = clipPaths.slice();
            }
            else {
                clipPaths = [];
            }
            var currentClipPath = userSetClipPath;
            var parentClipPath = el;
            while (currentClipPath) {
                currentClipPath.parent = parentClipPath;
                currentClipPath.updateTransform();
                clipPaths.push(currentClipPath);
                parentClipPath = currentClipPath;
                currentClipPath = currentClipPath.getClipPath();
            }
        }
        if (el.childrenRef) {
            var children = el.childrenRef();
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (el.__dirty) {
                    child.__dirty |= REDRAW_BIT;
                }
                this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
            }
            el.__dirty = 0;
        }
        else {
            var disp = el;
            if (clipPaths && clipPaths.length) {
                disp.__clipPaths = clipPaths;
            }
            else if (disp.__clipPaths && disp.__clipPaths.length > 0) {
                disp.__clipPaths = [];
            }
            if (isNaN(disp.z)) {
                logInvalidZError();
                disp.z = 0;
            }
            if (isNaN(disp.z2)) {
                logInvalidZError();
                disp.z2 = 0;
            }
            if (isNaN(disp.zlevel)) {
                logInvalidZError();
                disp.zlevel = 0;
            }
            this._displayList[this._displayListLen++] = disp;
        }
        var decalEl = el.getDecalElement && el.getDecalElement();
        if (decalEl) {
            this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore);
        }
        var textGuide = el.getTextGuideLine();
        if (textGuide) {
            this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore);
        }
        var textEl = el.getTextContent();
        if (textEl) {
            this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore);
        }
    };
    Storage.prototype.addRoot = function (el) {
        if (el.__zr && el.__zr.storage === this) {
            return;
        }
        this._roots.push(el);
    };
    Storage.prototype.delRoot = function (el) {
        if (el instanceof Array) {
            for (var i = 0, l = el.length; i < l; i++) {
                this.delRoot(el[i]);
            }
            return;
        }
        var idx = indexOf(this._roots, el);
        if (idx >= 0) {
            this._roots.splice(idx, 1);
        }
    };
    Storage.prototype.delAllRoots = function () {
        this._roots = [];
        this._displayList = [];
        this._displayListLen = 0;
        return;
    };
    Storage.prototype.getRoots = function () {
        return this._roots;
    };
    Storage.prototype.dispose = function () {
        this._displayList = null;
        this._roots = null;
    };
    return Storage;
}());
var Storage$1 = Storage;

var requestAnimationFrame$1;
requestAnimationFrame$1 = (env$1.hasGlobalWindow
    && ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))
        || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))
        || window.mozRequestAnimationFrame
        || window.webkitRequestAnimationFrame)) || function (func) {
    return setTimeout(func, 16);
};
var requestAnimationFrame$2 = requestAnimationFrame$1;

var easingFuncs = {
    linear: function (k) {
        return k;
    },
    quadraticIn: function (k) {
        return k * k;
    },
    quadraticOut: function (k) {
        return k * (2 - k);
    },
    quadraticInOut: function (k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k;
        }
        return -0.5 * (--k * (k - 2) - 1);
    },
    cubicIn: function (k) {
        return k * k * k;
    },
    cubicOut: function (k) {
        return --k * k * k + 1;
    },
    cubicInOut: function (k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k + 2);
    },
    quarticIn: function (k) {
        return k * k * k * k;
    },
    quarticOut: function (k) {
        return 1 - (--k * k * k * k);
    },
    quarticInOut: function (k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k * k;
        }
        return -0.5 * ((k -= 2) * k * k * k - 2);
    },
    quinticIn: function (k) {
        return k * k * k * k * k;
    },
    quinticOut: function (k) {
        return --k * k * k * k * k + 1;
    },
    quinticInOut: function (k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k * k * k + 2);
    },
    sinusoidalIn: function (k) {
        return 1 - Math.cos(k * Math.PI / 2);
    },
    sinusoidalOut: function (k) {
        return Math.sin(k * Math.PI / 2);
    },
    sinusoidalInOut: function (k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
    },
    exponentialIn: function (k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
    },
    exponentialOut: function (k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
    },
    exponentialInOut: function (k) {
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if ((k *= 2) < 1) {
            return 0.5 * Math.pow(1024, k - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
    },
    circularIn: function (k) {
        return 1 - Math.sqrt(1 - k * k);
    },
    circularOut: function (k) {
        return Math.sqrt(1 - (--k * k));
    },
    circularInOut: function (k) {
        if ((k *= 2) < 1) {
            return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    },
    elasticIn: function (k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if (!a || a < 1) {
            a = 1;
            s = p / 4;
        }
        else {
            s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return -(a * Math.pow(2, 10 * (k -= 1))
            * Math.sin((k - s) * (2 * Math.PI) / p));
    },
    elasticOut: function (k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if (!a || a < 1) {
            a = 1;
            s = p / 4;
        }
        else {
            s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return (a * Math.pow(2, -10 * k)
            * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
    },
    elasticInOut: function (k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if (!a || a < 1) {
            a = 1;
            s = p / 4;
        }
        else {
            s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        if ((k *= 2) < 1) {
            return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
                * Math.sin((k - s) * (2 * Math.PI) / p));
        }
        return a * Math.pow(2, -10 * (k -= 1))
            * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
    },
    backIn: function (k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
    },
    backOut: function (k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
    },
    backInOut: function (k) {
        var s = 1.70158 * 1.525;
        if ((k *= 2) < 1) {
            return 0.5 * (k * k * ((s + 1) * k - s));
        }
        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    },
    bounceIn: function (k) {
        return 1 - easingFuncs.bounceOut(1 - k);
    },
    bounceOut: function (k) {
        if (k < (1 / 2.75)) {
            return 7.5625 * k * k;
        }
        else if (k < (2 / 2.75)) {
            return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
        }
        else if (k < (2.5 / 2.75)) {
            return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
        }
        else {
            return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
        }
    },
    bounceInOut: function (k) {
        if (k < 0.5) {
            return easingFuncs.bounceIn(k * 2) * 0.5;
        }
        return easingFuncs.bounceOut(k * 2 - 1) * 0.5 + 0.5;
    }
};
var easingFuncs$1 = easingFuncs;

var mathPow$1 = Math.pow;
var mathSqrt$3 = Math.sqrt;
var EPSILON$3 = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt$3(3);
var ONE_THIRD = 1 / 3;
var _v0 = create$1();
var _v1 = create$1();
var _v2 = create$1();
function isAroundZero(val) {
    return val > -EPSILON$3 && val < EPSILON$3;
}
function isNotAroundZero$1(val) {
    return val > EPSILON$3 || val < -EPSILON$3;
}
function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * (onet * p0 + 3 * t * p1)
        + t * t * (t * p3 + 3 * onet * p2);
}
function cubicDerivativeAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
        + (p3 - p2) * t * t);
}
function cubicRootAt(p0, p1, p2, p3, val, roots) {
    var a = p3 + 3 * (p1 - p2) - p0;
    var b = 3 * (p2 - p1 * 2 + p0);
    var c = 3 * (p1 - p0);
    var d = p0 - val;
    var A = b * b - 3 * a * c;
    var B = b * c - 9 * a * d;
    var C = c * c - 3 * b * d;
    var n = 0;
    if (isAroundZero(A) && isAroundZero(B)) {
        if (isAroundZero(b)) {
            roots[0] = 0;
        }
        else {
            var t1 = -c / b;
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
    }
    else {
        var disc = B * B - 4 * A * C;
        if (isAroundZero(disc)) {
            var K = B / A;
            var t1 = -b / a + K;
            var t2 = -K / 2;
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                roots[n++] = t2;
            }
        }
        else if (disc > 0) {
            var discSqrt = mathSqrt$3(disc);
            var Y1 = A * b + 1.5 * a * (-B + discSqrt);
            var Y2 = A * b + 1.5 * a * (-B - discSqrt);
            if (Y1 < 0) {
                Y1 = -mathPow$1(-Y1, ONE_THIRD);
            }
            else {
                Y1 = mathPow$1(Y1, ONE_THIRD);
            }
            if (Y2 < 0) {
                Y2 = -mathPow$1(-Y2, ONE_THIRD);
            }
            else {
                Y2 = mathPow$1(Y2, ONE_THIRD);
            }
            var t1 = (-b - (Y1 + Y2)) / (3 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
        else {
            var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt$3(A * A * A));
            var theta = Math.acos(T) / 3;
            var ASqrt = mathSqrt$3(A);
            var tmp = Math.cos(theta);
            var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
            var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
            var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                roots[n++] = t2;
            }
            if (t3 >= 0 && t3 <= 1) {
                roots[n++] = t3;
            }
        }
    }
    return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema) {
    var b = 6 * p2 - 12 * p1 + 6 * p0;
    var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
    var c = 3 * p1 - 3 * p0;
    var n = 0;
    if (isAroundZero(a)) {
        if (isNotAroundZero$1(b)) {
            var t1 = -c / b;
            if (t1 >= 0 && t1 <= 1) {
                extrema[n++] = t1;
            }
        }
    }
    else {
        var disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
            extrema[0] = -b / (2 * a);
        }
        else if (disc > 0) {
            var discSqrt = mathSqrt$3(disc);
            var t1 = (-b + discSqrt) / (2 * a);
            var t2 = (-b - discSqrt) / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                extrema[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                extrema[n++] = t2;
            }
        }
    }
    return n;
}
function cubicSubdivide(p0, p1, p2, p3, t, out) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p23 = (p3 - p2) * t + p2;
    var p012 = (p12 - p01) * t + p01;
    var p123 = (p23 - p12) * t + p12;
    var p0123 = (p123 - p012) * t + p012;
    out[0] = p0;
    out[1] = p01;
    out[2] = p012;
    out[3] = p0123;
    out[4] = p0123;
    out[5] = p123;
    out[6] = p23;
    out[7] = p3;
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
    var t;
    var interval = 0.005;
    var d = Infinity;
    var prev;
    var next;
    var d1;
    var d2;
    _v0[0] = x;
    _v0[1] = y;
    for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = cubicAt(x0, x1, x2, x3, _t);
        _v1[1] = cubicAt(y0, y1, y2, y3, _t);
        d1 = distSquare(_v0, _v1);
        if (d1 < d) {
            t = _t;
            d = d1;
        }
    }
    d = Infinity;
    for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
            break;
        }
        prev = t - interval;
        next = t + interval;
        _v1[0] = cubicAt(x0, x1, x2, x3, prev);
        _v1[1] = cubicAt(y0, y1, y2, y3, prev);
        d1 = distSquare(_v1, _v0);
        if (prev >= 0 && d1 < d) {
            t = prev;
            d = d1;
        }
        else {
            _v2[0] = cubicAt(x0, x1, x2, x3, next);
            _v2[1] = cubicAt(y0, y1, y2, y3, next);
            d2 = distSquare(_v2, _v0);
            if (next <= 1 && d2 < d) {
                t = next;
                d = d2;
            }
            else {
                interval *= 0.5;
            }
        }
    }
    if (out) {
        out[0] = cubicAt(x0, x1, x2, x3, t);
        out[1] = cubicAt(y0, y1, y2, y3, t);
    }
    return mathSqrt$3(d);
}
function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
    var px = x0;
    var py = y0;
    var d = 0;
    var step = 1 / iteration;
    for (var i = 1; i <= iteration; i++) {
        var t = i * step;
        var x = cubicAt(x0, x1, x2, x3, t);
        var y = cubicAt(y0, y1, y2, y3, t);
        var dx = x - px;
        var dy = y - py;
        d += Math.sqrt(dx * dx + dy * dy);
        px = x;
        py = y;
    }
    return d;
}
function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
function quadraticDerivativeAt(p0, p1, p2, t) {
    return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
}
function quadraticRootAt(p0, p1, p2, val, roots) {
    var a = p0 - 2 * p1 + p2;
    var b = 2 * (p1 - p0);
    var c = p0 - val;
    var n = 0;
    if (isAroundZero(a)) {
        if (isNotAroundZero$1(b)) {
            var t1 = -c / b;
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
    }
    else {
        var disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
            var t1 = -b / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
        else if (disc > 0) {
            var discSqrt = mathSqrt$3(disc);
            var t1 = (-b + discSqrt) / (2 * a);
            var t2 = (-b - discSqrt) / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                roots[n++] = t2;
            }
        }
    }
    return n;
}
function quadraticExtremum(p0, p1, p2) {
    var divider = p0 + p2 - 2 * p1;
    if (divider === 0) {
        return 0.5;
    }
    else {
        return (p0 - p1) / divider;
    }
}
function quadraticSubdivide(p0, p1, p2, t, out) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p012 = (p12 - p01) * t + p01;
    out[0] = p0;
    out[1] = p01;
    out[2] = p012;
    out[3] = p012;
    out[4] = p12;
    out[5] = p2;
}
function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
    var t;
    var interval = 0.005;
    var d = Infinity;
    _v0[0] = x;
    _v0[1] = y;
    for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = quadraticAt(x0, x1, x2, _t);
        _v1[1] = quadraticAt(y0, y1, y2, _t);
        var d1 = distSquare(_v0, _v1);
        if (d1 < d) {
            t = _t;
            d = d1;
        }
    }
    d = Infinity;
    for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
            break;
        }
        var prev = t - interval;
        var next = t + interval;
        _v1[0] = quadraticAt(x0, x1, x2, prev);
        _v1[1] = quadraticAt(y0, y1, y2, prev);
        var d1 = distSquare(_v1, _v0);
        if (prev >= 0 && d1 < d) {
            t = prev;
            d = d1;
        }
        else {
            _v2[0] = quadraticAt(x0, x1, x2, next);
            _v2[1] = quadraticAt(y0, y1, y2, next);
            var d2 = distSquare(_v2, _v0);
            if (next <= 1 && d2 < d) {
                t = next;
                d = d2;
            }
            else {
                interval *= 0.5;
            }
        }
    }
    if (out) {
        out[0] = quadraticAt(x0, x1, x2, t);
        out[1] = quadraticAt(y0, y1, y2, t);
    }
    return mathSqrt$3(d);
}
function quadraticLength(x0, y0, x1, y1, x2, y2, iteration) {
    var px = x0;
    var py = y0;
    var d = 0;
    var step = 1 / iteration;
    for (var i = 1; i <= iteration; i++) {
        var t = i * step;
        var x = quadraticAt(x0, x1, x2, t);
        var y = quadraticAt(y0, y1, y2, t);
        var dx = x - px;
        var dy = y - py;
        d += Math.sqrt(dx * dx + dy * dy);
        px = x;
        py = y;
    }
    return d;
}

var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
function createCubicEasingFunc(cubicEasingStr) {
    var cubic = cubicEasingStr && regexp.exec(cubicEasingStr);
    if (cubic) {
        var points = cubic[1].split(',');
        var a_1 = +trim(points[0]);
        var b_1 = +trim(points[1]);
        var c_1 = +trim(points[2]);
        var d_1 = +trim(points[3]);
        if (isNaN(a_1 + b_1 + c_1 + d_1)) {
            return;
        }
        var roots_1 = [];
        return function (p) {
            return p <= 0
                ? 0 : p >= 1
                ? 1
                : cubicRootAt(0, a_1, c_1, 1, p, roots_1) && cubicAt(0, b_1, d_1, 1, roots_1[0]);
        };
    }
}

var Clip = (function () {
    function Clip(opts) {
        this._inited = false;
        this._startTime = 0;
        this._pausedTime = 0;
        this._paused = false;
        this._life = opts.life || 1000;
        this._delay = opts.delay || 0;
        this.loop = opts.loop || false;
        this.onframe = opts.onframe || noop$1;
        this.ondestroy = opts.ondestroy || noop$1;
        this.onrestart = opts.onrestart || noop$1;
        opts.easing && this.setEasing(opts.easing);
    }
    Clip.prototype.step = function (globalTime, deltaTime) {
        if (!this._inited) {
            this._startTime = globalTime + this._delay;
            this._inited = true;
        }
        if (this._paused) {
            this._pausedTime += deltaTime;
            return;
        }
        var life = this._life;
        var elapsedTime = globalTime - this._startTime - this._pausedTime;
        var percent = elapsedTime / life;
        if (percent < 0) {
            percent = 0;
        }
        percent = Math.min(percent, 1);
        var easingFunc = this.easingFunc;
        var schedule = easingFunc ? easingFunc(percent) : percent;
        this.onframe(schedule);
        if (percent === 1) {
            if (this.loop) {
                var remainder = elapsedTime % life;
                this._startTime = globalTime - remainder;
                this._pausedTime = 0;
                this.onrestart();
            }
            else {
                return true;
            }
        }
        return false;
    };
    Clip.prototype.pause = function () {
        this._paused = true;
    };
    Clip.prototype.resume = function () {
        this._paused = false;
    };
    Clip.prototype.setEasing = function (easing) {
        this.easing = easing;
        this.easingFunc = isFunction(easing)
            ? easing
            : easingFuncs$1[easing] || createCubicEasingFunc(easing);
    };
    return Clip;
}());
var Clip$1 = Clip;

var Entry = (function () {
    function Entry(val) {
        this.value = val;
    }
    return Entry;
}());
var LinkedList = (function () {
    function LinkedList() {
        this._len = 0;
    }
    LinkedList.prototype.insert = function (val) {
        var entry = new Entry(val);
        this.insertEntry(entry);
        return entry;
    };
    LinkedList.prototype.insertEntry = function (entry) {
        if (!this.head) {
            this.head = this.tail = entry;
        }
        else {
            this.tail.next = entry;
            entry.prev = this.tail;
            entry.next = null;
            this.tail = entry;
        }
        this._len++;
    };
    LinkedList.prototype.remove = function (entry) {
        var prev = entry.prev;
        var next = entry.next;
        if (prev) {
            prev.next = next;
        }
        else {
            this.head = next;
        }
        if (next) {
            next.prev = prev;
        }
        else {
            this.tail = prev;
        }
        entry.next = entry.prev = null;
        this._len--;
    };
    LinkedList.prototype.len = function () {
        return this._len;
    };
    LinkedList.prototype.clear = function () {
        this.head = this.tail = null;
        this._len = 0;
    };
    return LinkedList;
}());
var LRU = (function () {
    function LRU(maxSize) {
        this._list = new LinkedList();
        this._maxSize = 10;
        this._map = {};
        this._maxSize = maxSize;
    }
    LRU.prototype.put = function (key, value) {
        var list = this._list;
        var map = this._map;
        var removed = null;
        if (map[key] == null) {
            var len = list.len();
            var entry = this._lastRemovedEntry;
            if (len >= this._maxSize && len > 0) {
                var leastUsedEntry = list.head;
                list.remove(leastUsedEntry);
                delete map[leastUsedEntry.key];
                removed = leastUsedEntry.value;
                this._lastRemovedEntry = leastUsedEntry;
            }
            if (entry) {
                entry.value = value;
            }
            else {
                entry = new Entry(value);
            }
            entry.key = key;
            list.insertEntry(entry);
            map[key] = entry;
        }
        return removed;
    };
    LRU.prototype.get = function (key) {
        var entry = this._map[key];
        var list = this._list;
        if (entry != null) {
            if (entry !== list.tail) {
                list.remove(entry);
                list.insertEntry(entry);
            }
            return entry.value;
        }
    };
    LRU.prototype.clear = function () {
        this._list.clear();
        this._map = {};
    };
    LRU.prototype.len = function () {
        return this._list.len();
    };
    return LRU;
}());
var LRU$1 = LRU;

var kCSSColorTable = {
    'transparent': [0, 0, 0, 0], 'aliceblue': [240, 248, 255, 1],
    'antiquewhite': [250, 235, 215, 1], 'aqua': [0, 255, 255, 1],
    'aquamarine': [127, 255, 212, 1], 'azure': [240, 255, 255, 1],
    'beige': [245, 245, 220, 1], 'bisque': [255, 228, 196, 1],
    'black': [0, 0, 0, 1], 'blanchedalmond': [255, 235, 205, 1],
    'blue': [0, 0, 255, 1], 'blueviolet': [138, 43, 226, 1],
    'brown': [165, 42, 42, 1], 'burlywood': [222, 184, 135, 1],
    'cadetblue': [95, 158, 160, 1], 'chartreuse': [127, 255, 0, 1],
    'chocolate': [210, 105, 30, 1], 'coral': [255, 127, 80, 1],
    'cornflowerblue': [100, 149, 237, 1], 'cornsilk': [255, 248, 220, 1],
    'crimson': [220, 20, 60, 1], 'cyan': [0, 255, 255, 1],
    'darkblue': [0, 0, 139, 1], 'darkcyan': [0, 139, 139, 1],
    'darkgoldenrod': [184, 134, 11, 1], 'darkgray': [169, 169, 169, 1],
    'darkgreen': [0, 100, 0, 1], 'darkgrey': [169, 169, 169, 1],
    'darkkhaki': [189, 183, 107, 1], 'darkmagenta': [139, 0, 139, 1],
    'darkolivegreen': [85, 107, 47, 1], 'darkorange': [255, 140, 0, 1],
    'darkorchid': [153, 50, 204, 1], 'darkred': [139, 0, 0, 1],
    'darksalmon': [233, 150, 122, 1], 'darkseagreen': [143, 188, 143, 1],
    'darkslateblue': [72, 61, 139, 1], 'darkslategray': [47, 79, 79, 1],
    'darkslategrey': [47, 79, 79, 1], 'darkturquoise': [0, 206, 209, 1],
    'darkviolet': [148, 0, 211, 1], 'deeppink': [255, 20, 147, 1],
    'deepskyblue': [0, 191, 255, 1], 'dimgray': [105, 105, 105, 1],
    'dimgrey': [105, 105, 105, 1], 'dodgerblue': [30, 144, 255, 1],
    'firebrick': [178, 34, 34, 1], 'floralwhite': [255, 250, 240, 1],
    'forestgreen': [34, 139, 34, 1], 'fuchsia': [255, 0, 255, 1],
    'gainsboro': [220, 220, 220, 1], 'ghostwhite': [248, 248, 255, 1],
    'gold': [255, 215, 0, 1], 'goldenrod': [218, 165, 32, 1],
    'gray': [128, 128, 128, 1], 'green': [0, 128, 0, 1],
    'greenyellow': [173, 255, 47, 1], 'grey': [128, 128, 128, 1],
    'honeydew': [240, 255, 240, 1], 'hotpink': [255, 105, 180, 1],
    'indianred': [205, 92, 92, 1], 'indigo': [75, 0, 130, 1],
    'ivory': [255, 255, 240, 1], 'khaki': [240, 230, 140, 1],
    'lavender': [230, 230, 250, 1], 'lavenderblush': [255, 240, 245, 1],
    'lawngreen': [124, 252, 0, 1], 'lemonchiffon': [255, 250, 205, 1],
    'lightblue': [173, 216, 230, 1], 'lightcoral': [240, 128, 128, 1],
    'lightcyan': [224, 255, 255, 1], 'lightgoldenrodyellow': [250, 250, 210, 1],
    'lightgray': [211, 211, 211, 1], 'lightgreen': [144, 238, 144, 1],
    'lightgrey': [211, 211, 211, 1], 'lightpink': [255, 182, 193, 1],
    'lightsalmon': [255, 160, 122, 1], 'lightseagreen': [32, 178, 170, 1],
    'lightskyblue': [135, 206, 250, 1], 'lightslategray': [119, 136, 153, 1],
    'lightslategrey': [119, 136, 153, 1], 'lightsteelblue': [176, 196, 222, 1],
    'lightyellow': [255, 255, 224, 1], 'lime': [0, 255, 0, 1],
    'limegreen': [50, 205, 50, 1], 'linen': [250, 240, 230, 1],
    'magenta': [255, 0, 255, 1], 'maroon': [128, 0, 0, 1],
    'mediumaquamarine': [102, 205, 170, 1], 'mediumblue': [0, 0, 205, 1],
    'mediumorchid': [186, 85, 211, 1], 'mediumpurple': [147, 112, 219, 1],
    'mediumseagreen': [60, 179, 113, 1], 'mediumslateblue': [123, 104, 238, 1],
    'mediumspringgreen': [0, 250, 154, 1], 'mediumturquoise': [72, 209, 204, 1],
    'mediumvioletred': [199, 21, 133, 1], 'midnightblue': [25, 25, 112, 1],
    'mintcream': [245, 255, 250, 1], 'mistyrose': [255, 228, 225, 1],
    'moccasin': [255, 228, 181, 1], 'navajowhite': [255, 222, 173, 1],
    'navy': [0, 0, 128, 1], 'oldlace': [253, 245, 230, 1],
    'olive': [128, 128, 0, 1], 'olivedrab': [107, 142, 35, 1],
    'orange': [255, 165, 0, 1], 'orangered': [255, 69, 0, 1],
    'orchid': [218, 112, 214, 1], 'palegoldenrod': [238, 232, 170, 1],
    'palegreen': [152, 251, 152, 1], 'paleturquoise': [175, 238, 238, 1],
    'palevioletred': [219, 112, 147, 1], 'papayawhip': [255, 239, 213, 1],
    'peachpuff': [255, 218, 185, 1], 'peru': [205, 133, 63, 1],
    'pink': [255, 192, 203, 1], 'plum': [221, 160, 221, 1],
    'powderblue': [176, 224, 230, 1], 'purple': [128, 0, 128, 1],
    'red': [255, 0, 0, 1], 'rosybrown': [188, 143, 143, 1],
    'royalblue': [65, 105, 225, 1], 'saddlebrown': [139, 69, 19, 1],
    'salmon': [250, 128, 114, 1], 'sandybrown': [244, 164, 96, 1],
    'seagreen': [46, 139, 87, 1], 'seashell': [255, 245, 238, 1],
    'sienna': [160, 82, 45, 1], 'silver': [192, 192, 192, 1],
    'skyblue': [135, 206, 235, 1], 'slateblue': [106, 90, 205, 1],
    'slategray': [112, 128, 144, 1], 'slategrey': [112, 128, 144, 1],
    'snow': [255, 250, 250, 1], 'springgreen': [0, 255, 127, 1],
    'steelblue': [70, 130, 180, 1], 'tan': [210, 180, 140, 1],
    'teal': [0, 128, 128, 1], 'thistle': [216, 191, 216, 1],
    'tomato': [255, 99, 71, 1], 'turquoise': [64, 224, 208, 1],
    'violet': [238, 130, 238, 1], 'wheat': [245, 222, 179, 1],
    'white': [255, 255, 255, 1], 'whitesmoke': [245, 245, 245, 1],
    'yellow': [255, 255, 0, 1], 'yellowgreen': [154, 205, 50, 1]
};
function clampCssByte(i) {
    i = Math.round(i);
    return i < 0 ? 0 : i > 255 ? 255 : i;
}
function clampCssAngle(i) {
    i = Math.round(i);
    return i < 0 ? 0 : i > 360 ? 360 : i;
}
function clampCssFloat(f) {
    return f < 0 ? 0 : f > 1 ? 1 : f;
}
function parseCssInt(val) {
    var str = val;
    if (str.length && str.charAt(str.length - 1) === '%') {
        return clampCssByte(parseFloat(str) / 100 * 255);
    }
    return clampCssByte(parseInt(str, 10));
}
function parseCssFloat(val) {
    var str = val;
    if (str.length && str.charAt(str.length - 1) === '%') {
        return clampCssFloat(parseFloat(str) / 100);
    }
    return clampCssFloat(parseFloat(str));
}
function cssHueToRgb(m1, m2, h) {
    if (h < 0) {
        h += 1;
    }
    else if (h > 1) {
        h -= 1;
    }
    if (h * 6 < 1) {
        return m1 + (m2 - m1) * h * 6;
    }
    if (h * 2 < 1) {
        return m2;
    }
    if (h * 3 < 2) {
        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }
    return m1;
}
function lerpNumber(a, b, p) {
    return a + (b - a) * p;
}
function setRgba(out, r, g, b, a) {
    out[0] = r;
    out[1] = g;
    out[2] = b;
    out[3] = a;
    return out;
}
function copyRgba(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
var colorCache = new LRU$1(20);
var lastRemovedArr = null;
function putToCache(colorStr, rgbaArr) {
    if (lastRemovedArr) {
        copyRgba(lastRemovedArr, rgbaArr);
    }
    lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));
}
function parse(colorStr, rgbaArr) {
    if (!colorStr) {
        return;
    }
    rgbaArr = rgbaArr || [];
    var cached = colorCache.get(colorStr);
    if (cached) {
        return copyRgba(rgbaArr, cached);
    }
    colorStr = colorStr + '';
    var str = colorStr.replace(/ /g, '').toLowerCase();
    if (str in kCSSColorTable) {
        copyRgba(rgbaArr, kCSSColorTable[str]);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
    }
    var strLen = str.length;
    if (str.charAt(0) === '#') {
        if (strLen === 4 || strLen === 5) {
            var iv = parseInt(str.slice(1, 4), 16);
            if (!(iv >= 0 && iv <= 0xfff)) {
                setRgba(rgbaArr, 0, 0, 0, 1);
                return;
            }
            setRgba(rgbaArr, ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8), (iv & 0xf0) | ((iv & 0xf0) >> 4), (iv & 0xf) | ((iv & 0xf) << 4), strLen === 5 ? parseInt(str.slice(4), 16) / 0xf : 1);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
        }
        else if (strLen === 7 || strLen === 9) {
            var iv = parseInt(str.slice(1, 7), 16);
            if (!(iv >= 0 && iv <= 0xffffff)) {
                setRgba(rgbaArr, 0, 0, 0, 1);
                return;
            }
            setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, strLen === 9 ? parseInt(str.slice(7), 16) / 0xff : 1);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
        }
        return;
    }
    var op = str.indexOf('(');
    var ep = str.indexOf(')');
    if (op !== -1 && ep + 1 === strLen) {
        var fname = str.substr(0, op);
        var params = str.substr(op + 1, ep - (op + 1)).split(',');
        var alpha = 1;
        switch (fname) {
            case 'rgba':
                if (params.length !== 4) {
                    return params.length === 3
                        ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1)
                        : setRgba(rgbaArr, 0, 0, 0, 1);
                }
                alpha = parseCssFloat(params.pop());
            case 'rgb':
                if (params.length >= 3) {
                    setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), params.length === 3 ? alpha : parseCssFloat(params[3]));
                    putToCache(colorStr, rgbaArr);
                    return rgbaArr;
                }
                else {
                    setRgba(rgbaArr, 0, 0, 0, 1);
                    return;
                }
            case 'hsla':
                if (params.length !== 4) {
                    setRgba(rgbaArr, 0, 0, 0, 1);
                    return;
                }
                params[3] = parseCssFloat(params[3]);
                hsla2rgba(params, rgbaArr);
                putToCache(colorStr, rgbaArr);
                return rgbaArr;
            case 'hsl':
                if (params.length !== 3) {
                    setRgba(rgbaArr, 0, 0, 0, 1);
                    return;
                }
                hsla2rgba(params, rgbaArr);
                putToCache(colorStr, rgbaArr);
                return rgbaArr;
            default:
                return;
        }
    }
    setRgba(rgbaArr, 0, 0, 0, 1);
    return;
}
function hsla2rgba(hsla, rgba) {
    var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;
    var s = parseCssFloat(hsla[1]);
    var l = parseCssFloat(hsla[2]);
    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
    var m1 = l * 2 - m2;
    rgba = rgba || [];
    setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
    if (hsla.length === 4) {
        rgba[3] = hsla[3];
    }
    return rgba;
}
function rgba2hsla(rgba) {
    if (!rgba) {
        return;
    }
    var R = rgba[0] / 255;
    var G = rgba[1] / 255;
    var B = rgba[2] / 255;
    var vMin = Math.min(R, G, B);
    var vMax = Math.max(R, G, B);
    var delta = vMax - vMin;
    var L = (vMax + vMin) / 2;
    var H;
    var S;
    if (delta === 0) {
        H = 0;
        S = 0;
    }
    else {
        if (L < 0.5) {
            S = delta / (vMax + vMin);
        }
        else {
            S = delta / (2 - vMax - vMin);
        }
        var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
        var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
        var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;
        if (R === vMax) {
            H = deltaB - deltaG;
        }
        else if (G === vMax) {
            H = (1 / 3) + deltaR - deltaB;
        }
        else if (B === vMax) {
            H = (2 / 3) + deltaG - deltaR;
        }
        if (H < 0) {
            H += 1;
        }
        if (H > 1) {
            H -= 1;
        }
    }
    var hsla = [H * 360, S, L];
    if (rgba[3] != null) {
        hsla.push(rgba[3]);
    }
    return hsla;
}
function lift(color, level) {
    var colorArr = parse(color);
    if (colorArr) {
        for (var i = 0; i < 3; i++) {
            if (level < 0) {
                colorArr[i] = colorArr[i] * (1 - level) | 0;
            }
            else {
                colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;
            }
            if (colorArr[i] > 255) {
                colorArr[i] = 255;
            }
            else if (colorArr[i] < 0) {
                colorArr[i] = 0;
            }
        }
        return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
    }
}
function toHex(color) {
    var colorArr = parse(color);
    if (colorArr) {
        return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);
    }
}
function fastLerp(normalizedValue, colors, out) {
    if (!(colors && colors.length)
        || !(normalizedValue >= 0 && normalizedValue <= 1)) {
        return;
    }
    out = out || [];
    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = colors[leftIndex];
    var rightColor = colors[rightIndex];
    var dv = value - leftIndex;
    out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
    out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
    out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
    out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
    return out;
}
var fastMapToColor = fastLerp;
function lerp(normalizedValue, colors, fullOutput) {
    if (!(colors && colors.length)
        || !(normalizedValue >= 0 && normalizedValue <= 1)) {
        return;
    }
    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = parse(colors[leftIndex]);
    var rightColor = parse(colors[rightIndex]);
    var dv = value - leftIndex;
    var color = stringify([
        clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
        clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
        clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
        clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
    ], 'rgba');
    return fullOutput
        ? {
            color: color,
            leftIndex: leftIndex,
            rightIndex: rightIndex,
            value: value
        }
        : color;
}
var mapToColor = lerp;
function modifyHSL(color, h, s, l) {
    var colorArr = parse(color);
    if (color) {
        colorArr = rgba2hsla(colorArr);
        h != null && (colorArr[0] = clampCssAngle(h));
        s != null && (colorArr[1] = parseCssFloat(s));
        l != null && (colorArr[2] = parseCssFloat(l));
        return stringify(hsla2rgba(colorArr), 'rgba');
    }
}
function modifyAlpha(color, alpha) {
    var colorArr = parse(color);
    if (colorArr && alpha != null) {
        colorArr[3] = clampCssFloat(alpha);
        return stringify(colorArr, 'rgba');
    }
}
function stringify(arrColor, type) {
    if (!arrColor || !arrColor.length) {
        return;
    }
    var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
    if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
        colorStr += ',' + arrColor[3];
    }
    return type + '(' + colorStr + ')';
}
function lum(color, backgroundLum) {
    var arr = parse(color);
    return arr
        ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255
            + (1 - arr[3]) * backgroundLum
        : 0;
}
function random() {
    return stringify([
        Math.round(Math.random() * 255),
        Math.round(Math.random() * 255),
        Math.round(Math.random() * 255)
    ], 'rgb');
}

var color = /*#__PURE__*/Object.freeze({
  __proto__: null,
  parse: parse,
  lift: lift,
  toHex: toHex,
  fastLerp: fastLerp,
  fastMapToColor: fastMapToColor,
  lerp: lerp,
  mapToColor: mapToColor,
  modifyHSL: modifyHSL,
  modifyAlpha: modifyAlpha,
  stringify: stringify,
  lum: lum,
  random: random
});

function isLinearGradient(val) {
    return val.type === 'linear';
}
function isRadialGradient(val) {
    return val.type === 'radial';
}
((function () {
    if (env$1.hasGlobalWindow && isFunction(window.btoa)) {
        return function (str) {
            return window.btoa(unescape(str));
        };
    }
    if (typeof Buffer !== 'undefined') {
        return function (str) {
            return Buffer.from(str).toString('base64');
        };
    }
    return function (str) {
        if (process.env.NODE_ENV !== 'production') {
            logError('Base64 isn\'t natively supported in the current environment.');
        }
        return null;
    };
}))();

var arraySlice = Array.prototype.slice;
function interpolateNumber$1(p0, p1, percent) {
    return (p1 - p0) * percent + p0;
}
function interpolate1DArray(out, p0, p1, percent) {
    var len = p0.length;
    for (var i = 0; i < len; i++) {
        out[i] = interpolateNumber$1(p0[i], p1[i], percent);
    }
    return out;
}
function interpolate2DArray(out, p0, p1, percent) {
    var len = p0.length;
    var len2 = len && p0[0].length;
    for (var i = 0; i < len; i++) {
        if (!out[i]) {
            out[i] = [];
        }
        for (var j = 0; j < len2; j++) {
            out[i][j] = interpolateNumber$1(p0[i][j], p1[i][j], percent);
        }
    }
    return out;
}
function add1DArray(out, p0, p1, sign) {
    var len = p0.length;
    for (var i = 0; i < len; i++) {
        out[i] = p0[i] + p1[i] * sign;
    }
    return out;
}
function add2DArray(out, p0, p1, sign) {
    var len = p0.length;
    var len2 = len && p0[0].length;
    for (var i = 0; i < len; i++) {
        if (!out[i]) {
            out[i] = [];
        }
        for (var j = 0; j < len2; j++) {
            out[i][j] = p0[i][j] + p1[i][j] * sign;
        }
    }
    return out;
}
function fillColorStops(val0, val1) {
    var len0 = val0.length;
    var len1 = val1.length;
    var shorterArr = len0 > len1 ? val1 : val0;
    var shorterLen = Math.min(len0, len1);
    var last = shorterArr[shorterLen - 1] || { color: [0, 0, 0, 0], offset: 0 };
    for (var i = shorterLen; i < Math.max(len0, len1); i++) {
        shorterArr.push({
            offset: last.offset,
            color: last.color.slice()
        });
    }
}
function fillArray(val0, val1, arrDim) {
    var arr0 = val0;
    var arr1 = val1;
    if (!arr0.push || !arr1.push) {
        return;
    }
    var arr0Len = arr0.length;
    var arr1Len = arr1.length;
    if (arr0Len !== arr1Len) {
        var isPreviousLarger = arr0Len > arr1Len;
        if (isPreviousLarger) {
            arr0.length = arr1Len;
        }
        else {
            for (var i = arr0Len; i < arr1Len; i++) {
                arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
            }
        }
    }
    var len2 = arr0[0] && arr0[0].length;
    for (var i = 0; i < arr0.length; i++) {
        if (arrDim === 1) {
            if (isNaN(arr0[i])) {
                arr0[i] = arr1[i];
            }
        }
        else {
            for (var j = 0; j < len2; j++) {
                if (isNaN(arr0[i][j])) {
                    arr0[i][j] = arr1[i][j];
                }
            }
        }
    }
}
function cloneValue(value) {
    if (isArrayLike(value)) {
        var len = value.length;
        if (isArrayLike(value[0])) {
            var ret = [];
            for (var i = 0; i < len; i++) {
                ret.push(arraySlice.call(value[i]));
            }
            return ret;
        }
        return arraySlice.call(value);
    }
    return value;
}
function rgba2String(rgba) {
    rgba[0] = Math.floor(rgba[0]) || 0;
    rgba[1] = Math.floor(rgba[1]) || 0;
    rgba[2] = Math.floor(rgba[2]) || 0;
    rgba[3] = rgba[3] == null ? 1 : rgba[3];
    return 'rgba(' + rgba.join(',') + ')';
}
function guessArrayDim(value) {
    return isArrayLike(value && value[0]) ? 2 : 1;
}
var VALUE_TYPE_NUMBER = 0;
var VALUE_TYPE_1D_ARRAY = 1;
var VALUE_TYPE_2D_ARRAY = 2;
var VALUE_TYPE_COLOR = 3;
var VALUE_TYPE_LINEAR_GRADIENT = 4;
var VALUE_TYPE_RADIAL_GRADIENT = 5;
var VALUE_TYPE_UNKOWN = 6;
function isGradientValueType(valType) {
    return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;
}
function isArrayValueType(valType) {
    return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;
}
var tmpRgba = [0, 0, 0, 0];
var Track = (function () {
    function Track(propName) {
        this.keyframes = [];
        this.discrete = false;
        this._invalid = false;
        this._needsSort = false;
        this._lastFr = 0;
        this._lastFrP = 0;
        this.propName = propName;
    }
    Track.prototype.isFinished = function () {
        return this._finished;
    };
    Track.prototype.setFinished = function () {
        this._finished = true;
        if (this._additiveTrack) {
            this._additiveTrack.setFinished();
        }
    };
    Track.prototype.needsAnimate = function () {
        return this.keyframes.length >= 1;
    };
    Track.prototype.getAdditiveTrack = function () {
        return this._additiveTrack;
    };
    Track.prototype.addKeyframe = function (time, rawValue, easing) {
        this._needsSort = true;
        var keyframes = this.keyframes;
        var len = keyframes.length;
        var discrete = false;
        var valType = VALUE_TYPE_UNKOWN;
        var value = rawValue;
        if (isArrayLike(rawValue)) {
            var arrayDim = guessArrayDim(rawValue);
            valType = arrayDim;
            if (arrayDim === 1 && !isNumber(rawValue[0])
                || arrayDim === 2 && !isNumber(rawValue[0][0])) {
                discrete = true;
            }
        }
        else {
            if (isNumber(rawValue) && !eqNaN(rawValue)) {
                valType = VALUE_TYPE_NUMBER;
            }
            else if (isString(rawValue)) {
                if (!isNaN(+rawValue)) {
                    valType = VALUE_TYPE_NUMBER;
                }
                else {
                    var colorArray = parse(rawValue);
                    if (colorArray) {
                        value = colorArray;
                        valType = VALUE_TYPE_COLOR;
                    }
                }
            }
            else if (isGradientObject(rawValue)) {
                var parsedGradient = extend$2({}, value);
                parsedGradient.colorStops = map$1(rawValue.colorStops, function (colorStop) { return ({
                    offset: colorStop.offset,
                    color: parse(colorStop.color)
                }); });
                if (isLinearGradient(rawValue)) {
                    valType = VALUE_TYPE_LINEAR_GRADIENT;
                }
                else if (isRadialGradient(rawValue)) {
                    valType = VALUE_TYPE_RADIAL_GRADIENT;
                }
                value = parsedGradient;
            }
        }
        if (len === 0) {
            this.valType = valType;
        }
        else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {
            discrete = true;
        }
        this.discrete = this.discrete || discrete;
        var kf = {
            time: time,
            value: value,
            rawValue: rawValue,
            percent: 0
        };
        if (easing) {
            kf.easing = easing;
            kf.easingFunc = isFunction(easing)
                ? easing
                : easingFuncs$1[easing] || createCubicEasingFunc(easing);
        }
        keyframes.push(kf);
        return kf;
    };
    Track.prototype.prepare = function (maxTime, additiveTrack) {
        var kfs = this.keyframes;
        if (this._needsSort) {
            kfs.sort(function (a, b) {
                return a.time - b.time;
            });
        }
        var valType = this.valType;
        var kfsLen = kfs.length;
        var lastKf = kfs[kfsLen - 1];
        var isDiscrete = this.discrete;
        var isArr = isArrayValueType(valType);
        var isGradient = isGradientValueType(valType);
        for (var i = 0; i < kfsLen; i++) {
            var kf = kfs[i];
            var value = kf.value;
            var lastValue = lastKf.value;
            kf.percent = kf.time / maxTime;
            if (!isDiscrete) {
                if (isArr && i !== kfsLen - 1) {
                    fillArray(value, lastValue, valType);
                }
                else if (isGradient) {
                    fillColorStops(value.colorStops, lastValue.colorStops);
                }
            }
        }
        if (!isDiscrete
            && valType !== VALUE_TYPE_RADIAL_GRADIENT
            && additiveTrack
            && this.needsAnimate()
            && additiveTrack.needsAnimate()
            && valType === additiveTrack.valType
            && !additiveTrack._finished) {
            this._additiveTrack = additiveTrack;
            var startValue = kfs[0].value;
            for (var i = 0; i < kfsLen; i++) {
                if (valType === VALUE_TYPE_NUMBER) {
                    kfs[i].additiveValue = kfs[i].value - startValue;
                }
                else if (valType === VALUE_TYPE_COLOR) {
                    kfs[i].additiveValue =
                        add1DArray([], kfs[i].value, startValue, -1);
                }
                else if (isArrayValueType(valType)) {
                    kfs[i].additiveValue = valType === VALUE_TYPE_1D_ARRAY
                        ? add1DArray([], kfs[i].value, startValue, -1)
                        : add2DArray([], kfs[i].value, startValue, -1);
                }
            }
        }
    };
    Track.prototype.step = function (target, percent) {
        if (this._finished) {
            return;
        }
        if (this._additiveTrack && this._additiveTrack._finished) {
            this._additiveTrack = null;
        }
        var isAdditive = this._additiveTrack != null;
        var valueKey = isAdditive ? 'additiveValue' : 'value';
        var valType = this.valType;
        var keyframes = this.keyframes;
        var kfsNum = keyframes.length;
        var propName = this.propName;
        var isValueColor = valType === VALUE_TYPE_COLOR;
        var frameIdx;
        var lastFrame = this._lastFr;
        var mathMin = Math.min;
        var frame;
        var nextFrame;
        if (kfsNum === 1) {
            frame = nextFrame = keyframes[0];
        }
        else {
            if (percent < 0) {
                frameIdx = 0;
            }
            else if (percent < this._lastFrP) {
                var start = mathMin(lastFrame + 1, kfsNum - 1);
                for (frameIdx = start; frameIdx >= 0; frameIdx--) {
                    if (keyframes[frameIdx].percent <= percent) {
                        break;
                    }
                }
                frameIdx = mathMin(frameIdx, kfsNum - 2);
            }
            else {
                for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {
                    if (keyframes[frameIdx].percent > percent) {
                        break;
                    }
                }
                frameIdx = mathMin(frameIdx - 1, kfsNum - 2);
            }
            nextFrame = keyframes[frameIdx + 1];
            frame = keyframes[frameIdx];
        }
        if (!(frame && nextFrame)) {
            return;
        }
        this._lastFr = frameIdx;
        this._lastFrP = percent;
        var interval = (nextFrame.percent - frame.percent);
        var w = interval === 0 ? 1 : mathMin((percent - frame.percent) / interval, 1);
        if (nextFrame.easingFunc) {
            w = nextFrame.easingFunc(w);
        }
        var targetArr = isAdditive ? this._additiveValue
            : (isValueColor ? tmpRgba : target[propName]);
        if ((isArrayValueType(valType) || isValueColor) && !targetArr) {
            targetArr = this._additiveValue = [];
        }
        if (this.discrete) {
            target[propName] = w < 1 ? frame.rawValue : nextFrame.rawValue;
        }
        else if (isArrayValueType(valType)) {
            valType === VALUE_TYPE_1D_ARRAY
                ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w)
                : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
        }
        else if (isGradientValueType(valType)) {
            var val = frame[valueKey];
            var nextVal_1 = nextFrame[valueKey];
            var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;
            target[propName] = {
                type: isLinearGradient_1 ? 'linear' : 'radial',
                x: interpolateNumber$1(val.x, nextVal_1.x, w),
                y: interpolateNumber$1(val.y, nextVal_1.y, w),
                colorStops: map$1(val.colorStops, function (colorStop, idx) {
                    var nextColorStop = nextVal_1.colorStops[idx];
                    return {
                        offset: interpolateNumber$1(colorStop.offset, nextColorStop.offset, w),
                        color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w))
                    };
                }),
                global: nextVal_1.global
            };
            if (isLinearGradient_1) {
                target[propName].x2 = interpolateNumber$1(val.x2, nextVal_1.x2, w);
                target[propName].y2 = interpolateNumber$1(val.y2, nextVal_1.y2, w);
            }
            else {
                target[propName].r = interpolateNumber$1(val.r, nextVal_1.r, w);
            }
        }
        else if (isValueColor) {
            interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
            if (!isAdditive) {
                target[propName] = rgba2String(targetArr);
            }
        }
        else {
            var value = interpolateNumber$1(frame[valueKey], nextFrame[valueKey], w);
            if (isAdditive) {
                this._additiveValue = value;
            }
            else {
                target[propName] = value;
            }
        }
        if (isAdditive) {
            this._addToTarget(target);
        }
    };
    Track.prototype._addToTarget = function (target) {
        var valType = this.valType;
        var propName = this.propName;
        var additiveValue = this._additiveValue;
        if (valType === VALUE_TYPE_NUMBER) {
            target[propName] = target[propName] + additiveValue;
        }
        else if (valType === VALUE_TYPE_COLOR) {
            parse(target[propName], tmpRgba);
            add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
            target[propName] = rgba2String(tmpRgba);
        }
        else if (valType === VALUE_TYPE_1D_ARRAY) {
            add1DArray(target[propName], target[propName], additiveValue, 1);
        }
        else if (valType === VALUE_TYPE_2D_ARRAY) {
            add2DArray(target[propName], target[propName], additiveValue, 1);
        }
    };
    return Track;
}());
var Animator = (function () {
    function Animator(target, loop, allowDiscreteAnimation, additiveTo) {
        this._tracks = {};
        this._trackKeys = [];
        this._maxTime = 0;
        this._started = 0;
        this._clip = null;
        this._target = target;
        this._loop = loop;
        if (loop && additiveTo) {
            logError('Can\' use additive animation on looped animation.');
            return;
        }
        this._additiveAnimators = additiveTo;
        this._allowDiscrete = allowDiscreteAnimation;
    }
    Animator.prototype.getMaxTime = function () {
        return this._maxTime;
    };
    Animator.prototype.getDelay = function () {
        return this._delay;
    };
    Animator.prototype.getLoop = function () {
        return this._loop;
    };
    Animator.prototype.getTarget = function () {
        return this._target;
    };
    Animator.prototype.changeTarget = function (target) {
        this._target = target;
    };
    Animator.prototype.when = function (time, props, easing) {
        return this.whenWithKeys(time, props, keys(props), easing);
    };
    Animator.prototype.whenWithKeys = function (time, props, propNames, easing) {
        var tracks = this._tracks;
        for (var i = 0; i < propNames.length; i++) {
            var propName = propNames[i];
            var track = tracks[propName];
            if (!track) {
                track = tracks[propName] = new Track(propName);
                var initialValue = void 0;
                var additiveTrack = this._getAdditiveTrack(propName);
                if (additiveTrack) {
                    var addtiveTrackKfs = additiveTrack.keyframes;
                    var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];
                    initialValue = lastFinalKf && lastFinalKf.value;
                    if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {
                        initialValue = rgba2String(initialValue);
                    }
                }
                else {
                    initialValue = this._target[propName];
                }
                if (initialValue == null) {
                    continue;
                }
                if (time > 0) {
                    track.addKeyframe(0, cloneValue(initialValue), easing);
                }
                this._trackKeys.push(propName);
            }
            track.addKeyframe(time, cloneValue(props[propName]), easing);
        }
        this._maxTime = Math.max(this._maxTime, time);
        return this;
    };
    Animator.prototype.pause = function () {
        this._clip.pause();
        this._paused = true;
    };
    Animator.prototype.resume = function () {
        this._clip.resume();
        this._paused = false;
    };
    Animator.prototype.isPaused = function () {
        return !!this._paused;
    };
    Animator.prototype.duration = function (duration) {
        this._maxTime = duration;
        this._force = true;
        return this;
    };
    Animator.prototype._doneCallback = function () {
        this._setTracksFinished();
        this._clip = null;
        var doneList = this._doneCbs;
        if (doneList) {
            var len = doneList.length;
            for (var i = 0; i < len; i++) {
                doneList[i].call(this);
            }
        }
    };
    Animator.prototype._abortedCallback = function () {
        this._setTracksFinished();
        var animation = this.animation;
        var abortedList = this._abortedCbs;
        if (animation) {
            animation.removeClip(this._clip);
        }
        this._clip = null;
        if (abortedList) {
            for (var i = 0; i < abortedList.length; i++) {
                abortedList[i].call(this);
            }
        }
    };
    Animator.prototype._setTracksFinished = function () {
        var tracks = this._tracks;
        var tracksKeys = this._trackKeys;
        for (var i = 0; i < tracksKeys.length; i++) {
            tracks[tracksKeys[i]].setFinished();
        }
    };
    Animator.prototype._getAdditiveTrack = function (trackName) {
        var additiveTrack;
        var additiveAnimators = this._additiveAnimators;
        if (additiveAnimators) {
            for (var i = 0; i < additiveAnimators.length; i++) {
                var track = additiveAnimators[i].getTrack(trackName);
                if (track) {
                    additiveTrack = track;
                }
            }
        }
        return additiveTrack;
    };
    Animator.prototype.start = function (easing) {
        if (this._started > 0) {
            return;
        }
        this._started = 1;
        var self = this;
        var tracks = [];
        var maxTime = this._maxTime || 0;
        for (var i = 0; i < this._trackKeys.length; i++) {
            var propName = this._trackKeys[i];
            var track = this._tracks[propName];
            var additiveTrack = this._getAdditiveTrack(propName);
            var kfs = track.keyframes;
            var kfsNum = kfs.length;
            track.prepare(maxTime, additiveTrack);
            if (track.needsAnimate()) {
                if (!this._allowDiscrete && track.discrete) {
                    var lastKf = kfs[kfsNum - 1];
                    if (lastKf) {
                        self._target[track.propName] = lastKf.rawValue;
                    }
                    track.setFinished();
                }
                else {
                    tracks.push(track);
                }
            }
        }
        if (tracks.length || this._force) {
            var clip = new Clip$1({
                life: maxTime,
                loop: this._loop,
                delay: this._delay || 0,
                onframe: function (percent) {
                    self._started = 2;
                    var additiveAnimators = self._additiveAnimators;
                    if (additiveAnimators) {
                        var stillHasAdditiveAnimator = false;
                        for (var i = 0; i < additiveAnimators.length; i++) {
                            if (additiveAnimators[i]._clip) {
                                stillHasAdditiveAnimator = true;
                                break;
                            }
                        }
                        if (!stillHasAdditiveAnimator) {
                            self._additiveAnimators = null;
                        }
                    }
                    for (var i = 0; i < tracks.length; i++) {
                        tracks[i].step(self._target, percent);
                    }
                    var onframeList = self._onframeCbs;
                    if (onframeList) {
                        for (var i = 0; i < onframeList.length; i++) {
                            onframeList[i](self._target, percent);
                        }
                    }
                },
                ondestroy: function () {
                    self._doneCallback();
                }
            });
            this._clip = clip;
            if (this.animation) {
                this.animation.addClip(clip);
            }
            if (easing) {
                clip.setEasing(easing);
            }
        }
        else {
            this._doneCallback();
        }
        return this;
    };
    Animator.prototype.stop = function (forwardToLast) {
        if (!this._clip) {
            return;
        }
        var clip = this._clip;
        if (forwardToLast) {
            clip.onframe(1);
        }
        this._abortedCallback();
    };
    Animator.prototype.delay = function (time) {
        this._delay = time;
        return this;
    };
    Animator.prototype.during = function (cb) {
        if (cb) {
            if (!this._onframeCbs) {
                this._onframeCbs = [];
            }
            this._onframeCbs.push(cb);
        }
        return this;
    };
    Animator.prototype.done = function (cb) {
        if (cb) {
            if (!this._doneCbs) {
                this._doneCbs = [];
            }
            this._doneCbs.push(cb);
        }
        return this;
    };
    Animator.prototype.aborted = function (cb) {
        if (cb) {
            if (!this._abortedCbs) {
                this._abortedCbs = [];
            }
            this._abortedCbs.push(cb);
        }
        return this;
    };
    Animator.prototype.getClip = function () {
        return this._clip;
    };
    Animator.prototype.getTrack = function (propName) {
        return this._tracks[propName];
    };
    Animator.prototype.getTracks = function () {
        var _this = this;
        return map$1(this._trackKeys, function (key) { return _this._tracks[key]; });
    };
    Animator.prototype.stopTracks = function (propNames, forwardToLast) {
        if (!propNames.length || !this._clip) {
            return true;
        }
        var tracks = this._tracks;
        var tracksKeys = this._trackKeys;
        for (var i = 0; i < propNames.length; i++) {
            var track = tracks[propNames[i]];
            if (track && !track.isFinished()) {
                if (forwardToLast) {
                    track.step(this._target, 1);
                }
                else if (this._started === 1) {
                    track.step(this._target, 0);
                }
                track.setFinished();
            }
        }
        var allAborted = true;
        for (var i = 0; i < tracksKeys.length; i++) {
            if (!tracks[tracksKeys[i]].isFinished()) {
                allAborted = false;
                break;
            }
        }
        if (allAborted) {
            this._abortedCallback();
        }
        return allAborted;
    };
    Animator.prototype.saveTo = function (target, trackKeys, firstOrLast) {
        if (!target) {
            return;
        }
        trackKeys = trackKeys || this._trackKeys;
        for (var i = 0; i < trackKeys.length; i++) {
            var propName = trackKeys[i];
            var track = this._tracks[propName];
            if (!track || track.isFinished()) {
                continue;
            }
            var kfs = track.keyframes;
            var kf = kfs[firstOrLast ? 0 : kfs.length - 1];
            if (kf) {
                target[propName] = cloneValue(kf.rawValue);
            }
        }
    };
    Animator.prototype.__changeFinalValue = function (finalProps, trackKeys) {
        trackKeys = trackKeys || keys(finalProps);
        for (var i = 0; i < trackKeys.length; i++) {
            var propName = trackKeys[i];
            var track = this._tracks[propName];
            if (!track) {
                continue;
            }
            var kfs = track.keyframes;
            if (kfs.length > 1) {
                var lastKf = kfs.pop();
                track.addKeyframe(lastKf.time, finalProps[propName]);
                track.prepare(this._maxTime, track.getAdditiveTrack());
            }
        }
    };
    return Animator;
}());
var Animator$1 = Animator;

function getTime() {
    return new Date().getTime();
}
var Animation = (function (_super) {
    __extends(Animation, _super);
    function Animation(opts) {
        var _this = _super.call(this) || this;
        _this._running = false;
        _this._time = 0;
        _this._pausedTime = 0;
        _this._pauseStart = 0;
        _this._paused = false;
        opts = opts || {};
        _this.stage = opts.stage || {};
        return _this;
    }
    Animation.prototype.addClip = function (clip) {
        if (clip.animation) {
            this.removeClip(clip);
        }
        if (!this._head) {
            this._head = this._tail = clip;
        }
        else {
            this._tail.next = clip;
            clip.prev = this._tail;
            clip.next = null;
            this._tail = clip;
        }
        clip.animation = this;
    };
    Animation.prototype.addAnimator = function (animator) {
        animator.animation = this;
        var clip = animator.getClip();
        if (clip) {
            this.addClip(clip);
        }
    };
    Animation.prototype.removeClip = function (clip) {
        if (!clip.animation) {
            return;
        }
        var prev = clip.prev;
        var next = clip.next;
        if (prev) {
            prev.next = next;
        }
        else {
            this._head = next;
        }
        if (next) {
            next.prev = prev;
        }
        else {
            this._tail = prev;
        }
        clip.next = clip.prev = clip.animation = null;
    };
    Animation.prototype.removeAnimator = function (animator) {
        var clip = animator.getClip();
        if (clip) {
            this.removeClip(clip);
        }
        animator.animation = null;
    };
    Animation.prototype.update = function (notTriggerFrameAndStageUpdate) {
        var time = getTime() - this._pausedTime;
        var delta = time - this._time;
        var clip = this._head;
        while (clip) {
            var nextClip = clip.next;
            var finished = clip.step(time, delta);
            if (finished) {
                clip.ondestroy();
                this.removeClip(clip);
                clip = nextClip;
            }
            else {
                clip = nextClip;
            }
        }
        this._time = time;
        if (!notTriggerFrameAndStageUpdate) {
            this.trigger('frame', delta);
            this.stage.update && this.stage.update();
        }
    };
    Animation.prototype._startLoop = function () {
        var self = this;
        this._running = true;
        function step() {
            if (self._running) {
                requestAnimationFrame$2(step);
                !self._paused && self.update();
            }
        }
        requestAnimationFrame$2(step);
    };
    Animation.prototype.start = function () {
        if (this._running) {
            return;
        }
        this._time = getTime();
        this._pausedTime = 0;
        this._startLoop();
    };
    Animation.prototype.stop = function () {
        this._running = false;
    };
    Animation.prototype.pause = function () {
        if (!this._paused) {
            this._pauseStart = getTime();
            this._paused = true;
        }
    };
    Animation.prototype.resume = function () {
        if (this._paused) {
            this._pausedTime += getTime() - this._pauseStart;
            this._paused = false;
        }
    };
    Animation.prototype.clear = function () {
        var clip = this._head;
        while (clip) {
            var nextClip = clip.next;
            clip.prev = clip.next = clip.animation = null;
            clip = nextClip;
        }
        this._head = this._tail = null;
    };
    Animation.prototype.isFinished = function () {
        return this._head == null;
    };
    Animation.prototype.animate = function (target, options) {
        options = options || {};
        this.start();
        var animator = new Animator$1(target, options.loop);
        this.addAnimator(animator);
        return animator;
    };
    return Animation;
}(Eventful$1));
var Animation$1 = Animation;

var TOUCH_CLICK_DELAY = 300;
var globalEventSupported = env$1.domSupported;
var localNativeListenerNames = (function () {
    var mouseHandlerNames = [
        'click', 'dblclick', 'mousewheel', 'wheel', 'mouseout',
        'mouseup', 'mousedown', 'mousemove', 'contextmenu'
    ];
    var touchHandlerNames = [
        'touchstart', 'touchend', 'touchmove'
    ];
    var pointerEventNameMap = {
        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1
    };
    var pointerHandlerNames = map$1(mouseHandlerNames, function (name) {
        var nm = name.replace('mouse', 'pointer');
        return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
    });
    return {
        mouse: mouseHandlerNames,
        touch: touchHandlerNames,
        pointer: pointerHandlerNames
    };
})();
var globalNativeListenerNames = {
    mouse: ['mousemove', 'mouseup'],
    pointer: ['pointermove', 'pointerup']
};
var wheelEventSupported = false;
function isPointerFromTouch(event) {
    var pointerType = event.pointerType;
    return pointerType === 'pen' || pointerType === 'touch';
}
function setTouchTimer(scope) {
    scope.touching = true;
    if (scope.touchTimer != null) {
        clearTimeout(scope.touchTimer);
        scope.touchTimer = null;
    }
    scope.touchTimer = setTimeout(function () {
        scope.touching = false;
        scope.touchTimer = null;
    }, 700);
}
function markTouch(event) {
    event && (event.zrByTouch = true);
}
function normalizeGlobalEvent(instance, event) {
    return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
}
function isLocalEl(instance, el) {
    var elTmp = el;
    var isLocal = false;
    while (elTmp && elTmp.nodeType !== 9
        && !(isLocal = elTmp.domBelongToZr
            || (elTmp !== el && elTmp === instance.painterRoot))) {
        elTmp = elTmp.parentNode;
    }
    return isLocal;
}
var FakeGlobalEvent = (function () {
    function FakeGlobalEvent(instance, event) {
        this.stopPropagation = noop$1;
        this.stopImmediatePropagation = noop$1;
        this.preventDefault = noop$1;
        this.type = event.type;
        this.target = this.currentTarget = instance.dom;
        this.pointerType = event.pointerType;
        this.clientX = event.clientX;
        this.clientY = event.clientY;
    }
    return FakeGlobalEvent;
}());
var localDOMHandlers = {
    mousedown: function (event) {
        event = normalizeEvent(this.dom, event);
        this.__mayPointerCapture = [event.zrX, event.zrY];
        this.trigger('mousedown', event);
    },
    mousemove: function (event) {
        event = normalizeEvent(this.dom, event);
        var downPoint = this.__mayPointerCapture;
        if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
            this.__togglePointerCapture(true);
        }
        this.trigger('mousemove', event);
    },
    mouseup: function (event) {
        event = normalizeEvent(this.dom, event);
        this.__togglePointerCapture(false);
        this.trigger('mouseup', event);
    },
    mouseout: function (event) {
        event = normalizeEvent(this.dom, event);
        var element = event.toElement || event.relatedTarget;
        if (!isLocalEl(this, element)) {
            if (this.__pointerCapturing) {
                event.zrEventControl = 'no_globalout';
            }
            this.trigger('mouseout', event);
        }
    },
    wheel: function (event) {
        wheelEventSupported = true;
        event = normalizeEvent(this.dom, event);
        this.trigger('mousewheel', event);
    },
    mousewheel: function (event) {
        if (wheelEventSupported) {
            return;
        }
        event = normalizeEvent(this.dom, event);
        this.trigger('mousewheel', event);
    },
    touchstart: function (event) {
        event = normalizeEvent(this.dom, event);
        markTouch(event);
        this.__lastTouchMoment = new Date();
        this.handler.processGesture(event, 'start');
        localDOMHandlers.mousemove.call(this, event);
        localDOMHandlers.mousedown.call(this, event);
    },
    touchmove: function (event) {
        event = normalizeEvent(this.dom, event);
        markTouch(event);
        this.handler.processGesture(event, 'change');
        localDOMHandlers.mousemove.call(this, event);
    },
    touchend: function (event) {
        event = normalizeEvent(this.dom, event);
        markTouch(event);
        this.handler.processGesture(event, 'end');
        localDOMHandlers.mouseup.call(this, event);
        if (+new Date() - (+this.__lastTouchMoment) < TOUCH_CLICK_DELAY) {
            localDOMHandlers.click.call(this, event);
        }
    },
    pointerdown: function (event) {
        localDOMHandlers.mousedown.call(this, event);
    },
    pointermove: function (event) {
        if (!isPointerFromTouch(event)) {
            localDOMHandlers.mousemove.call(this, event);
        }
    },
    pointerup: function (event) {
        localDOMHandlers.mouseup.call(this, event);
    },
    pointerout: function (event) {
        if (!isPointerFromTouch(event)) {
            localDOMHandlers.mouseout.call(this, event);
        }
    }
};
each$9(['click', 'dblclick', 'contextmenu'], function (name) {
    localDOMHandlers[name] = function (event) {
        event = normalizeEvent(this.dom, event);
        this.trigger(name, event);
    };
});
var globalDOMHandlers = {
    pointermove: function (event) {
        if (!isPointerFromTouch(event)) {
            globalDOMHandlers.mousemove.call(this, event);
        }
    },
    pointerup: function (event) {
        globalDOMHandlers.mouseup.call(this, event);
    },
    mousemove: function (event) {
        this.trigger('mousemove', event);
    },
    mouseup: function (event) {
        var pointerCaptureReleasing = this.__pointerCapturing;
        this.__togglePointerCapture(false);
        this.trigger('mouseup', event);
        if (pointerCaptureReleasing) {
            event.zrEventControl = 'only_globalout';
            this.trigger('mouseout', event);
        }
    }
};
function mountLocalDOMEventListeners(instance, scope) {
    var domHandlers = scope.domHandlers;
    if (env$1.pointerEventsSupported) {
        each$9(localNativeListenerNames.pointer, function (nativeEventName) {
            mountSingleDOMEventListener(scope, nativeEventName, function (event) {
                domHandlers[nativeEventName].call(instance, event);
            });
        });
    }
    else {
        if (env$1.touchEventsSupported) {
            each$9(localNativeListenerNames.touch, function (nativeEventName) {
                mountSingleDOMEventListener(scope, nativeEventName, function (event) {
                    domHandlers[nativeEventName].call(instance, event);
                    setTouchTimer(scope);
                });
            });
        }
        each$9(localNativeListenerNames.mouse, function (nativeEventName) {
            mountSingleDOMEventListener(scope, nativeEventName, function (event) {
                event = getNativeEvent(event);
                if (!scope.touching) {
                    domHandlers[nativeEventName].call(instance, event);
                }
            });
        });
    }
}
function mountGlobalDOMEventListeners(instance, scope) {
    if (env$1.pointerEventsSupported) {
        each$9(globalNativeListenerNames.pointer, mount);
    }
    else if (!env$1.touchEventsSupported) {
        each$9(globalNativeListenerNames.mouse, mount);
    }
    function mount(nativeEventName) {
        function nativeEventListener(event) {
            event = getNativeEvent(event);
            if (!isLocalEl(instance, event.target)) {
                event = normalizeGlobalEvent(instance, event);
                scope.domHandlers[nativeEventName].call(instance, event);
            }
        }
        mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true });
    }
}
function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
    scope.mounted[nativeEventName] = listener;
    scope.listenerOpts[nativeEventName] = opt;
    addEventListener(scope.domTarget, nativeEventName, listener, opt);
}
function unmountDOMEventListeners(scope) {
    var mounted = scope.mounted;
    for (var nativeEventName in mounted) {
        if (mounted.hasOwnProperty(nativeEventName)) {
            removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
        }
    }
    scope.mounted = {};
}
var DOMHandlerScope = (function () {
    function DOMHandlerScope(domTarget, domHandlers) {
        this.mounted = {};
        this.listenerOpts = {};
        this.touching = false;
        this.domTarget = domTarget;
        this.domHandlers = domHandlers;
    }
    return DOMHandlerScope;
}());
var HandlerDomProxy = (function (_super) {
    __extends(HandlerDomProxy, _super);
    function HandlerDomProxy(dom, painterRoot) {
        var _this = _super.call(this) || this;
        _this.__pointerCapturing = false;
        _this.dom = dom;
        _this.painterRoot = painterRoot;
        _this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
        if (globalEventSupported) {
            _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
        }
        mountLocalDOMEventListeners(_this, _this._localHandlerScope);
        return _this;
    }
    HandlerDomProxy.prototype.dispose = function () {
        unmountDOMEventListeners(this._localHandlerScope);
        if (globalEventSupported) {
            unmountDOMEventListeners(this._globalHandlerScope);
        }
    };
    HandlerDomProxy.prototype.setCursor = function (cursorStyle) {
        this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');
    };
    HandlerDomProxy.prototype.__togglePointerCapture = function (isPointerCapturing) {
        this.__mayPointerCapture = null;
        if (globalEventSupported
            && ((+this.__pointerCapturing) ^ (+isPointerCapturing))) {
            this.__pointerCapturing = isPointerCapturing;
            var globalHandlerScope = this._globalHandlerScope;
            isPointerCapturing
                ? mountGlobalDOMEventListeners(this, globalHandlerScope)
                : unmountDOMEventListeners(globalHandlerScope);
        }
    };
    return HandlerDomProxy;
}(Eventful$1));
var HandlerProxy = HandlerDomProxy;

var dpr = 1;
if (env$1.hasGlobalWindow) {
    dpr = Math.max(window.devicePixelRatio
        || (window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI)
        || 1, 1);
}
var devicePixelRatio = dpr;
var DARK_MODE_THRESHOLD = 0.4;
var DARK_LABEL_COLOR = '#333';
var LIGHT_LABEL_COLOR = '#ccc';
var LIGHTER_LABEL_COLOR = '#eee';

var mIdentity = identity;
var EPSILON$2 = 5e-5;
function isNotAroundZero(val) {
    return val > EPSILON$2 || val < -EPSILON$2;
}
var scaleTmp = [];
var tmpTransform = [];
var originTransform = create();
var abs = Math.abs;
var Transformable = (function () {
    function Transformable() {
    }
    Transformable.prototype.getLocalTransform = function (m) {
        return Transformable.getLocalTransform(this, m);
    };
    Transformable.prototype.setPosition = function (arr) {
        this.x = arr[0];
        this.y = arr[1];
    };
    Transformable.prototype.setScale = function (arr) {
        this.scaleX = arr[0];
        this.scaleY = arr[1];
    };
    Transformable.prototype.setSkew = function (arr) {
        this.skewX = arr[0];
        this.skewY = arr[1];
    };
    Transformable.prototype.setOrigin = function (arr) {
        this.originX = arr[0];
        this.originY = arr[1];
    };
    Transformable.prototype.needLocalTransform = function () {
        return isNotAroundZero(this.rotation)
            || isNotAroundZero(this.x)
            || isNotAroundZero(this.y)
            || isNotAroundZero(this.scaleX - 1)
            || isNotAroundZero(this.scaleY - 1)
            || isNotAroundZero(this.skewX)
            || isNotAroundZero(this.skewY);
    };
    Transformable.prototype.updateTransform = function () {
        var parentTransform = this.parent && this.parent.transform;
        var needLocalTransform = this.needLocalTransform();
        var m = this.transform;
        if (!(needLocalTransform || parentTransform)) {
            m && mIdentity(m);
            return;
        }
        m = m || create();
        if (needLocalTransform) {
            this.getLocalTransform(m);
        }
        else {
            mIdentity(m);
        }
        if (parentTransform) {
            if (needLocalTransform) {
                mul(m, parentTransform, m);
            }
            else {
                copy(m, parentTransform);
            }
        }
        this.transform = m;
        this._resolveGlobalScaleRatio(m);
    };
    Transformable.prototype._resolveGlobalScaleRatio = function (m) {
        var globalScaleRatio = this.globalScaleRatio;
        if (globalScaleRatio != null && globalScaleRatio !== 1) {
            this.getGlobalScale(scaleTmp);
            var relX = scaleTmp[0] < 0 ? -1 : 1;
            var relY = scaleTmp[1] < 0 ? -1 : 1;
            var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
            var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
            m[0] *= sx;
            m[1] *= sx;
            m[2] *= sy;
            m[3] *= sy;
        }
        this.invTransform = this.invTransform || create();
        invert(this.invTransform, m);
    };
    Transformable.prototype.getComputedTransform = function () {
        var transformNode = this;
        var ancestors = [];
        while (transformNode) {
            ancestors.push(transformNode);
            transformNode = transformNode.parent;
        }
        while (transformNode = ancestors.pop()) {
            transformNode.updateTransform();
        }
        return this.transform;
    };
    Transformable.prototype.setLocalTransform = function (m) {
        if (!m) {
            return;
        }
        var sx = m[0] * m[0] + m[1] * m[1];
        var sy = m[2] * m[2] + m[3] * m[3];
        var rotation = Math.atan2(m[1], m[0]);
        var shearX = Math.PI / 2 + rotation - Math.atan2(m[3], m[2]);
        sy = Math.sqrt(sy) * Math.cos(shearX);
        sx = Math.sqrt(sx);
        this.skewX = shearX;
        this.skewY = 0;
        this.rotation = -rotation;
        this.x = +m[4];
        this.y = +m[5];
        this.scaleX = sx;
        this.scaleY = sy;
        this.originX = 0;
        this.originY = 0;
    };
    Transformable.prototype.decomposeTransform = function () {
        if (!this.transform) {
            return;
        }
        var parent = this.parent;
        var m = this.transform;
        if (parent && parent.transform) {
            mul(tmpTransform, parent.invTransform, m);
            m = tmpTransform;
        }
        var ox = this.originX;
        var oy = this.originY;
        if (ox || oy) {
            originTransform[4] = ox;
            originTransform[5] = oy;
            mul(tmpTransform, m, originTransform);
            tmpTransform[4] -= ox;
            tmpTransform[5] -= oy;
            m = tmpTransform;
        }
        this.setLocalTransform(m);
    };
    Transformable.prototype.getGlobalScale = function (out) {
        var m = this.transform;
        out = out || [];
        if (!m) {
            out[0] = 1;
            out[1] = 1;
            return out;
        }
        out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
        out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
        if (m[0] < 0) {
            out[0] = -out[0];
        }
        if (m[3] < 0) {
            out[1] = -out[1];
        }
        return out;
    };
    Transformable.prototype.transformCoordToLocal = function (x, y) {
        var v2 = [x, y];
        var invTransform = this.invTransform;
        if (invTransform) {
            applyTransform$1(v2, v2, invTransform);
        }
        return v2;
    };
    Transformable.prototype.transformCoordToGlobal = function (x, y) {
        var v2 = [x, y];
        var transform = this.transform;
        if (transform) {
            applyTransform$1(v2, v2, transform);
        }
        return v2;
    };
    Transformable.prototype.getLineScale = function () {
        var m = this.transform;
        return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10
            ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))
            : 1;
    };
    Transformable.prototype.copyTransform = function (source) {
        copyTransform(this, source);
    };
    Transformable.getLocalTransform = function (target, m) {
        m = m || [];
        var ox = target.originX || 0;
        var oy = target.originY || 0;
        var sx = target.scaleX;
        var sy = target.scaleY;
        var ax = target.anchorX;
        var ay = target.anchorY;
        var rotation = target.rotation || 0;
        var x = target.x;
        var y = target.y;
        var skewX = target.skewX ? Math.tan(target.skewX) : 0;
        var skewY = target.skewY ? Math.tan(-target.skewY) : 0;
        if (ox || oy || ax || ay) {
            var dx = ox + ax;
            var dy = oy + ay;
            m[4] = -dx * sx - skewX * dy * sy;
            m[5] = -dy * sy - skewY * dx * sx;
        }
        else {
            m[4] = m[5] = 0;
        }
        m[0] = sx;
        m[3] = sy;
        m[1] = skewY * sx;
        m[2] = skewX * sy;
        rotation && rotate(m, m, rotation);
        m[4] += ox + x;
        m[5] += oy + y;
        return m;
    };
    Transformable.initDefaultProps = (function () {
        var proto = Transformable.prototype;
        proto.scaleX =
            proto.scaleY =
                proto.globalScaleRatio = 1;
        proto.x =
            proto.y =
                proto.originX =
                    proto.originY =
                        proto.skewX =
                            proto.skewY =
                                proto.rotation =
                                    proto.anchorX =
                                        proto.anchorY = 0;
    })();
    return Transformable;
}());
var TRANSFORMABLE_PROPS = [
    'x', 'y', 'originX', 'originY', 'anchorX', 'anchorY', 'rotation', 'scaleX', 'scaleY', 'skewX', 'skewY'
];
function copyTransform(target, source) {
    for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
        var propName = TRANSFORMABLE_PROPS[i];
        target[propName] = source[propName];
    }
}
var Transformable$1 = Transformable;

var textWidthCache = {};
function getWidth(text, font) {
    font = font || DEFAULT_FONT;
    var cacheOfFont = textWidthCache[font];
    if (!cacheOfFont) {
        cacheOfFont = textWidthCache[font] = new LRU$1(500);
    }
    var width = cacheOfFont.get(text);
    if (width == null) {
        width = platformApi.measureText(text, font).width;
        cacheOfFont.put(text, width);
    }
    return width;
}
function innerGetBoundingRect(text, font, textAlign, textBaseline) {
    var width = getWidth(text, font);
    var height = getLineHeight(font);
    var x = adjustTextX(0, width, textAlign);
    var y = adjustTextY(0, height, textBaseline);
    var rect = new BoundingRect$1(x, y, width, height);
    return rect;
}
function getBoundingRect(text, font, textAlign, textBaseline) {
    var textLines = ((text || '') + '').split('\n');
    var len = textLines.length;
    if (len === 1) {
        return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
    }
    else {
        var uniondRect = new BoundingRect$1(0, 0, 0, 0);
        for (var i = 0; i < textLines.length; i++) {
            var rect = innerGetBoundingRect(textLines[i], font, textAlign, textBaseline);
            i === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
        }
        return uniondRect;
    }
}
function adjustTextX(x, width, textAlign) {
    if (textAlign === 'right') {
        x -= width;
    }
    else if (textAlign === 'center') {
        x -= width / 2;
    }
    return x;
}
function adjustTextY(y, height, verticalAlign) {
    if (verticalAlign === 'middle') {
        y -= height / 2;
    }
    else if (verticalAlign === 'bottom') {
        y -= height;
    }
    return y;
}
function getLineHeight(font) {
    return getWidth('国', font);
}
function parsePercent$1(value, maxValue) {
    if (typeof value === 'string') {
        if (value.lastIndexOf('%') >= 0) {
            return parseFloat(value) / 100 * maxValue;
        }
        return parseFloat(value);
    }
    return value;
}
function calculateTextPosition(out, opts, rect) {
    var textPosition = opts.position || 'inside';
    var distance = opts.distance != null ? opts.distance : 5;
    var height = rect.height;
    var width = rect.width;
    var halfHeight = height / 2;
    var x = rect.x;
    var y = rect.y;
    var textAlign = 'left';
    var textVerticalAlign = 'top';
    if (textPosition instanceof Array) {
        x += parsePercent$1(textPosition[0], rect.width);
        y += parsePercent$1(textPosition[1], rect.height);
        textAlign = null;
        textVerticalAlign = null;
    }
    else {
        switch (textPosition) {
            case 'left':
                x -= distance;
                y += halfHeight;
                textAlign = 'right';
                textVerticalAlign = 'middle';
                break;
            case 'right':
                x += distance + width;
                y += halfHeight;
                textVerticalAlign = 'middle';
                break;
            case 'top':
                x += width / 2;
                y -= distance;
                textAlign = 'center';
                textVerticalAlign = 'bottom';
                break;
            case 'bottom':
                x += width / 2;
                y += height + distance;
                textAlign = 'center';
                break;
            case 'inside':
                x += width / 2;
                y += halfHeight;
                textAlign = 'center';
                textVerticalAlign = 'middle';
                break;
            case 'insideLeft':
                x += distance;
                y += halfHeight;
                textVerticalAlign = 'middle';
                break;
            case 'insideRight':
                x += width - distance;
                y += halfHeight;
                textAlign = 'right';
                textVerticalAlign = 'middle';
                break;
            case 'insideTop':
                x += width / 2;
                y += distance;
                textAlign = 'center';
                break;
            case 'insideBottom':
                x += width / 2;
                y += height - distance;
                textAlign = 'center';
                textVerticalAlign = 'bottom';
                break;
            case 'insideTopLeft':
                x += distance;
                y += distance;
                break;
            case 'insideTopRight':
                x += width - distance;
                y += distance;
                textAlign = 'right';
                break;
            case 'insideBottomLeft':
                x += distance;
                y += height - distance;
                textVerticalAlign = 'bottom';
                break;
            case 'insideBottomRight':
                x += width - distance;
                y += height - distance;
                textAlign = 'right';
                textVerticalAlign = 'bottom';
                break;
        }
    }
    out = out || {};
    out.x = x;
    out.y = y;
    out.align = textAlign;
    out.verticalAlign = textVerticalAlign;
    return out;
}

var PRESERVED_NORMAL_STATE = '__zr_normal__';
var PRIMARY_STATES_KEYS$1 = TRANSFORMABLE_PROPS.concat(['ignore']);
var DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function (obj, key) {
    obj[key] = true;
    return obj;
}, { ignore: false });
var tmpTextPosCalcRes = {};
var tmpBoundingRect = new BoundingRect$1(0, 0, 0, 0);
var Element = (function () {
    function Element(props) {
        this.id = guid();
        this.animators = [];
        this.currentStates = [];
        this.states = {};
        this._init(props);
    }
    Element.prototype._init = function (props) {
        this.attr(props);
    };
    Element.prototype.drift = function (dx, dy, e) {
        switch (this.draggable) {
            case 'horizontal':
                dy = 0;
                break;
            case 'vertical':
                dx = 0;
                break;
        }
        var m = this.transform;
        if (!m) {
            m = this.transform = [1, 0, 0, 1, 0, 0];
        }
        m[4] += dx;
        m[5] += dy;
        this.decomposeTransform();
        this.markRedraw();
    };
    Element.prototype.beforeUpdate = function () { };
    Element.prototype.afterUpdate = function () { };
    Element.prototype.update = function () {
        this.updateTransform();
        if (this.__dirty) {
            this.updateInnerText();
        }
    };
    Element.prototype.updateInnerText = function (forceUpdate) {
        var textEl = this._textContent;
        if (textEl && (!textEl.ignore || forceUpdate)) {
            if (!this.textConfig) {
                this.textConfig = {};
            }
            var textConfig = this.textConfig;
            var isLocal = textConfig.local;
            var innerTransformable = textEl.innerTransformable;
            var textAlign = void 0;
            var textVerticalAlign = void 0;
            var textStyleChanged = false;
            innerTransformable.parent = isLocal ? this : null;
            var innerOrigin = false;
            innerTransformable.copyTransform(textEl);
            if (textConfig.position != null) {
                var layoutRect = tmpBoundingRect;
                if (textConfig.layoutRect) {
                    layoutRect.copy(textConfig.layoutRect);
                }
                else {
                    layoutRect.copy(this.getBoundingRect());
                }
                if (!isLocal) {
                    layoutRect.applyTransform(this.transform);
                }
                if (this.calculateTextPosition) {
                    this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
                }
                else {
                    calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
                }
                innerTransformable.x = tmpTextPosCalcRes.x;
                innerTransformable.y = tmpTextPosCalcRes.y;
                textAlign = tmpTextPosCalcRes.align;
                textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
                var textOrigin = textConfig.origin;
                if (textOrigin && textConfig.rotation != null) {
                    var relOriginX = void 0;
                    var relOriginY = void 0;
                    if (textOrigin === 'center') {
                        relOriginX = layoutRect.width * 0.5;
                        relOriginY = layoutRect.height * 0.5;
                    }
                    else {
                        relOriginX = parsePercent$1(textOrigin[0], layoutRect.width);
                        relOriginY = parsePercent$1(textOrigin[1], layoutRect.height);
                    }
                    innerOrigin = true;
                    innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);
                    innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);
                }
            }
            if (textConfig.rotation != null) {
                innerTransformable.rotation = textConfig.rotation;
            }
            var textOffset = textConfig.offset;
            if (textOffset) {
                innerTransformable.x += textOffset[0];
                innerTransformable.y += textOffset[1];
                if (!innerOrigin) {
                    innerTransformable.originX = -textOffset[0];
                    innerTransformable.originY = -textOffset[1];
                }
            }
            var isInside = textConfig.inside == null
                ? (typeof textConfig.position === 'string' && textConfig.position.indexOf('inside') >= 0)
                : textConfig.inside;
            var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
            var textFill = void 0;
            var textStroke = void 0;
            var autoStroke = void 0;
            if (isInside && this.canBeInsideText()) {
                textFill = textConfig.insideFill;
                textStroke = textConfig.insideStroke;
                if (textFill == null || textFill === 'auto') {
                    textFill = this.getInsideTextFill();
                }
                if (textStroke == null || textStroke === 'auto') {
                    textStroke = this.getInsideTextStroke(textFill);
                    autoStroke = true;
                }
            }
            else {
                textFill = textConfig.outsideFill;
                textStroke = textConfig.outsideStroke;
                if (textFill == null || textFill === 'auto') {
                    textFill = this.getOutsideFill();
                }
                if (textStroke == null || textStroke === 'auto') {
                    textStroke = this.getOutsideStroke(textFill);
                    autoStroke = true;
                }
            }
            textFill = textFill || '#000';
            if (textFill !== innerTextDefaultStyle.fill
                || textStroke !== innerTextDefaultStyle.stroke
                || autoStroke !== innerTextDefaultStyle.autoStroke
                || textAlign !== innerTextDefaultStyle.align
                || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
                textStyleChanged = true;
                innerTextDefaultStyle.fill = textFill;
                innerTextDefaultStyle.stroke = textStroke;
                innerTextDefaultStyle.autoStroke = autoStroke;
                innerTextDefaultStyle.align = textAlign;
                innerTextDefaultStyle.verticalAlign = textVerticalAlign;
                textEl.setDefaultTextStyle(innerTextDefaultStyle);
            }
            textEl.__dirty |= REDRAW_BIT;
            if (textStyleChanged) {
                textEl.dirtyStyle(true);
            }
        }
    };
    Element.prototype.canBeInsideText = function () {
        return true;
    };
    Element.prototype.getInsideTextFill = function () {
        return '#fff';
    };
    Element.prototype.getInsideTextStroke = function (textFill) {
        return '#000';
    };
    Element.prototype.getOutsideFill = function () {
        return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
    };
    Element.prototype.getOutsideStroke = function (textFill) {
        var backgroundColor = this.__zr && this.__zr.getBackgroundColor();
        var colorArr = typeof backgroundColor === 'string' && parse(backgroundColor);
        if (!colorArr) {
            colorArr = [255, 255, 255, 1];
        }
        var alpha = colorArr[3];
        var isDark = this.__zr.isDarkMode();
        for (var i = 0; i < 3; i++) {
            colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha);
        }
        colorArr[3] = 1;
        return stringify(colorArr, 'rgba');
    };
    Element.prototype.traverse = function (cb, context) { };
    Element.prototype.attrKV = function (key, value) {
        if (key === 'textConfig') {
            this.setTextConfig(value);
        }
        else if (key === 'textContent') {
            this.setTextContent(value);
        }
        else if (key === 'clipPath') {
            this.setClipPath(value);
        }
        else if (key === 'extra') {
            this.extra = this.extra || {};
            extend$2(this.extra, value);
        }
        else {
            this[key] = value;
        }
    };
    Element.prototype.hide = function () {
        this.ignore = true;
        this.markRedraw();
    };
    Element.prototype.show = function () {
        this.ignore = false;
        this.markRedraw();
    };
    Element.prototype.attr = function (keyOrObj, value) {
        if (typeof keyOrObj === 'string') {
            this.attrKV(keyOrObj, value);
        }
        else if (isObject$3(keyOrObj)) {
            var obj = keyOrObj;
            var keysArr = keys(obj);
            for (var i = 0; i < keysArr.length; i++) {
                var key = keysArr[i];
                this.attrKV(key, keyOrObj[key]);
            }
        }
        this.markRedraw();
        return this;
    };
    Element.prototype.saveCurrentToNormalState = function (toState) {
        this._innerSaveToNormal(toState);
        var normalState = this._normalState;
        for (var i = 0; i < this.animators.length; i++) {
            var animator = this.animators[i];
            var fromStateTransition = animator.__fromStateTransition;
            if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {
                continue;
            }
            var targetName = animator.targetName;
            var target = targetName
                ? normalState[targetName] : normalState;
            animator.saveTo(target);
        }
    };
    Element.prototype._innerSaveToNormal = function (toState) {
        var normalState = this._normalState;
        if (!normalState) {
            normalState = this._normalState = {};
        }
        if (toState.textConfig && !normalState.textConfig) {
            normalState.textConfig = this.textConfig;
        }
        this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS$1);
    };
    Element.prototype._savePrimaryToNormal = function (toState, normalState, primaryKeys) {
        for (var i = 0; i < primaryKeys.length; i++) {
            var key = primaryKeys[i];
            if (toState[key] != null && !(key in normalState)) {
                normalState[key] = this[key];
            }
        }
    };
    Element.prototype.hasState = function () {
        return this.currentStates.length > 0;
    };
    Element.prototype.getState = function (name) {
        return this.states[name];
    };
    Element.prototype.ensureState = function (name) {
        var states = this.states;
        if (!states[name]) {
            states[name] = {};
        }
        return states[name];
    };
    Element.prototype.clearStates = function (noAnimation) {
        this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);
    };
    Element.prototype.useState = function (stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
        var toNormalState = stateName === PRESERVED_NORMAL_STATE;
        var hasStates = this.hasState();
        if (!hasStates && toNormalState) {
            return;
        }
        var currentStates = this.currentStates;
        var animationCfg = this.stateTransition;
        if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
            return;
        }
        var state;
        if (this.stateProxy && !toNormalState) {
            state = this.stateProxy(stateName);
        }
        if (!state) {
            state = (this.states && this.states[stateName]);
        }
        if (!state && !toNormalState) {
            logError("State " + stateName + " not exists.");
            return;
        }
        if (!toNormalState) {
            this.saveCurrentToNormalState(state);
        }
        var useHoverLayer = !!((state && state.hoverLayer) || forceUseHoverLayer);
        if (useHoverLayer) {
            this._toggleHoverLayerFlag(true);
        }
        this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
        var textContent = this._textContent;
        var textGuide = this._textGuide;
        if (textContent) {
            textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
        }
        if (textGuide) {
            textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
        }
        if (toNormalState) {
            this.currentStates = [];
            this._normalState = {};
        }
        else {
            if (!keepCurrentStates) {
                this.currentStates = [stateName];
            }
            else {
                this.currentStates.push(stateName);
            }
        }
        this._updateAnimationTargets();
        this.markRedraw();
        if (!useHoverLayer && this.__inHover) {
            this._toggleHoverLayerFlag(false);
            this.__dirty &= ~REDRAW_BIT;
        }
        return state;
    };
    Element.prototype.useStates = function (states, noAnimation, forceUseHoverLayer) {
        if (!states.length) {
            this.clearStates();
        }
        else {
            var stateObjects = [];
            var currentStates = this.currentStates;
            var len = states.length;
            var notChange = len === currentStates.length;
            if (notChange) {
                for (var i = 0; i < len; i++) {
                    if (states[i] !== currentStates[i]) {
                        notChange = false;
                        break;
                    }
                }
            }
            if (notChange) {
                return;
            }
            for (var i = 0; i < len; i++) {
                var stateName = states[i];
                var stateObj = void 0;
                if (this.stateProxy) {
                    stateObj = this.stateProxy(stateName, states);
                }
                if (!stateObj) {
                    stateObj = this.states[stateName];
                }
                if (stateObj) {
                    stateObjects.push(stateObj);
                }
            }
            var lastStateObj = stateObjects[len - 1];
            var useHoverLayer = !!((lastStateObj && lastStateObj.hoverLayer) || forceUseHoverLayer);
            if (useHoverLayer) {
                this._toggleHoverLayerFlag(true);
            }
            var mergedState = this._mergeStates(stateObjects);
            var animationCfg = this.stateTransition;
            this.saveCurrentToNormalState(mergedState);
            this._applyStateObj(states.join(','), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
            var textContent = this._textContent;
            var textGuide = this._textGuide;
            if (textContent) {
                textContent.useStates(states, noAnimation, useHoverLayer);
            }
            if (textGuide) {
                textGuide.useStates(states, noAnimation, useHoverLayer);
            }
            this._updateAnimationTargets();
            this.currentStates = states.slice();
            this.markRedraw();
            if (!useHoverLayer && this.__inHover) {
                this._toggleHoverLayerFlag(false);
                this.__dirty &= ~REDRAW_BIT;
            }
        }
    };
    Element.prototype._updateAnimationTargets = function () {
        for (var i = 0; i < this.animators.length; i++) {
            var animator = this.animators[i];
            if (animator.targetName) {
                animator.changeTarget(this[animator.targetName]);
            }
        }
    };
    Element.prototype.removeState = function (state) {
        var idx = indexOf(this.currentStates, state);
        if (idx >= 0) {
            var currentStates = this.currentStates.slice();
            currentStates.splice(idx, 1);
            this.useStates(currentStates);
        }
    };
    Element.prototype.replaceState = function (oldState, newState, forceAdd) {
        var currentStates = this.currentStates.slice();
        var idx = indexOf(currentStates, oldState);
        var newStateExists = indexOf(currentStates, newState) >= 0;
        if (idx >= 0) {
            if (!newStateExists) {
                currentStates[idx] = newState;
            }
            else {
                currentStates.splice(idx, 1);
            }
        }
        else if (forceAdd && !newStateExists) {
            currentStates.push(newState);
        }
        this.useStates(currentStates);
    };
    Element.prototype.toggleState = function (state, enable) {
        if (enable) {
            this.useState(state, true);
        }
        else {
            this.removeState(state);
        }
    };
    Element.prototype._mergeStates = function (states) {
        var mergedState = {};
        var mergedTextConfig;
        for (var i = 0; i < states.length; i++) {
            var state = states[i];
            extend$2(mergedState, state);
            if (state.textConfig) {
                mergedTextConfig = mergedTextConfig || {};
                extend$2(mergedTextConfig, state.textConfig);
            }
        }
        if (mergedTextConfig) {
            mergedState.textConfig = mergedTextConfig;
        }
        return mergedState;
    };
    Element.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
        var needsRestoreToNormal = !(state && keepCurrentStates);
        if (state && state.textConfig) {
            this.textConfig = extend$2({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
            extend$2(this.textConfig, state.textConfig);
        }
        else if (needsRestoreToNormal) {
            if (normalState.textConfig) {
                this.textConfig = normalState.textConfig;
            }
        }
        var transitionTarget = {};
        var hasTransition = false;
        for (var i = 0; i < PRIMARY_STATES_KEYS$1.length; i++) {
            var key = PRIMARY_STATES_KEYS$1[i];
            var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key];
            if (state && state[key] != null) {
                if (propNeedsTransition) {
                    hasTransition = true;
                    transitionTarget[key] = state[key];
                }
                else {
                    this[key] = state[key];
                }
            }
            else if (needsRestoreToNormal) {
                if (normalState[key] != null) {
                    if (propNeedsTransition) {
                        hasTransition = true;
                        transitionTarget[key] = normalState[key];
                    }
                    else {
                        this[key] = normalState[key];
                    }
                }
            }
        }
        if (!transition) {
            for (var i = 0; i < this.animators.length; i++) {
                var animator = this.animators[i];
                var targetName = animator.targetName;
                if (!animator.getLoop()) {
                    animator.__changeFinalValue(targetName
                        ? (state || normalState)[targetName]
                        : (state || normalState));
                }
            }
        }
        if (hasTransition) {
            this._transitionState(stateName, transitionTarget, animationCfg);
        }
    };
    Element.prototype._attachComponent = function (componentEl) {
        if (componentEl.__zr && !componentEl.__hostTarget) {
            if (process.env.NODE_ENV !== 'production') {
                throw new Error('Text element has been added to zrender.');
            }
            return;
        }
        if (componentEl === this) {
            if (process.env.NODE_ENV !== 'production') {
                throw new Error('Recursive component attachment.');
            }
            return;
        }
        var zr = this.__zr;
        if (zr) {
            componentEl.addSelfToZr(zr);
        }
        componentEl.__zr = zr;
        componentEl.__hostTarget = this;
    };
    Element.prototype._detachComponent = function (componentEl) {
        if (componentEl.__zr) {
            componentEl.removeSelfFromZr(componentEl.__zr);
        }
        componentEl.__zr = null;
        componentEl.__hostTarget = null;
    };
    Element.prototype.getClipPath = function () {
        return this._clipPath;
    };
    Element.prototype.setClipPath = function (clipPath) {
        if (this._clipPath && this._clipPath !== clipPath) {
            this.removeClipPath();
        }
        this._attachComponent(clipPath);
        this._clipPath = clipPath;
        this.markRedraw();
    };
    Element.prototype.removeClipPath = function () {
        var clipPath = this._clipPath;
        if (clipPath) {
            this._detachComponent(clipPath);
            this._clipPath = null;
            this.markRedraw();
        }
    };
    Element.prototype.getTextContent = function () {
        return this._textContent;
    };
    Element.prototype.setTextContent = function (textEl) {
        var previousTextContent = this._textContent;
        if (previousTextContent === textEl) {
            return;
        }
        if (previousTextContent && previousTextContent !== textEl) {
            this.removeTextContent();
        }
        if (process.env.NODE_ENV !== 'production') {
            if (textEl.__zr && !textEl.__hostTarget) {
                throw new Error('Text element has been added to zrender.');
            }
        }
        textEl.innerTransformable = new Transformable$1();
        this._attachComponent(textEl);
        this._textContent = textEl;
        this.markRedraw();
    };
    Element.prototype.setTextConfig = function (cfg) {
        if (!this.textConfig) {
            this.textConfig = {};
        }
        extend$2(this.textConfig, cfg);
        this.markRedraw();
    };
    Element.prototype.removeTextConfig = function () {
        this.textConfig = null;
        this.markRedraw();
    };
    Element.prototype.removeTextContent = function () {
        var textEl = this._textContent;
        if (textEl) {
            textEl.innerTransformable = null;
            this._detachComponent(textEl);
            this._textContent = null;
            this._innerTextDefaultStyle = null;
            this.markRedraw();
        }
    };
    Element.prototype.getTextGuideLine = function () {
        return this._textGuide;
    };
    Element.prototype.setTextGuideLine = function (guideLine) {
        if (this._textGuide && this._textGuide !== guideLine) {
            this.removeTextGuideLine();
        }
        this._attachComponent(guideLine);
        this._textGuide = guideLine;
        this.markRedraw();
    };
    Element.prototype.removeTextGuideLine = function () {
        var textGuide = this._textGuide;
        if (textGuide) {
            this._detachComponent(textGuide);
            this._textGuide = null;
            this.markRedraw();
        }
    };
    Element.prototype.markRedraw = function () {
        this.__dirty |= REDRAW_BIT;
        var zr = this.__zr;
        if (zr) {
            if (this.__inHover) {
                zr.refreshHover();
            }
            else {
                zr.refresh();
            }
        }
        if (this.__hostTarget) {
            this.__hostTarget.markRedraw();
        }
    };
    Element.prototype.dirty = function () {
        this.markRedraw();
    };
    Element.prototype._toggleHoverLayerFlag = function (inHover) {
        this.__inHover = inHover;
        var textContent = this._textContent;
        var textGuide = this._textGuide;
        if (textContent) {
            textContent.__inHover = inHover;
        }
        if (textGuide) {
            textGuide.__inHover = inHover;
        }
    };
    Element.prototype.addSelfToZr = function (zr) {
        if (this.__zr === zr) {
            return;
        }
        this.__zr = zr;
        var animators = this.animators;
        if (animators) {
            for (var i = 0; i < animators.length; i++) {
                zr.animation.addAnimator(animators[i]);
            }
        }
        if (this._clipPath) {
            this._clipPath.addSelfToZr(zr);
        }
        if (this._textContent) {
            this._textContent.addSelfToZr(zr);
        }
        if (this._textGuide) {
            this._textGuide.addSelfToZr(zr);
        }
    };
    Element.prototype.removeSelfFromZr = function (zr) {
        if (!this.__zr) {
            return;
        }
        this.__zr = null;
        var animators = this.animators;
        if (animators) {
            for (var i = 0; i < animators.length; i++) {
                zr.animation.removeAnimator(animators[i]);
            }
        }
        if (this._clipPath) {
            this._clipPath.removeSelfFromZr(zr);
        }
        if (this._textContent) {
            this._textContent.removeSelfFromZr(zr);
        }
        if (this._textGuide) {
            this._textGuide.removeSelfFromZr(zr);
        }
    };
    Element.prototype.animate = function (key, loop, allowDiscreteAnimation) {
        var target = key ? this[key] : this;
        if (process.env.NODE_ENV !== 'production') {
            if (!target) {
                logError('Property "'
                    + key
                    + '" is not existed in element '
                    + this.id);
                return;
            }
        }
        var animator = new Animator$1(target, loop, allowDiscreteAnimation);
        key && (animator.targetName = key);
        this.addAnimator(animator, key);
        return animator;
    };
    Element.prototype.addAnimator = function (animator, key) {
        var zr = this.__zr;
        var el = this;
        animator.during(function () {
            el.updateDuringAnimation(key);
        }).done(function () {
            var animators = el.animators;
            var idx = indexOf(animators, animator);
            if (idx >= 0) {
                animators.splice(idx, 1);
            }
        });
        this.animators.push(animator);
        if (zr) {
            zr.animation.addAnimator(animator);
        }
        zr && zr.wakeUp();
    };
    Element.prototype.updateDuringAnimation = function (key) {
        this.markRedraw();
    };
    Element.prototype.stopAnimation = function (scope, forwardToLast) {
        var animators = this.animators;
        var len = animators.length;
        var leftAnimators = [];
        for (var i = 0; i < len; i++) {
            var animator = animators[i];
            if (!scope || scope === animator.scope) {
                animator.stop(forwardToLast);
            }
            else {
                leftAnimators.push(animator);
            }
        }
        this.animators = leftAnimators;
        return this;
    };
    Element.prototype.animateTo = function (target, cfg, animationProps) {
        animateTo(this, target, cfg, animationProps);
    };
    Element.prototype.animateFrom = function (target, cfg, animationProps) {
        animateTo(this, target, cfg, animationProps, true);
    };
    Element.prototype._transitionState = function (stateName, target, cfg, animationProps) {
        var animators = animateTo(this, target, cfg, animationProps);
        for (var i = 0; i < animators.length; i++) {
            animators[i].__fromStateTransition = stateName;
        }
    };
    Element.prototype.getBoundingRect = function () {
        return null;
    };
    Element.prototype.getPaintRect = function () {
        return null;
    };
    Element.initDefaultProps = (function () {
        var elProto = Element.prototype;
        elProto.type = 'element';
        elProto.name = '';
        elProto.ignore =
            elProto.silent =
                elProto.isGroup =
                    elProto.draggable =
                        elProto.dragging =
                            elProto.ignoreClip =
                                elProto.__inHover = false;
        elProto.__dirty = REDRAW_BIT;
        var logs = {};
        function logDeprecatedError(key, xKey, yKey) {
            if (!logs[key + xKey + yKey]) {
                console.warn("DEPRECATED: '" + key + "' has been deprecated. use '" + xKey + "', '" + yKey + "' instead");
                logs[key + xKey + yKey] = true;
            }
        }
        function createLegacyProperty(key, privateKey, xKey, yKey) {
            Object.defineProperty(elProto, key, {
                get: function () {
                    if (process.env.NODE_ENV !== 'production') {
                        logDeprecatedError(key, xKey, yKey);
                    }
                    if (!this[privateKey]) {
                        var pos = this[privateKey] = [];
                        enhanceArray(this, pos);
                    }
                    return this[privateKey];
                },
                set: function (pos) {
                    if (process.env.NODE_ENV !== 'production') {
                        logDeprecatedError(key, xKey, yKey);
                    }
                    this[xKey] = pos[0];
                    this[yKey] = pos[1];
                    this[privateKey] = pos;
                    enhanceArray(this, pos);
                }
            });
            function enhanceArray(self, pos) {
                Object.defineProperty(pos, 0, {
                    get: function () {
                        return self[xKey];
                    },
                    set: function (val) {
                        self[xKey] = val;
                    }
                });
                Object.defineProperty(pos, 1, {
                    get: function () {
                        return self[yKey];
                    },
                    set: function (val) {
                        self[yKey] = val;
                    }
                });
            }
        }
        if (Object.defineProperty) {
            createLegacyProperty('position', '_legacyPos', 'x', 'y');
            createLegacyProperty('scale', '_legacyScale', 'scaleX', 'scaleY');
            createLegacyProperty('origin', '_legacyOrigin', 'originX', 'originY');
        }
    })();
    return Element;
}());
mixin(Element, Eventful$1);
mixin(Element, Transformable$1);
function animateTo(animatable, target, cfg, animationProps, reverse) {
    cfg = cfg || {};
    var animators = [];
    animateToShallow(animatable, '', animatable, target, cfg, animationProps, animators, reverse);
    var finishCount = animators.length;
    var doneHappened = false;
    var cfgDone = cfg.done;
    var cfgAborted = cfg.aborted;
    var doneCb = function () {
        doneHappened = true;
        finishCount--;
        if (finishCount <= 0) {
            doneHappened
                ? (cfgDone && cfgDone())
                : (cfgAborted && cfgAborted());
        }
    };
    var abortedCb = function () {
        finishCount--;
        if (finishCount <= 0) {
            doneHappened
                ? (cfgDone && cfgDone())
                : (cfgAborted && cfgAborted());
        }
    };
    if (!finishCount) {
        cfgDone && cfgDone();
    }
    if (animators.length > 0 && cfg.during) {
        animators[0].during(function (target, percent) {
            cfg.during(percent);
        });
    }
    for (var i = 0; i < animators.length; i++) {
        var animator = animators[i];
        if (doneCb) {
            animator.done(doneCb);
        }
        if (abortedCb) {
            animator.aborted(abortedCb);
        }
        if (cfg.force) {
            animator.duration(cfg.duration);
        }
        animator.start(cfg.easing);
    }
    return animators;
}
function copyArrShallow(source, target, len) {
    for (var i = 0; i < len; i++) {
        source[i] = target[i];
    }
}
function is2DArray(value) {
    return isArrayLike(value[0]);
}
function copyValue(target, source, key) {
    if (isArrayLike(source[key])) {
        if (!isArrayLike(target[key])) {
            target[key] = [];
        }
        if (isTypedArray(source[key])) {
            var len = source[key].length;
            if (target[key].length !== len) {
                target[key] = new (source[key].constructor)(len);
                copyArrShallow(target[key], source[key], len);
            }
        }
        else {
            var sourceArr = source[key];
            var targetArr = target[key];
            var len0 = sourceArr.length;
            if (is2DArray(sourceArr)) {
                var len1 = sourceArr[0].length;
                for (var i = 0; i < len0; i++) {
                    if (!targetArr[i]) {
                        targetArr[i] = Array.prototype.slice.call(sourceArr[i]);
                    }
                    else {
                        copyArrShallow(targetArr[i], sourceArr[i], len1);
                    }
                }
            }
            else {
                copyArrShallow(targetArr, sourceArr, len0);
            }
            targetArr.length = sourceArr.length;
        }
    }
    else {
        target[key] = source[key];
    }
}
function isValueSame(val1, val2) {
    return val1 === val2
        || isArrayLike(val1) && isArrayLike(val2) && is1DArraySame(val1, val2);
}
function is1DArraySame(arr0, arr1) {
    var len = arr0.length;
    if (len !== arr1.length) {
        return false;
    }
    for (var i = 0; i < len; i++) {
        if (arr0[i] !== arr1[i]) {
            return false;
        }
    }
    return true;
}
function animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse) {
    var targetKeys = keys(target);
    var duration = cfg.duration;
    var delay = cfg.delay;
    var additive = cfg.additive;
    var setToFinal = cfg.setToFinal;
    var animateAll = !isObject$3(animationProps);
    var existsAnimators = animatable.animators;
    var animationKeys = [];
    for (var k = 0; k < targetKeys.length; k++) {
        var innerKey = targetKeys[k];
        var targetVal = target[innerKey];
        if (targetVal != null && animateObj[innerKey] != null
            && (animateAll || animationProps[innerKey])) {
            if (isObject$3(targetVal)
                && !isArrayLike(targetVal)
                && !isGradientObject(targetVal)) {
                if (topKey) {
                    if (!reverse) {
                        animateObj[innerKey] = targetVal;
                        animatable.updateDuringAnimation(topKey);
                    }
                    continue;
                }
                animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse);
            }
            else {
                animationKeys.push(innerKey);
            }
        }
        else if (!reverse) {
            animateObj[innerKey] = targetVal;
            animatable.updateDuringAnimation(topKey);
            animationKeys.push(innerKey);
        }
    }
    var keyLen = animationKeys.length;
    if (!additive && keyLen) {
        for (var i = 0; i < existsAnimators.length; i++) {
            var animator = existsAnimators[i];
            if (animator.targetName === topKey) {
                var allAborted = animator.stopTracks(animationKeys);
                if (allAborted) {
                    var idx = indexOf(existsAnimators, animator);
                    existsAnimators.splice(idx, 1);
                }
            }
        }
    }
    if (!cfg.force) {
        animationKeys = filter(animationKeys, function (key) { return !isValueSame(target[key], animateObj[key]); });
        keyLen = animationKeys.length;
    }
    if (keyLen > 0
        || (cfg.force && !animators.length)) {
        var revertedSource = void 0;
        var reversedTarget = void 0;
        var sourceClone = void 0;
        if (reverse) {
            reversedTarget = {};
            if (setToFinal) {
                revertedSource = {};
            }
            for (var i = 0; i < keyLen; i++) {
                var innerKey = animationKeys[i];
                reversedTarget[innerKey] = animateObj[innerKey];
                if (setToFinal) {
                    revertedSource[innerKey] = target[innerKey];
                }
                else {
                    animateObj[innerKey] = target[innerKey];
                }
            }
        }
        else if (setToFinal) {
            sourceClone = {};
            for (var i = 0; i < keyLen; i++) {
                var innerKey = animationKeys[i];
                sourceClone[innerKey] = cloneValue(animateObj[innerKey]);
                copyValue(animateObj, target, innerKey);
            }
        }
        var animator = new Animator$1(animateObj, false, false, additive ? filter(existsAnimators, function (animator) { return animator.targetName === topKey; }) : null);
        animator.targetName = topKey;
        if (cfg.scope) {
            animator.scope = cfg.scope;
        }
        if (setToFinal && revertedSource) {
            animator.whenWithKeys(0, revertedSource, animationKeys);
        }
        if (sourceClone) {
            animator.whenWithKeys(0, sourceClone, animationKeys);
        }
        animator.whenWithKeys(duration == null ? 500 : duration, reverse ? reversedTarget : target, animationKeys).delay(delay || 0);
        animatable.addAnimator(animator, topKey);
        animators.push(animator);
    }
}
var Element$1 = Element;

var Group$2 = (function (_super) {
    __extends(Group, _super);
    function Group(opts) {
        var _this = _super.call(this) || this;
        _this.isGroup = true;
        _this._children = [];
        _this.attr(opts);
        return _this;
    }
    Group.prototype.childrenRef = function () {
        return this._children;
    };
    Group.prototype.children = function () {
        return this._children.slice();
    };
    Group.prototype.childAt = function (idx) {
        return this._children[idx];
    };
    Group.prototype.childOfName = function (name) {
        var children = this._children;
        for (var i = 0; i < children.length; i++) {
            if (children[i].name === name) {
                return children[i];
            }
        }
    };
    Group.prototype.childCount = function () {
        return this._children.length;
    };
    Group.prototype.add = function (child) {
        if (child) {
            if (child !== this && child.parent !== this) {
                this._children.push(child);
                this._doAdd(child);
            }
            if (process.env.NODE_ENV !== 'production') {
                if (child.__hostTarget) {
                    throw 'This elemenet has been used as an attachment';
                }
            }
        }
        return this;
    };
    Group.prototype.addBefore = function (child, nextSibling) {
        if (child && child !== this && child.parent !== this
            && nextSibling && nextSibling.parent === this) {
            var children = this._children;
            var idx = children.indexOf(nextSibling);
            if (idx >= 0) {
                children.splice(idx, 0, child);
                this._doAdd(child);
            }
        }
        return this;
    };
    Group.prototype.replace = function (oldChild, newChild) {
        var idx = indexOf(this._children, oldChild);
        if (idx >= 0) {
            this.replaceAt(newChild, idx);
        }
        return this;
    };
    Group.prototype.replaceAt = function (child, index) {
        var children = this._children;
        var old = children[index];
        if (child && child !== this && child.parent !== this && child !== old) {
            children[index] = child;
            old.parent = null;
            var zr = this.__zr;
            if (zr) {
                old.removeSelfFromZr(zr);
            }
            this._doAdd(child);
        }
        return this;
    };
    Group.prototype._doAdd = function (child) {
        if (child.parent) {
            child.parent.remove(child);
        }
        child.parent = this;
        var zr = this.__zr;
        if (zr && zr !== child.__zr) {
            child.addSelfToZr(zr);
        }
        zr && zr.refresh();
    };
    Group.prototype.remove = function (child) {
        var zr = this.__zr;
        var children = this._children;
        var idx = indexOf(children, child);
        if (idx < 0) {
            return this;
        }
        children.splice(idx, 1);
        child.parent = null;
        if (zr) {
            child.removeSelfFromZr(zr);
        }
        zr && zr.refresh();
        return this;
    };
    Group.prototype.removeAll = function () {
        var children = this._children;
        var zr = this.__zr;
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (zr) {
                child.removeSelfFromZr(zr);
            }
            child.parent = null;
        }
        children.length = 0;
        return this;
    };
    Group.prototype.eachChild = function (cb, context) {
        var children = this._children;
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            cb.call(context, child, i);
        }
        return this;
    };
    Group.prototype.traverse = function (cb, context) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            var stopped = cb.call(context, child);
            if (child.isGroup && !stopped) {
                child.traverse(cb, context);
            }
        }
        return this;
    };
    Group.prototype.addSelfToZr = function (zr) {
        _super.prototype.addSelfToZr.call(this, zr);
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            child.addSelfToZr(zr);
        }
    };
    Group.prototype.removeSelfFromZr = function (zr) {
        _super.prototype.removeSelfFromZr.call(this, zr);
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            child.removeSelfFromZr(zr);
        }
    };
    Group.prototype.getBoundingRect = function (includeChildren) {
        var tmpRect = new BoundingRect$1(0, 0, 0, 0);
        var children = includeChildren || this._children;
        var tmpMat = [];
        var rect = null;
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (child.ignore || child.invisible) {
                continue;
            }
            var childRect = child.getBoundingRect();
            var transform = child.getLocalTransform(tmpMat);
            if (transform) {
                BoundingRect$1.applyTransform(tmpRect, childRect, transform);
                rect = rect || tmpRect.clone();
                rect.union(tmpRect);
            }
            else {
                rect = rect || childRect.clone();
                rect.union(childRect);
            }
        }
        return rect || tmpRect;
    };
    return Group;
}(Element$1));
Group$2.prototype.type = 'group';
var Group$3 = Group$2;

/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var painterCtors = {};
var instances$1 = {};
function delInstance(id) {
    delete instances$1[id];
}
function isDarkMode(backgroundColor) {
    if (!backgroundColor) {
        return false;
    }
    if (typeof backgroundColor === 'string') {
        return lum(backgroundColor, 1) < DARK_MODE_THRESHOLD;
    }
    else if (backgroundColor.colorStops) {
        var colorStops = backgroundColor.colorStops;
        var totalLum = 0;
        var len = colorStops.length;
        for (var i = 0; i < len; i++) {
            totalLum += lum(colorStops[i].color, 1);
        }
        totalLum /= len;
        return totalLum < DARK_MODE_THRESHOLD;
    }
    return false;
}
var ZRender = (function () {
    function ZRender(id, dom, opts) {
        var _this = this;
        this._sleepAfterStill = 10;
        this._stillFrameAccum = 0;
        this._needsRefresh = true;
        this._needsRefreshHover = true;
        this._darkMode = false;
        opts = opts || {};
        this.dom = dom;
        this.id = id;
        var storage = new Storage$1();
        var rendererType = opts.renderer || 'canvas';
        if (!painterCtors[rendererType]) {
            rendererType = keys(painterCtors)[0];
        }
        if (process.env.NODE_ENV !== 'production') {
            if (!painterCtors[rendererType]) {
                throw new Error("Renderer '" + rendererType + "' is not imported. Please import it first.");
            }
        }
        opts.useDirtyRect = opts.useDirtyRect == null
            ? false
            : opts.useDirtyRect;
        var painter = new painterCtors[rendererType](dom, storage, opts, id);
        var ssrMode = opts.ssr || painter.ssrOnly;
        this.storage = storage;
        this.painter = painter;
        var handerProxy = (!env$1.node && !env$1.worker && !ssrMode)
            ? new HandlerProxy(painter.getViewportRoot(), painter.root)
            : null;
        var useCoarsePointer = opts.useCoarsePointer;
        var usePointerSize = (useCoarsePointer == null || useCoarsePointer === 'auto')
            ? env$1.touchEventsSupported
            : !!useCoarsePointer;
        var defaultPointerSize = 44;
        var pointerSize;
        if (usePointerSize) {
            pointerSize = retrieve2(opts.pointerSize, defaultPointerSize);
        }
        this.handler = new Handler$1(storage, painter, handerProxy, painter.root, pointerSize);
        this.animation = new Animation$1({
            stage: {
                update: ssrMode ? null : function () { return _this._flush(true); }
            }
        });
        if (!ssrMode) {
            this.animation.start();
        }
    }
    ZRender.prototype.add = function (el) {
        if (!el) {
            return;
        }
        this.storage.addRoot(el);
        el.addSelfToZr(this);
        this.refresh();
    };
    ZRender.prototype.remove = function (el) {
        if (!el) {
            return;
        }
        this.storage.delRoot(el);
        el.removeSelfFromZr(this);
        this.refresh();
    };
    ZRender.prototype.configLayer = function (zLevel, config) {
        if (this.painter.configLayer) {
            this.painter.configLayer(zLevel, config);
        }
        this.refresh();
    };
    ZRender.prototype.setBackgroundColor = function (backgroundColor) {
        if (this.painter.setBackgroundColor) {
            this.painter.setBackgroundColor(backgroundColor);
        }
        this.refresh();
        this._backgroundColor = backgroundColor;
        this._darkMode = isDarkMode(backgroundColor);
    };
    ZRender.prototype.getBackgroundColor = function () {
        return this._backgroundColor;
    };
    ZRender.prototype.setDarkMode = function (darkMode) {
        this._darkMode = darkMode;
    };
    ZRender.prototype.isDarkMode = function () {
        return this._darkMode;
    };
    ZRender.prototype.refreshImmediately = function (fromInside) {
        if (!fromInside) {
            this.animation.update(true);
        }
        this._needsRefresh = false;
        this.painter.refresh();
        this._needsRefresh = false;
    };
    ZRender.prototype.refresh = function () {
        this._needsRefresh = true;
        this.animation.start();
    };
    ZRender.prototype.flush = function () {
        this._flush(false);
    };
    ZRender.prototype._flush = function (fromInside) {
        var triggerRendered;
        var start = getTime();
        if (this._needsRefresh) {
            triggerRendered = true;
            this.refreshImmediately(fromInside);
        }
        if (this._needsRefreshHover) {
            triggerRendered = true;
            this.refreshHoverImmediately();
        }
        var end = getTime();
        if (triggerRendered) {
            this._stillFrameAccum = 0;
            this.trigger('rendered', {
                elapsedTime: end - start
            });
        }
        else if (this._sleepAfterStill > 0) {
            this._stillFrameAccum++;
            if (this._stillFrameAccum > this._sleepAfterStill) {
                this.animation.stop();
            }
        }
    };
    ZRender.prototype.setSleepAfterStill = function (stillFramesCount) {
        this._sleepAfterStill = stillFramesCount;
    };
    ZRender.prototype.wakeUp = function () {
        this.animation.start();
        this._stillFrameAccum = 0;
    };
    ZRender.prototype.refreshHover = function () {
        this._needsRefreshHover = true;
    };
    ZRender.prototype.refreshHoverImmediately = function () {
        this._needsRefreshHover = false;
        if (this.painter.refreshHover && this.painter.getType() === 'canvas') {
            this.painter.refreshHover();
        }
    };
    ZRender.prototype.resize = function (opts) {
        opts = opts || {};
        this.painter.resize(opts.width, opts.height);
        this.handler.resize();
    };
    ZRender.prototype.clearAnimation = function () {
        this.animation.clear();
    };
    ZRender.prototype.getWidth = function () {
        return this.painter.getWidth();
    };
    ZRender.prototype.getHeight = function () {
        return this.painter.getHeight();
    };
    ZRender.prototype.setCursorStyle = function (cursorStyle) {
        this.handler.setCursorStyle(cursorStyle);
    };
    ZRender.prototype.findHover = function (x, y) {
        return this.handler.findHover(x, y);
    };
    ZRender.prototype.on = function (eventName, eventHandler, context) {
        this.handler.on(eventName, eventHandler, context);
        return this;
    };
    ZRender.prototype.off = function (eventName, eventHandler) {
        this.handler.off(eventName, eventHandler);
    };
    ZRender.prototype.trigger = function (eventName, event) {
        this.handler.trigger(eventName, event);
    };
    ZRender.prototype.clear = function () {
        var roots = this.storage.getRoots();
        for (var i = 0; i < roots.length; i++) {
            if (roots[i] instanceof Group$3) {
                roots[i].removeSelfFromZr(this);
            }
        }
        this.storage.delAllRoots();
        this.painter.clear();
    };
    ZRender.prototype.dispose = function () {
        this.animation.stop();
        this.clear();
        this.storage.dispose();
        this.painter.dispose();
        this.handler.dispose();
        this.animation =
            this.storage =
                this.painter =
                    this.handler = null;
        delInstance(this.id);
    };
    return ZRender;
}());
function init$1(dom, opts) {
    var zr = new ZRender(guid(), dom, opts);
    instances$1[zr.id] = zr;
    return zr;
}
function dispose$1(zr) {
    zr.dispose();
}
function disposeAll() {
    for (var key in instances$1) {
        if (instances$1.hasOwnProperty(key)) {
            instances$1[key].dispose();
        }
    }
    instances$1 = {};
}
function getInstance(id) {
    return instances$1[id];
}
function registerPainter(name, Ctor) {
    painterCtors[name] = Ctor;
}
var version$1 = '5.4.0';

var zrender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  init: init$1,
  dispose: dispose$1,
  disposeAll: disposeAll,
  getInstance: getInstance,
  registerPainter: registerPainter,
  version: version$1
});

var RADIAN_EPSILON = 1e-4; // Although chrome already enlarge this number to 100 for `toFixed`, but
// we sill follow the spec for compatibility.

var ROUND_SUPPORTED_PRECISION_MAX = 20;

function _trim(str) {
  return str.replace(/^\s+|\s+$/g, '');
}
/**
 * Linear mapping a value from domain to range
 * @param  val
 * @param  domain Domain extent domain[0] can be bigger than domain[1]
 * @param  range  Range extent range[0] can be bigger than range[1]
 * @param  clamp Default to be false
 */


function linearMap$2(val, domain, range, clamp) {
  var d0 = domain[0];
  var d1 = domain[1];
  var r0 = range[0];
  var r1 = range[1];
  var subDomain = d1 - d0;
  var subRange = r1 - r0;

  if (subDomain === 0) {
    return subRange === 0 ? r0 : (r0 + r1) / 2;
  } // Avoid accuracy problem in edge, such as
  // 146.39 - 62.83 === 83.55999999999999.
  // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError
  // It is a little verbose for efficiency considering this method
  // is a hotspot.


  if (clamp) {
    if (subDomain > 0) {
      if (val <= d0) {
        return r0;
      } else if (val >= d1) {
        return r1;
      }
    } else {
      if (val >= d0) {
        return r0;
      } else if (val <= d1) {
        return r1;
      }
    }
  } else {
    if (val === d0) {
      return r0;
    }

    if (val === d1) {
      return r1;
    }
  }

  return (val - d0) / subDomain * subRange + r0;
}
/**
 * Convert a percent string to absolute number.
 * Returns NaN if percent is not a valid string or number
 */

function parsePercent(percent, all) {
  switch (percent) {
    case 'center':
    case 'middle':
      percent = '50%';
      break;

    case 'left':
    case 'top':
      percent = '0%';
      break;

    case 'right':
    case 'bottom':
      percent = '100%';
      break;
  }

  if (isString(percent)) {
    if (_trim(percent).match(/%$/)) {
      return parseFloat(percent) / 100 * all;
    }

    return parseFloat(percent);
  }

  return percent == null ? NaN : +percent;
}
function round$1(x, precision, returnStr) {
  if (precision == null) {
    precision = 10;
  } // Avoid range error


  precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX); // PENDING: 1.005.toFixed(2) is '1.00' rather than '1.01'

  x = (+x).toFixed(precision);
  return returnStr ? x : +x;
}
/**
 * Inplacd asc sort arr.
 * The input arr will be modified.
 */

function asc$1(arr) {
  arr.sort(function (a, b) {
    return a - b;
  });
  return arr;
}
/**
 * Get precision.
 */

function getPrecision(val) {
  val = +val;

  if (isNaN(val)) {
    return 0;
  } // It is much faster than methods converting number to string as follows
  //      let tmp = val.toString();
  //      return tmp.length - 1 - tmp.indexOf('.');
  // especially when precision is low
  // Notice:
  // (1) If the loop count is over about 20, it is slower than `getPrecisionSafe`.
  //     (see https://jsbench.me/2vkpcekkvw/1)
  // (2) If the val is less than for example 1e-15, the result may be incorrect.
  //     (see test/ut/spec/util/number.test.ts `getPrecision_equal_random`)


  if (val > 1e-14) {
    var e = 1;

    for (var i = 0; i < 15; i++, e *= 10) {
      if (Math.round(val * e) / e === val) {
        return i;
      }
    }
  }

  return getPrecisionSafe(val);
}
/**
 * Get precision with slow but safe method
 */

function getPrecisionSafe(val) {
  // toLowerCase for: '3.4E-12'
  var str = val.toString().toLowerCase(); // Consider scientific notation: '3.4e-12' '3.4e+12'

  var eIndex = str.indexOf('e');
  var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
  var significandPartLen = eIndex > 0 ? eIndex : str.length;
  var dotIndex = str.indexOf('.');
  var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
  return Math.max(0, decimalPartLen - exp);
}
/**
 * Minimal dicernible data precisioin according to a single pixel.
 */

function getPixelPrecision(dataExtent, pixelExtent) {
  var log = Math.log;
  var LN10 = Math.LN10;
  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10); // toFixed() digits argument must be between 0 and 20.

  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
  return !isFinite(precision) ? 20 : precision;
}
/**
 * Get a data of given precision, assuring the sum of percentages
 * in valueList is 1.
 * The largest remainer method is used.
 * https://en.wikipedia.org/wiki/Largest_remainder_method
 *
 * @param valueList a list of all data
 * @param idx index of the data to be processed in valueList
 * @param precision integer number showing digits of precision
 * @return percent ranging from 0 to 100
 */

function getPercentWithPrecision(valueList, idx, precision) {
  if (!valueList[idx]) {
    return 0;
  }

  var seats = getPercentSeats(valueList, precision);
  return seats[idx] || 0;
}
/**
 * Get a data of given precision, assuring the sum of percentages
 * in valueList is 1.
 * The largest remainer method is used.
 * https://en.wikipedia.org/wiki/Largest_remainder_method
 *
 * @param valueList a list of all data
 * @param precision integer number showing digits of precision
 * @return {Array<number>}
 */

function getPercentSeats(valueList, precision) {
  var sum = reduce(valueList, function (acc, val) {
    return acc + (isNaN(val) ? 0 : val);
  }, 0);

  if (sum === 0) {
    return [];
  }

  var digits = Math.pow(10, precision);
  var votesPerQuota = map$1(valueList, function (val) {
    return (isNaN(val) ? 0 : val) / sum * digits * 100;
  });
  var targetSeats = digits * 100;
  var seats = map$1(votesPerQuota, function (votes) {
    // Assign automatic seats.
    return Math.floor(votes);
  });
  var currentSum = reduce(seats, function (acc, val) {
    return acc + val;
  }, 0);
  var remainder = map$1(votesPerQuota, function (votes, idx) {
    return votes - seats[idx];
  }); // Has remainding votes.

  while (currentSum < targetSeats) {
    // Find next largest remainder.
    var max = Number.NEGATIVE_INFINITY;
    var maxId = null;

    for (var i = 0, len = remainder.length; i < len; ++i) {
      if (remainder[i] > max) {
        max = remainder[i];
        maxId = i;
      }
    } // Add a vote to max remainder.


    ++seats[maxId];
    remainder[maxId] = 0;
    ++currentSum;
  }

  return map$1(seats, function (seat) {
    return seat / digits;
  });
}
/**
 * Solve the floating point adding problem like 0.1 + 0.2 === 0.30000000000000004
 * See <http://0.30000000000000004.com/>
 */

function addSafe(val0, val1) {
  var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1)); // const multiplier = Math.pow(10, maxPrecision);
  // return (Math.round(val0 * multiplier) + Math.round(val1 * multiplier)) / multiplier;

  var sum = val0 + val1; // // PENDING: support more?

  return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum : round$1(sum, maxPrecision);
} // Number.MAX_SAFE_INTEGER, ie do not support.

var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * To 0 - 2 * PI, considering negative radian.
 */

function remRadian(radian) {
  var pi2 = Math.PI * 2;
  return (radian % pi2 + pi2) % pi2;
}
/**
 * @param {type} radian
 * @return {boolean}
 */

function isRadianAroundZero(val) {
  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
} // eslint-disable-next-line

var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/; // jshint ignore:line

/**
 * @param value valid type: number | string | Date, otherwise return `new Date(NaN)`
 *   These values can be accepted:
 *   + An instance of Date, represent a time in its own time zone.
 *   + Or string in a subset of ISO 8601, only including:
 *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',
 *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',
 *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',
 *     all of which will be treated as local time if time zone is not specified
 *     (see <https://momentjs.com/>).
 *   + Or other string format, including (all of which will be treated as loacal time):
 *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',
 *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'
 *   + a timestamp, which represent a time in UTC.
 * @return date Never be null/undefined. If invalid, return `new Date(NaN)`.
 */

function parseDate(value) {
  if (value instanceof Date) {
    return value;
  } else if (isString(value)) {
    // Different browsers parse date in different way, so we parse it manually.
    // Some other issues:
    // new Date('1970-01-01') is UTC,
    // new Date('1970/01/01') and new Date('1970-1-01') is local.
    // See issue #3623
    var match = TIME_REG.exec(value);

    if (!match) {
      // return Invalid Date.
      return new Date(NaN);
    } // Use local time when no timezone offset specifed.


    if (!match[8]) {
      // match[n] can only be string or undefined.
      // But take care of '12' + 1 => '121'.
      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
    } // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,
    // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).
    // For example, system timezone is set as "Time Zone: America/Toronto",
    // then these code will get different result:
    // `new Date(1478411999999).getTimezoneOffset();  // get 240`
    // `new Date(1478412000000).getTimezoneOffset();  // get 300`
    // So we should not use `new Date`, but use `Date.UTC`.
    else {
        var hour = +match[4] || 0;

        if (match[8].toUpperCase() !== 'Z') {
          hour -= +match[8].slice(0, 3);
        }

        return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
      }
  } else if (value == null) {
    return new Date(NaN);
  }

  return new Date(Math.round(value));
}
/**
 * Quantity of a number. e.g. 0.1, 1, 10, 100
 *
 * @param val
 * @return
 */

function quantity(val) {
  return Math.pow(10, quantityExponent(val));
}
/**
 * Exponent of the quantity of a number
 * e.g., 1234 equals to 1.234*10^3, so quantityExponent(1234) is 3
 *
 * @param val non-negative value
 * @return
 */

function quantityExponent(val) {
  if (val === 0) {
    return 0;
  }

  var exp = Math.floor(Math.log(val) / Math.LN10);
  /**
   * exp is expected to be the rounded-down result of the base-10 log of val.
   * But due to the precision loss with Math.log(val), we need to restore it
   * using 10^exp to make sure we can get val back from exp. #11249
   */

  if (val / Math.pow(10, exp) >= 10) {
    exp++;
  }

  return exp;
}
/**
 * find a “nice” number approximately equal to x. Round the number if round = true,
 * take ceiling if round = false. The primary observation is that the “nicest”
 * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
 *
 * See "Nice Numbers for Graph Labels" of Graphic Gems.
 *
 * @param  val Non-negative value.
 * @param  round
 * @return Niced number
 */

function nice(val, round) {
  var exponent = quantityExponent(val);
  var exp10 = Math.pow(10, exponent);
  var f = val / exp10; // 1 <= f < 10

  var nf;

  if (round) {
    if (f < 1.5) {
      nf = 1;
    } else if (f < 2.5) {
      nf = 2;
    } else if (f < 4) {
      nf = 3;
    } else if (f < 7) {
      nf = 5;
    } else {
      nf = 10;
    }
  } else {
    if (f < 1) {
      nf = 1;
    } else if (f < 2) {
      nf = 2;
    } else if (f < 3) {
      nf = 3;
    } else if (f < 5) {
      nf = 5;
    } else {
      nf = 10;
    }
  }

  val = nf * exp10; // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).
  // 20 is the uppper bound of toFixed.

  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}
/**
 * This code was copied from "d3.js"
 * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/arrays/quantile.js>.
 * See the license statement at the head of this file.
 * @param ascArr
 */

function quantile(ascArr, p) {
  var H = (ascArr.length - 1) * p + 1;
  var h = Math.floor(H);
  var v = +ascArr[h - 1];
  var e = H - h;
  return e ? v + e * (ascArr[h] - v) : v;
}
/**
 * Order intervals asc, and split them when overlap.
 * expect(numberUtil.reformIntervals([
 *     {interval: [18, 62], close: [1, 1]},
 *     {interval: [-Infinity, -70], close: [0, 0]},
 *     {interval: [-70, -26], close: [1, 1]},
 *     {interval: [-26, 18], close: [1, 1]},
 *     {interval: [62, 150], close: [1, 1]},
 *     {interval: [106, 150], close: [1, 1]},
 *     {interval: [150, Infinity], close: [0, 0]}
 * ])).toEqual([
 *     {interval: [-Infinity, -70], close: [0, 0]},
 *     {interval: [-70, -26], close: [1, 1]},
 *     {interval: [-26, 18], close: [0, 1]},
 *     {interval: [18, 62], close: [0, 1]},
 *     {interval: [62, 150], close: [0, 1]},
 *     {interval: [150, Infinity], close: [0, 0]}
 * ]);
 * @param list, where `close` mean open or close
 *        of the interval, and Infinity can be used.
 * @return The origin list, which has been reformed.
 */

function reformIntervals(list) {
  list.sort(function (a, b) {
    return littleThan(a, b, 0) ? -1 : 1;
  });
  var curr = -Infinity;
  var currClose = 1;

  for (var i = 0; i < list.length;) {
    var interval = list[i].interval;
    var close_1 = list[i].close;

    for (var lg = 0; lg < 2; lg++) {
      if (interval[lg] <= curr) {
        interval[lg] = curr;
        close_1[lg] = !lg ? 1 - currClose : 1;
      }

      curr = interval[lg];
      currClose = close_1[lg];
    }

    if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {
      list.splice(i, 1);
    } else {
      i++;
    }
  }

  return list;

  function littleThan(a, b, lg) {
    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));
  }
}
/**
 * [Numberic is defined as]:
 *     `parseFloat(val) == val`
 * For example:
 * numeric:
 *     typeof number except NaN, '-123', '123', '2e3', '-2e3', '011', 'Infinity', Infinity,
 *     and they rounded by white-spaces or line-terminal like ' -123 \n ' (see es spec)
 * not-numeric:
 *     null, undefined, [], {}, true, false, 'NaN', NaN, '123ab',
 *     empty string, string with only white-spaces or line-terminal (see es spec),
 *     0x12, '0x12', '-0x12', 012, '012', '-012',
 *     non-string, ...
 *
 * @test See full test cases in `test/ut/spec/util/number.js`.
 * @return Must be a typeof number. If not numeric, return NaN.
 */

function numericToNumber(val) {
  var valFloat = parseFloat(val);
  return valFloat == val // eslint-disable-line eqeqeq
  && (valFloat !== 0 || !isString(val) || val.indexOf('x') <= 0) // For case ' 0x0 '.
  ? valFloat : NaN;
}
/**
 * Definition of "numeric": see `numericToNumber`.
 */

function isNumeric(val) {
  return !isNaN(numericToNumber(val));
}
/**
 * Use random base to prevent users hard code depending on
 * this auto generated marker id.
 * @return An positive integer.
 */

function getRandomIdBase() {
  return Math.round(Math.random() * 9);
}
/**
 * Get the greatest common dividor
 *
 * @param {number} a one number
 * @param {number} b the other number
 */

function getGreatestCommonDividor(a, b) {
  if (b === 0) {
    return a;
  }

  return getGreatestCommonDividor(b, a % b);
}
/**
 * Get the least common multiple
 *
 * @param {number} a one number
 * @param {number} b the other number
 */

function getLeastCommonMultiple(a, b) {
  if (a == null) {
    return b;
  }

  if (b == null) {
    return a;
  }

  return a * b / getGreatestCommonDividor(a, b);
}

var ECHARTS_PREFIX = '[ECharts] ';
var storedLogs = {};
var hasConsole = typeof console !== 'undefined' // eslint-disable-next-line
&& console.warn && console.log;

function outputLog(type, str, onlyOnce) {
  if (hasConsole) {
    if (onlyOnce) {
      if (storedLogs[str]) {
        return;
      }

      storedLogs[str] = true;
    } // eslint-disable-next-line


    console[type](ECHARTS_PREFIX + str);
  }
}

function log(str, onlyOnce) {
  outputLog('log', str, onlyOnce);
}
function warn(str, onlyOnce) {
  outputLog('warn', str, onlyOnce);
}
function error(str, onlyOnce) {
  outputLog('error', str, onlyOnce);
}
function deprecateLog(str) {
  if (process.env.NODE_ENV !== 'production') {
    // Not display duplicate message.
    outputLog('warn', 'DEPRECATED: ' + str, true);
  }
}
function deprecateReplaceLog(oldOpt, newOpt, scope) {
  if (process.env.NODE_ENV !== 'production') {
    deprecateLog((scope ? "[" + scope + "]" : '') + (oldOpt + " is deprecated, use " + newOpt + " instead."));
  }
}
/**
 * If in __DEV__ environment, get console printable message for users hint.
 * Parameters are separated by ' '.
 * @usage
 * makePrintable('This is an error on', someVar, someObj);
 *
 * @param hintInfo anything about the current execution context to hint users.
 * @throws Error
 */

function makePrintable() {
  var hintInfo = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    hintInfo[_i] = arguments[_i];
  }

  var msg = '';

  if (process.env.NODE_ENV !== 'production') {
    // Fuzzy stringify for print.
    // This code only exist in dev environment.
    var makePrintableStringIfPossible_1 = function (val) {
      return val === void 0 ? 'undefined' : val === Infinity ? 'Infinity' : val === -Infinity ? '-Infinity' : eqNaN(val) ? 'NaN' : val instanceof Date ? 'Date(' + val.toISOString() + ')' : isFunction(val) ? 'function () { ... }' : isRegExp(val) ? val + '' : null;
    };

    msg = map$1(hintInfo, function (arg) {
      if (isString(arg)) {
        // Print without quotation mark for some statement.
        return arg;
      } else {
        var printableStr = makePrintableStringIfPossible_1(arg);

        if (printableStr != null) {
          return printableStr;
        } else if (typeof JSON !== 'undefined' && JSON.stringify) {
          try {
            return JSON.stringify(arg, function (n, val) {
              var printableStr = makePrintableStringIfPossible_1(val);
              return printableStr == null ? val : printableStr;
            }); // In most cases the info object is small, so do not line break.
          } catch (err) {
            return '?';
          }
        } else {
          return '?';
        }
      }
    }).join(' ');
  }

  return msg;
}
/**
 * @throws Error
 */

function throwError(msg) {
  throw new Error(msg);
}

function interpolateNumber(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
/**
 * Make the name displayable. But we should
 * make sure it is not duplicated with user
 * specified name, so use '\0';
 */


var DUMMY_COMPONENT_NAME_PREFIX = 'series\0';
var INTERNAL_COMPONENT_ID_PREFIX = '\0_ec_\0';
/**
 * If value is not array, then translate it to array.
 * @param  {*} value
 * @return {Array} [value] or value
 */

function normalizeToArray(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
}
/**
 * Sync default option between normal and emphasis like `position` and `show`
 * In case some one will write code like
 *     label: {
 *          show: false,
 *          position: 'outside',
 *          fontSize: 18
 *     },
 *     emphasis: {
 *          label: { show: true }
 *     }
 */

function defaultEmphasis(opt, key, subOpts) {
  // Caution: performance sensitive.
  if (opt) {
    opt[key] = opt[key] || {};
    opt.emphasis = opt.emphasis || {};
    opt.emphasis[key] = opt.emphasis[key] || {}; // Default emphasis option from normal

    for (var i = 0, len = subOpts.length; i < len; i++) {
      var subOptName = subOpts[i];

      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
        opt.emphasis[key][subOptName] = opt[key][subOptName];
      }
    }
  }
}
var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([
//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',
//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',
//     // FIXME: deprecated, check and remove it.
//     'textStyle'
// ]);

/**
 * The method do not ensure performance.
 * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
 * This helper method retieves value from data.
 */

function getDataItemValue(dataItem) {
  return isObject$3(dataItem) && !isArray$1(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
}
/**
 * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
 * This helper method determine if dataItem has extra option besides value
 */

function isDataItemOption(dataItem) {
  return isObject$3(dataItem) && !(dataItem instanceof Array); // // markLine data can be array
  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));
}
/**
 * Mapping to existings for merge.
 *
 * Mode "normalMege":
 *     The mapping result (merge result) will keep the order of the existing
 *     component, rather than the order of new option. Because we should ensure
 *     some specified index reference (like xAxisIndex) keep work.
 *     And in most cases, "merge option" is used to update partial option but not
 *     be expected to change the order.
 *
 * Mode "replaceMege":
 *     (1) Only the id mapped components will be merged.
 *     (2) Other existing components (except internal compoonets) will be removed.
 *     (3) Other new options will be used to create new component.
 *     (4) The index of the existing compoents will not be modified.
 *     That means their might be "hole" after the removal.
 *     The new components are created first at those available index.
 *
 * Mode "replaceAll":
 *     This mode try to support that reproduce an echarts instance from another
 *     echarts instance (via `getOption`) in some simple cases.
 *     In this senario, the `result` index are exactly the consistent with the `newCmptOptions`,
 *     which ensures the compoennt index referring (like `xAxisIndex: ?`) corrent. That is,
 *     the "hole" in `newCmptOptions` will also be kept.
 *     On the contrary, other modes try best to eliminate holes.
 *     PENDING: This is an experimental mode yet.
 *
 * @return See the comment of <MappingResult>.
 */

function mappingToExists(existings, newCmptOptions, mode) {
  var isNormalMergeMode = mode === 'normalMerge';
  var isReplaceMergeMode = mode === 'replaceMerge';
  var isReplaceAllMode = mode === 'replaceAll';
  existings = existings || [];
  newCmptOptions = (newCmptOptions || []).slice();
  var existingIdIdxMap = createHashMap(); // Validate id and name on user input option.

  each$9(newCmptOptions, function (cmptOption, index) {
    if (!isObject$3(cmptOption)) {
      newCmptOptions[index] = null;
      return;
    }

    if (process.env.NODE_ENV !== 'production') {
      // There is some legacy case that name is set as `false`.
      // But should work normally rather than throw error.
      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {
        warnInvalidateIdOrName(cmptOption.id);
      }

      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {
        warnInvalidateIdOrName(cmptOption.name);
      }
    }
  });
  var result = prepareResult(existings, existingIdIdxMap, mode);

  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingById(result, existings, existingIdIdxMap, newCmptOptions);
  }

  if (isNormalMergeMode) {
    mappingByName(result, newCmptOptions);
  }

  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
  } else if (isReplaceAllMode) {
    mappingInReplaceAllMode(result, newCmptOptions);
  }

  makeIdAndName(result); // The array `result` MUST NOT contain elided items, otherwise the
  // forEach will ommit those items and result in incorrect result.

  return result;
}

function prepareResult(existings, existingIdIdxMap, mode) {
  var result = [];

  if (mode === 'replaceAll') {
    return result;
  } // Do not use native `map` to in case that the array `existings`
  // contains elided items, which will be ommited.


  for (var index = 0; index < existings.length; index++) {
    var existing = existings[index]; // Because of replaceMerge, `existing` may be null/undefined.

    if (existing && existing.id != null) {
      existingIdIdxMap.set(existing.id, index);
    } // For non-internal-componnets:
    //     Mode "normalMerge": all existings kept.
    //     Mode "replaceMerge": all existing removed unless mapped by id.
    // For internal-components:
    //     go with "replaceMerge" approach in both mode.


    result.push({
      existing: mode === 'replaceMerge' || isComponentIdInternal(existing) ? null : existing,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }

  return result;
}

function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
  // Mapping by id if specified.
  each$9(newCmptOptions, function (cmptOption, index) {
    if (!cmptOption || cmptOption.id == null) {
      return;
    }

    var optionId = makeComparableKey(cmptOption.id);
    var existingIdx = existingIdIdxMap.get(optionId);

    if (existingIdx != null) {
      var resultItem = result[existingIdx];
      assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".');
      resultItem.newOption = cmptOption; // In both mode, if id matched, new option will be merged to
      // the existings rather than creating new component model.

      resultItem.existing = existings[existingIdx];
      newCmptOptions[index] = null;
    }
  });
}

function mappingByName(result, newCmptOptions) {
  // Mapping by name if specified.
  each$9(newCmptOptions, function (cmptOption, index) {
    if (!cmptOption || cmptOption.name == null) {
      return;
    }

    for (var i = 0; i < result.length; i++) {
      var existing = result[i].existing;

      if (!result[i].newOption // Consider name: two map to one.
      // Can not match when both ids existing but different.
      && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual('name', existing, cmptOption)) {
        result[i].newOption = cmptOption;
        newCmptOptions[index] = null;
        return;
      }
    }
  });
}

function mappingByIndex(result, newCmptOptions, brandNew) {
  each$9(newCmptOptions, function (cmptOption) {
    if (!cmptOption) {
      return;
    } // Find the first place that not mapped by id and not internal component (consider the "hole").


    var resultItem;
    var nextIdx = 0;

    while ( // Be `!resultItem` only when `nextIdx >= result.length`.
    (resultItem = result[nextIdx]) && ( // (1) Existing models that already have id should be able to mapped to. Because
    // after mapping performed, model will always be assigned with an id if user not given.
    // After that all models have id.
    // (2) If new option has id, it can only set to a hole or append to the last. It should
    // not be merged to the existings with different id. Because id should not be overwritten.
    // (3) Name can be overwritten, because axis use name as 'show label text'.
    resultItem.newOption || isComponentIdInternal(resultItem.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
    resultItem.existing && cmptOption.id != null && !keyExistAndEqual('id', cmptOption, resultItem.existing))) {
      nextIdx++;
    }

    if (resultItem) {
      resultItem.newOption = cmptOption;
      resultItem.brandNew = brandNew;
    } else {
      result.push({
        newOption: cmptOption,
        brandNew: brandNew,
        existing: null,
        keyInfo: null
      });
    }

    nextIdx++;
  });
}

function mappingInReplaceAllMode(result, newCmptOptions) {
  each$9(newCmptOptions, function (cmptOption) {
    // The feature "reproduce" requires "hole" will also reproduced
    // in case that compoennt index referring are broken.
    result.push({
      newOption: cmptOption,
      brandNew: true,
      existing: null,
      keyInfo: null
    });
  });
}
/**
 * Make id and name for mapping result (result of mappingToExists)
 * into `keyInfo` field.
 */


function makeIdAndName(mapResult) {
  // We use this id to hash component models and view instances
  // in echarts. id can be specified by user, or auto generated.
  // The id generation rule ensures new view instance are able
  // to mapped to old instance when setOption are called in
  // no-merge mode. So we generate model id by name and plus
  // type in view id.
  // name can be duplicated among components, which is convenient
  // to specify multi components (like series) by one name.
  // Ensure that each id is distinct.
  var idMap = createHashMap();
  each$9(mapResult, function (item) {
    var existing = item.existing;
    existing && idMap.set(existing.id, item);
  });
  each$9(mapResult, function (item) {
    var opt = item.newOption; // Force ensure id not duplicated.

    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));
    opt && opt.id != null && idMap.set(opt.id, item);
    !item.keyInfo && (item.keyInfo = {});
  }); // Make name and id.

  each$9(mapResult, function (item, index) {
    var existing = item.existing;
    var opt = item.newOption;
    var keyInfo = item.keyInfo;

    if (!isObject$3(opt)) {
      return;
    } // name can be overwitten. Consider case: axis.name = '20km'.
    // But id generated by name will not be changed, which affect
    // only in that case: setOption with 'not merge mode' and view
    // instance will be recreated, which can be accepted.


    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name // Avoid diffferent series has the same name,
    // because name may be used like in color pallet.
    : DUMMY_COMPONENT_NAME_PREFIX + index;

    if (existing) {
      keyInfo.id = makeComparableKey(existing.id);
    } else if (opt.id != null) {
      keyInfo.id = makeComparableKey(opt.id);
    } else {
      // Consider this situatoin:
      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]
      //  optionB [{..}, {name: 'a'}, {name: 'a'}]
      // Series with the same name between optionA and optionB
      // should be mapped.
      var idNum = 0;

      do {
        keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++;
      } while (idMap.get(keyInfo.id));
    }

    idMap.set(keyInfo.id, item);
  });
}

function keyExistAndEqual(attr, obj1, obj2) {
  var key1 = convertOptionIdName(obj1[attr], null);
  var key2 = convertOptionIdName(obj2[attr], null); // See `MappingExistingItem`. `id` and `name` trade string equals to number.

  return key1 != null && key2 != null && key1 === key2;
}
/**
 * @return return null if not exist.
 */


function makeComparableKey(val) {
  if (process.env.NODE_ENV !== 'production') {
    if (val == null) {
      throw new Error();
    }
  }

  return convertOptionIdName(val, '');
}

function convertOptionIdName(idOrName, defaultValue) {
  if (idOrName == null) {
    return defaultValue;
  }

  return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + '' : defaultValue;
}

function warnInvalidateIdOrName(idOrName) {
  if (process.env.NODE_ENV !== 'production') {
    warn('`' + idOrName + '` is invalid id or name. Must be a string or number.');
  }
}

function isValidIdOrName(idOrName) {
  return isStringSafe(idOrName) || isNumeric(idOrName);
}

function isNameSpecified(componentModel) {
  var name = componentModel.name; // Is specified when `indexOf` get -1 or > 0.

  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
/**
 * @public
 * @param {Object} cmptOption
 * @return {boolean}
 */

function isComponentIdInternal(cmptOption) {
  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
  // Set mainType and complete subType.
  each$9(mappingResult, function (item) {
    var newOption = item.newOption;

    if (isObject$3(newOption)) {
      item.keyInfo.mainType = mainType;
      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
    }
  });
}

function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.
  : componentModelCtor.determineSubType(mainType, newCmptOption); // tooltip, markline, markpoint may always has no subType

  return subType;
}
/**
 * A helper for removing duplicate items between batchA and batchB,
 * and in themselves, and categorize by series.
 *
 * @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
 * @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
 * @return result: [resultBatchA, resultBatchB]
 */


function compressBatches(batchA, batchB) {
  var mapA = {};
  var mapB = {};
  makeMap(batchA || [], mapA);
  makeMap(batchB || [], mapB, mapA);
  return [mapToArray(mapA), mapToArray(mapB)];

  function makeMap(sourceBatch, map, otherMap) {
    for (var i = 0, len = sourceBatch.length; i < len; i++) {
      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);

      if (seriesId == null) {
        return;
      }

      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
      var otherDataIndices = otherMap && otherMap[seriesId];

      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
        var dataIndex = dataIndices[j];

        if (otherDataIndices && otherDataIndices[dataIndex]) {
          otherDataIndices[dataIndex] = null;
        } else {
          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
        }
      }
    }
  }

  function mapToArray(map, isData) {
    var result = [];

    for (var i in map) {
      if (map.hasOwnProperty(i) && map[i] != null) {
        if (isData) {
          result.push(+i);
        } else {
          var dataIndices = mapToArray(map[i], true);
          dataIndices.length && result.push({
            seriesId: i,
            dataIndex: dataIndices
          });
        }
      }
    }

    return result;
  }
}
/**
 * @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name
 *                         each of which can be Array or primary type.
 * @return dataIndex If not found, return undefined/null.
 */

function queryDataIndex(data, payload) {
  if (payload.dataIndexInside != null) {
    return payload.dataIndexInside;
  } else if (payload.dataIndex != null) {
    return isArray$1(payload.dataIndex) ? map$1(payload.dataIndex, function (value) {
      return data.indexOfRawIndex(value);
    }) : data.indexOfRawIndex(payload.dataIndex);
  } else if (payload.name != null) {
    return isArray$1(payload.name) ? map$1(payload.name, function (value) {
      return data.indexOfName(value);
    }) : data.indexOfName(payload.name);
  }
}
/**
 * Enable property storage to any host object.
 * Notice: Serialization is not supported.
 *
 * For example:
 * let inner = zrUitl.makeInner();
 *
 * function some1(hostObj) {
 *      inner(hostObj).someProperty = 1212;
 *      ...
 * }
 * function some2() {
 *      let fields = inner(this);
 *      fields.someProperty1 = 1212;
 *      fields.someProperty2 = 'xx';
 *      ...
 * }
 *
 * @return {Function}
 */

function makeInner() {
  var key = '__ec_inner_' + innerUniqueIndex++;
  return function (hostObj) {
    return hostObj[key] || (hostObj[key] = {});
  };
}
var innerUniqueIndex = getRandomIdBase();
/**
 * The same behavior as `component.getReferringComponents`.
 */

function parseFinder(ecModel, finderInput, opt) {
  var _a = preParseFinder(finderInput, opt),
      mainTypeSpecified = _a.mainTypeSpecified,
      queryOptionMap = _a.queryOptionMap,
      others = _a.others;

  var result = others;
  var defaultMainType = opt ? opt.defaultMainType : null;

  if (!mainTypeSpecified && defaultMainType) {
    queryOptionMap.set(defaultMainType, {});
  }

  queryOptionMap.each(function (queryOption, mainType) {
    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
      useDefault: defaultMainType === mainType,
      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
      enableNone: opt && opt.enableNone != null ? opt.enableNone : true
    });
    result[mainType + 'Models'] = queryResult.models;
    result[mainType + 'Model'] = queryResult.models[0];
  });
  return result;
}
function preParseFinder(finderInput, opt) {
  var finder;

  if (isString(finderInput)) {
    var obj = {};
    obj[finderInput + 'Index'] = 0;
    finder = obj;
  } else {
    finder = finderInput;
  }

  var queryOptionMap = createHashMap();
  var others = {};
  var mainTypeSpecified = false;
  each$9(finder, function (value, key) {
    // Exclude 'dataIndex' and other illgal keys.
    if (key === 'dataIndex' || key === 'dataIndexInside') {
      others[key] = value;
      return;
    }

    var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
    var mainType = parsedKey[1];
    var queryType = (parsedKey[2] || '').toLowerCase();

    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {
      return;
    }

    mainTypeSpecified = mainTypeSpecified || !!mainType;
    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
    queryOption[queryType] = value;
  });
  return {
    mainTypeSpecified: mainTypeSpecified,
    queryOptionMap: queryOptionMap,
    others: others
  };
}
var SINGLE_REFERRING = {
  useDefault: true,
  enableAll: false,
  enableNone: false
};
function queryReferringComponents(ecModel, mainType, userOption, opt) {
  opt = opt || SINGLE_REFERRING;
  var indexOption = userOption.index;
  var idOption = userOption.id;
  var nameOption = userOption.name;
  var result = {
    models: null,
    specified: indexOption != null || idOption != null || nameOption != null
  };

  if (!result.specified) {
    // Use the first as default if `useDefault`.
    var firstCmpt = void 0;
    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
    return result;
  }

  if (indexOption === 'none' || indexOption === false) {
    assert(opt.enableNone, '`"none"` or `false` is not a valid value on index option.');
    result.models = [];
    return result;
  } // `queryComponents` will return all components if
  // both all of index/id/name are null/undefined.


  if (indexOption === 'all') {
    assert(opt.enableAll, '`"all"` is not a valid value on index option.');
    indexOption = idOption = nameOption = null;
  }

  result.models = ecModel.queryComponents({
    mainType: mainType,
    index: indexOption,
    id: idOption,
    name: nameOption
  });
  return result;
}
function setAttribute(dom, key, value) {
  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
}
function getAttribute(dom, key) {
  return dom.getAttribute ? dom.getAttribute(key) : dom[key];
}
function getTooltipRenderMode(renderModeOption) {
  if (renderModeOption === 'auto') {
    // Using html when `document` exists, use richText otherwise
    return env$1.domSupported ? 'html' : 'richText';
  } else {
    return renderModeOption || 'html';
  }
}
/**
 * Interpolate raw values of a series with percent
 *
 * @param data         data
 * @param labelModel   label model of the text element
 * @param sourceValue  start value. May be null/undefined when init.
 * @param targetValue  end value
 * @param percent      0~1 percentage; 0 uses start value while 1 uses end value
 * @return             interpolated values
 *                     If `sourceValue` and `targetValue` are `number`, return `number`.
 *                     If `sourceValue` and `targetValue` are `string`, return `string`.
 *                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.
 *                     Other cases do not supported.
 */

function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
  var isAutoPrecision = precision == null || precision === 'auto';

  if (targetValue == null) {
    return targetValue;
  }

  if (isNumber(targetValue)) {
    var value = interpolateNumber(sourceValue || 0, targetValue, percent);
    return round$1(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
  } else if (isString(targetValue)) {
    return percent < 1 ? sourceValue : targetValue;
  } else {
    var interpolated = [];
    var leftArr = sourceValue;
    var rightArr = targetValue;
    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);

    for (var i = 0; i < length_1; ++i) {
      var info = data.getDimensionInfo(i); // Don't interpolate ordinal dims

      if (info && info.type === 'ordinal') {
        // In init, there is no `sourceValue`, but should better not to get undefined result.
        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];
      } else {
        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;
        var rightVal = rightArr[i];
        var value = interpolateNumber(leftVal, rightVal, percent);
        interpolated[i] = round$1(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
      }
    }

    return interpolated;
  }
}

var TYPE_DELIMITER = '.';
var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';
var IS_EXTENDED_CLASS = '___EC__EXTENDED_CLASS___';
/**
 * Notice, parseClassType('') should returns {main: '', sub: ''}
 * @public
 */

function parseClassType(componentType) {
  var ret = {
    main: '',
    sub: ''
  };

  if (componentType) {
    var typeArr = componentType.split(TYPE_DELIMITER);
    ret.main = typeArr[0] || '';
    ret.sub = typeArr[1] || '';
  }

  return ret;
}
/**
 * @public
 */

function checkClassType(componentType) {
  assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}

function isExtendedClass(clz) {
  return !!(clz && clz[IS_EXTENDED_CLASS]);
}
/**
 * Implements `ExtendableConstructor` for `rootClz`.
 *
 * @usage
 * ```ts
 * class Xxx {}
 * type XxxConstructor = typeof Xxx & ExtendableConstructor
 * enableClassExtend(Xxx as XxxConstructor);
 * ```
 */

function enableClassExtend(rootClz, mandatoryMethods) {
  rootClz.$constructor = rootClz; // FIXME: not necessary?

  rootClz.extend = function (proto) {
    if (process.env.NODE_ENV !== 'production') {
      each$9(mandatoryMethods, function (method) {
        if (!proto[method]) {
          console.warn('Method `' + method + '` should be implemented' + (proto.type ? ' in ' + proto.type : '') + '.');
        }
      });
    }

    var superClass = this;
    var ExtendedClass;

    if (isESClass(superClass)) {
      ExtendedClass =
      /** @class */
      function (_super) {
        __extends$1(class_1, _super);

        function class_1() {
          return _super.apply(this, arguments) || this;
        }

        return class_1;
      }(superClass);
    } else {
      // For backward compat, we both support ts class inheritance and this
      // "extend" approach.
      // The constructor should keep the same behavior as ts class inheritance:
      // If this constructor/$constructor is not declared, auto invoke the super
      // constructor.
      // If this constructor/$constructor is declared, it is responsible for
      // calling the super constructor.
      ExtendedClass = function () {
        (proto.$constructor || superClass).apply(this, arguments);
      };

      inherits(ExtendedClass, this);
    }

    extend$2(ExtendedClass.prototype, proto);
    ExtendedClass[IS_EXTENDED_CLASS] = true;
    ExtendedClass.extend = this.extend;
    ExtendedClass.superCall = superCall;
    ExtendedClass.superApply = superApply;
    ExtendedClass.superClass = superClass;
    return ExtendedClass;
  };
}

function isESClass(fn) {
  return isFunction(fn) && /^class\s/.test(Function.prototype.toString.call(fn));
}
/**
 * A work around to both support ts extend and this extend mechanism.
 * on sub-class.
 * @usage
 * ```ts
 * class Component { ... }
 * classUtil.enableClassExtend(Component);
 * classUtil.enableClassManagement(Component, {registerWhenExtend: true});
 *
 * class Series extends Component { ... }
 * // Without calling `markExtend`, `registerWhenExtend` will not work.
 * Component.markExtend(Series);
 * ```
 */


function mountExtend(SubClz, SupperClz) {
  SubClz.extend = SupperClz.extend;
} // A random offset.

var classBase = Math.round(Math.random() * 10);
/**
 * Implements `CheckableConstructor` for `target`.
 * Can not use instanceof, consider different scope by
 * cross domain or es module import in ec extensions.
 * Mount a method "isInstance()" to Clz.
 *
 * @usage
 * ```ts
 * class Xxx {}
 * type XxxConstructor = typeof Xxx & CheckableConstructor;
 * enableClassCheck(Xxx as XxxConstructor)
 * ```
 */

function enableClassCheck(target) {
  var classAttr = ['__\0is_clz', classBase++].join('_');
  target.prototype[classAttr] = true;

  if (process.env.NODE_ENV !== 'production') {
    assert(!target.isInstance, 'The method "is" can not be defined.');
  }

  target.isInstance = function (obj) {
    return !!(obj && obj[classAttr]);
  };
} // superCall should have class info, which can not be fetch from 'this'.
// Consider this case:
// class A has method f,
// class B inherits class A, overrides method f, f call superApply('f'),
// class C inherits class B, do not overrides method f,
// then when method of class C is called, dead loop occured.

function superCall(context, methodName) {
  var args = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }

  return this.superClass.prototype[methodName].apply(context, args);
}

function superApply(context, methodName, args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
/**
 * Implements `ClassManager` for `target`
 *
 * @usage
 * ```ts
 * class Xxx {}
 * type XxxConstructor = typeof Xxx & ClassManager
 * enableClassManagement(Xxx as XxxConstructor);
 * ```
 */


function enableClassManagement(target) {
  /**
   * Component model classes
   * key: componentType,
   * value:
   *     componentClass, when componentType is 'a'
   *     or Object.<subKey, componentClass>, when componentType is 'a.b'
   */
  var storage = {};

  target.registerClass = function (clz) {
    // `type` should not be a "instance memeber".
    // If using TS class, should better declared as `static type = 'series.pie'`.
    // otherwise users have to mount `type` on prototype manually.
    // For backward compat and enable instance visit type via `this.type`,
    // we stil support fetch `type` from prototype.
    var componentFullType = clz.type || clz.prototype.type;

    if (componentFullType) {
      checkClassType(componentFullType); // If only static type declared, we assign it to prototype mandatorily.

      clz.prototype.type = componentFullType;
      var componentTypeInfo = parseClassType(componentFullType);

      if (!componentTypeInfo.sub) {
        if (process.env.NODE_ENV !== 'production') {
          if (storage[componentTypeInfo.main]) {
            console.warn(componentTypeInfo.main + ' exists.');
          }
        }

        storage[componentTypeInfo.main] = clz;
      } else if (componentTypeInfo.sub !== IS_CONTAINER) {
        var container = makeContainer(componentTypeInfo);
        container[componentTypeInfo.sub] = clz;
      }
    }

    return clz;
  };

  target.getClass = function (mainType, subType, throwWhenNotFound) {
    var clz = storage[mainType];

    if (clz && clz[IS_CONTAINER]) {
      clz = subType ? clz[subType] : null;
    }

    if (throwWhenNotFound && !clz) {
      throw new Error(!subType ? mainType + '.' + 'type should be specified.' : 'Component ' + mainType + '.' + (subType || '') + ' is used but not imported.');
    }

    return clz;
  };

  target.getClassesByMainType = function (componentType) {
    var componentTypeInfo = parseClassType(componentType);
    var result = [];
    var obj = storage[componentTypeInfo.main];

    if (obj && obj[IS_CONTAINER]) {
      each$9(obj, function (o, type) {
        type !== IS_CONTAINER && result.push(o);
      });
    } else {
      result.push(obj);
    }

    return result;
  };

  target.hasClass = function (componentType) {
    // Just consider componentType.main.
    var componentTypeInfo = parseClassType(componentType);
    return !!storage[componentTypeInfo.main];
  };
  /**
   * @return Like ['aa', 'bb'], but can not be ['aa.xx']
   */


  target.getAllClassMainTypes = function () {
    var types = [];
    each$9(storage, function (obj, type) {
      types.push(type);
    });
    return types;
  };
  /**
   * If a main type is container and has sub types
   */


  target.hasSubTypes = function (componentType) {
    var componentTypeInfo = parseClassType(componentType);
    var obj = storage[componentTypeInfo.main];
    return obj && obj[IS_CONTAINER];
  };

  function makeContainer(componentTypeInfo) {
    var container = storage[componentTypeInfo.main];

    if (!container || !container[IS_CONTAINER]) {
      container = storage[componentTypeInfo.main] = {};
      container[IS_CONTAINER] = true;
    }

    return container;
  }
} // /**
//  * @param {string|Array.<string>} properties
//  */
// export function setReadOnly(obj, properties) {
// FIXME It seems broken in IE8 simulation of IE11
// if (!zrUtil.isArray(properties)) {
//     properties = properties != null ? [properties] : [];
// }
// zrUtil.each(properties, function (prop) {
//     let value = obj[prop];
//     Object.defineProperty
//         && Object.defineProperty(obj, prop, {
//             value: value, writable: false
//         });
//     zrUtil.isArray(obj[prop])
//         && Object.freeze
//         && Object.freeze(obj[prop]);
// });
// }

function makeStyleMapper(properties, ignoreParent) {
  // Normalize
  for (var i = 0; i < properties.length; i++) {
    if (!properties[i][1]) {
      properties[i][1] = properties[i][0];
    }
  }

  ignoreParent = ignoreParent || false;
  return function (model, excludes, includes) {
    var style = {};

    for (var i = 0; i < properties.length; i++) {
      var propName = properties[i][1];

      if (excludes && indexOf(excludes, propName) >= 0 || includes && indexOf(includes, propName) < 0) {
        continue;
      }

      var val = model.getShallow(propName, ignoreParent);

      if (val != null) {
        style[properties[i][0]] = val;
      }
    } // TODO Text or image?


    return style;
  };
}

var AREA_STYLE_KEY_MAP = [['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor'] // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
// So do not transfer decal directly.
];
var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);

var AreaStyleMixin =
/** @class */
function () {
  function AreaStyleMixin() {}

  AreaStyleMixin.prototype.getAreaStyle = function (excludes, includes) {
    return getAreaStyle(this, excludes, includes);
  };

  return AreaStyleMixin;
}();

var globalImageCache = new LRU$1(50);
function findExistImage(newImageOrSrc) {
    if (typeof newImageOrSrc === 'string') {
        var cachedImgObj = globalImageCache.get(newImageOrSrc);
        return cachedImgObj && cachedImgObj.image;
    }
    else {
        return newImageOrSrc;
    }
}
function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
    if (!newImageOrSrc) {
        return image;
    }
    else if (typeof newImageOrSrc === 'string') {
        if ((image && image.__zrImageSrc === newImageOrSrc) || !hostEl) {
            return image;
        }
        var cachedImgObj = globalImageCache.get(newImageOrSrc);
        var pendingWrap = { hostEl: hostEl, cb: onload, cbPayload: cbPayload };
        if (cachedImgObj) {
            image = cachedImgObj.image;
            !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
        }
        else {
            image = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad);
            image.__zrImageSrc = newImageOrSrc;
            globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
                image: image,
                pending: [pendingWrap]
            });
        }
        return image;
    }
    else {
        return newImageOrSrc;
    }
}
function imageOnLoad() {
    var cachedImgObj = this.__cachedImgObj;
    this.onload = this.onerror = this.__cachedImgObj = null;
    for (var i = 0; i < cachedImgObj.pending.length; i++) {
        var pendingWrap = cachedImgObj.pending[i];
        var cb = pendingWrap.cb;
        cb && cb(this, pendingWrap.cbPayload);
        pendingWrap.hostEl.dirty();
    }
    cachedImgObj.pending.length = 0;
}
function isImageReady(image) {
    return image && image.width && image.height;
}

var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function truncateText(text, containerWidth, font, ellipsis, options) {
    if (!containerWidth) {
        return '';
    }
    var textLines = (text + '').split('\n');
    options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
    for (var i = 0, len = textLines.length; i < len; i++) {
        textLines[i] = truncateSingleLine(textLines[i], options);
    }
    return textLines.join('\n');
}
function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
    options = options || {};
    var preparedOpts = extend$2({}, options);
    preparedOpts.font = font;
    ellipsis = retrieve2(ellipsis, '...');
    preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);
    var minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);
    preparedOpts.cnCharWidth = getWidth('国', font);
    var ascCharWidth = preparedOpts.ascCharWidth = getWidth('a', font);
    preparedOpts.placeholder = retrieve2(options.placeholder, '');
    var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
    for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
        contentWidth -= ascCharWidth;
    }
    var ellipsisWidth = getWidth(ellipsis, font);
    if (ellipsisWidth > contentWidth) {
        ellipsis = '';
        ellipsisWidth = 0;
    }
    contentWidth = containerWidth - ellipsisWidth;
    preparedOpts.ellipsis = ellipsis;
    preparedOpts.ellipsisWidth = ellipsisWidth;
    preparedOpts.contentWidth = contentWidth;
    preparedOpts.containerWidth = containerWidth;
    return preparedOpts;
}
function truncateSingleLine(textLine, options) {
    var containerWidth = options.containerWidth;
    var font = options.font;
    var contentWidth = options.contentWidth;
    if (!containerWidth) {
        return '';
    }
    var lineWidth = getWidth(textLine, font);
    if (lineWidth <= containerWidth) {
        return textLine;
    }
    for (var j = 0;; j++) {
        if (lineWidth <= contentWidth || j >= options.maxIterations) {
            textLine += options.ellipsis;
            break;
        }
        var subLength = j === 0
            ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)
            : lineWidth > 0
                ? Math.floor(textLine.length * contentWidth / lineWidth)
                : 0;
        textLine = textLine.substr(0, subLength);
        lineWidth = getWidth(textLine, font);
    }
    if (textLine === '') {
        textLine = options.placeholder;
    }
    return textLine;
}
function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
    var width = 0;
    var i = 0;
    for (var len = text.length; i < len && width < contentWidth; i++) {
        var charCode = text.charCodeAt(i);
        width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;
    }
    return i;
}
function parsePlainText(text, style) {
    text != null && (text += '');
    var overflow = style.overflow;
    var padding = style.padding;
    var font = style.font;
    var truncate = overflow === 'truncate';
    var calculatedLineHeight = getLineHeight(font);
    var lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);
    var bgColorDrawn = !!(style.backgroundColor);
    var truncateLineOverflow = style.lineOverflow === 'truncate';
    var width = style.width;
    var lines;
    if (width != null && (overflow === 'break' || overflow === 'breakAll')) {
        lines = text ? wrapText(text, style.font, width, overflow === 'breakAll', 0).lines : [];
    }
    else {
        lines = text ? text.split('\n') : [];
    }
    var contentHeight = lines.length * lineHeight;
    var height = retrieve2(style.height, contentHeight);
    if (contentHeight > height && truncateLineOverflow) {
        var lineCount = Math.floor(height / lineHeight);
        lines = lines.slice(0, lineCount);
    }
    if (text && truncate && width != null) {
        var options = prepareTruncateOptions(width, font, style.ellipsis, {
            minChar: style.truncateMinChar,
            placeholder: style.placeholder
        });
        for (var i = 0; i < lines.length; i++) {
            lines[i] = truncateSingleLine(lines[i], options);
        }
    }
    var outerHeight = height;
    var contentWidth = 0;
    for (var i = 0; i < lines.length; i++) {
        contentWidth = Math.max(getWidth(lines[i], font), contentWidth);
    }
    if (width == null) {
        width = contentWidth;
    }
    var outerWidth = contentWidth;
    if (padding) {
        outerHeight += padding[0] + padding[2];
        outerWidth += padding[1] + padding[3];
        width += padding[1] + padding[3];
    }
    if (bgColorDrawn) {
        outerWidth = width;
    }
    return {
        lines: lines,
        height: height,
        outerWidth: outerWidth,
        outerHeight: outerHeight,
        lineHeight: lineHeight,
        calculatedLineHeight: calculatedLineHeight,
        contentWidth: contentWidth,
        contentHeight: contentHeight,
        width: width
    };
}
var RichTextToken = (function () {
    function RichTextToken() {
    }
    return RichTextToken;
}());
var RichTextLine = (function () {
    function RichTextLine(tokens) {
        this.tokens = [];
        if (tokens) {
            this.tokens = tokens;
        }
    }
    return RichTextLine;
}());
var RichTextContentBlock = (function () {
    function RichTextContentBlock() {
        this.width = 0;
        this.height = 0;
        this.contentWidth = 0;
        this.contentHeight = 0;
        this.outerWidth = 0;
        this.outerHeight = 0;
        this.lines = [];
    }
    return RichTextContentBlock;
}());
function parseRichText(text, style) {
    var contentBlock = new RichTextContentBlock();
    text != null && (text += '');
    if (!text) {
        return contentBlock;
    }
    var topWidth = style.width;
    var topHeight = style.height;
    var overflow = style.overflow;
    var wrapInfo = (overflow === 'break' || overflow === 'breakAll') && topWidth != null
        ? { width: topWidth, accumWidth: 0, breakAll: overflow === 'breakAll' }
        : null;
    var lastIndex = STYLE_REG.lastIndex = 0;
    var result;
    while ((result = STYLE_REG.exec(text)) != null) {
        var matchedIndex = result.index;
        if (matchedIndex > lastIndex) {
            pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);
        }
        pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
        lastIndex = STYLE_REG.lastIndex;
    }
    if (lastIndex < text.length) {
        pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);
    }
    var pendingList = [];
    var calculatedHeight = 0;
    var calculatedWidth = 0;
    var stlPadding = style.padding;
    var truncate = overflow === 'truncate';
    var truncateLine = style.lineOverflow === 'truncate';
    function finishLine(line, lineWidth, lineHeight) {
        line.width = lineWidth;
        line.lineHeight = lineHeight;
        calculatedHeight += lineHeight;
        calculatedWidth = Math.max(calculatedWidth, lineWidth);
    }
    outer: for (var i = 0; i < contentBlock.lines.length; i++) {
        var line = contentBlock.lines[i];
        var lineHeight = 0;
        var lineWidth = 0;
        for (var j = 0; j < line.tokens.length; j++) {
            var token = line.tokens[j];
            var tokenStyle = token.styleName && style.rich[token.styleName] || {};
            var textPadding = token.textPadding = tokenStyle.padding;
            var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
            var font = token.font = tokenStyle.font || style.font;
            token.contentHeight = getLineHeight(font);
            var tokenHeight = retrieve2(tokenStyle.height, token.contentHeight);
            token.innerHeight = tokenHeight;
            textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
            token.height = tokenHeight;
            token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
            token.align = tokenStyle && tokenStyle.align || style.align;
            token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || 'middle';
            if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {
                if (j > 0) {
                    line.tokens = line.tokens.slice(0, j);
                    finishLine(line, lineWidth, lineHeight);
                    contentBlock.lines = contentBlock.lines.slice(0, i + 1);
                }
                else {
                    contentBlock.lines = contentBlock.lines.slice(0, i);
                }
                break outer;
            }
            var styleTokenWidth = tokenStyle.width;
            var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === 'auto';
            if (typeof styleTokenWidth === 'string' && styleTokenWidth.charAt(styleTokenWidth.length - 1) === '%') {
                token.percentWidth = styleTokenWidth;
                pendingList.push(token);
                token.contentWidth = getWidth(token.text, font);
            }
            else {
                if (tokenWidthNotSpecified) {
                    var textBackgroundColor = tokenStyle.backgroundColor;
                    var bgImg = textBackgroundColor && textBackgroundColor.image;
                    if (bgImg) {
                        bgImg = findExistImage(bgImg);
                        if (isImageReady(bgImg)) {
                            token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);
                        }
                    }
                }
                var remainTruncWidth = truncate && topWidth != null
                    ? topWidth - lineWidth : null;
                if (remainTruncWidth != null && remainTruncWidth < token.width) {
                    if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
                        token.text = '';
                        token.width = token.contentWidth = 0;
                    }
                    else {
                        token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });
                        token.width = token.contentWidth = getWidth(token.text, font);
                    }
                }
                else {
                    token.contentWidth = getWidth(token.text, font);
                }
            }
            token.width += paddingH;
            lineWidth += token.width;
            tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
        }
        finishLine(line, lineWidth, lineHeight);
    }
    contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);
    contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);
    contentBlock.contentHeight = calculatedHeight;
    contentBlock.contentWidth = calculatedWidth;
    if (stlPadding) {
        contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
        contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
    }
    for (var i = 0; i < pendingList.length; i++) {
        var token = pendingList[i];
        var percentWidth = token.percentWidth;
        token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
    }
    return contentBlock;
}
function pushTokens(block, str, style, wrapInfo, styleName) {
    var isEmptyStr = str === '';
    var tokenStyle = styleName && style.rich[styleName] || {};
    var lines = block.lines;
    var font = tokenStyle.font || style.font;
    var newLine = false;
    var strLines;
    var linesWidths;
    if (wrapInfo) {
        var tokenPadding = tokenStyle.padding;
        var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
        if (tokenStyle.width != null && tokenStyle.width !== 'auto') {
            var outerWidth_1 = parsePercent$1(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
            if (lines.length > 0) {
                if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {
                    strLines = str.split('\n');
                    newLine = true;
                }
            }
            wrapInfo.accumWidth = outerWidth_1;
        }
        else {
            var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
            wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
            linesWidths = res.linesWidths;
            strLines = res.lines;
        }
    }
    else {
        strLines = str.split('\n');
    }
    for (var i = 0; i < strLines.length; i++) {
        var text = strLines[i];
        var token = new RichTextToken();
        token.styleName = styleName;
        token.text = text;
        token.isLineHolder = !text && !isEmptyStr;
        if (typeof tokenStyle.width === 'number') {
            token.width = tokenStyle.width;
        }
        else {
            token.width = linesWidths
                ? linesWidths[i]
                : getWidth(text, font);
        }
        if (!i && !newLine) {
            var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;
            var tokensLen = tokens.length;
            (tokensLen === 1 && tokens[0].isLineHolder)
                ? (tokens[0] = token)
                : ((text || !tokensLen || isEmptyStr) && tokens.push(token));
        }
        else {
            lines.push(new RichTextLine([token]));
        }
    }
}
function isLatin(ch) {
    var code = ch.charCodeAt(0);
    return code >= 0x21 && code <= 0x17F;
}
var breakCharMap = reduce(',&?/;] '.split(''), function (obj, ch) {
    obj[ch] = true;
    return obj;
}, {});
function isWordBreakChar(ch) {
    if (isLatin(ch)) {
        if (breakCharMap[ch]) {
            return true;
        }
        return false;
    }
    return true;
}
function wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {
    var lines = [];
    var linesWidths = [];
    var line = '';
    var currentWord = '';
    var currentWordWidth = 0;
    var accumWidth = 0;
    for (var i = 0; i < text.length; i++) {
        var ch = text.charAt(i);
        if (ch === '\n') {
            if (currentWord) {
                line += currentWord;
                accumWidth += currentWordWidth;
            }
            lines.push(line);
            linesWidths.push(accumWidth);
            line = '';
            currentWord = '';
            currentWordWidth = 0;
            accumWidth = 0;
            continue;
        }
        var chWidth = getWidth(ch, font);
        var inWord = isBreakAll ? false : !isWordBreakChar(ch);
        if (!lines.length
            ? lastAccumWidth + accumWidth + chWidth > lineWidth
            : accumWidth + chWidth > lineWidth) {
            if (!accumWidth) {
                if (inWord) {
                    lines.push(currentWord);
                    linesWidths.push(currentWordWidth);
                    currentWord = ch;
                    currentWordWidth = chWidth;
                }
                else {
                    lines.push(ch);
                    linesWidths.push(chWidth);
                }
            }
            else if (line || currentWord) {
                if (inWord) {
                    if (!line) {
                        line = currentWord;
                        currentWord = '';
                        currentWordWidth = 0;
                        accumWidth = currentWordWidth;
                    }
                    lines.push(line);
                    linesWidths.push(accumWidth - currentWordWidth);
                    currentWord += ch;
                    currentWordWidth += chWidth;
                    line = '';
                    accumWidth = currentWordWidth;
                }
                else {
                    if (currentWord) {
                        line += currentWord;
                        currentWord = '';
                        currentWordWidth = 0;
                    }
                    lines.push(line);
                    linesWidths.push(accumWidth);
                    line = ch;
                    accumWidth = chWidth;
                }
            }
            continue;
        }
        accumWidth += chWidth;
        if (inWord) {
            currentWord += ch;
            currentWordWidth += chWidth;
        }
        else {
            if (currentWord) {
                line += currentWord;
                currentWord = '';
                currentWordWidth = 0;
            }
            line += ch;
        }
    }
    if (!lines.length && !line) {
        line = text;
        currentWord = '';
        currentWordWidth = 0;
    }
    if (currentWord) {
        line += currentWord;
    }
    if (line) {
        lines.push(line);
        linesWidths.push(accumWidth);
    }
    if (lines.length === 1) {
        accumWidth += lastAccumWidth;
    }
    return {
        accumWidth: accumWidth,
        lines: lines,
        linesWidths: linesWidths
    };
}

var STYLE_MAGIC_KEY = '__zr_style_' + Math.round((Math.random() * 10));
var DEFAULT_COMMON_STYLE = {
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: '#000',
    opacity: 1,
    blend: 'source-over'
};
var DEFAULT_COMMON_ANIMATION_PROPS = {
    style: {
        shadowBlur: true,
        shadowOffsetX: true,
        shadowOffsetY: true,
        shadowColor: true,
        opacity: true
    }
};
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
var PRIMARY_STATES_KEYS = ['z', 'z2', 'invisible'];
var PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ['invisible'];
var Displayable = (function (_super) {
    __extends(Displayable, _super);
    function Displayable(props) {
        return _super.call(this, props) || this;
    }
    Displayable.prototype._init = function (props) {
        var keysArr = keys(props);
        for (var i = 0; i < keysArr.length; i++) {
            var key = keysArr[i];
            if (key === 'style') {
                this.useStyle(props[key]);
            }
            else {
                _super.prototype.attrKV.call(this, key, props[key]);
            }
        }
        if (!this.style) {
            this.useStyle({});
        }
    };
    Displayable.prototype.beforeBrush = function () { };
    Displayable.prototype.afterBrush = function () { };
    Displayable.prototype.innerBeforeBrush = function () { };
    Displayable.prototype.innerAfterBrush = function () { };
    Displayable.prototype.shouldBePainted = function (viewWidth, viewHeight, considerClipPath, considerAncestors) {
        var m = this.transform;
        if (this.ignore
            || this.invisible
            || this.style.opacity === 0
            || (this.culling
                && isDisplayableCulled(this, viewWidth, viewHeight))
            || (m && !m[0] && !m[3])) {
            return false;
        }
        if (considerClipPath && this.__clipPaths) {
            for (var i = 0; i < this.__clipPaths.length; ++i) {
                if (this.__clipPaths[i].isZeroArea()) {
                    return false;
                }
            }
        }
        if (considerAncestors && this.parent) {
            var parent_1 = this.parent;
            while (parent_1) {
                if (parent_1.ignore) {
                    return false;
                }
                parent_1 = parent_1.parent;
            }
        }
        return true;
    };
    Displayable.prototype.contain = function (x, y) {
        return this.rectContain(x, y);
    };
    Displayable.prototype.traverse = function (cb, context) {
        cb.call(context, this);
    };
    Displayable.prototype.rectContain = function (x, y) {
        var coord = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        return rect.contain(coord[0], coord[1]);
    };
    Displayable.prototype.getPaintRect = function () {
        var rect = this._paintRect;
        if (!this._paintRect || this.__dirty) {
            var transform = this.transform;
            var elRect = this.getBoundingRect();
            var style = this.style;
            var shadowSize = style.shadowBlur || 0;
            var shadowOffsetX = style.shadowOffsetX || 0;
            var shadowOffsetY = style.shadowOffsetY || 0;
            rect = this._paintRect || (this._paintRect = new BoundingRect$1(0, 0, 0, 0));
            if (transform) {
                BoundingRect$1.applyTransform(rect, elRect, transform);
            }
            else {
                rect.copy(elRect);
            }
            if (shadowSize || shadowOffsetX || shadowOffsetY) {
                rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
                rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
                rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
                rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
            }
            var tolerance = this.dirtyRectTolerance;
            if (!rect.isZero()) {
                rect.x = Math.floor(rect.x - tolerance);
                rect.y = Math.floor(rect.y - tolerance);
                rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
                rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
            }
        }
        return rect;
    };
    Displayable.prototype.setPrevPaintRect = function (paintRect) {
        if (paintRect) {
            this._prevPaintRect = this._prevPaintRect || new BoundingRect$1(0, 0, 0, 0);
            this._prevPaintRect.copy(paintRect);
        }
        else {
            this._prevPaintRect = null;
        }
    };
    Displayable.prototype.getPrevPaintRect = function () {
        return this._prevPaintRect;
    };
    Displayable.prototype.animateStyle = function (loop) {
        return this.animate('style', loop);
    };
    Displayable.prototype.updateDuringAnimation = function (targetKey) {
        if (targetKey === 'style') {
            this.dirtyStyle();
        }
        else {
            this.markRedraw();
        }
    };
    Displayable.prototype.attrKV = function (key, value) {
        if (key !== 'style') {
            _super.prototype.attrKV.call(this, key, value);
        }
        else {
            if (!this.style) {
                this.useStyle(value);
            }
            else {
                this.setStyle(value);
            }
        }
    };
    Displayable.prototype.setStyle = function (keyOrObj, value) {
        if (typeof keyOrObj === 'string') {
            this.style[keyOrObj] = value;
        }
        else {
            extend$2(this.style, keyOrObj);
        }
        this.dirtyStyle();
        return this;
    };
    Displayable.prototype.dirtyStyle = function (notRedraw) {
        if (!notRedraw) {
            this.markRedraw();
        }
        this.__dirty |= STYLE_CHANGED_BIT;
        if (this._rect) {
            this._rect = null;
        }
    };
    Displayable.prototype.dirty = function () {
        this.dirtyStyle();
    };
    Displayable.prototype.styleChanged = function () {
        return !!(this.__dirty & STYLE_CHANGED_BIT);
    };
    Displayable.prototype.styleUpdated = function () {
        this.__dirty &= ~STYLE_CHANGED_BIT;
    };
    Displayable.prototype.createStyle = function (obj) {
        return createObject(DEFAULT_COMMON_STYLE, obj);
    };
    Displayable.prototype.useStyle = function (obj) {
        if (!obj[STYLE_MAGIC_KEY]) {
            obj = this.createStyle(obj);
        }
        if (this.__inHover) {
            this.__hoverStyle = obj;
        }
        else {
            this.style = obj;
        }
        this.dirtyStyle();
    };
    Displayable.prototype.isStyleObject = function (obj) {
        return obj[STYLE_MAGIC_KEY];
    };
    Displayable.prototype._innerSaveToNormal = function (toState) {
        _super.prototype._innerSaveToNormal.call(this, toState);
        var normalState = this._normalState;
        if (toState.style && !normalState.style) {
            normalState.style = this._mergeStyle(this.createStyle(), this.style);
        }
        this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
    };
    Displayable.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
        _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
        var needsRestoreToNormal = !(state && keepCurrentStates);
        var targetStyle;
        if (state && state.style) {
            if (transition) {
                if (keepCurrentStates) {
                    targetStyle = state.style;
                }
                else {
                    targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
                    this._mergeStyle(targetStyle, state.style);
                }
            }
            else {
                targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
                this._mergeStyle(targetStyle, state.style);
            }
        }
        else if (needsRestoreToNormal) {
            targetStyle = normalState.style;
        }
        if (targetStyle) {
            if (transition) {
                var sourceStyle = this.style;
                this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
                if (needsRestoreToNormal) {
                    var changedKeys = keys(sourceStyle);
                    for (var i = 0; i < changedKeys.length; i++) {
                        var key = changedKeys[i];
                        if (key in targetStyle) {
                            targetStyle[key] = targetStyle[key];
                            this.style[key] = sourceStyle[key];
                        }
                    }
                }
                var targetKeys = keys(targetStyle);
                for (var i = 0; i < targetKeys.length; i++) {
                    var key = targetKeys[i];
                    this.style[key] = this.style[key];
                }
                this._transitionState(stateName, {
                    style: targetStyle
                }, animationCfg, this.getAnimationStyleProps());
            }
            else {
                this.useStyle(targetStyle);
            }
        }
        var statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS;
        for (var i = 0; i < statesKeys.length; i++) {
            var key = statesKeys[i];
            if (state && state[key] != null) {
                this[key] = state[key];
            }
            else if (needsRestoreToNormal) {
                if (normalState[key] != null) {
                    this[key] = normalState[key];
                }
            }
        }
    };
    Displayable.prototype._mergeStates = function (states) {
        var mergedState = _super.prototype._mergeStates.call(this, states);
        var mergedStyle;
        for (var i = 0; i < states.length; i++) {
            var state = states[i];
            if (state.style) {
                mergedStyle = mergedStyle || {};
                this._mergeStyle(mergedStyle, state.style);
            }
        }
        if (mergedStyle) {
            mergedState.style = mergedStyle;
        }
        return mergedState;
    };
    Displayable.prototype._mergeStyle = function (targetStyle, sourceStyle) {
        extend$2(targetStyle, sourceStyle);
        return targetStyle;
    };
    Displayable.prototype.getAnimationStyleProps = function () {
        return DEFAULT_COMMON_ANIMATION_PROPS;
    };
    Displayable.initDefaultProps = (function () {
        var dispProto = Displayable.prototype;
        dispProto.type = 'displayable';
        dispProto.invisible = false;
        dispProto.z = 0;
        dispProto.z2 = 0;
        dispProto.zlevel = 0;
        dispProto.culling = false;
        dispProto.cursor = 'pointer';
        dispProto.rectHover = false;
        dispProto.incremental = false;
        dispProto._rect = null;
        dispProto.dirtyRectTolerance = 0;
        dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
    })();
    return Displayable;
}(Element$1));
var tmpRect = new BoundingRect$1(0, 0, 0, 0);
var viewRect = new BoundingRect$1(0, 0, 0, 0);
function isDisplayableCulled(el, width, height) {
    tmpRect.copy(el.getBoundingRect());
    if (el.transform) {
        tmpRect.applyTransform(el.transform);
    }
    viewRect.width = width;
    viewRect.height = height;
    return !tmpRect.intersect(viewRect);
}
var Displayable$1 = Displayable;

var mathMin$6 = Math.min;
var mathMax$6 = Math.max;
var mathSin$3 = Math.sin;
var mathCos$3 = Math.cos;
var PI2$6 = Math.PI * 2;
var start = create$1();
var end = create$1();
var extremity = create$1();
function fromLine(x0, y0, x1, y1, min, max) {
    min[0] = mathMin$6(x0, x1);
    min[1] = mathMin$6(y0, y1);
    max[0] = mathMax$6(x0, x1);
    max[1] = mathMax$6(y0, y1);
}
var xDim = [];
var yDim = [];
function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
    var cubicExtrema$1 = cubicExtrema;
    var cubicAt$1 = cubicAt;
    var n = cubicExtrema$1(x0, x1, x2, x3, xDim);
    min[0] = Infinity;
    min[1] = Infinity;
    max[0] = -Infinity;
    max[1] = -Infinity;
    for (var i = 0; i < n; i++) {
        var x = cubicAt$1(x0, x1, x2, x3, xDim[i]);
        min[0] = mathMin$6(x, min[0]);
        max[0] = mathMax$6(x, max[0]);
    }
    n = cubicExtrema$1(y0, y1, y2, y3, yDim);
    for (var i = 0; i < n; i++) {
        var y = cubicAt$1(y0, y1, y2, y3, yDim[i]);
        min[1] = mathMin$6(y, min[1]);
        max[1] = mathMax$6(y, max[1]);
    }
    min[0] = mathMin$6(x0, min[0]);
    max[0] = mathMax$6(x0, max[0]);
    min[0] = mathMin$6(x3, min[0]);
    max[0] = mathMax$6(x3, max[0]);
    min[1] = mathMin$6(y0, min[1]);
    max[1] = mathMax$6(y0, max[1]);
    min[1] = mathMin$6(y3, min[1]);
    max[1] = mathMax$6(y3, max[1]);
}
function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
    var quadraticExtremum$1 = quadraticExtremum;
    var quadraticAt$1 = quadraticAt;
    var tx = mathMax$6(mathMin$6(quadraticExtremum$1(x0, x1, x2), 1), 0);
    var ty = mathMax$6(mathMin$6(quadraticExtremum$1(y0, y1, y2), 1), 0);
    var x = quadraticAt$1(x0, x1, x2, tx);
    var y = quadraticAt$1(y0, y1, y2, ty);
    min[0] = mathMin$6(x0, x2, x);
    min[1] = mathMin$6(y0, y2, y);
    max[0] = mathMax$6(x0, x2, x);
    max[1] = mathMax$6(y0, y2, y);
}
function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
    var vec2Min = min$1;
    var vec2Max = max$1;
    var diff = Math.abs(startAngle - endAngle);
    if (diff % PI2$6 < 1e-4 && diff > 1e-4) {
        min[0] = x - rx;
        min[1] = y - ry;
        max[0] = x + rx;
        max[1] = y + ry;
        return;
    }
    start[0] = mathCos$3(startAngle) * rx + x;
    start[1] = mathSin$3(startAngle) * ry + y;
    end[0] = mathCos$3(endAngle) * rx + x;
    end[1] = mathSin$3(endAngle) * ry + y;
    vec2Min(min, start, end);
    vec2Max(max, start, end);
    startAngle = startAngle % (PI2$6);
    if (startAngle < 0) {
        startAngle = startAngle + PI2$6;
    }
    endAngle = endAngle % (PI2$6);
    if (endAngle < 0) {
        endAngle = endAngle + PI2$6;
    }
    if (startAngle > endAngle && !anticlockwise) {
        endAngle += PI2$6;
    }
    else if (startAngle < endAngle && anticlockwise) {
        startAngle += PI2$6;
    }
    if (anticlockwise) {
        var tmp = endAngle;
        endAngle = startAngle;
        startAngle = tmp;
    }
    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
        if (angle > startAngle) {
            extremity[0] = mathCos$3(angle) * rx + x;
            extremity[1] = mathSin$3(angle) * ry + y;
            vec2Min(min, extremity, min);
            vec2Max(max, extremity, max);
        }
    }
}

var CMD$2 = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    R: 7
};
var tmpOutX = [];
var tmpOutY = [];
var min = [];
var max = [];
var min2 = [];
var max2 = [];
var mathMin$5 = Math.min;
var mathMax$5 = Math.max;
var mathCos$2 = Math.cos;
var mathSin$2 = Math.sin;
var mathAbs$1 = Math.abs;
var PI$4 = Math.PI;
var PI2$5 = PI$4 * 2;
var hasTypedArray = typeof Float32Array !== 'undefined';
var tmpAngles = [];
function modPI2(radian) {
    var n = Math.round(radian / PI$4 * 1e8) / 1e8;
    return (n % 2) * PI$4;
}
function normalizeArcAngles(angles, anticlockwise) {
    var newStartAngle = modPI2(angles[0]);
    if (newStartAngle < 0) {
        newStartAngle += PI2$5;
    }
    var delta = newStartAngle - angles[0];
    var newEndAngle = angles[1];
    newEndAngle += delta;
    if (!anticlockwise && newEndAngle - newStartAngle >= PI2$5) {
        newEndAngle = newStartAngle + PI2$5;
    }
    else if (anticlockwise && newStartAngle - newEndAngle >= PI2$5) {
        newEndAngle = newStartAngle - PI2$5;
    }
    else if (!anticlockwise && newStartAngle > newEndAngle) {
        newEndAngle = newStartAngle + (PI2$5 - modPI2(newStartAngle - newEndAngle));
    }
    else if (anticlockwise && newStartAngle < newEndAngle) {
        newEndAngle = newStartAngle - (PI2$5 - modPI2(newEndAngle - newStartAngle));
    }
    angles[0] = newStartAngle;
    angles[1] = newEndAngle;
}
var PathProxy = (function () {
    function PathProxy(notSaveData) {
        this.dpr = 1;
        this._xi = 0;
        this._yi = 0;
        this._x0 = 0;
        this._y0 = 0;
        this._len = 0;
        if (notSaveData) {
            this._saveData = false;
        }
        if (this._saveData) {
            this.data = [];
        }
    }
    PathProxy.prototype.increaseVersion = function () {
        this._version++;
    };
    PathProxy.prototype.getVersion = function () {
        return this._version;
    };
    PathProxy.prototype.setScale = function (sx, sy, segmentIgnoreThreshold) {
        segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
        if (segmentIgnoreThreshold > 0) {
            this._ux = mathAbs$1(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;
            this._uy = mathAbs$1(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;
        }
    };
    PathProxy.prototype.setDPR = function (dpr) {
        this.dpr = dpr;
    };
    PathProxy.prototype.setContext = function (ctx) {
        this._ctx = ctx;
    };
    PathProxy.prototype.getContext = function () {
        return this._ctx;
    };
    PathProxy.prototype.beginPath = function () {
        this._ctx && this._ctx.beginPath();
        this.reset();
        return this;
    };
    PathProxy.prototype.reset = function () {
        if (this._saveData) {
            this._len = 0;
        }
        if (this._pathSegLen) {
            this._pathSegLen = null;
            this._pathLen = 0;
        }
        this._version++;
    };
    PathProxy.prototype.moveTo = function (x, y) {
        this._drawPendingPt();
        this.addData(CMD$2.M, x, y);
        this._ctx && this._ctx.moveTo(x, y);
        this._x0 = x;
        this._y0 = y;
        this._xi = x;
        this._yi = y;
        return this;
    };
    PathProxy.prototype.lineTo = function (x, y) {
        var dx = mathAbs$1(x - this._xi);
        var dy = mathAbs$1(y - this._yi);
        var exceedUnit = dx > this._ux || dy > this._uy;
        this.addData(CMD$2.L, x, y);
        if (this._ctx && exceedUnit) {
            this._ctx.lineTo(x, y);
        }
        if (exceedUnit) {
            this._xi = x;
            this._yi = y;
            this._pendingPtDist = 0;
        }
        else {
            var d2 = dx * dx + dy * dy;
            if (d2 > this._pendingPtDist) {
                this._pendingPtX = x;
                this._pendingPtY = y;
                this._pendingPtDist = d2;
            }
        }
        return this;
    };
    PathProxy.prototype.bezierCurveTo = function (x1, y1, x2, y2, x3, y3) {
        this._drawPendingPt();
        this.addData(CMD$2.C, x1, y1, x2, y2, x3, y3);
        if (this._ctx) {
            this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }
        this._xi = x3;
        this._yi = y3;
        return this;
    };
    PathProxy.prototype.quadraticCurveTo = function (x1, y1, x2, y2) {
        this._drawPendingPt();
        this.addData(CMD$2.Q, x1, y1, x2, y2);
        if (this._ctx) {
            this._ctx.quadraticCurveTo(x1, y1, x2, y2);
        }
        this._xi = x2;
        this._yi = y2;
        return this;
    };
    PathProxy.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {
        this._drawPendingPt();
        tmpAngles[0] = startAngle;
        tmpAngles[1] = endAngle;
        normalizeArcAngles(tmpAngles, anticlockwise);
        startAngle = tmpAngles[0];
        endAngle = tmpAngles[1];
        var delta = endAngle - startAngle;
        this.addData(CMD$2.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1);
        this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
        this._xi = mathCos$2(endAngle) * r + cx;
        this._yi = mathSin$2(endAngle) * r + cy;
        return this;
    };
    PathProxy.prototype.arcTo = function (x1, y1, x2, y2, radius) {
        this._drawPendingPt();
        if (this._ctx) {
            this._ctx.arcTo(x1, y1, x2, y2, radius);
        }
        return this;
    };
    PathProxy.prototype.rect = function (x, y, w, h) {
        this._drawPendingPt();
        this._ctx && this._ctx.rect(x, y, w, h);
        this.addData(CMD$2.R, x, y, w, h);
        return this;
    };
    PathProxy.prototype.closePath = function () {
        this._drawPendingPt();
        this.addData(CMD$2.Z);
        var ctx = this._ctx;
        var x0 = this._x0;
        var y0 = this._y0;
        if (ctx) {
            ctx.closePath();
        }
        this._xi = x0;
        this._yi = y0;
        return this;
    };
    PathProxy.prototype.fill = function (ctx) {
        ctx && ctx.fill();
        this.toStatic();
    };
    PathProxy.prototype.stroke = function (ctx) {
        ctx && ctx.stroke();
        this.toStatic();
    };
    PathProxy.prototype.len = function () {
        return this._len;
    };
    PathProxy.prototype.setData = function (data) {
        var len = data.length;
        if (!(this.data && this.data.length === len) && hasTypedArray) {
            this.data = new Float32Array(len);
        }
        for (var i = 0; i < len; i++) {
            this.data[i] = data[i];
        }
        this._len = len;
    };
    PathProxy.prototype.appendPath = function (path) {
        if (!(path instanceof Array)) {
            path = [path];
        }
        var len = path.length;
        var appendSize = 0;
        var offset = this._len;
        for (var i = 0; i < len; i++) {
            appendSize += path[i].len();
        }
        if (hasTypedArray && (this.data instanceof Float32Array)) {
            this.data = new Float32Array(offset + appendSize);
        }
        for (var i = 0; i < len; i++) {
            var appendPathData = path[i].data;
            for (var k = 0; k < appendPathData.length; k++) {
                this.data[offset++] = appendPathData[k];
            }
        }
        this._len = offset;
    };
    PathProxy.prototype.addData = function (cmd, a, b, c, d, e, f, g, h) {
        if (!this._saveData) {
            return;
        }
        var data = this.data;
        if (this._len + arguments.length > data.length) {
            this._expandData();
            data = this.data;
        }
        for (var i = 0; i < arguments.length; i++) {
            data[this._len++] = arguments[i];
        }
    };
    PathProxy.prototype._drawPendingPt = function () {
        if (this._pendingPtDist > 0) {
            this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY);
            this._pendingPtDist = 0;
        }
    };
    PathProxy.prototype._expandData = function () {
        if (!(this.data instanceof Array)) {
            var newData = [];
            for (var i = 0; i < this._len; i++) {
                newData[i] = this.data[i];
            }
            this.data = newData;
        }
    };
    PathProxy.prototype.toStatic = function () {
        if (!this._saveData) {
            return;
        }
        this._drawPendingPt();
        var data = this.data;
        if (data instanceof Array) {
            data.length = this._len;
            if (hasTypedArray && this._len > 11) {
                this.data = new Float32Array(data);
            }
        }
    };
    PathProxy.prototype.getBoundingRect = function () {
        min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
        max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
        var data = this.data;
        var xi = 0;
        var yi = 0;
        var x0 = 0;
        var y0 = 0;
        var i;
        for (i = 0; i < this._len;) {
            var cmd = data[i++];
            var isFirst = i === 1;
            if (isFirst) {
                xi = data[i];
                yi = data[i + 1];
                x0 = xi;
                y0 = yi;
            }
            switch (cmd) {
                case CMD$2.M:
                    xi = x0 = data[i++];
                    yi = y0 = data[i++];
                    min2[0] = x0;
                    min2[1] = y0;
                    max2[0] = x0;
                    max2[1] = y0;
                    break;
                case CMD$2.L:
                    fromLine(xi, yi, data[i], data[i + 1], min2, max2);
                    xi = data[i++];
                    yi = data[i++];
                    break;
                case CMD$2.C:
                    fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
                    xi = data[i++];
                    yi = data[i++];
                    break;
                case CMD$2.Q:
                    fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
                    xi = data[i++];
                    yi = data[i++];
                    break;
                case CMD$2.A:
                    var cx = data[i++];
                    var cy = data[i++];
                    var rx = data[i++];
                    var ry = data[i++];
                    var startAngle = data[i++];
                    var endAngle = data[i++] + startAngle;
                    i += 1;
                    var anticlockwise = !data[i++];
                    if (isFirst) {
                        x0 = mathCos$2(startAngle) * rx + cx;
                        y0 = mathSin$2(startAngle) * ry + cy;
                    }
                    fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
                    xi = mathCos$2(endAngle) * rx + cx;
                    yi = mathSin$2(endAngle) * ry + cy;
                    break;
                case CMD$2.R:
                    x0 = xi = data[i++];
                    y0 = yi = data[i++];
                    var width = data[i++];
                    var height = data[i++];
                    fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
                    break;
                case CMD$2.Z:
                    xi = x0;
                    yi = y0;
                    break;
            }
            min$1(min, min, min2);
            max$1(max, max, max2);
        }
        if (i === 0) {
            min[0] = min[1] = max[0] = max[1] = 0;
        }
        return new BoundingRect$1(min[0], min[1], max[0] - min[0], max[1] - min[1]);
    };
    PathProxy.prototype._calculateLength = function () {
        var data = this.data;
        var len = this._len;
        var ux = this._ux;
        var uy = this._uy;
        var xi = 0;
        var yi = 0;
        var x0 = 0;
        var y0 = 0;
        if (!this._pathSegLen) {
            this._pathSegLen = [];
        }
        var pathSegLen = this._pathSegLen;
        var pathTotalLen = 0;
        var segCount = 0;
        for (var i = 0; i < len;) {
            var cmd = data[i++];
            var isFirst = i === 1;
            if (isFirst) {
                xi = data[i];
                yi = data[i + 1];
                x0 = xi;
                y0 = yi;
            }
            var l = -1;
            switch (cmd) {
                case CMD$2.M:
                    xi = x0 = data[i++];
                    yi = y0 = data[i++];
                    break;
                case CMD$2.L: {
                    var x2 = data[i++];
                    var y2 = data[i++];
                    var dx = x2 - xi;
                    var dy = y2 - yi;
                    if (mathAbs$1(dx) > ux || mathAbs$1(dy) > uy || i === len - 1) {
                        l = Math.sqrt(dx * dx + dy * dy);
                        xi = x2;
                        yi = y2;
                    }
                    break;
                }
                case CMD$2.C: {
                    var x1 = data[i++];
                    var y1 = data[i++];
                    var x2 = data[i++];
                    var y2 = data[i++];
                    var x3 = data[i++];
                    var y3 = data[i++];
                    l = cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);
                    xi = x3;
                    yi = y3;
                    break;
                }
                case CMD$2.Q: {
                    var x1 = data[i++];
                    var y1 = data[i++];
                    var x2 = data[i++];
                    var y2 = data[i++];
                    l = quadraticLength(xi, yi, x1, y1, x2, y2, 10);
                    xi = x2;
                    yi = y2;
                    break;
                }
                case CMD$2.A:
                    var cx = data[i++];
                    var cy = data[i++];
                    var rx = data[i++];
                    var ry = data[i++];
                    var startAngle = data[i++];
                    var delta = data[i++];
                    var endAngle = delta + startAngle;
                    i += 1;
                    !data[i++];
                    if (isFirst) {
                        x0 = mathCos$2(startAngle) * rx + cx;
                        y0 = mathSin$2(startAngle) * ry + cy;
                    }
                    l = mathMax$5(rx, ry) * mathMin$5(PI2$5, Math.abs(delta));
                    xi = mathCos$2(endAngle) * rx + cx;
                    yi = mathSin$2(endAngle) * ry + cy;
                    break;
                case CMD$2.R: {
                    x0 = xi = data[i++];
                    y0 = yi = data[i++];
                    var width = data[i++];
                    var height = data[i++];
                    l = width * 2 + height * 2;
                    break;
                }
                case CMD$2.Z: {
                    var dx = x0 - xi;
                    var dy = y0 - yi;
                    l = Math.sqrt(dx * dx + dy * dy);
                    xi = x0;
                    yi = y0;
                    break;
                }
            }
            if (l >= 0) {
                pathSegLen[segCount++] = l;
                pathTotalLen += l;
            }
        }
        this._pathLen = pathTotalLen;
        return pathTotalLen;
    };
    PathProxy.prototype.rebuildPath = function (ctx, percent) {
        var d = this.data;
        var ux = this._ux;
        var uy = this._uy;
        var len = this._len;
        var x0;
        var y0;
        var xi;
        var yi;
        var x;
        var y;
        var drawPart = percent < 1;
        var pathSegLen;
        var pathTotalLen;
        var accumLength = 0;
        var segCount = 0;
        var displayedLength;
        var pendingPtDist = 0;
        var pendingPtX;
        var pendingPtY;
        if (drawPart) {
            if (!this._pathSegLen) {
                this._calculateLength();
            }
            pathSegLen = this._pathSegLen;
            pathTotalLen = this._pathLen;
            displayedLength = percent * pathTotalLen;
            if (!displayedLength) {
                return;
            }
        }
        lo: for (var i = 0; i < len;) {
            var cmd = d[i++];
            var isFirst = i === 1;
            if (isFirst) {
                xi = d[i];
                yi = d[i + 1];
                x0 = xi;
                y0 = yi;
            }
            if (cmd !== CMD$2.L && pendingPtDist > 0) {
                ctx.lineTo(pendingPtX, pendingPtY);
                pendingPtDist = 0;
            }
            switch (cmd) {
                case CMD$2.M:
                    x0 = xi = d[i++];
                    y0 = yi = d[i++];
                    ctx.moveTo(xi, yi);
                    break;
                case CMD$2.L: {
                    x = d[i++];
                    y = d[i++];
                    var dx = mathAbs$1(x - xi);
                    var dy = mathAbs$1(y - yi);
                    if (dx > ux || dy > uy) {
                        if (drawPart) {
                            var l = pathSegLen[segCount++];
                            if (accumLength + l > displayedLength) {
                                var t = (displayedLength - accumLength) / l;
                                ctx.lineTo(xi * (1 - t) + x * t, yi * (1 - t) + y * t);
                                break lo;
                            }
                            accumLength += l;
                        }
                        ctx.lineTo(x, y);
                        xi = x;
                        yi = y;
                        pendingPtDist = 0;
                    }
                    else {
                        var d2 = dx * dx + dy * dy;
                        if (d2 > pendingPtDist) {
                            pendingPtX = x;
                            pendingPtY = y;
                            pendingPtDist = d2;
                        }
                    }
                    break;
                }
                case CMD$2.C: {
                    var x1 = d[i++];
                    var y1 = d[i++];
                    var x2 = d[i++];
                    var y2 = d[i++];
                    var x3 = d[i++];
                    var y3 = d[i++];
                    if (drawPart) {
                        var l = pathSegLen[segCount++];
                        if (accumLength + l > displayedLength) {
                            var t = (displayedLength - accumLength) / l;
                            cubicSubdivide(xi, x1, x2, x3, t, tmpOutX);
                            cubicSubdivide(yi, y1, y2, y3, t, tmpOutY);
                            ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                            break lo;
                        }
                        accumLength += l;
                    }
                    ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
                    xi = x3;
                    yi = y3;
                    break;
                }
                case CMD$2.Q: {
                    var x1 = d[i++];
                    var y1 = d[i++];
                    var x2 = d[i++];
                    var y2 = d[i++];
                    if (drawPart) {
                        var l = pathSegLen[segCount++];
                        if (accumLength + l > displayedLength) {
                            var t = (displayedLength - accumLength) / l;
                            quadraticSubdivide(xi, x1, x2, t, tmpOutX);
                            quadraticSubdivide(yi, y1, y2, t, tmpOutY);
                            ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                            break lo;
                        }
                        accumLength += l;
                    }
                    ctx.quadraticCurveTo(x1, y1, x2, y2);
                    xi = x2;
                    yi = y2;
                    break;
                }
                case CMD$2.A:
                    var cx = d[i++];
                    var cy = d[i++];
                    var rx = d[i++];
                    var ry = d[i++];
                    var startAngle = d[i++];
                    var delta = d[i++];
                    var psi = d[i++];
                    var anticlockwise = !d[i++];
                    var r = (rx > ry) ? rx : ry;
                    var isEllipse = mathAbs$1(rx - ry) > 1e-3;
                    var endAngle = startAngle + delta;
                    var breakBuild = false;
                    if (drawPart) {
                        var l = pathSegLen[segCount++];
                        if (accumLength + l > displayedLength) {
                            endAngle = startAngle + delta * (displayedLength - accumLength) / l;
                            breakBuild = true;
                        }
                        accumLength += l;
                    }
                    if (isEllipse && ctx.ellipse) {
                        ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
                    }
                    else {
                        ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
                    }
                    if (breakBuild) {
                        break lo;
                    }
                    if (isFirst) {
                        x0 = mathCos$2(startAngle) * rx + cx;
                        y0 = mathSin$2(startAngle) * ry + cy;
                    }
                    xi = mathCos$2(endAngle) * rx + cx;
                    yi = mathSin$2(endAngle) * ry + cy;
                    break;
                case CMD$2.R:
                    x0 = xi = d[i];
                    y0 = yi = d[i + 1];
                    x = d[i++];
                    y = d[i++];
                    var width = d[i++];
                    var height = d[i++];
                    if (drawPart) {
                        var l = pathSegLen[segCount++];
                        if (accumLength + l > displayedLength) {
                            var d_1 = displayedLength - accumLength;
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + mathMin$5(d_1, width), y);
                            d_1 -= width;
                            if (d_1 > 0) {
                                ctx.lineTo(x + width, y + mathMin$5(d_1, height));
                            }
                            d_1 -= height;
                            if (d_1 > 0) {
                                ctx.lineTo(x + mathMax$5(width - d_1, 0), y + height);
                            }
                            d_1 -= width;
                            if (d_1 > 0) {
                                ctx.lineTo(x, y + mathMax$5(height - d_1, 0));
                            }
                            break lo;
                        }
                        accumLength += l;
                    }
                    ctx.rect(x, y, width, height);
                    break;
                case CMD$2.Z:
                    if (drawPart) {
                        var l = pathSegLen[segCount++];
                        if (accumLength + l > displayedLength) {
                            var t = (displayedLength - accumLength) / l;
                            ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t);
                            break lo;
                        }
                        accumLength += l;
                    }
                    ctx.closePath();
                    xi = x0;
                    yi = y0;
            }
        }
    };
    PathProxy.prototype.clone = function () {
        var newProxy = new PathProxy();
        var data = this.data;
        newProxy.data = data.slice ? data.slice()
            : Array.prototype.slice.call(data);
        newProxy._len = this._len;
        return newProxy;
    };
    PathProxy.CMD = CMD$2;
    PathProxy.initDefaultProps = (function () {
        var proto = PathProxy.prototype;
        proto._saveData = true;
        proto._ux = 0;
        proto._uy = 0;
        proto._pendingPtDist = 0;
        proto._version = 0;
    })();
    return PathProxy;
}());
var PathProxy$1 = PathProxy;

function containStroke$4(x0, y0, x1, y1, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    var _l = lineWidth;
    var _a = 0;
    var _b = x0;
    if ((y > y0 + _l && y > y1 + _l)
        || (y < y0 - _l && y < y1 - _l)
        || (x > x0 + _l && x > x1 + _l)
        || (x < x0 - _l && x < x1 - _l)) {
        return false;
    }
    if (x0 !== x1) {
        _a = (y0 - y1) / (x0 - x1);
        _b = (x0 * y1 - x1 * y0) / (x0 - x1);
    }
    else {
        return Math.abs(x - x0) <= _l / 2;
    }
    var tmp = _a * x - y + _b;
    var _s = tmp * tmp / (_a * _a + 1);
    return _s <= _l / 2 * _l / 2;
}

function containStroke$3(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    var _l = lineWidth;
    if ((y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
        || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
        || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
        || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)) {
        return false;
    }
    var d = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
    return d <= _l / 2;
}

function containStroke$2(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    var _l = lineWidth;
    if ((y > y0 + _l && y > y1 + _l && y > y2 + _l)
        || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
        || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
        || (x < x0 - _l && x < x1 - _l && x < x2 - _l)) {
        return false;
    }
    var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
    return d <= _l / 2;
}

var PI2$4 = Math.PI * 2;
function normalizeRadian(angle) {
    angle %= PI2$4;
    if (angle < 0) {
        angle += PI2$4;
    }
    return angle;
}

var PI2$3 = Math.PI * 2;
function containStroke$1(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    var _l = lineWidth;
    x -= cx;
    y -= cy;
    var d = Math.sqrt(x * x + y * y);
    if ((d - _l > r) || (d + _l < r)) {
        return false;
    }
    if (Math.abs(startAngle - endAngle) % PI2$3 < 1e-4) {
        return true;
    }
    if (anticlockwise) {
        var tmp = startAngle;
        startAngle = normalizeRadian(endAngle);
        endAngle = normalizeRadian(tmp);
    }
    else {
        startAngle = normalizeRadian(startAngle);
        endAngle = normalizeRadian(endAngle);
    }
    if (startAngle > endAngle) {
        endAngle += PI2$3;
    }
    var angle = Math.atan2(y, x);
    if (angle < 0) {
        angle += PI2$3;
    }
    return (angle >= startAngle && angle <= endAngle)
        || (angle + PI2$3 >= startAngle && angle + PI2$3 <= endAngle);
}

function windingLine(x0, y0, x1, y1, x, y) {
    if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
        return 0;
    }
    if (y1 === y0) {
        return 0;
    }
    var t = (y - y0) / (y1 - y0);
    var dir = y1 < y0 ? 1 : -1;
    if (t === 1 || t === 0) {
        dir = y1 < y0 ? 0.5 : -0.5;
    }
    var x_ = t * (x1 - x0) + x0;
    return x_ === x ? Infinity : x_ > x ? dir : 0;
}

var CMD$1 = PathProxy$1.CMD;
var PI2$2 = Math.PI * 2;
var EPSILON$1 = 1e-4;
function isAroundEqual$1(a, b) {
    return Math.abs(a - b) < EPSILON$1;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
    var tmp = extrema[0];
    extrema[0] = extrema[1];
    extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
    if ((y > y0 && y > y1 && y > y2 && y > y3)
        || (y < y0 && y < y1 && y < y2 && y < y3)) {
        return 0;
    }
    var nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
    if (nRoots === 0) {
        return 0;
    }
    else {
        var w = 0;
        var nExtrema = -1;
        var y0_ = void 0;
        var y1_ = void 0;
        for (var i = 0; i < nRoots; i++) {
            var t = roots[i];
            var unit = (t === 0 || t === 1) ? 0.5 : 1;
            var x_ = cubicAt(x0, x1, x2, x3, t);
            if (x_ < x) {
                continue;
            }
            if (nExtrema < 0) {
                nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);
                if (extrema[1] < extrema[0] && nExtrema > 1) {
                    swapExtrema();
                }
                y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);
                if (nExtrema > 1) {
                    y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
                }
            }
            if (nExtrema === 2) {
                if (t < extrema[0]) {
                    w += y0_ < y0 ? unit : -unit;
                }
                else if (t < extrema[1]) {
                    w += y1_ < y0_ ? unit : -unit;
                }
                else {
                    w += y3 < y1_ ? unit : -unit;
                }
            }
            else {
                if (t < extrema[0]) {
                    w += y0_ < y0 ? unit : -unit;
                }
                else {
                    w += y3 < y0_ ? unit : -unit;
                }
            }
        }
        return w;
    }
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
    if ((y > y0 && y > y1 && y > y2)
        || (y < y0 && y < y1 && y < y2)) {
        return 0;
    }
    var nRoots = quadraticRootAt(y0, y1, y2, y, roots);
    if (nRoots === 0) {
        return 0;
    }
    else {
        var t = quadraticExtremum(y0, y1, y2);
        if (t >= 0 && t <= 1) {
            var w = 0;
            var y_ = quadraticAt(y0, y1, y2, t);
            for (var i = 0; i < nRoots; i++) {
                var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;
                var x_ = quadraticAt(x0, x1, x2, roots[i]);
                if (x_ < x) {
                    continue;
                }
                if (roots[i] < t) {
                    w += y_ < y0 ? unit : -unit;
                }
                else {
                    w += y2 < y_ ? unit : -unit;
                }
            }
            return w;
        }
        else {
            var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;
            var x_ = quadraticAt(x0, x1, x2, roots[0]);
            if (x_ < x) {
                return 0;
            }
            return y2 < y0 ? unit : -unit;
        }
    }
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
    y -= cy;
    if (y > r || y < -r) {
        return 0;
    }
    var tmp = Math.sqrt(r * r - y * y);
    roots[0] = -tmp;
    roots[1] = tmp;
    var dTheta = Math.abs(startAngle - endAngle);
    if (dTheta < 1e-4) {
        return 0;
    }
    if (dTheta >= PI2$2 - 1e-4) {
        startAngle = 0;
        endAngle = PI2$2;
        var dir = anticlockwise ? 1 : -1;
        if (x >= roots[0] + cx && x <= roots[1] + cx) {
            return dir;
        }
        else {
            return 0;
        }
    }
    if (startAngle > endAngle) {
        var tmp_1 = startAngle;
        startAngle = endAngle;
        endAngle = tmp_1;
    }
    if (startAngle < 0) {
        startAngle += PI2$2;
        endAngle += PI2$2;
    }
    var w = 0;
    for (var i = 0; i < 2; i++) {
        var x_ = roots[i];
        if (x_ + cx > x) {
            var angle = Math.atan2(y, x_);
            var dir = anticlockwise ? 1 : -1;
            if (angle < 0) {
                angle = PI2$2 + angle;
            }
            if ((angle >= startAngle && angle <= endAngle)
                || (angle + PI2$2 >= startAngle && angle + PI2$2 <= endAngle)) {
                if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
                    dir = -dir;
                }
                w += dir;
            }
        }
    }
    return w;
}
function containPath(path, lineWidth, isStroke, x, y) {
    var data = path.data;
    var len = path.len();
    var w = 0;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    var x1;
    var y1;
    for (var i = 0; i < len;) {
        var cmd = data[i++];
        var isFirst = i === 1;
        if (cmd === CMD$1.M && i > 1) {
            if (!isStroke) {
                w += windingLine(xi, yi, x0, y0, x, y);
            }
        }
        if (isFirst) {
            xi = data[i];
            yi = data[i + 1];
            x0 = xi;
            y0 = yi;
        }
        switch (cmd) {
            case CMD$1.M:
                x0 = data[i++];
                y0 = data[i++];
                xi = x0;
                yi = y0;
                break;
            case CMD$1.L:
                if (isStroke) {
                    if (containStroke$4(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
                        return true;
                    }
                }
                else {
                    w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
                }
                xi = data[i++];
                yi = data[i++];
                break;
            case CMD$1.C:
                if (isStroke) {
                    if (containStroke$3(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                        return true;
                    }
                }
                else {
                    w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
                }
                xi = data[i++];
                yi = data[i++];
                break;
            case CMD$1.Q:
                if (isStroke) {
                    if (containStroke$2(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                        return true;
                    }
                }
                else {
                    w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
                }
                xi = data[i++];
                yi = data[i++];
                break;
            case CMD$1.A:
                var cx = data[i++];
                var cy = data[i++];
                var rx = data[i++];
                var ry = data[i++];
                var theta = data[i++];
                var dTheta = data[i++];
                i += 1;
                var anticlockwise = !!(1 - data[i++]);
                x1 = Math.cos(theta) * rx + cx;
                y1 = Math.sin(theta) * ry + cy;
                if (!isFirst) {
                    w += windingLine(xi, yi, x1, y1, x, y);
                }
                else {
                    x0 = x1;
                    y0 = y1;
                }
                var _x = (x - cx) * ry / rx + cx;
                if (isStroke) {
                    if (containStroke$1(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
                        return true;
                    }
                }
                else {
                    w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
                }
                xi = Math.cos(theta + dTheta) * rx + cx;
                yi = Math.sin(theta + dTheta) * ry + cy;
                break;
            case CMD$1.R:
                x0 = xi = data[i++];
                y0 = yi = data[i++];
                var width = data[i++];
                var height = data[i++];
                x1 = x0 + width;
                y1 = y0 + height;
                if (isStroke) {
                    if (containStroke$4(x0, y0, x1, y0, lineWidth, x, y)
                        || containStroke$4(x1, y0, x1, y1, lineWidth, x, y)
                        || containStroke$4(x1, y1, x0, y1, lineWidth, x, y)
                        || containStroke$4(x0, y1, x0, y0, lineWidth, x, y)) {
                        return true;
                    }
                }
                else {
                    w += windingLine(x1, y0, x1, y1, x, y);
                    w += windingLine(x0, y1, x0, y0, x, y);
                }
                break;
            case CMD$1.Z:
                if (isStroke) {
                    if (containStroke$4(xi, yi, x0, y0, lineWidth, x, y)) {
                        return true;
                    }
                }
                else {
                    w += windingLine(xi, yi, x0, y0, x, y);
                }
                xi = x0;
                yi = y0;
                break;
        }
    }
    if (!isStroke && !isAroundEqual$1(yi, y0)) {
        w += windingLine(xi, yi, x0, y0, x, y) || 0;
    }
    return w !== 0;
}
function contain$2(pathProxy, x, y) {
    return containPath(pathProxy, 0, false, x, y);
}
function containStroke(pathProxy, lineWidth, x, y) {
    return containPath(pathProxy, lineWidth, true, x, y);
}

var DEFAULT_PATH_STYLE = defaults({
    fill: '#000',
    stroke: null,
    strokePercent: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: 'butt',
    miterLimit: 10,
    strokeNoScale: false,
    strokeFirst: false
}, DEFAULT_COMMON_STYLE);
var DEFAULT_PATH_ANIMATION_PROPS = {
    style: defaults({
        fill: true,
        stroke: true,
        strokePercent: true,
        fillOpacity: true,
        strokeOpacity: true,
        lineDashOffset: true,
        lineWidth: true,
        miterLimit: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var pathCopyParams = TRANSFORMABLE_PROPS.concat(['invisible',
    'culling', 'z', 'z2', 'zlevel', 'parent'
]);
var Path = (function (_super) {
    __extends(Path, _super);
    function Path(opts) {
        return _super.call(this, opts) || this;
    }
    Path.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        var style = this.style;
        if (style.decal) {
            var decalEl = this._decalEl = this._decalEl || new Path();
            if (decalEl.buildPath === Path.prototype.buildPath) {
                decalEl.buildPath = function (ctx) {
                    _this.buildPath(ctx, _this.shape);
                };
            }
            decalEl.silent = true;
            var decalElStyle = decalEl.style;
            for (var key in style) {
                if (decalElStyle[key] !== style[key]) {
                    decalElStyle[key] = style[key];
                }
            }
            decalElStyle.fill = style.fill ? style.decal : null;
            decalElStyle.decal = null;
            decalElStyle.shadowColor = null;
            style.strokeFirst && (decalElStyle.stroke = null);
            for (var i = 0; i < pathCopyParams.length; ++i) {
                decalEl[pathCopyParams[i]] = this[pathCopyParams[i]];
            }
            decalEl.__dirty |= REDRAW_BIT;
        }
        else if (this._decalEl) {
            this._decalEl = null;
        }
    };
    Path.prototype.getDecalElement = function () {
        return this._decalEl;
    };
    Path.prototype._init = function (props) {
        var keysArr = keys(props);
        this.shape = this.getDefaultShape();
        var defaultStyle = this.getDefaultStyle();
        if (defaultStyle) {
            this.useStyle(defaultStyle);
        }
        for (var i = 0; i < keysArr.length; i++) {
            var key = keysArr[i];
            var value = props[key];
            if (key === 'style') {
                if (!this.style) {
                    this.useStyle(value);
                }
                else {
                    extend$2(this.style, value);
                }
            }
            else if (key === 'shape') {
                extend$2(this.shape, value);
            }
            else {
                _super.prototype.attrKV.call(this, key, value);
            }
        }
        if (!this.style) {
            this.useStyle({});
        }
    };
    Path.prototype.getDefaultStyle = function () {
        return null;
    };
    Path.prototype.getDefaultShape = function () {
        return {};
    };
    Path.prototype.canBeInsideText = function () {
        return this.hasFill();
    };
    Path.prototype.getInsideTextFill = function () {
        var pathFill = this.style.fill;
        if (pathFill !== 'none') {
            if (isString(pathFill)) {
                var fillLum = lum(pathFill, 0);
                if (fillLum > 0.5) {
                    return DARK_LABEL_COLOR;
                }
                else if (fillLum > 0.2) {
                    return LIGHTER_LABEL_COLOR;
                }
                return LIGHT_LABEL_COLOR;
            }
            else if (pathFill) {
                return LIGHT_LABEL_COLOR;
            }
        }
        return DARK_LABEL_COLOR;
    };
    Path.prototype.getInsideTextStroke = function (textFill) {
        var pathFill = this.style.fill;
        if (isString(pathFill)) {
            var zr = this.__zr;
            var isDarkMode = !!(zr && zr.isDarkMode());
            var isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD;
            if (isDarkMode === isDarkLabel) {
                return pathFill;
            }
        }
    };
    Path.prototype.buildPath = function (ctx, shapeCfg, inBatch) { };
    Path.prototype.pathUpdated = function () {
        this.__dirty &= ~SHAPE_CHANGED_BIT;
    };
    Path.prototype.getUpdatedPathProxy = function (inBatch) {
        !this.path && this.createPathProxy();
        this.path.beginPath();
        this.buildPath(this.path, this.shape, inBatch);
        return this.path;
    };
    Path.prototype.createPathProxy = function () {
        this.path = new PathProxy$1(false);
    };
    Path.prototype.hasStroke = function () {
        var style = this.style;
        var stroke = style.stroke;
        return !(stroke == null || stroke === 'none' || !(style.lineWidth > 0));
    };
    Path.prototype.hasFill = function () {
        var style = this.style;
        var fill = style.fill;
        return fill != null && fill !== 'none';
    };
    Path.prototype.getBoundingRect = function () {
        var rect = this._rect;
        var style = this.style;
        var needsUpdateRect = !rect;
        if (needsUpdateRect) {
            var firstInvoke = false;
            if (!this.path) {
                firstInvoke = true;
                this.createPathProxy();
            }
            var path = this.path;
            if (firstInvoke || (this.__dirty & SHAPE_CHANGED_BIT)) {
                path.beginPath();
                this.buildPath(path, this.shape, false);
                this.pathUpdated();
            }
            rect = path.getBoundingRect();
        }
        this._rect = rect;
        if (this.hasStroke() && this.path && this.path.len() > 0) {
            var rectStroke = this._rectStroke || (this._rectStroke = rect.clone());
            if (this.__dirty || needsUpdateRect) {
                rectStroke.copy(rect);
                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
                var w = style.lineWidth;
                if (!this.hasFill()) {
                    var strokeContainThreshold = this.strokeContainThreshold;
                    w = Math.max(w, strokeContainThreshold == null ? 4 : strokeContainThreshold);
                }
                if (lineScale > 1e-10) {
                    rectStroke.width += w / lineScale;
                    rectStroke.height += w / lineScale;
                    rectStroke.x -= w / lineScale / 2;
                    rectStroke.y -= w / lineScale / 2;
                }
            }
            return rectStroke;
        }
        return rect;
    };
    Path.prototype.contain = function (x, y) {
        var localPos = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        var style = this.style;
        x = localPos[0];
        y = localPos[1];
        if (rect.contain(x, y)) {
            var pathProxy = this.path;
            if (this.hasStroke()) {
                var lineWidth = style.lineWidth;
                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
                if (lineScale > 1e-10) {
                    if (!this.hasFill()) {
                        lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
                    }
                    if (containStroke(pathProxy, lineWidth / lineScale, x, y)) {
                        return true;
                    }
                }
            }
            if (this.hasFill()) {
                return contain$2(pathProxy, x, y);
            }
        }
        return false;
    };
    Path.prototype.dirtyShape = function () {
        this.__dirty |= SHAPE_CHANGED_BIT;
        if (this._rect) {
            this._rect = null;
        }
        if (this._decalEl) {
            this._decalEl.dirtyShape();
        }
        this.markRedraw();
    };
    Path.prototype.dirty = function () {
        this.dirtyStyle();
        this.dirtyShape();
    };
    Path.prototype.animateShape = function (loop) {
        return this.animate('shape', loop);
    };
    Path.prototype.updateDuringAnimation = function (targetKey) {
        if (targetKey === 'style') {
            this.dirtyStyle();
        }
        else if (targetKey === 'shape') {
            this.dirtyShape();
        }
        else {
            this.markRedraw();
        }
    };
    Path.prototype.attrKV = function (key, value) {
        if (key === 'shape') {
            this.setShape(value);
        }
        else {
            _super.prototype.attrKV.call(this, key, value);
        }
    };
    Path.prototype.setShape = function (keyOrObj, value) {
        var shape = this.shape;
        if (!shape) {
            shape = this.shape = {};
        }
        if (typeof keyOrObj === 'string') {
            shape[keyOrObj] = value;
        }
        else {
            extend$2(shape, keyOrObj);
        }
        this.dirtyShape();
        return this;
    };
    Path.prototype.shapeChanged = function () {
        return !!(this.__dirty & SHAPE_CHANGED_BIT);
    };
    Path.prototype.createStyle = function (obj) {
        return createObject(DEFAULT_PATH_STYLE, obj);
    };
    Path.prototype._innerSaveToNormal = function (toState) {
        _super.prototype._innerSaveToNormal.call(this, toState);
        var normalState = this._normalState;
        if (toState.shape && !normalState.shape) {
            normalState.shape = extend$2({}, this.shape);
        }
    };
    Path.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
        _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
        var needsRestoreToNormal = !(state && keepCurrentStates);
        var targetShape;
        if (state && state.shape) {
            if (transition) {
                if (keepCurrentStates) {
                    targetShape = state.shape;
                }
                else {
                    targetShape = extend$2({}, normalState.shape);
                    extend$2(targetShape, state.shape);
                }
            }
            else {
                targetShape = extend$2({}, keepCurrentStates ? this.shape : normalState.shape);
                extend$2(targetShape, state.shape);
            }
        }
        else if (needsRestoreToNormal) {
            targetShape = normalState.shape;
        }
        if (targetShape) {
            if (transition) {
                this.shape = extend$2({}, this.shape);
                var targetShapePrimaryProps = {};
                var shapeKeys = keys(targetShape);
                for (var i = 0; i < shapeKeys.length; i++) {
                    var key = shapeKeys[i];
                    if (typeof targetShape[key] === 'object') {
                        this.shape[key] = targetShape[key];
                    }
                    else {
                        targetShapePrimaryProps[key] = targetShape[key];
                    }
                }
                this._transitionState(stateName, {
                    shape: targetShapePrimaryProps
                }, animationCfg);
            }
            else {
                this.shape = targetShape;
                this.dirtyShape();
            }
        }
    };
    Path.prototype._mergeStates = function (states) {
        var mergedState = _super.prototype._mergeStates.call(this, states);
        var mergedShape;
        for (var i = 0; i < states.length; i++) {
            var state = states[i];
            if (state.shape) {
                mergedShape = mergedShape || {};
                this._mergeStyle(mergedShape, state.shape);
            }
        }
        if (mergedShape) {
            mergedState.shape = mergedShape;
        }
        return mergedState;
    };
    Path.prototype.getAnimationStyleProps = function () {
        return DEFAULT_PATH_ANIMATION_PROPS;
    };
    Path.prototype.isZeroArea = function () {
        return false;
    };
    Path.extend = function (defaultProps) {
        var Sub = (function (_super) {
            __extends(Sub, _super);
            function Sub(opts) {
                var _this = _super.call(this, opts) || this;
                defaultProps.init && defaultProps.init.call(_this, opts);
                return _this;
            }
            Sub.prototype.getDefaultStyle = function () {
                return clone$3(defaultProps.style);
            };
            Sub.prototype.getDefaultShape = function () {
                return clone$3(defaultProps.shape);
            };
            return Sub;
        }(Path));
        for (var key in defaultProps) {
            if (typeof defaultProps[key] === 'function') {
                Sub.prototype[key] = defaultProps[key];
            }
        }
        return Sub;
    };
    Path.initDefaultProps = (function () {
        var pathProto = Path.prototype;
        pathProto.type = 'path';
        pathProto.strokeContainThreshold = 5;
        pathProto.segmentIgnoreThreshold = 0;
        pathProto.subPixelOptimize = false;
        pathProto.autoBatch = false;
        pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
    })();
    return Path;
}(Displayable$1));
var Path$1 = Path;

var DEFAULT_TSPAN_STYLE = defaults({
    strokeFirst: true,
    font: DEFAULT_FONT,
    x: 0,
    y: 0,
    textAlign: 'left',
    textBaseline: 'top',
    miterLimit: 2
}, DEFAULT_PATH_STYLE);
var TSpan = (function (_super) {
    __extends(TSpan, _super);
    function TSpan() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TSpan.prototype.hasStroke = function () {
        var style = this.style;
        var stroke = style.stroke;
        return stroke != null && stroke !== 'none' && style.lineWidth > 0;
    };
    TSpan.prototype.hasFill = function () {
        var style = this.style;
        var fill = style.fill;
        return fill != null && fill !== 'none';
    };
    TSpan.prototype.createStyle = function (obj) {
        return createObject(DEFAULT_TSPAN_STYLE, obj);
    };
    TSpan.prototype.setBoundingRect = function (rect) {
        this._rect = rect;
    };
    TSpan.prototype.getBoundingRect = function () {
        var style = this.style;
        if (!this._rect) {
            var text = style.text;
            text != null ? (text += '') : (text = '');
            var rect = getBoundingRect(text, style.font, style.textAlign, style.textBaseline);
            rect.x += style.x || 0;
            rect.y += style.y || 0;
            if (this.hasStroke()) {
                var w = style.lineWidth;
                rect.x -= w / 2;
                rect.y -= w / 2;
                rect.width += w;
                rect.height += w;
            }
            this._rect = rect;
        }
        return this._rect;
    };
    TSpan.initDefaultProps = (function () {
        var tspanProto = TSpan.prototype;
        tspanProto.dirtyRectTolerance = 10;
    })();
    return TSpan;
}(Displayable$1));
TSpan.prototype.type = 'tspan';
var TSpan$1 = TSpan;

var DEFAULT_IMAGE_STYLE = defaults({
    x: 0,
    y: 0
}, DEFAULT_COMMON_STYLE);
var DEFAULT_IMAGE_ANIMATION_PROPS = {
    style: defaults({
        x: true,
        y: true,
        width: true,
        height: true,
        sx: true,
        sy: true,
        sWidth: true,
        sHeight: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
function isImageLike(source) {
    return !!(source
        && typeof source !== 'string'
        && source.width && source.height);
}
var ZRImage = (function (_super) {
    __extends(ZRImage, _super);
    function ZRImage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ZRImage.prototype.createStyle = function (obj) {
        return createObject(DEFAULT_IMAGE_STYLE, obj);
    };
    ZRImage.prototype._getSize = function (dim) {
        var style = this.style;
        var size = style[dim];
        if (size != null) {
            return size;
        }
        var imageSource = isImageLike(style.image)
            ? style.image : this.__image;
        if (!imageSource) {
            return 0;
        }
        var otherDim = dim === 'width' ? 'height' : 'width';
        var otherDimSize = style[otherDim];
        if (otherDimSize == null) {
            return imageSource[dim];
        }
        else {
            return imageSource[dim] / imageSource[otherDim] * otherDimSize;
        }
    };
    ZRImage.prototype.getWidth = function () {
        return this._getSize('width');
    };
    ZRImage.prototype.getHeight = function () {
        return this._getSize('height');
    };
    ZRImage.prototype.getAnimationStyleProps = function () {
        return DEFAULT_IMAGE_ANIMATION_PROPS;
    };
    ZRImage.prototype.getBoundingRect = function () {
        var style = this.style;
        if (!this._rect) {
            this._rect = new BoundingRect$1(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
        }
        return this._rect;
    };
    return ZRImage;
}(Displayable$1));
ZRImage.prototype.type = 'image';
var ZRImage$1 = ZRImage;

function buildPath$2(ctx, shape) {
    var x = shape.x;
    var y = shape.y;
    var width = shape.width;
    var height = shape.height;
    var r = shape.r;
    var r1;
    var r2;
    var r3;
    var r4;
    if (width < 0) {
        x = x + width;
        width = -width;
    }
    if (height < 0) {
        y = y + height;
        height = -height;
    }
    if (typeof r === 'number') {
        r1 = r2 = r3 = r4 = r;
    }
    else if (r instanceof Array) {
        if (r.length === 1) {
            r1 = r2 = r3 = r4 = r[0];
        }
        else if (r.length === 2) {
            r1 = r3 = r[0];
            r2 = r4 = r[1];
        }
        else if (r.length === 3) {
            r1 = r[0];
            r2 = r4 = r[1];
            r3 = r[2];
        }
        else {
            r1 = r[0];
            r2 = r[1];
            r3 = r[2];
            r4 = r[3];
        }
    }
    else {
        r1 = r2 = r3 = r4 = 0;
    }
    var total;
    if (r1 + r2 > width) {
        total = r1 + r2;
        r1 *= width / total;
        r2 *= width / total;
    }
    if (r3 + r4 > width) {
        total = r3 + r4;
        r3 *= width / total;
        r4 *= width / total;
    }
    if (r2 + r3 > height) {
        total = r2 + r3;
        r2 *= height / total;
        r3 *= height / total;
    }
    if (r1 + r4 > height) {
        total = r1 + r4;
        r1 *= height / total;
        r4 *= height / total;
    }
    ctx.moveTo(x + r1, y);
    ctx.lineTo(x + width - r2, y);
    r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
    ctx.lineTo(x + width, y + height - r3);
    r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
    ctx.lineTo(x + r4, y + height);
    r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
    ctx.lineTo(x, y + r1);
    r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
}

var round = Math.round;
function subPixelOptimizeLine$1(outputShape, inputShape, style) {
    if (!inputShape) {
        return;
    }
    var x1 = inputShape.x1;
    var x2 = inputShape.x2;
    var y1 = inputShape.y1;
    var y2 = inputShape.y2;
    outputShape.x1 = x1;
    outputShape.x2 = x2;
    outputShape.y1 = y1;
    outputShape.y2 = y2;
    var lineWidth = style && style.lineWidth;
    if (!lineWidth) {
        return outputShape;
    }
    if (round(x1 * 2) === round(x2 * 2)) {
        outputShape.x1 = outputShape.x2 = subPixelOptimize$1(x1, lineWidth, true);
    }
    if (round(y1 * 2) === round(y2 * 2)) {
        outputShape.y1 = outputShape.y2 = subPixelOptimize$1(y1, lineWidth, true);
    }
    return outputShape;
}
function subPixelOptimizeRect$1(outputShape, inputShape, style) {
    if (!inputShape) {
        return;
    }
    var originX = inputShape.x;
    var originY = inputShape.y;
    var originWidth = inputShape.width;
    var originHeight = inputShape.height;
    outputShape.x = originX;
    outputShape.y = originY;
    outputShape.width = originWidth;
    outputShape.height = originHeight;
    var lineWidth = style && style.lineWidth;
    if (!lineWidth) {
        return outputShape;
    }
    outputShape.x = subPixelOptimize$1(originX, lineWidth, true);
    outputShape.y = subPixelOptimize$1(originY, lineWidth, true);
    outputShape.width = Math.max(subPixelOptimize$1(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
    outputShape.height = Math.max(subPixelOptimize$1(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
    return outputShape;
}
function subPixelOptimize$1(position, lineWidth, positiveOrNegative) {
    if (!lineWidth) {
        return position;
    }
    var doubledPosition = round(position * 2);
    return (doubledPosition + round(lineWidth)) % 2 === 0
        ? doubledPosition / 2
        : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}

var RectShape = (function () {
    function RectShape() {
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
    }
    return RectShape;
}());
var subPixelOptimizeOutputShape$1 = {};
var Rect = (function (_super) {
    __extends(Rect, _super);
    function Rect(opts) {
        return _super.call(this, opts) || this;
    }
    Rect.prototype.getDefaultShape = function () {
        return new RectShape();
    };
    Rect.prototype.buildPath = function (ctx, shape) {
        var x;
        var y;
        var width;
        var height;
        if (this.subPixelOptimize) {
            var optimizedShape = subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, shape, this.style);
            x = optimizedShape.x;
            y = optimizedShape.y;
            width = optimizedShape.width;
            height = optimizedShape.height;
            optimizedShape.r = shape.r;
            shape = optimizedShape;
        }
        else {
            x = shape.x;
            y = shape.y;
            width = shape.width;
            height = shape.height;
        }
        if (!shape.r) {
            ctx.rect(x, y, width, height);
        }
        else {
            buildPath$2(ctx, shape);
        }
    };
    Rect.prototype.isZeroArea = function () {
        return !this.shape.width || !this.shape.height;
    };
    return Rect;
}(Path$1));
Rect.prototype.type = 'rect';
var Rect$1 = Rect;

var DEFAULT_RICH_TEXT_COLOR = {
    fill: '#000'
};
var DEFAULT_STROKE_LINE_WIDTH = 2;
var DEFAULT_TEXT_ANIMATION_PROPS = {
    style: defaults({
        fill: true,
        stroke: true,
        fillOpacity: true,
        strokeOpacity: true,
        lineWidth: true,
        fontSize: true,
        lineHeight: true,
        width: true,
        height: true,
        textShadowColor: true,
        textShadowBlur: true,
        textShadowOffsetX: true,
        textShadowOffsetY: true,
        backgroundColor: true,
        padding: true,
        borderColor: true,
        borderWidth: true,
        borderRadius: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var ZRText = (function (_super) {
    __extends(ZRText, _super);
    function ZRText(opts) {
        var _this = _super.call(this) || this;
        _this.type = 'text';
        _this._children = [];
        _this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
        _this.attr(opts);
        return _this;
    }
    ZRText.prototype.childrenRef = function () {
        return this._children;
    };
    ZRText.prototype.update = function () {
        _super.prototype.update.call(this);
        if (this.styleChanged()) {
            this._updateSubTexts();
        }
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            child.zlevel = this.zlevel;
            child.z = this.z;
            child.z2 = this.z2;
            child.culling = this.culling;
            child.cursor = this.cursor;
            child.invisible = this.invisible;
        }
    };
    ZRText.prototype.updateTransform = function () {
        var innerTransformable = this.innerTransformable;
        if (innerTransformable) {
            innerTransformable.updateTransform();
            if (innerTransformable.transform) {
                this.transform = innerTransformable.transform;
            }
        }
        else {
            _super.prototype.updateTransform.call(this);
        }
    };
    ZRText.prototype.getLocalTransform = function (m) {
        var innerTransformable = this.innerTransformable;
        return innerTransformable
            ? innerTransformable.getLocalTransform(m)
            : _super.prototype.getLocalTransform.call(this, m);
    };
    ZRText.prototype.getComputedTransform = function () {
        if (this.__hostTarget) {
            this.__hostTarget.getComputedTransform();
            this.__hostTarget.updateInnerText(true);
        }
        return _super.prototype.getComputedTransform.call(this);
    };
    ZRText.prototype._updateSubTexts = function () {
        this._childCursor = 0;
        normalizeTextStyle(this.style);
        this.style.rich
            ? this._updateRichTexts()
            : this._updatePlainTexts();
        this._children.length = this._childCursor;
        this.styleUpdated();
    };
    ZRText.prototype.addSelfToZr = function (zr) {
        _super.prototype.addSelfToZr.call(this, zr);
        for (var i = 0; i < this._children.length; i++) {
            this._children[i].__zr = zr;
        }
    };
    ZRText.prototype.removeSelfFromZr = function (zr) {
        _super.prototype.removeSelfFromZr.call(this, zr);
        for (var i = 0; i < this._children.length; i++) {
            this._children[i].__zr = null;
        }
    };
    ZRText.prototype.getBoundingRect = function () {
        if (this.styleChanged()) {
            this._updateSubTexts();
        }
        if (!this._rect) {
            var tmpRect = new BoundingRect$1(0, 0, 0, 0);
            var children = this._children;
            var tmpMat = [];
            var rect = null;
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                var childRect = child.getBoundingRect();
                var transform = child.getLocalTransform(tmpMat);
                if (transform) {
                    tmpRect.copy(childRect);
                    tmpRect.applyTransform(transform);
                    rect = rect || tmpRect.clone();
                    rect.union(tmpRect);
                }
                else {
                    rect = rect || childRect.clone();
                    rect.union(childRect);
                }
            }
            this._rect = rect || tmpRect;
        }
        return this._rect;
    };
    ZRText.prototype.setDefaultTextStyle = function (defaultTextStyle) {
        this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
    };
    ZRText.prototype.setTextContent = function (textContent) {
        if (process.env.NODE_ENV !== 'production') {
            throw new Error('Can\'t attach text on another text');
        }
    };
    ZRText.prototype._mergeStyle = function (targetStyle, sourceStyle) {
        if (!sourceStyle) {
            return targetStyle;
        }
        var sourceRich = sourceStyle.rich;
        var targetRich = targetStyle.rich || (sourceRich && {});
        extend$2(targetStyle, sourceStyle);
        if (sourceRich && targetRich) {
            this._mergeRich(targetRich, sourceRich);
            targetStyle.rich = targetRich;
        }
        else if (targetRich) {
            targetStyle.rich = targetRich;
        }
        return targetStyle;
    };
    ZRText.prototype._mergeRich = function (targetRich, sourceRich) {
        var richNames = keys(sourceRich);
        for (var i = 0; i < richNames.length; i++) {
            var richName = richNames[i];
            targetRich[richName] = targetRich[richName] || {};
            extend$2(targetRich[richName], sourceRich[richName]);
        }
    };
    ZRText.prototype.getAnimationStyleProps = function () {
        return DEFAULT_TEXT_ANIMATION_PROPS;
    };
    ZRText.prototype._getOrCreateChild = function (Ctor) {
        var child = this._children[this._childCursor];
        if (!child || !(child instanceof Ctor)) {
            child = new Ctor();
        }
        this._children[this._childCursor++] = child;
        child.__zr = this.__zr;
        child.parent = this;
        return child;
    };
    ZRText.prototype._updatePlainTexts = function () {
        var style = this.style;
        var textFont = style.font || DEFAULT_FONT;
        var textPadding = style.padding;
        var text = getStyleText(style);
        var contentBlock = parsePlainText(text, style);
        var needDrawBg = needDrawBackground(style);
        var bgColorDrawn = !!(style.backgroundColor);
        var outerHeight = contentBlock.outerHeight;
        var outerWidth = contentBlock.outerWidth;
        var contentWidth = contentBlock.contentWidth;
        var textLines = contentBlock.lines;
        var lineHeight = contentBlock.lineHeight;
        var defaultStyle = this._defaultStyle;
        var baseX = style.x || 0;
        var baseY = style.y || 0;
        var textAlign = style.align || defaultStyle.align || 'left';
        var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || 'top';
        var textX = baseX;
        var textY = adjustTextY(baseY, contentBlock.contentHeight, verticalAlign);
        if (needDrawBg || textPadding) {
            var boxX = adjustTextX(baseX, outerWidth, textAlign);
            var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
            needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
        }
        textY += lineHeight / 2;
        if (textPadding) {
            textX = getTextXForPadding(baseX, textAlign, textPadding);
            if (verticalAlign === 'top') {
                textY += textPadding[0];
            }
            else if (verticalAlign === 'bottom') {
                textY -= textPadding[2];
            }
        }
        var defaultLineWidth = 0;
        var useDefaultFill = false;
        var textFill = getFill('fill' in style
            ? style.fill
            : (useDefaultFill = true, defaultStyle.fill));
        var textStroke = getStroke('stroke' in style
            ? style.stroke
            : (!bgColorDrawn
                && (!defaultStyle.autoStroke || useDefaultFill))
                ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke)
                : null);
        var hasShadow = style.textShadowBlur > 0;
        var fixedBoundingRect = style.width != null
            && (style.overflow === 'truncate' || style.overflow === 'break' || style.overflow === 'breakAll');
        var calculatedLineHeight = contentBlock.calculatedLineHeight;
        for (var i = 0; i < textLines.length; i++) {
            var el = this._getOrCreateChild(TSpan$1);
            var subElStyle = el.createStyle();
            el.useStyle(subElStyle);
            subElStyle.text = textLines[i];
            subElStyle.x = textX;
            subElStyle.y = textY;
            if (textAlign) {
                subElStyle.textAlign = textAlign;
            }
            subElStyle.textBaseline = 'middle';
            subElStyle.opacity = style.opacity;
            subElStyle.strokeFirst = true;
            if (hasShadow) {
                subElStyle.shadowBlur = style.textShadowBlur || 0;
                subElStyle.shadowColor = style.textShadowColor || 'transparent';
                subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
                subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
            }
            subElStyle.stroke = textStroke;
            subElStyle.fill = textFill;
            if (textStroke) {
                subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
                subElStyle.lineDash = style.lineDash;
                subElStyle.lineDashOffset = style.lineDashOffset || 0;
            }
            subElStyle.font = textFont;
            setSeparateFont(subElStyle, style);
            textY += lineHeight;
            if (fixedBoundingRect) {
                el.setBoundingRect(new BoundingRect$1(adjustTextX(subElStyle.x, style.width, subElStyle.textAlign), adjustTextY(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), contentWidth, calculatedLineHeight));
            }
        }
    };
    ZRText.prototype._updateRichTexts = function () {
        var style = this.style;
        var text = getStyleText(style);
        var contentBlock = parseRichText(text, style);
        var contentWidth = contentBlock.width;
        var outerWidth = contentBlock.outerWidth;
        var outerHeight = contentBlock.outerHeight;
        var textPadding = style.padding;
        var baseX = style.x || 0;
        var baseY = style.y || 0;
        var defaultStyle = this._defaultStyle;
        var textAlign = style.align || defaultStyle.align;
        var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
        var boxX = adjustTextX(baseX, outerWidth, textAlign);
        var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
        var xLeft = boxX;
        var lineTop = boxY;
        if (textPadding) {
            xLeft += textPadding[3];
            lineTop += textPadding[0];
        }
        var xRight = xLeft + contentWidth;
        if (needDrawBackground(style)) {
            this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
        }
        var bgColorDrawn = !!(style.backgroundColor);
        for (var i = 0; i < contentBlock.lines.length; i++) {
            var line = contentBlock.lines[i];
            var tokens = line.tokens;
            var tokenCount = tokens.length;
            var lineHeight = line.lineHeight;
            var remainedWidth = line.width;
            var leftIndex = 0;
            var lineXLeft = xLeft;
            var lineXRight = xRight;
            var rightIndex = tokenCount - 1;
            var token = void 0;
            while (leftIndex < tokenCount
                && (token = tokens[leftIndex], !token.align || token.align === 'left')) {
                this._placeToken(token, style, lineHeight, lineTop, lineXLeft, 'left', bgColorDrawn);
                remainedWidth -= token.width;
                lineXLeft += token.width;
                leftIndex++;
            }
            while (rightIndex >= 0
                && (token = tokens[rightIndex], token.align === 'right')) {
                this._placeToken(token, style, lineHeight, lineTop, lineXRight, 'right', bgColorDrawn);
                remainedWidth -= token.width;
                lineXRight -= token.width;
                rightIndex--;
            }
            lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
            while (leftIndex <= rightIndex) {
                token = tokens[leftIndex];
                this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center', bgColorDrawn);
                lineXLeft += token.width;
                leftIndex++;
            }
            lineTop += lineHeight;
        }
    };
    ZRText.prototype._placeToken = function (token, style, lineHeight, lineTop, x, textAlign, parentBgColorDrawn) {
        var tokenStyle = style.rich[token.styleName] || {};
        tokenStyle.text = token.text;
        var verticalAlign = token.verticalAlign;
        var y = lineTop + lineHeight / 2;
        if (verticalAlign === 'top') {
            y = lineTop + token.height / 2;
        }
        else if (verticalAlign === 'bottom') {
            y = lineTop + lineHeight - token.height / 2;
        }
        var needDrawBg = !token.isLineHolder && needDrawBackground(tokenStyle);
        needDrawBg && this._renderBackground(tokenStyle, style, textAlign === 'right'
            ? x - token.width
            : textAlign === 'center'
                ? x - token.width / 2
                : x, y - token.height / 2, token.width, token.height);
        var bgColorDrawn = !!tokenStyle.backgroundColor;
        var textPadding = token.textPadding;
        if (textPadding) {
            x = getTextXForPadding(x, textAlign, textPadding);
            y -= token.height / 2 - textPadding[0] - token.innerHeight / 2;
        }
        var el = this._getOrCreateChild(TSpan$1);
        var subElStyle = el.createStyle();
        el.useStyle(subElStyle);
        var defaultStyle = this._defaultStyle;
        var useDefaultFill = false;
        var defaultLineWidth = 0;
        var textFill = getFill('fill' in tokenStyle ? tokenStyle.fill
            : 'fill' in style ? style.fill
                : (useDefaultFill = true, defaultStyle.fill));
        var textStroke = getStroke('stroke' in tokenStyle ? tokenStyle.stroke
            : 'stroke' in style ? style.stroke
                : (!bgColorDrawn
                    && !parentBgColorDrawn
                    && (!defaultStyle.autoStroke || useDefaultFill)) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke)
                    : null);
        var hasShadow = tokenStyle.textShadowBlur > 0
            || style.textShadowBlur > 0;
        subElStyle.text = token.text;
        subElStyle.x = x;
        subElStyle.y = y;
        if (hasShadow) {
            subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
            subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || 'transparent';
            subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
            subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
        }
        subElStyle.textAlign = textAlign;
        subElStyle.textBaseline = 'middle';
        subElStyle.font = token.font || DEFAULT_FONT;
        subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);
        setSeparateFont(subElStyle, tokenStyle);
        if (textStroke) {
            subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
            subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);
            subElStyle.lineDashOffset = style.lineDashOffset || 0;
            subElStyle.stroke = textStroke;
        }
        if (textFill) {
            subElStyle.fill = textFill;
        }
        var textWidth = token.contentWidth;
        var textHeight = token.contentHeight;
        el.setBoundingRect(new BoundingRect$1(adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), adjustTextY(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight));
    };
    ZRText.prototype._renderBackground = function (style, topStyle, x, y, width, height) {
        var textBackgroundColor = style.backgroundColor;
        var textBorderWidth = style.borderWidth;
        var textBorderColor = style.borderColor;
        var isImageBg = textBackgroundColor && textBackgroundColor.image;
        var isPlainOrGradientBg = textBackgroundColor && !isImageBg;
        var textBorderRadius = style.borderRadius;
        var self = this;
        var rectEl;
        var imgEl;
        if (isPlainOrGradientBg || style.lineHeight || (textBorderWidth && textBorderColor)) {
            rectEl = this._getOrCreateChild(Rect$1);
            rectEl.useStyle(rectEl.createStyle());
            rectEl.style.fill = null;
            var rectShape = rectEl.shape;
            rectShape.x = x;
            rectShape.y = y;
            rectShape.width = width;
            rectShape.height = height;
            rectShape.r = textBorderRadius;
            rectEl.dirtyShape();
        }
        if (isPlainOrGradientBg) {
            var rectStyle = rectEl.style;
            rectStyle.fill = textBackgroundColor || null;
            rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);
        }
        else if (isImageBg) {
            imgEl = this._getOrCreateChild(ZRImage$1);
            imgEl.onload = function () {
                self.dirtyStyle();
            };
            var imgStyle = imgEl.style;
            imgStyle.image = textBackgroundColor.image;
            imgStyle.x = x;
            imgStyle.y = y;
            imgStyle.width = width;
            imgStyle.height = height;
        }
        if (textBorderWidth && textBorderColor) {
            var rectStyle = rectEl.style;
            rectStyle.lineWidth = textBorderWidth;
            rectStyle.stroke = textBorderColor;
            rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);
            rectStyle.lineDash = style.borderDash;
            rectStyle.lineDashOffset = style.borderDashOffset || 0;
            rectEl.strokeContainThreshold = 0;
            if (rectEl.hasFill() && rectEl.hasStroke()) {
                rectStyle.strokeFirst = true;
                rectStyle.lineWidth *= 2;
            }
        }
        var commonStyle = (rectEl || imgEl).style;
        commonStyle.shadowBlur = style.shadowBlur || 0;
        commonStyle.shadowColor = style.shadowColor || 'transparent';
        commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
        commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
        commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);
    };
    ZRText.makeFont = function (style) {
        var font = '';
        if (hasSeparateFont(style)) {
            font = [
                style.fontStyle,
                style.fontWeight,
                parseFontSize(style.fontSize),
                style.fontFamily || 'sans-serif'
            ].join(' ');
        }
        return font && trim(font) || style.textFont || style.font;
    };
    return ZRText;
}(Displayable$1));
var VALID_TEXT_ALIGN = { left: true, right: 1, center: 1 };
var VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 };
var FONT_PARTS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily'];
function parseFontSize(fontSize) {
    if (typeof fontSize === 'string'
        && (fontSize.indexOf('px') !== -1
            || fontSize.indexOf('rem') !== -1
            || fontSize.indexOf('em') !== -1)) {
        return fontSize;
    }
    else if (!isNaN(+fontSize)) {
        return fontSize + 'px';
    }
    else {
        return DEFAULT_FONT_SIZE + 'px';
    }
}
function setSeparateFont(targetStyle, sourceStyle) {
    for (var i = 0; i < FONT_PARTS.length; i++) {
        var fontProp = FONT_PARTS[i];
        var val = sourceStyle[fontProp];
        if (val != null) {
            targetStyle[fontProp] = val;
        }
    }
}
function hasSeparateFont(style) {
    return style.fontSize != null || style.fontFamily || style.fontWeight;
}
function normalizeTextStyle(style) {
    normalizeStyle(style);
    each$9(style.rich, normalizeStyle);
    return style;
}
function normalizeStyle(style) {
    if (style) {
        style.font = ZRText.makeFont(style);
        var textAlign = style.align;
        textAlign === 'middle' && (textAlign = 'center');
        style.align = (textAlign == null || VALID_TEXT_ALIGN[textAlign]) ? textAlign : 'left';
        var verticalAlign = style.verticalAlign;
        verticalAlign === 'center' && (verticalAlign = 'middle');
        style.verticalAlign = (verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign]) ? verticalAlign : 'top';
        var textPadding = style.padding;
        if (textPadding) {
            style.padding = normalizeCssArray$1(style.padding);
        }
    }
}
function getStroke(stroke, lineWidth) {
    return (stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none')
        ? null
        : (stroke.image || stroke.colorStops)
            ? '#000'
            : stroke;
}
function getFill(fill) {
    return (fill == null || fill === 'none')
        ? null
        : (fill.image || fill.colorStops)
            ? '#000'
            : fill;
}
function getTextXForPadding(x, textAlign, textPadding) {
    return textAlign === 'right'
        ? (x - textPadding[1])
        : textAlign === 'center'
            ? (x + textPadding[3] / 2 - textPadding[1] / 2)
            : (x + textPadding[3]);
}
function getStyleText(style) {
    var text = style.text;
    text != null && (text += '');
    return text;
}
function needDrawBackground(style) {
    return !!(style.backgroundColor
        || style.lineHeight
        || (style.borderWidth && style.borderColor));
}
var ZRText$1 = ZRText;

var getECData = makeInner();
var setCommonECData = function (seriesIndex, dataType, dataIdx, el) {
  if (el) {
    var ecData = getECData(el); // Add data index and series index for indexing the data by element
    // Useful in tooltip

    ecData.dataIndex = dataIdx;
    ecData.dataType = dataType;
    ecData.seriesIndex = seriesIndex; // TODO: not store dataIndex on children.

    if (el.type === 'group') {
      el.traverse(function (child) {
        var childECData = getECData(child);
        childECData.seriesIndex = seriesIndex;
        childECData.dataIndex = dataIdx;
        childECData.dataType = dataType;
      });
    }
  }
};

var _highlightNextDigit = 1;
var _highlightKeyMap = {};
var getSavedStates = makeInner();
var getComponentStates = makeInner();
var HOVER_STATE_NORMAL = 0;
var HOVER_STATE_BLUR = 1;
var HOVER_STATE_EMPHASIS = 2;
var SPECIAL_STATES = ['emphasis', 'blur', 'select'];
var DISPLAY_STATES = ['normal', 'emphasis', 'blur', 'select'];
var Z2_EMPHASIS_LIFT = 10;
var Z2_SELECT_LIFT = 9;
var HIGHLIGHT_ACTION_TYPE = 'highlight';
var DOWNPLAY_ACTION_TYPE = 'downplay';
var SELECT_ACTION_TYPE = 'select';
var UNSELECT_ACTION_TYPE = 'unselect';
var TOGGLE_SELECT_ACTION_TYPE = 'toggleSelect';

function hasFillOrStroke(fillOrStroke) {
  return fillOrStroke != null && fillOrStroke !== 'none';
} // Most lifted color are duplicated.


var liftedColorCache = new LRU$1(100);

function liftColor(color$1) {
  if (isString(color$1)) {
    var liftedColor = liftedColorCache.get(color$1);

    if (!liftedColor) {
      liftedColor = lift(color$1, -0.1);
      liftedColorCache.put(color$1, liftedColor);
    }

    return liftedColor;
  } else if (isGradientObject(color$1)) {
    var ret = extend$2({}, color$1);
    ret.colorStops = map$1(color$1.colorStops, function (stop) {
      return {
        offset: stop.offset,
        color: lift(stop.color, -0.1)
      };
    });
    return ret;
  } // Change nothing.


  return color$1;
}

function doChangeHoverState(el, stateName, hoverStateEnum) {
  if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {
    el.onHoverStateChange(stateName);
  }

  el.hoverState = hoverStateEnum;
}

function singleEnterEmphasis(el) {
  // Only mark the flag.
  // States will be applied in the echarts.ts in next frame.
  doChangeHoverState(el, 'emphasis', HOVER_STATE_EMPHASIS);
}

function singleLeaveEmphasis(el) {
  // Only mark the flag.
  // States will be applied in the echarts.ts in next frame.
  if (el.hoverState === HOVER_STATE_EMPHASIS) {
    doChangeHoverState(el, 'normal', HOVER_STATE_NORMAL);
  }
}

function singleEnterBlur(el) {
  doChangeHoverState(el, 'blur', HOVER_STATE_BLUR);
}

function singleLeaveBlur(el) {
  if (el.hoverState === HOVER_STATE_BLUR) {
    doChangeHoverState(el, 'normal', HOVER_STATE_NORMAL);
  }
}

function singleEnterSelect(el) {
  el.selected = true;
}

function singleLeaveSelect(el) {
  el.selected = false;
}

function updateElementState(el, updater, commonParam) {
  updater(el, commonParam);
}

function traverseUpdateState(el, updater, commonParam) {
  updateElementState(el, updater, commonParam);
  el.isGroup && el.traverse(function (child) {
    updateElementState(child, updater, commonParam);
  });
}

function setStatesFlag(el, stateName) {
  switch (stateName) {
    case 'emphasis':
      el.hoverState = HOVER_STATE_EMPHASIS;
      break;

    case 'normal':
      el.hoverState = HOVER_STATE_NORMAL;
      break;

    case 'blur':
      el.hoverState = HOVER_STATE_BLUR;
      break;

    case 'select':
      el.selected = true;
  }
}

function getFromStateStyle(el, props, toStateName, defaultValue) {
  var style = el.style;
  var fromState = {};

  for (var i = 0; i < props.length; i++) {
    var propName = props[i];
    var val = style[propName];
    fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
  }

  for (var i = 0; i < el.animators.length; i++) {
    var animator = el.animators[i];

    if (animator.__fromStateTransition // Dont consider the animation to emphasis state.
    && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === 'style') {
      animator.saveTo(fromState, props);
    }
  }

  return fromState;
}

function createEmphasisDefaultState(el, stateName, targetStates, state) {
  var hasSelect = targetStates && indexOf(targetStates, 'select') >= 0;
  var cloned = false;

  if (el instanceof Path$1) {
    var store = getSavedStates(el);
    var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
    var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;

    if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
      state = state || {};
      var emphasisStyle = state.style || {}; // inherit case

      if (emphasisStyle.fill === 'inherit') {
        cloned = true;
        state = extend$2({}, state);
        emphasisStyle = extend$2({}, emphasisStyle);
        emphasisStyle.fill = fromFill;
      } // Apply default color lift
      else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
          cloned = true; // Not modify the original value.

          state = extend$2({}, state);
          emphasisStyle = extend$2({}, emphasisStyle); // Already being applied 'emphasis'. DON'T lift color multiple times.

          emphasisStyle.fill = liftColor(fromFill);
        } // Not highlight stroke if fill has been highlighted.
        else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
            if (!cloned) {
              state = extend$2({}, state);
              emphasisStyle = extend$2({}, emphasisStyle);
            }

            emphasisStyle.stroke = liftColor(fromStroke);
          }

      state.style = emphasisStyle;
    }
  }

  if (state) {
    // TODO Share with textContent?
    if (state.z2 == null) {
      if (!cloned) {
        state = extend$2({}, state);
      }

      var z2EmphasisLift = el.z2EmphasisLift;
      state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
    }
  }

  return state;
}

function createSelectDefaultState(el, stateName, state) {
  // const hasSelect = indexOf(el.currentStates, stateName) >= 0;
  if (state) {
    // TODO Share with textContent?
    if (state.z2 == null) {
      state = extend$2({}, state);
      var z2SelectLift = el.z2SelectLift;
      state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
    }
  }

  return state;
}

function createBlurDefaultState(el, stateName, state) {
  var hasBlur = indexOf(el.currentStates, stateName) >= 0;
  var currentOpacity = el.style.opacity;
  var fromState = !hasBlur ? getFromStateStyle(el, ['opacity'], stateName, {
    opacity: 1
  }) : null;
  state = state || {};
  var blurStyle = state.style || {};

  if (blurStyle.opacity == null) {
    // clone state
    state = extend$2({}, state);
    blurStyle = extend$2({
      // Already being applied 'emphasis'. DON'T mul opacity multiple times.
      opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
    }, blurStyle);
    state.style = blurStyle;
  }

  return state;
}

function elementStateProxy(stateName, targetStates) {
  var state = this.states[stateName];

  if (this.style) {
    if (stateName === 'emphasis') {
      return createEmphasisDefaultState(this, stateName, targetStates, state);
    } else if (stateName === 'blur') {
      return createBlurDefaultState(this, stateName, state);
    } else if (stateName === 'select') {
      return createSelectDefaultState(this, stateName, state);
    }
  }

  return state;
}
/**FI
 * Set hover style (namely "emphasis style") of element.
 * @param el Should not be `zrender/graphic/Group`.
 * @param focus 'self' | 'selfInSeries' | 'series'
 */


function setDefaultStateProxy(el) {
  el.stateProxy = elementStateProxy;
  var textContent = el.getTextContent();
  var textGuide = el.getTextGuideLine();

  if (textContent) {
    textContent.stateProxy = elementStateProxy;
  }

  if (textGuide) {
    textGuide.stateProxy = elementStateProxy;
  }
}
function enterEmphasisWhenMouseOver(el, e) {
  !shouldSilent(el, e) // "emphasis" event highlight has higher priority than mouse highlight.
  && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(el, e) {
  !shouldSilent(el, e) // "emphasis" event highlight has higher priority than mouse highlight.
  && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterEmphasis(el, highlightDigit) {
  el.__highByOuter |= 1 << (highlightDigit || 0);
  traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasis(el, highlightDigit) {
  !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterBlur(el) {
  traverseUpdateState(el, singleEnterBlur);
}
function leaveBlur(el) {
  traverseUpdateState(el, singleLeaveBlur);
}
function enterSelect(el) {
  traverseUpdateState(el, singleEnterSelect);
}
function leaveSelect(el) {
  traverseUpdateState(el, singleLeaveSelect);
}

function shouldSilent(el, e) {
  return el.__highDownSilentOnTouch && e.zrByTouch;
}

function allLeaveBlur(api) {
  var model = api.getModel();
  var leaveBlurredSeries = [];
  var allComponentViews = [];
  model.eachComponent(function (componentType, componentModel) {
    var componentStates = getComponentStates(componentModel);
    var isSeries = componentType === 'series';
    var view = isSeries ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);
    !isSeries && allComponentViews.push(view);

    if (componentStates.isBlured) {
      // Leave blur anyway
      view.group.traverse(function (child) {
        singleLeaveBlur(child);
      });
      isSeries && leaveBlurredSeries.push(componentModel);
    }

    componentStates.isBlured = false;
  });
  each$9(allComponentViews, function (view) {
    if (view && view.toggleBlurSeries) {
      view.toggleBlurSeries(leaveBlurredSeries, false, model);
    }
  });
}
function blurSeries(targetSeriesIndex, focus, blurScope, api) {
  var ecModel = api.getModel();
  blurScope = blurScope || 'coordinateSystem';

  function leaveBlurOfIndices(data, dataIndices) {
    for (var i = 0; i < dataIndices.length; i++) {
      var itemEl = data.getItemGraphicEl(dataIndices[i]);
      itemEl && leaveBlur(itemEl);
    }
  }

  if (targetSeriesIndex == null) {
    return;
  }

  if (!focus || focus === 'none') {
    return;
  }

  var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
  var targetCoordSys = targetSeriesModel.coordinateSystem;

  if (targetCoordSys && targetCoordSys.master) {
    targetCoordSys = targetCoordSys.master;
  }

  var blurredSeries = [];
  ecModel.eachSeries(function (seriesModel) {
    var sameSeries = targetSeriesModel === seriesModel;
    var coordSys = seriesModel.coordinateSystem;

    if (coordSys && coordSys.master) {
      coordSys = coordSys.master;
    }

    var sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries; // If there is no coordinate system. use sameSeries instead.

    if (!( // Not blur other series if blurScope series
    blurScope === 'series' && !sameSeries // Not blur other coordinate system if blurScope is coordinateSystem
    || blurScope === 'coordinateSystem' && !sameCoordSys // Not blur self series if focus is series.
    || focus === 'series' && sameSeries // TODO blurScope: coordinate system
    )) {
      var view = api.getViewOfSeriesModel(seriesModel);
      view.group.traverse(function (child) {
        singleEnterBlur(child);
      });

      if (isArrayLike(focus)) {
        leaveBlurOfIndices(seriesModel.getData(), focus);
      } else if (isObject$3(focus)) {
        var dataTypes = keys(focus);

        for (var d = 0; d < dataTypes.length; d++) {
          leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]]);
        }
      }

      blurredSeries.push(seriesModel);
      getComponentStates(seriesModel).isBlured = true;
    }
  });
  ecModel.eachComponent(function (componentType, componentModel) {
    if (componentType === 'series') {
      return;
    }

    var view = api.getViewOfComponentModel(componentModel);

    if (view && view.toggleBlurSeries) {
      view.toggleBlurSeries(blurredSeries, true, ecModel);
    }
  });
}
function blurComponent(componentMainType, componentIndex, api) {
  if (componentMainType == null || componentIndex == null) {
    return;
  }

  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);

  if (!componentModel) {
    return;
  }

  getComponentStates(componentModel).isBlured = true;
  var view = api.getViewOfComponentModel(componentModel);

  if (!view || !view.focusBlurEnabled) {
    return;
  }

  view.group.traverse(function (child) {
    singleEnterBlur(child);
  });
}
function blurSeriesFromHighlightPayload(seriesModel, payload, api) {
  var seriesIndex = seriesModel.seriesIndex;
  var data = seriesModel.getData(payload.dataType);

  if (!data) {
    if (process.env.NODE_ENV !== 'production') {
      error("Unknown dataType " + payload.dataType);
    }

    return;
  }

  var dataIndex = queryDataIndex(data, payload); // Pick the first one if there is multiple/none exists.

  dataIndex = (isArray$1(dataIndex) ? dataIndex[0] : dataIndex) || 0;
  var el = data.getItemGraphicEl(dataIndex);

  if (!el) {
    var count = data.count();
    var current = 0; // If data on dataIndex is NaN.

    while (!el && current < count) {
      el = data.getItemGraphicEl(current++);
    }
  }

  if (el) {
    var ecData = getECData(el);
    blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api);
  } else {
    // If there is no element put on the data. Try getting it from raw option
    // TODO Should put it on seriesModel?
    var focus_1 = seriesModel.get(['emphasis', 'focus']);
    var blurScope = seriesModel.get(['emphasis', 'blurScope']);

    if (focus_1 != null) {
      blurSeries(seriesIndex, focus_1, blurScope, api);
    }
  }
}
function findComponentHighDownDispatchers(componentMainType, componentIndex, name, api) {
  var ret = {
    focusSelf: false,
    dispatchers: null
  };

  if (componentMainType == null || componentMainType === 'series' || componentIndex == null || name == null) {
    return ret;
  }

  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);

  if (!componentModel) {
    return ret;
  }

  var view = api.getViewOfComponentModel(componentModel);

  if (!view || !view.findHighDownDispatchers) {
    return ret;
  }

  var dispatchers = view.findHighDownDispatchers(name); // At presnet, the component (like Geo) only blur inside itself.
  // So we do not use `blurScope` in component.

  var focusSelf;

  for (var i = 0; i < dispatchers.length; i++) {
    if (process.env.NODE_ENV !== 'production' && !isHighDownDispatcher(dispatchers[i])) {
      error('param should be highDownDispatcher');
    }

    if (getECData(dispatchers[i]).focus === 'self') {
      focusSelf = true;
      break;
    }
  }

  return {
    focusSelf: focusSelf,
    dispatchers: dispatchers
  };
}
function handleGlobalMouseOverForHighDown(dispatcher, e, api) {
  if (process.env.NODE_ENV !== 'production' && !isHighDownDispatcher(dispatcher)) {
    error('param should be highDownDispatcher');
  }

  var ecData = getECData(dispatcher);

  var _a = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api),
      dispatchers = _a.dispatchers,
      focusSelf = _a.focusSelf; // If `findHighDownDispatchers` is supported on the component,
  // highlight/downplay elements with the same name.


  if (dispatchers) {
    if (focusSelf) {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api);
    }

    each$9(dispatchers, function (dispatcher) {
      return enterEmphasisWhenMouseOver(dispatcher, e);
    });
  } else {
    // Try blur all in the related series. Then emphasis the hoverred.
    // TODO. progressive mode.
    blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api);

    if (ecData.focus === 'self') {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api);
    } // Other than series, component that not support `findHighDownDispatcher` will
    // also use it. But in this case, highlight/downplay are only supported in
    // mouse hover but not in dispatchAction.


    enterEmphasisWhenMouseOver(dispatcher, e);
  }
}
function handleGlobalMouseOutForHighDown(dispatcher, e, api) {
  if (process.env.NODE_ENV !== 'production' && !isHighDownDispatcher(dispatcher)) {
    error('param should be highDownDispatcher');
  }

  allLeaveBlur(api);
  var ecData = getECData(dispatcher);
  var dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api).dispatchers;

  if (dispatchers) {
    each$9(dispatchers, function (dispatcher) {
      return leaveEmphasisWhenMouseOut(dispatcher, e);
    });
  } else {
    leaveEmphasisWhenMouseOut(dispatcher, e);
  }
}
function toggleSelectionFromPayload(seriesModel, payload, api) {
  if (!isSelectChangePayload(payload)) {
    return;
  }

  var dataType = payload.dataType;
  var data = seriesModel.getData(dataType);
  var dataIndex = queryDataIndex(data, payload);

  if (!isArray$1(dataIndex)) {
    dataIndex = [dataIndex];
  }

  seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? 'toggleSelect' : payload.type === SELECT_ACTION_TYPE ? 'select' : 'unselect'](dataIndex, dataType);
}
function updateSeriesElementSelection(seriesModel) {
  var allData = seriesModel.getAllData();
  each$9(allData, function (_a) {
    var data = _a.data,
        type = _a.type;
    data.eachItemGraphicEl(function (el, idx) {
      seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
    });
  });
}
function getAllSelectedIndices(ecModel) {
  var ret = [];
  ecModel.eachSeries(function (seriesModel) {
    var allData = seriesModel.getAllData();
    each$9(allData, function (_a) {
      _a.data;
          var type = _a.type;
      var dataIndices = seriesModel.getSelectedDataIndices();

      if (dataIndices.length > 0) {
        var item = {
          dataIndex: dataIndices,
          seriesIndex: seriesModel.seriesIndex
        };

        if (type != null) {
          item.dataType = type;
        }

        ret.push(item);
      }
    });
  });
  return ret;
}
/**
 * Enable the function that mouseover will trigger the emphasis state.
 *
 * NOTE:
 * This function should be used on the element with dataIndex, seriesIndex.
 *
 */

function enableHoverEmphasis(el, focus, blurScope) {
  setAsHighDownDispatcher(el, true);
  traverseUpdateState(el, setDefaultStateProxy);
  enableHoverFocus(el, focus, blurScope);
}
function disableHoverEmphasis(el) {
  setAsHighDownDispatcher(el, false);
}
function toggleHoverEmphasis(el, focus, blurScope, isDisabled) {
  isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);
}
function enableHoverFocus(el, focus, blurScope) {
  var ecData = getECData(el);

  if (focus != null) {
    // TODO dataIndex may be set after this function. This check is not useful.
    // if (ecData.dataIndex == null) {
    //     if (__DEV__) {
    //         console.warn('focus can only been set on element with dataIndex');
    //     }
    // }
    // else {
    ecData.focus = focus;
    ecData.blurScope = blurScope; // }
  } else if (ecData.focus) {
    ecData.focus = null;
  }
}
var OTHER_STATES = ['emphasis', 'blur', 'select'];
var defaultStyleGetterMap = {
  itemStyle: 'getItemStyle',
  lineStyle: 'getLineStyle',
  areaStyle: 'getAreaStyle'
};
/**
 * Set emphasis/blur/selected states of element.
 */

function setStatesStylesFromModel(el, itemModel, styleType, // default itemStyle
getter) {
  styleType = styleType || 'itemStyle';

  for (var i = 0; i < OTHER_STATES.length; i++) {
    var stateName = OTHER_STATES[i];
    var model = itemModel.getModel([stateName, styleType]);
    var state = el.ensureState(stateName); // Let it throw error if getterType is not found.

    state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();
  }
}
/**
 *
 * Set element as highlight / downplay dispatcher.
 * It will be checked when element recieved mouseover event or from highlight action.
 * It's in change of all highlight/downplay behavior of it's children.
 *
 * @param el
 * @param el.highDownSilentOnTouch
 *        In touch device, mouseover event will be trigger on touchstart event
 *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
 *        conveniently use hoverStyle when tap on touch screen without additional
 *        code for compatibility.
 *        But if the chart/component has select feature, which usually also use
 *        hoverStyle, there might be conflict between 'select-highlight' and
 *        'hover-highlight' especially when roam is enabled (see geo for example).
 *        In this case, `highDownSilentOnTouch` should be used to disable
 *        hover-highlight on touch device.
 * @param asDispatcher If `false`, do not set as "highDownDispatcher".
 */

function setAsHighDownDispatcher(el, asDispatcher) {
  var disable = asDispatcher === false;
  var extendedEl = el; // Make `highDownSilentOnTouch` and `onStateChange` only work after
  // `setAsHighDownDispatcher` called. Avoid it is modified by user unexpectedly.

  if (el.highDownSilentOnTouch) {
    extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
  } // Simple optimize, since this method might be
  // called for each elements of a group in some cases.


  if (!disable || extendedEl.__highDownDispatcher) {
    // Emphasis, normal can be triggered manually by API or other components like hover link.
    // el[method]('emphasis', onElementEmphasisEvent)[method]('normal', onElementNormalEvent);
    // Also keep previous record.
    extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
    extendedEl.__highDownDispatcher = !disable;
  }
}
function isHighDownDispatcher(el) {
  return !!(el && el.__highDownDispatcher);
}
/**
 * Enable component highlight/downplay features:
 * + hover link (within the same name)
 * + focus blur in component
 */

function enableComponentHighDownFeatures(el, componentModel, componentHighDownName) {
  var ecData = getECData(el);
  ecData.componentMainType = componentModel.mainType;
  ecData.componentIndex = componentModel.componentIndex;
  ecData.componentHighDownName = componentHighDownName;
}
/**
 * Support hightlight/downplay record on each elements.
 * For the case: hover highlight/downplay (legend, visualMap, ...) and
 * user triggerred hightlight/downplay should not conflict.
 * Only all of the highlightDigit cleared, return to normal.
 * @param {string} highlightKey
 * @return {number} highlightDigit
 */

function getHighlightDigit(highlightKey) {
  var highlightDigit = _highlightKeyMap[highlightKey];

  if (highlightDigit == null && _highlightNextDigit <= 32) {
    highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
  }

  return highlightDigit;
}
function isSelectChangePayload(payload) {
  var payloadType = payload.type;
  return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
}
function isHighDownPayload(payload) {
  var payloadType = payload.type;
  return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
}
function savePathStates(el) {
  var store = getSavedStates(el);
  store.normalFill = el.style.fill;
  store.normalStroke = el.style.stroke;
  var selectState = el.states.select || {};
  store.selectFill = selectState.style && selectState.style.fill || null;
  store.selectStroke = selectState.style && selectState.style.stroke || null;
}

var CMD = PathProxy$1.CMD;
var points$2 = [[], [], []];
var mathSqrt$2 = Math.sqrt;
var mathAtan2 = Math.atan2;
function transformPath(path, m) {
    if (!m) {
        return;
    }
    var data = path.data;
    var len = path.len();
    var cmd;
    var nPoint;
    var i;
    var j;
    var k;
    var p;
    var M = CMD.M;
    var C = CMD.C;
    var L = CMD.L;
    var R = CMD.R;
    var A = CMD.A;
    var Q = CMD.Q;
    for (i = 0, j = 0; i < len;) {
        cmd = data[i++];
        j = i;
        nPoint = 0;
        switch (cmd) {
            case M:
                nPoint = 1;
                break;
            case L:
                nPoint = 1;
                break;
            case C:
                nPoint = 3;
                break;
            case Q:
                nPoint = 2;
                break;
            case A:
                var x = m[4];
                var y = m[5];
                var sx = mathSqrt$2(m[0] * m[0] + m[1] * m[1]);
                var sy = mathSqrt$2(m[2] * m[2] + m[3] * m[3]);
                var angle = mathAtan2(-m[1] / sy, m[0] / sx);
                data[i] *= sx;
                data[i++] += x;
                data[i] *= sy;
                data[i++] += y;
                data[i++] *= sx;
                data[i++] *= sy;
                data[i++] += angle;
                data[i++] += angle;
                i += 2;
                j = i;
                break;
            case R:
                p[0] = data[i++];
                p[1] = data[i++];
                applyTransform$1(p, p, m);
                data[j++] = p[0];
                data[j++] = p[1];
                p[0] += data[i++];
                p[1] += data[i++];
                applyTransform$1(p, p, m);
                data[j++] = p[0];
                data[j++] = p[1];
        }
        for (k = 0; k < nPoint; k++) {
            var p_1 = points$2[k];
            p_1[0] = data[i++];
            p_1[1] = data[i++];
            applyTransform$1(p_1, p_1, m);
            data[j++] = p_1[0];
            data[j++] = p_1[1];
        }
    }
    path.increaseVersion();
}

var mathSqrt$1 = Math.sqrt;
var mathSin$1 = Math.sin;
var mathCos$1 = Math.cos;
var PI$3 = Math.PI;
function vMag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
    return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
}
function vAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)
        * Math.acos(vRatio(u, v));
}
function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
    var psi = psiDeg * (PI$3 / 180.0);
    var xp = mathCos$1(psi) * (x1 - x2) / 2.0
        + mathSin$1(psi) * (y1 - y2) / 2.0;
    var yp = -1 * mathSin$1(psi) * (x1 - x2) / 2.0
        + mathCos$1(psi) * (y1 - y2) / 2.0;
    var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
    if (lambda > 1) {
        rx *= mathSqrt$1(lambda);
        ry *= mathSqrt$1(lambda);
    }
    var f = (fa === fs ? -1 : 1)
        * mathSqrt$1((((rx * rx) * (ry * ry))
            - ((rx * rx) * (yp * yp))
            - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)
            + (ry * ry) * (xp * xp))) || 0;
    var cxp = f * rx * yp / ry;
    var cyp = f * -ry * xp / rx;
    var cx = (x1 + x2) / 2.0
        + mathCos$1(psi) * cxp
        - mathSin$1(psi) * cyp;
    var cy = (y1 + y2) / 2.0
        + mathSin$1(psi) * cxp
        + mathCos$1(psi) * cyp;
    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
        dTheta = PI$3;
    }
    if (vRatio(u, v) >= 1) {
        dTheta = 0;
    }
    if (dTheta < 0) {
        var n = Math.round(dTheta / PI$3 * 1e6) / 1e6;
        dTheta = PI$3 * 2 + (n % 2) * PI$3;
    }
    path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
var numberReg$1 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(data) {
    var path = new PathProxy$1();
    if (!data) {
        return path;
    }
    var cpx = 0;
    var cpy = 0;
    var subpathX = cpx;
    var subpathY = cpy;
    var prevCmd;
    var CMD = PathProxy$1.CMD;
    var cmdList = data.match(commandReg);
    if (!cmdList) {
        return path;
    }
    for (var l = 0; l < cmdList.length; l++) {
        var cmdText = cmdList[l];
        var cmdStr = cmdText.charAt(0);
        var cmd = void 0;
        var p = cmdText.match(numberReg$1) || [];
        var pLen = p.length;
        for (var i = 0; i < pLen; i++) {
            p[i] = parseFloat(p[i]);
        }
        var off = 0;
        while (off < pLen) {
            var ctlPtx = void 0;
            var ctlPty = void 0;
            var rx = void 0;
            var ry = void 0;
            var psi = void 0;
            var fa = void 0;
            var fs = void 0;
            var x1 = cpx;
            var y1 = cpy;
            var len = void 0;
            var pathData = void 0;
            switch (cmdStr) {
                case 'l':
                    cpx += p[off++];
                    cpy += p[off++];
                    cmd = CMD.L;
                    path.addData(cmd, cpx, cpy);
                    break;
                case 'L':
                    cpx = p[off++];
                    cpy = p[off++];
                    cmd = CMD.L;
                    path.addData(cmd, cpx, cpy);
                    break;
                case 'm':
                    cpx += p[off++];
                    cpy += p[off++];
                    cmd = CMD.M;
                    path.addData(cmd, cpx, cpy);
                    subpathX = cpx;
                    subpathY = cpy;
                    cmdStr = 'l';
                    break;
                case 'M':
                    cpx = p[off++];
                    cpy = p[off++];
                    cmd = CMD.M;
                    path.addData(cmd, cpx, cpy);
                    subpathX = cpx;
                    subpathY = cpy;
                    cmdStr = 'L';
                    break;
                case 'h':
                    cpx += p[off++];
                    cmd = CMD.L;
                    path.addData(cmd, cpx, cpy);
                    break;
                case 'H':
                    cpx = p[off++];
                    cmd = CMD.L;
                    path.addData(cmd, cpx, cpy);
                    break;
                case 'v':
                    cpy += p[off++];
                    cmd = CMD.L;
                    path.addData(cmd, cpx, cpy);
                    break;
                case 'V':
                    cpy = p[off++];
                    cmd = CMD.L;
                    path.addData(cmd, cpx, cpy);
                    break;
                case 'C':
                    cmd = CMD.C;
                    path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
                    cpx = p[off - 2];
                    cpy = p[off - 1];
                    break;
                case 'c':
                    cmd = CMD.C;
                    path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
                    cpx += p[off - 2];
                    cpy += p[off - 1];
                    break;
                case 'S':
                    ctlPtx = cpx;
                    ctlPty = cpy;
                    len = path.len();
                    pathData = path.data;
                    if (prevCmd === CMD.C) {
                        ctlPtx += cpx - pathData[len - 4];
                        ctlPty += cpy - pathData[len - 3];
                    }
                    cmd = CMD.C;
                    x1 = p[off++];
                    y1 = p[off++];
                    cpx = p[off++];
                    cpy = p[off++];
                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
                    break;
                case 's':
                    ctlPtx = cpx;
                    ctlPty = cpy;
                    len = path.len();
                    pathData = path.data;
                    if (prevCmd === CMD.C) {
                        ctlPtx += cpx - pathData[len - 4];
                        ctlPty += cpy - pathData[len - 3];
                    }
                    cmd = CMD.C;
                    x1 = cpx + p[off++];
                    y1 = cpy + p[off++];
                    cpx += p[off++];
                    cpy += p[off++];
                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
                    break;
                case 'Q':
                    x1 = p[off++];
                    y1 = p[off++];
                    cpx = p[off++];
                    cpy = p[off++];
                    cmd = CMD.Q;
                    path.addData(cmd, x1, y1, cpx, cpy);
                    break;
                case 'q':
                    x1 = p[off++] + cpx;
                    y1 = p[off++] + cpy;
                    cpx += p[off++];
                    cpy += p[off++];
                    cmd = CMD.Q;
                    path.addData(cmd, x1, y1, cpx, cpy);
                    break;
                case 'T':
                    ctlPtx = cpx;
                    ctlPty = cpy;
                    len = path.len();
                    pathData = path.data;
                    if (prevCmd === CMD.Q) {
                        ctlPtx += cpx - pathData[len - 4];
                        ctlPty += cpy - pathData[len - 3];
                    }
                    cpx = p[off++];
                    cpy = p[off++];
                    cmd = CMD.Q;
                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
                    break;
                case 't':
                    ctlPtx = cpx;
                    ctlPty = cpy;
                    len = path.len();
                    pathData = path.data;
                    if (prevCmd === CMD.Q) {
                        ctlPtx += cpx - pathData[len - 4];
                        ctlPty += cpy - pathData[len - 3];
                    }
                    cpx += p[off++];
                    cpy += p[off++];
                    cmd = CMD.Q;
                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
                    break;
                case 'A':
                    rx = p[off++];
                    ry = p[off++];
                    psi = p[off++];
                    fa = p[off++];
                    fs = p[off++];
                    x1 = cpx, y1 = cpy;
                    cpx = p[off++];
                    cpy = p[off++];
                    cmd = CMD.A;
                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
                    break;
                case 'a':
                    rx = p[off++];
                    ry = p[off++];
                    psi = p[off++];
                    fa = p[off++];
                    fs = p[off++];
                    x1 = cpx, y1 = cpy;
                    cpx += p[off++];
                    cpy += p[off++];
                    cmd = CMD.A;
                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
                    break;
            }
        }
        if (cmdStr === 'z' || cmdStr === 'Z') {
            cmd = CMD.Z;
            path.addData(cmd);
            cpx = subpathX;
            cpy = subpathY;
        }
        prevCmd = cmd;
    }
    path.toStatic();
    return path;
}
var SVGPath = (function (_super) {
    __extends(SVGPath, _super);
    function SVGPath() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SVGPath.prototype.applyTransform = function (m) { };
    return SVGPath;
}(Path$1));
function isPathProxy(path) {
    return path.setData != null;
}
function createPathOptions(str, opts) {
    var pathProxy = createPathProxyFromString(str);
    var innerOpts = extend$2({}, opts);
    innerOpts.buildPath = function (path) {
        if (isPathProxy(path)) {
            path.setData(pathProxy.data);
            var ctx = path.getContext();
            if (ctx) {
                path.rebuildPath(ctx, 1);
            }
        }
        else {
            var ctx = path;
            pathProxy.rebuildPath(ctx, 1);
        }
    };
    innerOpts.applyTransform = function (m) {
        transformPath(pathProxy, m);
        this.dirtyShape();
    };
    return innerOpts;
}
function createFromString(str, opts) {
    return new SVGPath(createPathOptions(str, opts));
}
function extendFromString(str, defaultOpts) {
    var innerOpts = createPathOptions(str, defaultOpts);
    var Sub = (function (_super) {
        __extends(Sub, _super);
        function Sub(opts) {
            var _this = _super.call(this, opts) || this;
            _this.applyTransform = innerOpts.applyTransform;
            _this.buildPath = innerOpts.buildPath;
            return _this;
        }
        return Sub;
    }(SVGPath));
    return Sub;
}
function mergePath$1(pathEls, opts) {
    var pathList = [];
    var len = pathEls.length;
    for (var i = 0; i < len; i++) {
        var pathEl = pathEls[i];
        pathList.push(pathEl.getUpdatedPathProxy(true));
    }
    var pathBundle = new Path$1(opts);
    pathBundle.createPathProxy();
    pathBundle.buildPath = function (path) {
        if (isPathProxy(path)) {
            path.appendPath(pathList);
            var ctx = path.getContext();
            if (ctx) {
                path.rebuildPath(ctx, 1);
            }
        }
    };
    return pathBundle;
}

var CircleShape = (function () {
    function CircleShape() {
        this.cx = 0;
        this.cy = 0;
        this.r = 0;
    }
    return CircleShape;
}());
var Circle = (function (_super) {
    __extends(Circle, _super);
    function Circle(opts) {
        return _super.call(this, opts) || this;
    }
    Circle.prototype.getDefaultShape = function () {
        return new CircleShape();
    };
    Circle.prototype.buildPath = function (ctx, shape) {
        ctx.moveTo(shape.cx + shape.r, shape.cy);
        ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
    };
    return Circle;
}(Path$1));
Circle.prototype.type = 'circle';
var Circle$1 = Circle;

var EllipseShape = (function () {
    function EllipseShape() {
        this.cx = 0;
        this.cy = 0;
        this.rx = 0;
        this.ry = 0;
    }
    return EllipseShape;
}());
var Ellipse = (function (_super) {
    __extends(Ellipse, _super);
    function Ellipse(opts) {
        return _super.call(this, opts) || this;
    }
    Ellipse.prototype.getDefaultShape = function () {
        return new EllipseShape();
    };
    Ellipse.prototype.buildPath = function (ctx, shape) {
        var k = 0.5522848;
        var x = shape.cx;
        var y = shape.cy;
        var a = shape.rx;
        var b = shape.ry;
        var ox = a * k;
        var oy = b * k;
        ctx.moveTo(x - a, y);
        ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
        ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
        ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
        ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
        ctx.closePath();
    };
    return Ellipse;
}(Path$1));
Ellipse.prototype.type = 'ellipse';
var Ellipse$1 = Ellipse;

var PI$2 = Math.PI;
var PI2$1 = PI$2 * 2;
var mathSin = Math.sin;
var mathCos = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathAbs = Math.abs;
var mathSqrt = Math.sqrt;
var mathMax$4 = Math.max;
var mathMin$4 = Math.min;
var e = 1e-4;
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var dx10 = x1 - x0;
    var dy10 = y1 - y0;
    var dx32 = x3 - x2;
    var dy32 = y3 - y2;
    var t = dy32 * dx10 - dx32 * dy10;
    if (t * t < e) {
        return;
    }
    t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
    return [x0 + t * dx10, y0 + t * dy10];
}
function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
    var x01 = x0 - x1;
    var y01 = y0 - y1;
    var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
    var ox = lo * y01;
    var oy = -lo * x01;
    var x11 = x0 + ox;
    var y11 = y0 + oy;
    var x10 = x1 + ox;
    var y10 = y1 + oy;
    var x00 = (x11 + x10) / 2;
    var y00 = (y11 + y10) / 2;
    var dx = x10 - x11;
    var dy = y10 - y11;
    var d2 = dx * dx + dy * dy;
    var r = radius - cr;
    var s = x11 * y10 - x10 * y11;
    var d = (dy < 0 ? -1 : 1) * mathSqrt(mathMax$4(0, r * r * d2 - s * s));
    var cx0 = (s * dy - dx * d) / d2;
    var cy0 = (-s * dx - dy * d) / d2;
    var cx1 = (s * dy + dx * d) / d2;
    var cy1 = (-s * dx + dy * d) / d2;
    var dx0 = cx0 - x00;
    var dy0 = cy0 - y00;
    var dx1 = cx1 - x00;
    var dy1 = cy1 - y00;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
        cx0 = cx1;
        cy0 = cy1;
    }
    return {
        cx: cx0,
        cy: cy0,
        x0: -ox,
        y0: -oy,
        x1: cx0 * (radius / r - 1),
        y1: cy0 * (radius / r - 1)
    };
}
function normalizeCornerRadius(cr) {
    var arr;
    if (isArray$1(cr)) {
        var len = cr.length;
        if (!len) {
            return cr;
        }
        if (len === 1) {
            arr = [cr[0], cr[0], 0, 0];
        }
        else if (len === 2) {
            arr = [cr[0], cr[0], cr[1], cr[1]];
        }
        else if (len === 3) {
            arr = cr.concat(cr[2]);
        }
        else {
            arr = cr;
        }
    }
    else {
        arr = [cr, cr, cr, cr];
    }
    return arr;
}
function buildPath$1(ctx, shape) {
    var _a;
    var radius = mathMax$4(shape.r, 0);
    var innerRadius = mathMax$4(shape.r0 || 0, 0);
    var hasRadius = radius > 0;
    var hasInnerRadius = innerRadius > 0;
    if (!hasRadius && !hasInnerRadius) {
        return;
    }
    if (!hasRadius) {
        radius = innerRadius;
        innerRadius = 0;
    }
    if (innerRadius > radius) {
        var tmp = radius;
        radius = innerRadius;
        innerRadius = tmp;
    }
    var startAngle = shape.startAngle, endAngle = shape.endAngle;
    if (isNaN(startAngle) || isNaN(endAngle)) {
        return;
    }
    var cx = shape.cx, cy = shape.cy;
    var clockwise = !!shape.clockwise;
    var arc = mathAbs(endAngle - startAngle);
    var mod = arc > PI2$1 && arc % PI2$1;
    mod > e && (arc = mod);
    if (!(radius > e)) {
        ctx.moveTo(cx, cy);
    }
    else if (arc > PI2$1 - e) {
        ctx.moveTo(cx + radius * mathCos(startAngle), cy + radius * mathSin(startAngle));
        ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
        if (innerRadius > e) {
            ctx.moveTo(cx + innerRadius * mathCos(endAngle), cy + innerRadius * mathSin(endAngle));
            ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
        }
    }
    else {
        var icrStart = void 0;
        var icrEnd = void 0;
        var ocrStart = void 0;
        var ocrEnd = void 0;
        var ocrs = void 0;
        var ocre = void 0;
        var icrs = void 0;
        var icre = void 0;
        var ocrMax = void 0;
        var icrMax = void 0;
        var limitedOcrMax = void 0;
        var limitedIcrMax = void 0;
        var xre = void 0;
        var yre = void 0;
        var xirs = void 0;
        var yirs = void 0;
        var xrs = radius * mathCos(startAngle);
        var yrs = radius * mathSin(startAngle);
        var xire = innerRadius * mathCos(endAngle);
        var yire = innerRadius * mathSin(endAngle);
        var hasArc = arc > e;
        if (hasArc) {
            var cornerRadius = shape.cornerRadius;
            if (cornerRadius) {
                _a = normalizeCornerRadius(cornerRadius), icrStart = _a[0], icrEnd = _a[1], ocrStart = _a[2], ocrEnd = _a[3];
            }
            var halfRd = mathAbs(radius - innerRadius) / 2;
            ocrs = mathMin$4(halfRd, ocrStart);
            ocre = mathMin$4(halfRd, ocrEnd);
            icrs = mathMin$4(halfRd, icrStart);
            icre = mathMin$4(halfRd, icrEnd);
            limitedOcrMax = ocrMax = mathMax$4(ocrs, ocre);
            limitedIcrMax = icrMax = mathMax$4(icrs, icre);
            if (ocrMax > e || icrMax > e) {
                xre = radius * mathCos(endAngle);
                yre = radius * mathSin(endAngle);
                xirs = innerRadius * mathCos(startAngle);
                yirs = innerRadius * mathSin(startAngle);
                if (arc < PI$2) {
                    var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
                    if (it_1) {
                        var x0 = xrs - it_1[0];
                        var y0 = yrs - it_1[1];
                        var x1 = xre - it_1[0];
                        var y1 = yre - it_1[1];
                        var a = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
                        var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
                        limitedOcrMax = mathMin$4(ocrMax, (radius - b) / (a + 1));
                        limitedIcrMax = mathMin$4(icrMax, (innerRadius - b) / (a - 1));
                    }
                }
            }
        }
        if (!hasArc) {
            ctx.moveTo(cx + xrs, cy + yrs);
        }
        else if (limitedOcrMax > e) {
            var crStart = mathMin$4(ocrStart, limitedOcrMax);
            var crEnd = mathMin$4(ocrEnd, limitedOcrMax);
            var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
            var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
            ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
            if (limitedOcrMax < ocrMax && crStart === crEnd) {
                ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
            }
            else {
                crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
                ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
                crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
            }
        }
        else {
            ctx.moveTo(cx + xrs, cy + yrs);
            ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
        }
        if (!(innerRadius > e) || !hasArc) {
            ctx.lineTo(cx + xire, cy + yire);
        }
        else if (limitedIcrMax > e) {
            var crStart = mathMin$4(icrStart, limitedIcrMax);
            var crEnd = mathMin$4(icrEnd, limitedIcrMax);
            var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
            var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
            ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
            if (limitedIcrMax < icrMax && crStart === crEnd) {
                ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
            }
            else {
                crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
                ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
                crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
            }
        }
        else {
            ctx.lineTo(cx + xire, cy + yire);
            ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
        }
    }
    ctx.closePath();
}

var SectorShape = (function () {
    function SectorShape() {
        this.cx = 0;
        this.cy = 0;
        this.r0 = 0;
        this.r = 0;
        this.startAngle = 0;
        this.endAngle = Math.PI * 2;
        this.clockwise = true;
        this.cornerRadius = 0;
    }
    return SectorShape;
}());
var Sector = (function (_super) {
    __extends(Sector, _super);
    function Sector(opts) {
        return _super.call(this, opts) || this;
    }
    Sector.prototype.getDefaultShape = function () {
        return new SectorShape();
    };
    Sector.prototype.buildPath = function (ctx, shape) {
        buildPath$1(ctx, shape);
    };
    Sector.prototype.isZeroArea = function () {
        return this.shape.startAngle === this.shape.endAngle
            || this.shape.r === this.shape.r0;
    };
    return Sector;
}(Path$1));
Sector.prototype.type = 'sector';
var Sector$1 = Sector;

var RingShape = (function () {
    function RingShape() {
        this.cx = 0;
        this.cy = 0;
        this.r = 0;
        this.r0 = 0;
    }
    return RingShape;
}());
var Ring = (function (_super) {
    __extends(Ring, _super);
    function Ring(opts) {
        return _super.call(this, opts) || this;
    }
    Ring.prototype.getDefaultShape = function () {
        return new RingShape();
    };
    Ring.prototype.buildPath = function (ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var PI2 = Math.PI * 2;
        ctx.moveTo(x + shape.r, y);
        ctx.arc(x, y, shape.r, 0, PI2, false);
        ctx.moveTo(x + shape.r0, y);
        ctx.arc(x, y, shape.r0, 0, PI2, true);
    };
    return Ring;
}(Path$1));
Ring.prototype.type = 'ring';
var Ring$1 = Ring;

function smoothBezier(points, smooth, isLoop, constraint) {
    var cps = [];
    var v = [];
    var v1 = [];
    var v2 = [];
    var prevPoint;
    var nextPoint;
    var min;
    var max;
    if (constraint) {
        min = [Infinity, Infinity];
        max = [-Infinity, -Infinity];
        for (var i = 0, len = points.length; i < len; i++) {
            min$1(min, min, points[i]);
            max$1(max, max, points[i]);
        }
        min$1(min, min, constraint[0]);
        max$1(max, max, constraint[1]);
    }
    for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        if (isLoop) {
            prevPoint = points[i ? i - 1 : len - 1];
            nextPoint = points[(i + 1) % len];
        }
        else {
            if (i === 0 || i === len - 1) {
                cps.push(clone$2(points[i]));
                continue;
            }
            else {
                prevPoint = points[i - 1];
                nextPoint = points[i + 1];
            }
        }
        sub(v, nextPoint, prevPoint);
        scale$2(v, v, smooth);
        var d0 = distance(point, prevPoint);
        var d1 = distance(point, nextPoint);
        var sum = d0 + d1;
        if (sum !== 0) {
            d0 /= sum;
            d1 /= sum;
        }
        scale$2(v1, v, -d0);
        scale$2(v2, v, d1);
        var cp0 = add([], point, v1);
        var cp1 = add([], point, v2);
        if (constraint) {
            max$1(cp0, cp0, min);
            min$1(cp0, cp0, max);
            max$1(cp1, cp1, min);
            min$1(cp1, cp1, max);
        }
        cps.push(cp0);
        cps.push(cp1);
    }
    if (isLoop) {
        cps.push(cps.shift());
    }
    return cps;
}

function buildPath(ctx, shape, closePath) {
    var smooth = shape.smooth;
    var points = shape.points;
    if (points && points.length >= 2) {
        if (smooth) {
            var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
            ctx.moveTo(points[0][0], points[0][1]);
            var len = points.length;
            for (var i = 0; i < (closePath ? len : len - 1); i++) {
                var cp1 = controlPoints[i * 2];
                var cp2 = controlPoints[i * 2 + 1];
                var p = points[(i + 1) % len];
                ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
            }
        }
        else {
            ctx.moveTo(points[0][0], points[0][1]);
            for (var i = 1, l = points.length; i < l; i++) {
                ctx.lineTo(points[i][0], points[i][1]);
            }
        }
        closePath && ctx.closePath();
    }
}

var PolygonShape = (function () {
    function PolygonShape() {
        this.points = null;
        this.smooth = 0;
        this.smoothConstraint = null;
    }
    return PolygonShape;
}());
var Polygon = (function (_super) {
    __extends(Polygon, _super);
    function Polygon(opts) {
        return _super.call(this, opts) || this;
    }
    Polygon.prototype.getDefaultShape = function () {
        return new PolygonShape();
    };
    Polygon.prototype.buildPath = function (ctx, shape) {
        buildPath(ctx, shape, true);
    };
    return Polygon;
}(Path$1));
Polygon.prototype.type = 'polygon';
var Polygon$1 = Polygon;

var PolylineShape = (function () {
    function PolylineShape() {
        this.points = null;
        this.percent = 1;
        this.smooth = 0;
        this.smoothConstraint = null;
    }
    return PolylineShape;
}());
var Polyline = (function (_super) {
    __extends(Polyline, _super);
    function Polyline(opts) {
        return _super.call(this, opts) || this;
    }
    Polyline.prototype.getDefaultStyle = function () {
        return {
            stroke: '#000',
            fill: null
        };
    };
    Polyline.prototype.getDefaultShape = function () {
        return new PolylineShape();
    };
    Polyline.prototype.buildPath = function (ctx, shape) {
        buildPath(ctx, shape, false);
    };
    return Polyline;
}(Path$1));
Polyline.prototype.type = 'polyline';
var Polyline$1 = Polyline;

var subPixelOptimizeOutputShape = {};
var LineShape = (function () {
    function LineShape() {
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
        this.percent = 1;
    }
    return LineShape;
}());
var Line = (function (_super) {
    __extends(Line, _super);
    function Line(opts) {
        return _super.call(this, opts) || this;
    }
    Line.prototype.getDefaultStyle = function () {
        return {
            stroke: '#000',
            fill: null
        };
    };
    Line.prototype.getDefaultShape = function () {
        return new LineShape();
    };
    Line.prototype.buildPath = function (ctx, shape) {
        var x1;
        var y1;
        var x2;
        var y2;
        if (this.subPixelOptimize) {
            var optimizedShape = subPixelOptimizeLine$1(subPixelOptimizeOutputShape, shape, this.style);
            x1 = optimizedShape.x1;
            y1 = optimizedShape.y1;
            x2 = optimizedShape.x2;
            y2 = optimizedShape.y2;
        }
        else {
            x1 = shape.x1;
            y1 = shape.y1;
            x2 = shape.x2;
            y2 = shape.y2;
        }
        var percent = shape.percent;
        if (percent === 0) {
            return;
        }
        ctx.moveTo(x1, y1);
        if (percent < 1) {
            x2 = x1 * (1 - percent) + x2 * percent;
            y2 = y1 * (1 - percent) + y2 * percent;
        }
        ctx.lineTo(x2, y2);
    };
    Line.prototype.pointAt = function (p) {
        var shape = this.shape;
        return [
            shape.x1 * (1 - p) + shape.x2 * p,
            shape.y1 * (1 - p) + shape.y2 * p
        ];
    };
    return Line;
}(Path$1));
Line.prototype.type = 'line';
var Line$1 = Line;

var out = [];
var BezierCurveShape = (function () {
    function BezierCurveShape() {
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
        this.cpx1 = 0;
        this.cpy1 = 0;
        this.percent = 1;
    }
    return BezierCurveShape;
}());
function someVectorAt(shape, t, isTangent) {
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    if (cpx2 != null || cpy2 != null) {
        return [
            (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
            (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
        ];
    }
    else {
        return [
            (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
            (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
        ];
    }
}
var BezierCurve = (function (_super) {
    __extends(BezierCurve, _super);
    function BezierCurve(opts) {
        return _super.call(this, opts) || this;
    }
    BezierCurve.prototype.getDefaultStyle = function () {
        return {
            stroke: '#000',
            fill: null
        };
    };
    BezierCurve.prototype.getDefaultShape = function () {
        return new BezierCurveShape();
    };
    BezierCurve.prototype.buildPath = function (ctx, shape) {
        var x1 = shape.x1;
        var y1 = shape.y1;
        var x2 = shape.x2;
        var y2 = shape.y2;
        var cpx1 = shape.cpx1;
        var cpy1 = shape.cpy1;
        var cpx2 = shape.cpx2;
        var cpy2 = shape.cpy2;
        var percent = shape.percent;
        if (percent === 0) {
            return;
        }
        ctx.moveTo(x1, y1);
        if (cpx2 == null || cpy2 == null) {
            if (percent < 1) {
                quadraticSubdivide(x1, cpx1, x2, percent, out);
                cpx1 = out[1];
                x2 = out[2];
                quadraticSubdivide(y1, cpy1, y2, percent, out);
                cpy1 = out[1];
                y2 = out[2];
            }
            ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
        }
        else {
            if (percent < 1) {
                cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
                cpx1 = out[1];
                cpx2 = out[2];
                x2 = out[3];
                cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
                cpy1 = out[1];
                cpy2 = out[2];
                y2 = out[3];
            }
            ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
        }
    };
    BezierCurve.prototype.pointAt = function (t) {
        return someVectorAt(this.shape, t, false);
    };
    BezierCurve.prototype.tangentAt = function (t) {
        var p = someVectorAt(this.shape, t, true);
        return normalize$1(p, p);
    };
    return BezierCurve;
}(Path$1));
BezierCurve.prototype.type = 'bezier-curve';
var BezierCurve$1 = BezierCurve;

var ArcShape = (function () {
    function ArcShape() {
        this.cx = 0;
        this.cy = 0;
        this.r = 0;
        this.startAngle = 0;
        this.endAngle = Math.PI * 2;
        this.clockwise = true;
    }
    return ArcShape;
}());
var Arc = (function (_super) {
    __extends(Arc, _super);
    function Arc(opts) {
        return _super.call(this, opts) || this;
    }
    Arc.prototype.getDefaultStyle = function () {
        return {
            stroke: '#000',
            fill: null
        };
    };
    Arc.prototype.getDefaultShape = function () {
        return new ArcShape();
    };
    Arc.prototype.buildPath = function (ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r = Math.max(shape.r, 0);
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var unitX = Math.cos(startAngle);
        var unitY = Math.sin(startAngle);
        ctx.moveTo(unitX * r + x, unitY * r + y);
        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
    };
    return Arc;
}(Path$1));
Arc.prototype.type = 'arc';
var Arc$1 = Arc;

var CompoundPath = (function (_super) {
    __extends(CompoundPath, _super);
    function CompoundPath() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'compound';
        return _this;
    }
    CompoundPath.prototype._updatePathDirty = function () {
        var paths = this.shape.paths;
        var dirtyPath = this.shapeChanged();
        for (var i = 0; i < paths.length; i++) {
            dirtyPath = dirtyPath || paths[i].shapeChanged();
        }
        if (dirtyPath) {
            this.dirtyShape();
        }
    };
    CompoundPath.prototype.beforeBrush = function () {
        this._updatePathDirty();
        var paths = this.shape.paths || [];
        var scale = this.getGlobalScale();
        for (var i = 0; i < paths.length; i++) {
            if (!paths[i].path) {
                paths[i].createPathProxy();
            }
            paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold);
        }
    };
    CompoundPath.prototype.buildPath = function (ctx, shape) {
        var paths = shape.paths || [];
        for (var i = 0; i < paths.length; i++) {
            paths[i].buildPath(ctx, paths[i].shape, true);
        }
    };
    CompoundPath.prototype.afterBrush = function () {
        var paths = this.shape.paths || [];
        for (var i = 0; i < paths.length; i++) {
            paths[i].pathUpdated();
        }
    };
    CompoundPath.prototype.getBoundingRect = function () {
        this._updatePathDirty.call(this);
        return Path$1.prototype.getBoundingRect.call(this);
    };
    return CompoundPath;
}(Path$1));
var CompoundPath$1 = CompoundPath;

var Gradient = (function () {
    function Gradient(colorStops) {
        this.colorStops = colorStops || [];
    }
    Gradient.prototype.addColorStop = function (offset, color) {
        this.colorStops.push({
            offset: offset,
            color: color
        });
    };
    return Gradient;
}());
var Gradient$1 = Gradient;

var LinearGradient = (function (_super) {
    __extends(LinearGradient, _super);
    function LinearGradient(x, y, x2, y2, colorStops, globalCoord) {
        var _this = _super.call(this, colorStops) || this;
        _this.x = x == null ? 0 : x;
        _this.y = y == null ? 0 : y;
        _this.x2 = x2 == null ? 1 : x2;
        _this.y2 = y2 == null ? 0 : y2;
        _this.type = 'linear';
        _this.global = globalCoord || false;
        return _this;
    }
    return LinearGradient;
}(Gradient$1));
var LinearGradient$1 = LinearGradient;

var RadialGradient = (function (_super) {
    __extends(RadialGradient, _super);
    function RadialGradient(x, y, r, colorStops, globalCoord) {
        var _this = _super.call(this, colorStops) || this;
        _this.x = x == null ? 0.5 : x;
        _this.y = y == null ? 0.5 : y;
        _this.r = r == null ? 0.5 : r;
        _this.type = 'radial';
        _this.global = globalCoord || false;
        return _this;
    }
    return RadialGradient;
}(Gradient$1));
var RadialGradient$1 = RadialGradient;

var extent = [0, 0];
var extent2 = [0, 0];
var minTv = new Point$1();
var maxTv = new Point$1();
var OrientedBoundingRect = (function () {
    function OrientedBoundingRect(rect, transform) {
        this._corners = [];
        this._axes = [];
        this._origin = [0, 0];
        for (var i = 0; i < 4; i++) {
            this._corners[i] = new Point$1();
        }
        for (var i = 0; i < 2; i++) {
            this._axes[i] = new Point$1();
        }
        if (rect) {
            this.fromBoundingRect(rect, transform);
        }
    }
    OrientedBoundingRect.prototype.fromBoundingRect = function (rect, transform) {
        var corners = this._corners;
        var axes = this._axes;
        var x = rect.x;
        var y = rect.y;
        var x2 = x + rect.width;
        var y2 = y + rect.height;
        corners[0].set(x, y);
        corners[1].set(x2, y);
        corners[2].set(x2, y2);
        corners[3].set(x, y2);
        if (transform) {
            for (var i = 0; i < 4; i++) {
                corners[i].transform(transform);
            }
        }
        Point$1.sub(axes[0], corners[1], corners[0]);
        Point$1.sub(axes[1], corners[3], corners[0]);
        axes[0].normalize();
        axes[1].normalize();
        for (var i = 0; i < 2; i++) {
            this._origin[i] = axes[i].dot(corners[0]);
        }
    };
    OrientedBoundingRect.prototype.intersect = function (other, mtv) {
        var overlapped = true;
        var noMtv = !mtv;
        minTv.set(Infinity, Infinity);
        maxTv.set(0, 0);
        if (!this._intersectCheckOneSide(this, other, minTv, maxTv, noMtv, 1)) {
            overlapped = false;
            if (noMtv) {
                return overlapped;
            }
        }
        if (!this._intersectCheckOneSide(other, this, minTv, maxTv, noMtv, -1)) {
            overlapped = false;
            if (noMtv) {
                return overlapped;
            }
        }
        if (!noMtv) {
            Point$1.copy(mtv, overlapped ? minTv : maxTv);
        }
        return overlapped;
    };
    OrientedBoundingRect.prototype._intersectCheckOneSide = function (self, other, minTv, maxTv, noMtv, inverse) {
        var overlapped = true;
        for (var i = 0; i < 2; i++) {
            var axis = this._axes[i];
            this._getProjMinMaxOnAxis(i, self._corners, extent);
            this._getProjMinMaxOnAxis(i, other._corners, extent2);
            if (extent[1] < extent2[0] || extent[0] > extent2[1]) {
                overlapped = false;
                if (noMtv) {
                    return overlapped;
                }
                var dist0 = Math.abs(extent2[0] - extent[1]);
                var dist1 = Math.abs(extent[0] - extent2[1]);
                if (Math.min(dist0, dist1) > maxTv.len()) {
                    if (dist0 < dist1) {
                        Point$1.scale(maxTv, axis, -dist0 * inverse);
                    }
                    else {
                        Point$1.scale(maxTv, axis, dist1 * inverse);
                    }
                }
            }
            else if (minTv) {
                var dist0 = Math.abs(extent2[0] - extent[1]);
                var dist1 = Math.abs(extent[0] - extent2[1]);
                if (Math.min(dist0, dist1) < minTv.len()) {
                    if (dist0 < dist1) {
                        Point$1.scale(minTv, axis, dist0 * inverse);
                    }
                    else {
                        Point$1.scale(minTv, axis, -dist1 * inverse);
                    }
                }
            }
        }
        return overlapped;
    };
    OrientedBoundingRect.prototype._getProjMinMaxOnAxis = function (dim, corners, out) {
        var axis = this._axes[dim];
        var origin = this._origin;
        var proj = corners[0].dot(axis) + origin[dim];
        var min = proj;
        var max = proj;
        for (var i = 1; i < corners.length; i++) {
            var proj_1 = corners[i].dot(axis) + origin[dim];
            min = Math.min(proj_1, min);
            max = Math.max(proj_1, max);
        }
        out[0] = min;
        out[1] = max;
    };
    return OrientedBoundingRect;
}());
var OrientedBoundingRect$1 = OrientedBoundingRect;

var m = [];
var IncrementalDisplayable = (function (_super) {
    __extends(IncrementalDisplayable, _super);
    function IncrementalDisplayable() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.notClear = true;
        _this.incremental = true;
        _this._displayables = [];
        _this._temporaryDisplayables = [];
        _this._cursor = 0;
        return _this;
    }
    IncrementalDisplayable.prototype.traverse = function (cb, context) {
        cb.call(context, this);
    };
    IncrementalDisplayable.prototype.useStyle = function () {
        this.style = {};
    };
    IncrementalDisplayable.prototype.getCursor = function () {
        return this._cursor;
    };
    IncrementalDisplayable.prototype.innerAfterBrush = function () {
        this._cursor = this._displayables.length;
    };
    IncrementalDisplayable.prototype.clearDisplaybles = function () {
        this._displayables = [];
        this._temporaryDisplayables = [];
        this._cursor = 0;
        this.markRedraw();
        this.notClear = false;
    };
    IncrementalDisplayable.prototype.clearTemporalDisplayables = function () {
        this._temporaryDisplayables = [];
    };
    IncrementalDisplayable.prototype.addDisplayable = function (displayable, notPersistent) {
        if (notPersistent) {
            this._temporaryDisplayables.push(displayable);
        }
        else {
            this._displayables.push(displayable);
        }
        this.markRedraw();
    };
    IncrementalDisplayable.prototype.addDisplayables = function (displayables, notPersistent) {
        notPersistent = notPersistent || false;
        for (var i = 0; i < displayables.length; i++) {
            this.addDisplayable(displayables[i], notPersistent);
        }
    };
    IncrementalDisplayable.prototype.getDisplayables = function () {
        return this._displayables;
    };
    IncrementalDisplayable.prototype.getTemporalDisplayables = function () {
        return this._temporaryDisplayables;
    };
    IncrementalDisplayable.prototype.eachPendingDisplayable = function (cb) {
        for (var i = this._cursor; i < this._displayables.length; i++) {
            cb && cb(this._displayables[i]);
        }
        for (var i = 0; i < this._temporaryDisplayables.length; i++) {
            cb && cb(this._temporaryDisplayables[i]);
        }
    };
    IncrementalDisplayable.prototype.update = function () {
        this.updateTransform();
        for (var i = this._cursor; i < this._displayables.length; i++) {
            var displayable = this._displayables[i];
            displayable.parent = this;
            displayable.update();
            displayable.parent = null;
        }
        for (var i = 0; i < this._temporaryDisplayables.length; i++) {
            var displayable = this._temporaryDisplayables[i];
            displayable.parent = this;
            displayable.update();
            displayable.parent = null;
        }
    };
    IncrementalDisplayable.prototype.getBoundingRect = function () {
        if (!this._rect) {
            var rect = new BoundingRect$1(Infinity, Infinity, -Infinity, -Infinity);
            for (var i = 0; i < this._displayables.length; i++) {
                var displayable = this._displayables[i];
                var childRect = displayable.getBoundingRect().clone();
                if (displayable.needLocalTransform()) {
                    childRect.applyTransform(displayable.getLocalTransform(m));
                }
                rect.union(childRect);
            }
            this._rect = rect;
        }
        return this._rect;
    };
    IncrementalDisplayable.prototype.contain = function (x, y) {
        var localPos = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        if (rect.contain(localPos[0], localPos[1])) {
            for (var i = 0; i < this._displayables.length; i++) {
                var displayable = this._displayables[i];
                if (displayable.contain(x, y)) {
                    return true;
                }
            }
        }
        return false;
    };
    return IncrementalDisplayable;
}(Displayable$1));
var IncrementalDisplayable$1 = IncrementalDisplayable;

var transitionStore = makeInner();
/**
 * Return null if animation is disabled.
 */

function getAnimationConfig(animationType, animatableModel, dataIndex, // Extra opts can override the option in animatable model.
extraOpts, // TODO It's only for pictorial bar now.
extraDelayParams) {
  var animationPayload; // Check if there is global animation configuration from dataZoom/resize can override the config in option.
  // If animation is enabled. Will use this animation config in payload.
  // If animation is disabled. Just ignore it.

  if (animatableModel && animatableModel.ecModel) {
    var updatePayload = animatableModel.ecModel.getUpdatePayload();
    animationPayload = updatePayload && updatePayload.animation;
  }

  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
  var isUpdate = animationType === 'update';

  if (animationEnabled) {
    var duration = void 0;
    var easing = void 0;
    var delay = void 0;

    if (extraOpts) {
      duration = retrieve2(extraOpts.duration, 200);
      easing = retrieve2(extraOpts.easing, 'cubicOut');
      delay = 0;
    } else {
      duration = animatableModel.getShallow(isUpdate ? 'animationDurationUpdate' : 'animationDuration');
      easing = animatableModel.getShallow(isUpdate ? 'animationEasingUpdate' : 'animationEasing');
      delay = animatableModel.getShallow(isUpdate ? 'animationDelayUpdate' : 'animationDelay');
    } // animation from payload has highest priority.


    if (animationPayload) {
      animationPayload.duration != null && (duration = animationPayload.duration);
      animationPayload.easing != null && (easing = animationPayload.easing);
      animationPayload.delay != null && (delay = animationPayload.delay);
    }

    if (isFunction(delay)) {
      delay = delay(dataIndex, extraDelayParams);
    }

    if (isFunction(duration)) {
      duration = duration(dataIndex);
    }

    var config = {
      duration: duration || 0,
      delay: delay,
      easing: easing
    };
    return config;
  } else {
    return null;
  }
}

function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {
  var isFrom = false;
  var removeOpt;

  if (isFunction(dataIndex)) {
    during = cb;
    cb = dataIndex;
    dataIndex = null;
  } else if (isObject$3(dataIndex)) {
    cb = dataIndex.cb;
    during = dataIndex.during;
    isFrom = dataIndex.isFrom;
    removeOpt = dataIndex.removeOpt;
    dataIndex = dataIndex.dataIndex;
  }

  var isRemove = animationType === 'leave';

  if (!isRemove) {
    // Must stop the remove animation.
    el.stopAnimation('leave');
  }

  var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);

  if (animationConfig && animationConfig.duration > 0) {
    var duration = animationConfig.duration;
    var animationDelay = animationConfig.delay;
    var animationEasing = animationConfig.easing;
    var animateConfig = {
      duration: duration,
      delay: animationDelay || 0,
      easing: animationEasing,
      done: cb,
      force: !!cb || !!during,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !isRemove,
      scope: animationType,
      during: during
    };
    isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);
  } else {
    el.stopAnimation(); // If `isFrom`, the props is the "from" props.

    !isFrom && el.attr(props); // Call during at least once.

    during && during(1);
    cb && cb();
  }
}
/**
 * Update graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 * @example
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
 *     // Or
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, function () { console.log('Animation done!'); });
 */


function updateProps$1(el, props, // TODO: TYPE AnimatableModel
animatableModel, dataIndex, cb, during) {
  animateOrSetProps('update', el, props, animatableModel, dataIndex, cb, during);
}
/**
 * Init graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 */

function initProps(el, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps('enter', el, props, animatableModel, dataIndex, cb, during);
}
/**
 * If element is removed.
 * It can determine if element is having remove animation.
 */

function isElementRemoved(el) {
  if (!el.__zr) {
    return true;
  }

  for (var i = 0; i < el.animators.length; i++) {
    var animator = el.animators[i];

    if (animator.scope === 'leave') {
      return true;
    }
  }

  return false;
}
/**
 * Remove graphic element
 */

function removeElement(el, props, animatableModel, dataIndex, cb, during) {
  // Don't do remove animation twice.
  if (isElementRemoved(el)) {
    return;
  }

  animateOrSetProps('leave', el, props, animatableModel, dataIndex, cb, during);
}

function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
  el.removeTextContent();
  el.removeTextGuideLine();
  removeElement(el, {
    style: {
      opacity: 0
    }
  }, animatableModel, dataIndex, done);
}

function removeElementWithFadeOut(el, animatableModel, dataIndex) {
  function doRemove() {
    el.parent && el.parent.remove(el);
  } // Hide label and labelLine first
  // TODO Also use fade out animation?


  if (!el.isGroup) {
    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
  } else {
    el.traverse(function (disp) {
      if (!disp.isGroup) {
        // Can invoke doRemove multiple times.
        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
      }
    });
  }
}
/**
 * Save old style for style transition in universalTransition module.
 * It's used when element will be reused in each render.
 * For chart like map, heatmap, which will always create new element.
 * We don't need to save this because universalTransition can get old style from the old element
 */

function saveOldStyle(el) {
  transitionStore(el).oldStyle = el.style;
}

var mathMax$3 = Math.max;
var mathMin$3 = Math.min;
var _customShapeMap = {};
/**
 * Extend shape with parameters
 */

function extendShape(opts) {
  return Path$1.extend(opts);
}
var extendPathFromString = extendFromString;
/**
 * Extend path
 */

function extendPath(pathData, opts) {
  return extendPathFromString(pathData, opts);
}
/**
 * Register a user defined shape.
 * The shape class can be fetched by `getShapeClass`
 * This method will overwrite the registered shapes, including
 * the registered built-in shapes, if using the same `name`.
 * The shape can be used in `custom series` and
 * `graphic component` by declaring `{type: name}`.
 *
 * @param name
 * @param ShapeClass Can be generated by `extendShape`.
 */

function registerShape(name, ShapeClass) {
  _customShapeMap[name] = ShapeClass;
}
/**
 * Find shape class registered by `registerShape`. Usually used in
 * fetching user defined shape.
 *
 * [Caution]:
 * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared
 * to use user registered shapes.
 * Because the built-in shape (see `getBuiltInShape`) will be registered by
 * `registerShape` by default. That enables users to get both built-in
 * shapes as well as the shapes belonging to themsleves. But users can overwrite
 * the built-in shapes by using names like 'circle', 'rect' via calling
 * `registerShape`. So the echarts inner featrues should not fetch shapes from here
 * in case that it is overwritten by users, except that some features, like
 * `custom series`, `graphic component`, do it deliberately.
 *
 * (2) In the features like `custom series`, `graphic component`, the user input
 * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic
 * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names
 * are reserved names, that is, if some user register a shape named `'image'`,
 * the shape will not be used. If we intending to add some more reserved names
 * in feature, that might bring break changes (disable some existing user shape
 * names). But that case probably rearly happen. So we dont make more mechanism
 * to resolve this issue here.
 *
 * @param name
 * @return The shape class. If not found, return nothing.
 */

function getShapeClass(name) {
  if (_customShapeMap.hasOwnProperty(name)) {
    return _customShapeMap[name];
  }
}
/**
 * Create a path element from path data string
 * @param pathData
 * @param opts
 * @param rect
 * @param layout 'center' or 'cover' default to be cover
 */

function makePath(pathData, opts, rect, layout) {
  var path = createFromString(pathData, opts);

  if (rect) {
    if (layout === 'center') {
      rect = centerGraphic(rect, path.getBoundingRect());
    }

    resizePath(path, rect);
  }

  return path;
}
/**
 * Create a image element from image url
 * @param imageUrl image url
 * @param opts options
 * @param rect constrain rect
 * @param layout 'center' or 'cover'. Default to be 'cover'
 */

function makeImage(imageUrl, rect, layout) {
  var zrImg = new ZRImage$1({
    style: {
      image: imageUrl,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    onload: function (img) {
      if (layout === 'center') {
        var boundingRect = {
          width: img.width,
          height: img.height
        };
        zrImg.setStyle(centerGraphic(rect, boundingRect));
      }
    }
  });
  return zrImg;
}
/**
 * Get position of centered element in bounding box.
 *
 * @param  rect         element local bounding box
 * @param  boundingRect constraint bounding box
 * @return element position containing x, y, width, and height
 */

function centerGraphic(rect, boundingRect) {
  // Set rect to center, keep width / height ratio.
  var aspect = boundingRect.width / boundingRect.height;
  var width = rect.height * aspect;
  var height;

  if (width <= rect.width) {
    height = rect.height;
  } else {
    width = rect.width;
    height = width / aspect;
  }

  var cx = rect.x + rect.width / 2;
  var cy = rect.y + rect.height / 2;
  return {
    x: cx - width / 2,
    y: cy - height / 2,
    width: width,
    height: height
  };
}

var mergePath = mergePath$1;
/**
 * Resize a path to fit the rect
 * @param path
 * @param rect
 */

function resizePath(path, rect) {
  if (!path.applyTransform) {
    return;
  }

  var pathRect = path.getBoundingRect();
  var m = pathRect.calculateTransform(rect);
  path.applyTransform(m);
}
/**
 * Sub pixel optimize line for canvas
 */

function subPixelOptimizeLine(shape, lineWidth) {
  subPixelOptimizeLine$1(shape, shape, {
    lineWidth: lineWidth
  });
  return shape;
}
/**
 * Sub pixel optimize rect for canvas
 */

function subPixelOptimizeRect(param) {
  subPixelOptimizeRect$1(param.shape, param.shape, param.style);
  return param;
}
/**
 * Sub pixel optimize for canvas
 *
 * @param position Coordinate, such as x, y
 * @param lineWidth Should be nonnegative integer.
 * @param positiveOrNegative Default false (negative).
 * @return Optimized position.
 */

var subPixelOptimize = subPixelOptimize$1;
/**
 * Get transform matrix of target (param target),
 * in coordinate of its ancestor (param ancestor)
 *
 * @param target
 * @param [ancestor]
 */

function getTransform(target, ancestor) {
  var mat = identity([]);

  while (target && target !== ancestor) {
    mul(mat, target.getLocalTransform(), mat);
    target = target.parent;
  }

  return mat;
}
/**
 * Apply transform to an vertex.
 * @param target [x, y]
 * @param transform Can be:
 *      + Transform matrix: like [1, 0, 0, 1, 0, 0]
 *      + {position, rotation, scale}, the same as `zrender/Transformable`.
 * @param invert Whether use invert matrix.
 * @return [x, y]
 */

function applyTransform(target, transform, invert$1) {
  if (transform && !isArrayLike(transform)) {
    transform = Transformable$1.getLocalTransform(transform);
  }

  if (invert$1) {
    transform = invert([], transform);
  }

  return applyTransform$1([], target, transform);
}
/**
 * @param direction 'left' 'right' 'top' 'bottom'
 * @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]
 * @param invert Whether use invert matrix.
 * @return Transformed direction. 'left' 'right' 'top' 'bottom'
 */

function transformDirection(direction, transform, invert) {
  // Pick a base, ensure that transform result will not be (0, 0).
  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];
  vertex = applyTransform(vertex, transform, invert);
  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';
}

function isNotGroup(el) {
  return !el.isGroup;
}

function isPath(el) {
  return el.shape != null;
}
/**
 * Apply group transition animation from g1 to g2.
 * If no animatableModel, no animation.
 */


function groupTransition(g1, g2, animatableModel) {
  if (!g1 || !g2) {
    return;
  }

  function getElMap(g) {
    var elMap = {};
    g.traverse(function (el) {
      if (isNotGroup(el) && el.anid) {
        elMap[el.anid] = el;
      }
    });
    return elMap;
  }

  function getAnimatableProps(el) {
    var obj = {
      x: el.x,
      y: el.y,
      rotation: el.rotation
    };

    if (isPath(el)) {
      obj.shape = extend$2({}, el.shape);
    }

    return obj;
  }

  var elMap1 = getElMap(g1);
  g2.traverse(function (el) {
    if (isNotGroup(el) && el.anid) {
      var oldEl = elMap1[el.anid];

      if (oldEl) {
        var newProp = getAnimatableProps(el);
        el.attr(getAnimatableProps(oldEl));
        updateProps$1(el, newProp, animatableModel, getECData(el).dataIndex);
      }
    }
  });
}
function clipPointsByRect(points, rect) {
  // FIXME: this way migth be incorrect when grpahic clipped by a corner.
  // and when element have border.
  return map$1(points, function (point) {
    var x = point[0];
    x = mathMax$3(x, rect.x);
    x = mathMin$3(x, rect.x + rect.width);
    var y = point[1];
    y = mathMax$3(y, rect.y);
    y = mathMin$3(y, rect.y + rect.height);
    return [x, y];
  });
}
/**
 * Return a new clipped rect. If rect size are negative, return undefined.
 */

function clipRectByRect(targetRect, rect) {
  var x = mathMax$3(targetRect.x, rect.x);
  var x2 = mathMin$3(targetRect.x + targetRect.width, rect.x + rect.width);
  var y = mathMax$3(targetRect.y, rect.y);
  var y2 = mathMin$3(targetRect.y + targetRect.height, rect.y + rect.height); // If the total rect is cliped, nothing, including the border,
  // should be painted. So return undefined.

  if (x2 >= x && y2 >= y) {
    return {
      x: x,
      y: y,
      width: x2 - x,
      height: y2 - y
    };
  }
}
function createIcon(iconStr, // Support 'image://' or 'path://' or direct svg path.
opt, rect) {
  var innerOpts = extend$2({
    rectHover: true
  }, opt);
  var style = innerOpts.style = {
    strokeNoScale: true
  };
  rect = rect || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  };

  if (iconStr) {
    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage$1(innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center');
  }
}
/**
 * Return `true` if the given line (line `a`) and the given polygon
 * are intersect.
 * Note that we do not count colinear as intersect here because no
 * requirement for that. We could do that if required in future.
 */

function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {
  for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {
    var p = points[i];

    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {
      return true;
    }

    p2 = p;
  }
}
/**
 * Return `true` if the given two lines (line `a` and line `b`)
 * are intersect.
 * Note that we do not count colinear as intersect here because no
 * requirement for that. We could do that if required in future.
 */

function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.
  var mx = a2x - a1x;
  var my = a2y - a1y;
  var nx = b2x - b1x;
  var ny = b2y - b1y; // `vec_m` and `vec_n` are parallel iff
  //     exising `k` such that `vec_m = k · vec_n`, equivalent to `vec_m X vec_n = 0`.

  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);

  if (nearZero(nmCrossProduct)) {
    return false;
  } // `vec_m` and `vec_n` are intersect iff
  //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,
  //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`
  //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.


  var b1a1x = a1x - b1x;
  var b1a1y = a1y - b1y;
  var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;

  if (q < 0 || q > 1) {
    return false;
  }

  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;

  if (p < 0 || p > 1) {
    return false;
  }

  return true;
}
/**
 * Cross product of 2-dimension vector.
 */

function crossProduct2d(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}

function nearZero(val) {
  return val <= 1e-6 && val >= -1e-6;
}

function setTooltipConfig(opt) {
  var itemTooltipOption = opt.itemTooltipOption;
  var componentModel = opt.componentModel;
  var itemName = opt.itemName;
  var itemTooltipOptionObj = isString(itemTooltipOption) ? {
    formatter: itemTooltipOption
  } : itemTooltipOption;
  var mainType = componentModel.mainType;
  var componentIndex = componentModel.componentIndex;
  var formatterParams = {
    componentType: mainType,
    name: itemName,
    $vars: ['name']
  };
  formatterParams[mainType + 'Index'] = componentIndex;
  var formatterParamsExtra = opt.formatterParamsExtra;

  if (formatterParamsExtra) {
    each$9(keys(formatterParamsExtra), function (key) {
      if (!hasOwn(formatterParams, key)) {
        formatterParams[key] = formatterParamsExtra[key];
        formatterParams.$vars.push(key);
      }
    });
  }

  var ecData = getECData(opt.el);
  ecData.componentMainType = mainType;
  ecData.componentIndex = componentIndex;
  ecData.tooltipConfig = {
    name: itemName,
    option: defaults({
      content: itemName,
      formatterParams: formatterParams
    }, itemTooltipOptionObj)
  };
}

function traverseElement(el, cb) {
  var stopped; // TODO
  // Polyfill for fixing zrender group traverse don't visit it's root issue.

  if (el.isGroup) {
    stopped = cb(el);
  }

  if (!stopped) {
    el.traverse(cb);
  }
}

function traverseElements(els, cb) {
  if (els) {
    if (isArray$1(els)) {
      for (var i = 0; i < els.length; i++) {
        traverseElement(els[i], cb);
      }
    } else {
      traverseElement(els, cb);
    }
  }
} // Register built-in shapes. These shapes might be overwirtten
// by users, although we do not recommend that.

registerShape('circle', Circle$1);
registerShape('ellipse', Ellipse$1);
registerShape('sector', Sector$1);
registerShape('ring', Ring$1);
registerShape('polygon', Polygon$1);
registerShape('polyline', Polyline$1);
registerShape('rect', Rect$1);
registerShape('line', Line$1);
registerShape('bezierCurve', BezierCurve$1);
registerShape('arc', Arc$1);

var graphic$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  updateProps: updateProps$1,
  initProps: initProps,
  removeElement: removeElement,
  removeElementWithFadeOut: removeElementWithFadeOut,
  isElementRemoved: isElementRemoved,
  extendShape: extendShape,
  extendPath: extendPath,
  registerShape: registerShape,
  getShapeClass: getShapeClass,
  makePath: makePath,
  makeImage: makeImage,
  mergePath: mergePath,
  resizePath: resizePath,
  subPixelOptimizeLine: subPixelOptimizeLine,
  subPixelOptimizeRect: subPixelOptimizeRect,
  subPixelOptimize: subPixelOptimize,
  getTransform: getTransform,
  applyTransform: applyTransform,
  transformDirection: transformDirection,
  groupTransition: groupTransition,
  clipPointsByRect: clipPointsByRect,
  clipRectByRect: clipRectByRect,
  createIcon: createIcon,
  linePolygonIntersect: linePolygonIntersect,
  lineLineIntersect: lineLineIntersect,
  setTooltipConfig: setTooltipConfig,
  traverseElements: traverseElements,
  Group: Group$3,
  Image: ZRImage$1,
  Text: ZRText$1,
  Circle: Circle$1,
  Ellipse: Ellipse$1,
  Sector: Sector$1,
  Ring: Ring$1,
  Polygon: Polygon$1,
  Polyline: Polyline$1,
  Rect: Rect$1,
  Line: Line$1,
  BezierCurve: BezierCurve$1,
  Arc: Arc$1,
  IncrementalDisplayable: IncrementalDisplayable$1,
  CompoundPath: CompoundPath$1,
  LinearGradient: LinearGradient$1,
  RadialGradient: RadialGradient$1,
  BoundingRect: BoundingRect$1,
  OrientedBoundingRect: OrientedBoundingRect$1,
  Point: Point$1,
  Path: Path$1
});

var EMPTY_OBJ = {};
function setLabelText(label, labelTexts) {
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    var text = labelTexts[stateName];
    var state = label.ensureState(stateName);
    state.style = state.style || {};
    state.style.text = text;
  }

  var oldStates = label.currentStates.slice();
  label.clearStates(true);
  label.setStyle({
    text: labelTexts.normal
  });
  label.useStates(oldStates, true);
}

function getLabelText(opt, stateModels, interpolatedValue) {
  var labelFetcher = opt.labelFetcher;
  var labelDataIndex = opt.labelDataIndex;
  var labelDimIndex = opt.labelDimIndex;
  var normalModel = stateModels.normal;
  var baseText;

  if (labelFetcher) {
    baseText = labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex, normalModel && normalModel.get('formatter'), interpolatedValue != null ? {
      interpolatedValue: interpolatedValue
    } : null);
  }

  if (baseText == null) {
    baseText = isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
  }

  var statesText = {
    normal: baseText
  };

  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    var stateModel = stateModels[stateName];
    statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get('formatter')) : null, baseText);
  }

  return statesText;
}

function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified // TODO specified position?
) {
  opt = opt || EMPTY_OBJ;
  var isSetOnText = targetEl instanceof ZRText$1;
  var needsCreateText = false;

  for (var i = 0; i < DISPLAY_STATES.length; i++) {
    var stateModel = labelStatesModels[DISPLAY_STATES[i]];

    if (stateModel && stateModel.getShallow('show')) {
      needsCreateText = true;
      break;
    }
  }

  var textContent = isSetOnText ? targetEl : targetEl.getTextContent();

  if (needsCreateText) {
    if (!isSetOnText) {
      // Reuse the previous
      if (!textContent) {
        textContent = new ZRText$1();
        targetEl.setTextContent(textContent);
      } // Use same state proxy


      if (targetEl.stateProxy) {
        textContent.stateProxy = targetEl.stateProxy;
      }
    }

    var labelStatesTexts = getLabelText(opt, labelStatesModels);
    var normalModel = labelStatesModels.normal;
    var showNormal = !!normalModel.getShallow('show');
    var normalStyle = createTextStyle$1(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
    normalStyle.text = labelStatesTexts.normal;

    if (!isSetOnText) {
      // Always create new
      targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
    }

    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      var stateName = SPECIAL_STATES[i];
      var stateModel = labelStatesModels[stateName];

      if (stateModel) {
        var stateObj = textContent.ensureState(stateName);
        var stateShow = !!retrieve2(stateModel.getShallow('show'), showNormal);

        if (stateShow !== showNormal) {
          stateObj.ignore = !stateShow;
        }

        stateObj.style = createTextStyle$1(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
        stateObj.style.text = labelStatesTexts[stateName];

        if (!isSetOnText) {
          var targetElEmphasisState = targetEl.ensureState(stateName);
          targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
        }
      }
    } // PENDING: if there is many requirements that emphasis position
    // need to be different from normal position, we might consider
    // auto slient is those cases.


    textContent.silent = !!normalModel.getShallow('silent'); // Keep x and y

    if (textContent.style.x != null) {
      normalStyle.x = textContent.style.x;
    }

    if (textContent.style.y != null) {
      normalStyle.y = textContent.style.y;
    }

    textContent.ignore = !showNormal; // Always create new style.

    textContent.useStyle(normalStyle);
    textContent.dirty();

    if (opt.enableTextSetter) {
      labelInner(textContent).setLabelText = function (interpolatedValue) {
        var labelStatesTexts = getLabelText(opt, labelStatesModels, interpolatedValue);
        setLabelText(textContent, labelStatesTexts);
      };
    }
  } else if (textContent) {
    // Not display rich text.
    textContent.ignore = true;
  }

  targetEl.dirty();
}
function getLabelStatesModels(itemModel, labelName) {
  labelName = labelName || 'label';
  var statesModels = {
    normal: itemModel.getModel(labelName)
  };

  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    statesModels[stateName] = itemModel.getModel([stateName, labelName]);
  }

  return statesModels;
}
/**
 * Set basic textStyle properties.
 */

function createTextStyle$1(textStyleModel, specifiedTextStyle, // Fixed style in the code. Can't be set by model.
opt, isNotNormal, isAttached // If text is attached on an element. If so, auto color will handling in zrender.
) {
  var textStyle = {};
  setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
  specifiedTextStyle && extend$2(textStyle, specifiedTextStyle); // textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);

  return textStyle;
}
function createTextConfig(textStyleModel, opt, isNotNormal) {
  opt = opt || {};
  var textConfig = {};
  var labelPosition;
  var labelRotate = textStyleModel.getShallow('rotate');
  var labelDistance = retrieve2(textStyleModel.getShallow('distance'), isNotNormal ? null : 5);
  var labelOffset = textStyleModel.getShallow('offset');
  labelPosition = textStyleModel.getShallow('position') || (isNotNormal ? null : 'inside'); // 'outside' is not a valid zr textPostion value, but used
  // in bar series, and magric type should be considered.

  labelPosition === 'outside' && (labelPosition = opt.defaultOutsidePosition || 'top');

  if (labelPosition != null) {
    textConfig.position = labelPosition;
  }

  if (labelOffset != null) {
    textConfig.offset = labelOffset;
  }

  if (labelRotate != null) {
    labelRotate *= Math.PI / 180;
    textConfig.rotation = labelRotate;
  }

  if (labelDistance != null) {
    textConfig.distance = labelDistance;
  } // fill and auto is determined by the color of path fill if it's not specified by developers.


  textConfig.outsideFill = textStyleModel.get('color') === 'inherit' ? opt.inheritColor || null : 'auto';
  return textConfig;
}
/**
 * The uniform entry of set text style, that is, retrieve style definitions
 * from `model` and set to `textStyle` object.
 *
 * Never in merge mode, but in overwrite mode, that is, all of the text style
 * properties will be set. (Consider the states of normal and emphasis and
 * default value can be adopted, merge would make the logic too complicated
 * to manage.)
 */

function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
  // Consider there will be abnormal when merge hover style to normal style if given default value.
  opt = opt || EMPTY_OBJ;
  var ecModel = textStyleModel.ecModel;
  var globalTextStyle = ecModel && ecModel.option.textStyle; // Consider case:
  // {
  //     data: [{
  //         value: 12,
  //         label: {
  //             rich: {
  //                 // no 'a' here but using parent 'a'.
  //             }
  //         }
  //     }],
  //     rich: {
  //         a: { ... }
  //     }
  // }

  var richItemNames = getRichItemNames(textStyleModel);
  var richResult;

  if (richItemNames) {
    richResult = {};

    for (var name_1 in richItemNames) {
      if (richItemNames.hasOwnProperty(name_1)) {
        // Cascade is supported in rich.
        var richTextStyle = textStyleModel.getModel(['rich', name_1]); // In rich, never `disableBox`.
        // FIXME: consider `label: {formatter: '{a|xx}', color: 'blue', rich: {a: {}}}`,
        // the default color `'blue'` will not be adopted if no color declared in `rich`.
        // That might confuses users. So probably we should put `textStyleModel` as the
        // root ancestor of the `richTextStyle`. But that would be a break change.

        setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true);
      }
    }
  }

  if (richResult) {
    textStyle.rich = richResult;
  }

  var overflow = textStyleModel.get('overflow');

  if (overflow) {
    textStyle.overflow = overflow;
  }

  var margin = textStyleModel.get('minMargin');

  if (margin != null) {
    textStyle.margin = margin;
  }

  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false);
} // Consider case:
// {
//     data: [{
//         value: 12,
//         label: {
//             rich: {
//                 // no 'a' here but using parent 'a'.
//             }
//         }
//     }],
//     rich: {
//         a: { ... }
//     }
// }
// TODO TextStyleModel


function getRichItemNames(textStyleModel) {
  // Use object to remove duplicated names.
  var richItemNameMap;

  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
    var rich = (textStyleModel.option || EMPTY_OBJ).rich;

    if (rich) {
      richItemNameMap = richItemNameMap || {};
      var richKeys = keys(rich);

      for (var i = 0; i < richKeys.length; i++) {
        var richKey = richKeys[i];
        richItemNameMap[richKey] = 1;
      }
    }

    textStyleModel = textStyleModel.parentModel;
  }

  return richItemNameMap;
}

var TEXT_PROPS_WITH_GLOBAL = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY'];
var TEXT_PROPS_SELF = ['align', 'lineHeight', 'width', 'height', 'tag', 'verticalAlign'];
var TEXT_PROPS_BOX = ['padding', 'borderWidth', 'borderRadius', 'borderDashOffset', 'backgroundColor', 'borderColor', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];

function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {
  // In merge mode, default value should not be given.
  globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
  var inheritColor = opt && opt.inheritColor;
  var fillColor = textStyleModel.getShallow('color');
  var strokeColor = textStyleModel.getShallow('textBorderColor');
  var opacity = retrieve2(textStyleModel.getShallow('opacity'), globalTextStyle.opacity);

  if (fillColor === 'inherit' || fillColor === 'auto') {
    if (process.env.NODE_ENV !== 'production') {
      if (fillColor === 'auto') {
        deprecateReplaceLog('color: \'auto\'', 'color: \'inherit\'');
      }
    }

    if (inheritColor) {
      fillColor = inheritColor;
    } else {
      fillColor = null;
    }
  }

  if (strokeColor === 'inherit' || strokeColor === 'auto') {
    if (process.env.NODE_ENV !== 'production') {
      if (strokeColor === 'auto') {
        deprecateReplaceLog('color: \'auto\'', 'color: \'inherit\'');
      }
    }

    if (inheritColor) {
      strokeColor = inheritColor;
    } else {
      strokeColor = null;
    }
  }

  if (!isAttached) {
    // Only use default global textStyle.color if text is individual.
    // Otherwise it will use the strategy of attached text color because text may be on a path.
    fillColor = fillColor || globalTextStyle.color;
    strokeColor = strokeColor || globalTextStyle.textBorderColor;
  }

  if (fillColor != null) {
    textStyle.fill = fillColor;
  }

  if (strokeColor != null) {
    textStyle.stroke = strokeColor;
  }

  var textBorderWidth = retrieve2(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);

  if (textBorderWidth != null) {
    textStyle.lineWidth = textBorderWidth;
  }

  var textBorderType = retrieve2(textStyleModel.getShallow('textBorderType'), globalTextStyle.textBorderType);

  if (textBorderType != null) {
    textStyle.lineDash = textBorderType;
  }

  var textBorderDashOffset = retrieve2(textStyleModel.getShallow('textBorderDashOffset'), globalTextStyle.textBorderDashOffset);

  if (textBorderDashOffset != null) {
    textStyle.lineDashOffset = textBorderDashOffset;
  }

  if (!isNotNormal && opacity == null && !inRich) {
    opacity = opt && opt.defaultOpacity;
  }

  if (opacity != null) {
    textStyle.opacity = opacity;
  } // TODO


  if (!isNotNormal && !isAttached) {
    // Set default finally.
    if (textStyle.fill == null && opt.inheritColor) {
      textStyle.fill = opt.inheritColor;
    }
  } // Do not use `getFont` here, because merge should be supported, where
  // part of these properties may be changed in emphasis style, and the
  // others should remain their original value got from normal style.


  for (var i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {
    var key = TEXT_PROPS_WITH_GLOBAL[i];
    var val = retrieve2(textStyleModel.getShallow(key), globalTextStyle[key]);

    if (val != null) {
      textStyle[key] = val;
    }
  }

  for (var i = 0; i < TEXT_PROPS_SELF.length; i++) {
    var key = TEXT_PROPS_SELF[i];
    var val = textStyleModel.getShallow(key);

    if (val != null) {
      textStyle[key] = val;
    }
  }

  if (textStyle.verticalAlign == null) {
    var baseline = textStyleModel.getShallow('baseline');

    if (baseline != null) {
      textStyle.verticalAlign = baseline;
    }
  }

  if (!isBlock || !opt.disableBox) {
    for (var i = 0; i < TEXT_PROPS_BOX.length; i++) {
      var key = TEXT_PROPS_BOX[i];
      var val = textStyleModel.getShallow(key);

      if (val != null) {
        textStyle[key] = val;
      }
    }

    var borderType = textStyleModel.getShallow('borderType');

    if (borderType != null) {
      textStyle.borderDash = borderType;
    }

    if ((textStyle.backgroundColor === 'auto' || textStyle.backgroundColor === 'inherit') && inheritColor) {
      if (process.env.NODE_ENV !== 'production') {
        if (textStyle.backgroundColor === 'auto') {
          deprecateReplaceLog('backgroundColor: \'auto\'', 'backgroundColor: \'inherit\'');
        }
      }

      textStyle.backgroundColor = inheritColor;
    }

    if ((textStyle.borderColor === 'auto' || textStyle.borderColor === 'inherit') && inheritColor) {
      if (process.env.NODE_ENV !== 'production') {
        if (textStyle.borderColor === 'auto') {
          deprecateReplaceLog('borderColor: \'auto\'', 'borderColor: \'inherit\'');
        }
      }

      textStyle.borderColor = inheritColor;
    }
  }
}

function getFont(opt, ecModel) {
  var gTextStyleModel = ecModel && ecModel.getModel('textStyle');
  return trim([// FIXME in node-canvas fontWeight is before fontStyle
  opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' '));
}
var labelInner = makeInner();
function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {
  if (!label) {
    return;
  }

  var obj = labelInner(label);
  obj.prevValue = obj.value;
  obj.value = value;
  var normalLabelModel = labelStatesModels.normal;
  obj.valueAnimation = normalLabelModel.get('valueAnimation');

  if (obj.valueAnimation) {
    obj.precision = normalLabelModel.get('precision');
    obj.defaultInterpolatedText = getDefaultText;
    obj.statesModels = labelStatesModels;
  }
}

var PATH_COLOR = ['textStyle', 'color'];
var textStyleParams = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'padding', 'lineHeight', 'rich', 'width', 'height', 'overflow']; // TODO Performance improvement?

var tmpText = new ZRText$1();

var TextStyleMixin =
/** @class */
function () {
  function TextStyleMixin() {}
  /**
   * Get color property or get color from option.textStyle.color
   */
  // TODO Callback


  TextStyleMixin.prototype.getTextColor = function (isEmphasis) {
    var ecModel = this.ecModel;
    return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
  };
  /**
   * Create font string from fontStyle, fontWeight, fontSize, fontFamily
   * @return {string}
   */


  TextStyleMixin.prototype.getFont = function () {
    return getFont({
      fontStyle: this.getShallow('fontStyle'),
      fontWeight: this.getShallow('fontWeight'),
      fontSize: this.getShallow('fontSize'),
      fontFamily: this.getShallow('fontFamily')
    }, this.ecModel);
  };

  TextStyleMixin.prototype.getTextRect = function (text) {
    var style = {
      text: text,
      verticalAlign: this.getShallow('verticalAlign') || this.getShallow('baseline')
    };

    for (var i = 0; i < textStyleParams.length; i++) {
      style[textStyleParams[i]] = this.getShallow(textStyleParams[i]);
    }

    tmpText.useStyle(style);
    tmpText.update();
    return tmpText.getBoundingRect();
  };

  return TextStyleMixin;
}();
var TextStyleMixin$1 = TextStyleMixin;

var LINE_STYLE_KEY_MAP = [['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['lineDash', 'type'], ['lineDashOffset', 'dashOffset'], ['lineCap', 'cap'], ['lineJoin', 'join'], ['miterLimit'] // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
// So do not transfer decal directly.
];
var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);

var LineStyleMixin =
/** @class */
function () {
  function LineStyleMixin() {}

  LineStyleMixin.prototype.getLineStyle = function (excludes) {
    return getLineStyle(this, excludes);
  };

  return LineStyleMixin;
}();

var ITEM_STYLE_KEY_MAP = [['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['lineDash', 'borderType'], ['lineDashOffset', 'borderDashOffset'], ['lineCap', 'borderCap'], ['lineJoin', 'borderJoin'], ['miterLimit', 'borderMiterLimit'] // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
// So do not transfer decal directly.
];
var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);

var ItemStyleMixin =
/** @class */
function () {
  function ItemStyleMixin() {}

  ItemStyleMixin.prototype.getItemStyle = function (excludes, includes) {
    return getItemStyle(this, excludes, includes);
  };

  return ItemStyleMixin;
}();

var Model =
/** @class */
function () {
  function Model(option, parentModel, ecModel) {
    this.parentModel = parentModel;
    this.ecModel = ecModel;
    this.option = option; // Simple optimization
    // if (this.init) {
    //     if (arguments.length <= 4) {
    //         this.init(option, parentModel, ecModel, extraOpt);
    //     }
    //     else {
    //         this.init.apply(this, arguments);
    //     }
    // }
  }

  Model.prototype.init = function (option, parentModel, ecModel) {
  };
  /**
   * Merge the input option to me.
   */


  Model.prototype.mergeOption = function (option, ecModel) {
    merge$1(this.option, option, true);
  }; // `path` can be 'a.b.c', so the return value type have to be `ModelOption`
  // TODO: TYPE strict key check?
  // get(path: string | string[], ignoreParent?: boolean): ModelOption;


  Model.prototype.get = function (path, ignoreParent) {
    if (path == null) {
      return this.option;
    }

    return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
  };

  Model.prototype.getShallow = function (key, ignoreParent) {
    var option = this.option;
    var val = option == null ? option : option[key];

    if (val == null && !ignoreParent) {
      var parentModel = this.parentModel;

      if (parentModel) {
        // FIXME:TS do not know how to make it works
        val = parentModel.getShallow(key);
      }
    }

    return val;
  }; // `path` can be 'a.b.c', so the return value type have to be `Model<ModelOption>`
  // getModel(path: string | string[], parentModel?: Model): Model;
  // TODO 'a.b.c' is deprecated


  Model.prototype.getModel = function (path, parentModel) {
    var hasPath = path != null;
    var pathFinal = hasPath ? this.parsePath(path) : null;
    var obj = hasPath ? this._doGet(pathFinal) : this.option;
    parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
    return new Model(obj, parentModel, this.ecModel);
  };
  /**
   * If model has option
   */


  Model.prototype.isEmpty = function () {
    return this.option == null;
  };

  Model.prototype.restoreData = function () {}; // Pending


  Model.prototype.clone = function () {
    var Ctor = this.constructor;
    return new Ctor(clone$3(this.option));
  }; // setReadOnly(properties): void {
  // clazzUtil.setReadOnly(this, properties);
  // }
  // If path is null/undefined, return null/undefined.


  Model.prototype.parsePath = function (path) {
    if (typeof path === 'string') {
      return path.split('.');
    }

    return path;
  }; // Resolve path for parent. Perhaps useful when parent use a different property.
  // Default to be a identity resolver.
  // Can be modified to a different resolver.


  Model.prototype.resolveParentPath = function (path) {
    return path;
  }; // FIXME:TS check whether put this method here


  Model.prototype.isAnimationEnabled = function () {
    if (!env$1.node && this.option) {
      if (this.option.animation != null) {
        return !!this.option.animation;
      } else if (this.parentModel) {
        return this.parentModel.isAnimationEnabled();
      }
    }
  };

  Model.prototype._doGet = function (pathArr, parentModel) {
    var obj = this.option;

    if (!pathArr) {
      return obj;
    }

    for (var i = 0; i < pathArr.length; i++) {
      // Ignore empty
      if (!pathArr[i]) {
        continue;
      } // obj could be number/string/... (like 0)


      obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;

      if (obj == null) {
        break;
      }
    }

    if (obj == null && parentModel) {
      obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
    }

    return obj;
  };

  return Model;
}();

enableClassExtend(Model);
enableClassCheck(Model);
mixin(Model, LineStyleMixin);
mixin(Model, ItemStyleMixin);
mixin(Model, AreaStyleMixin);
mixin(Model, TextStyleMixin$1);
var Model$1 = Model;

var base = Math.round(Math.random() * 10);
/**
 * @public
 * @param {string} type
 * @return {string}
 */

function getUID(type) {
  // Considering the case of crossing js context,
  // use Math.random to make id as unique as possible.
  return [type || '', base++].join('_');
}
/**
 * Implements `SubTypeDefaulterManager` for `target`.
 */

function enableSubTypeDefaulter(target) {
  var subTypeDefaulters = {};

  target.registerSubTypeDefaulter = function (componentType, defaulter) {
    var componentTypeInfo = parseClassType(componentType);
    subTypeDefaulters[componentTypeInfo.main] = defaulter;
  };

  target.determineSubType = function (componentType, option) {
    var type = option.type;

    if (!type) {
      var componentTypeMain = parseClassType(componentType).main;

      if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
        type = subTypeDefaulters[componentTypeMain](option);
      }
    }

    return type;
  };
}
/**
 * Implements `TopologicalTravelable<any>` for `entity`.
 *
 * Topological travel on Activity Network (Activity On Vertices).
 * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
 * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
 * If there is circular dependencey, Error will be thrown.
 */

function enableTopologicalTravel(entity, dependencyGetter) {
  /**
   * @param targetNameList Target Component type list.
   *                       Can be ['aa', 'bb', 'aa.xx']
   * @param fullNameList By which we can build dependency graph.
   * @param callback Params: componentType, dependencies.
   * @param context Scope of callback.
   */
  entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {
    if (!targetNameList.length) {
      return;
    }

    var result = makeDepndencyGraph(fullNameList);
    var graph = result.graph;
    var noEntryList = result.noEntryList;
    var targetNameSet = {};
    each$9(targetNameList, function (name) {
      targetNameSet[name] = true;
    });

    while (noEntryList.length) {
      var currComponentType = noEntryList.pop();
      var currVertex = graph[currComponentType];
      var isInTargetNameSet = !!targetNameSet[currComponentType];

      if (isInTargetNameSet) {
        callback.call(context, currComponentType, currVertex.originalDeps.slice());
        delete targetNameSet[currComponentType];
      }

      each$9(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
    }

    each$9(targetNameSet, function () {
      var errMsg = '';

      if (process.env.NODE_ENV !== 'production') {
        errMsg = makePrintable('Circular dependency may exists: ', targetNameSet, targetNameList, fullNameList);
      }

      throw new Error(errMsg);
    });

    function removeEdge(succComponentType) {
      graph[succComponentType].entryCount--;

      if (graph[succComponentType].entryCount === 0) {
        noEntryList.push(succComponentType);
      }
    } // Consider this case: legend depends on series, and we call
    // chart.setOption({series: [...]}), where only series is in option.
    // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will
    // not be called, but only sereis.mergeOption is called. Thus legend
    // have no chance to update its local record about series (like which
    // name of series is available in legend).


    function removeEdgeAndAdd(succComponentType) {
      targetNameSet[succComponentType] = true;
      removeEdge(succComponentType);
    }
  };

  function makeDepndencyGraph(fullNameList) {
    var graph = {};
    var noEntryList = [];
    each$9(fullNameList, function (name) {
      var thisItem = createDependencyGraphItem(graph, name);
      var originalDeps = thisItem.originalDeps = dependencyGetter(name);
      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
      thisItem.entryCount = availableDeps.length;

      if (thisItem.entryCount === 0) {
        noEntryList.push(name);
      }

      each$9(availableDeps, function (dependentName) {
        if (indexOf(thisItem.predecessor, dependentName) < 0) {
          thisItem.predecessor.push(dependentName);
        }

        var thatItem = createDependencyGraphItem(graph, dependentName);

        if (indexOf(thatItem.successor, dependentName) < 0) {
          thatItem.successor.push(name);
        }
      });
    });
    return {
      graph: graph,
      noEntryList: noEntryList
    };
  }

  function createDependencyGraphItem(graph, name) {
    if (!graph[name]) {
      graph[name] = {
        predecessor: [],
        successor: []
      };
    }

    return graph[name];
  }

  function getAvailableDependencies(originalDeps, fullNameList) {
    var availableDeps = [];
    each$9(originalDeps, function (dep) {
      indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
    });
    return availableDeps;
  }
}
function inheritDefaultOption(superOption, subOption) {
  // See also `model/Component.ts#getDefaultOption`
  return merge$1(merge$1({}, superOption, true), subOption, true);
}

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Language: English.
 */
var langEN = {
  time: {
    month: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    monthAbbr: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    dayOfWeekAbbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
  },
  legend: {
    selector: {
      all: 'All',
      inverse: 'Inv'
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: 'Box Select',
        polygon: 'Lasso Select',
        lineX: 'Horizontally Select',
        lineY: 'Vertically Select',
        keep: 'Keep Selections',
        clear: 'Clear Selections'
      }
    },
    dataView: {
      title: 'Data View',
      lang: ['Data View', 'Close', 'Refresh']
    },
    dataZoom: {
      title: {
        zoom: 'Zoom',
        back: 'Zoom Reset'
      }
    },
    magicType: {
      title: {
        line: 'Switch to Line Chart',
        bar: 'Switch to Bar Chart',
        stack: 'Stack',
        tiled: 'Tile'
      }
    },
    restore: {
      title: 'Restore'
    },
    saveAsImage: {
      title: 'Save as Image',
      lang: ['Right Click to Save Image']
    }
  },
  series: {
    typeNames: {
      pie: 'Pie chart',
      bar: 'Bar chart',
      line: 'Line chart',
      scatter: 'Scatter plot',
      effectScatter: 'Ripple scatter plot',
      radar: 'Radar chart',
      tree: 'Tree',
      treemap: 'Treemap',
      boxplot: 'Boxplot',
      candlestick: 'Candlestick',
      k: 'K line chart',
      heatmap: 'Heat map',
      map: 'Map',
      parallel: 'Parallel coordinate map',
      lines: 'Line graph',
      graph: 'Relationship graph',
      sankey: 'Sankey diagram',
      funnel: 'Funnel chart',
      gauge: 'Gauge',
      pictorialBar: 'Pictorial bar',
      themeRiver: 'Theme River Map',
      sunburst: 'Sunburst'
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: 'This is a chart'
    },
    series: {
      single: {
        prefix: '',
        withName: ' with type {seriesType} named {seriesName}.',
        withoutName: ' with type {seriesType}.'
      },
      multiple: {
        prefix: '. It consists of {seriesCount} series count.',
        withName: ' The {seriesId} series is a {seriesType} representing {seriesName}.',
        withoutName: ' The {seriesId} series is a {seriesType}.',
        separator: {
          middle: '',
          end: ''
        }
      }
    },
    data: {
      allData: 'The data is as follows: ',
      partialData: 'The first {displayCnt} items are: ',
      withName: 'the data for {name} is {value}',
      withoutName: '{value}',
      separator: {
        middle: ', ',
        end: '. '
      }
    }
  }
};

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var langZH = {
  time: {
    month: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
    monthAbbr: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
    dayOfWeek: ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'],
    dayOfWeekAbbr: ['日', '一', '二', '三', '四', '五', '六']
  },
  legend: {
    selector: {
      all: '全选',
      inverse: '反选'
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: '矩形选择',
        polygon: '圈选',
        lineX: '横向选择',
        lineY: '纵向选择',
        keep: '保持选择',
        clear: '清除选择'
      }
    },
    dataView: {
      title: '数据视图',
      lang: ['数据视图', '关闭', '刷新']
    },
    dataZoom: {
      title: {
        zoom: '区域缩放',
        back: '区域缩放还原'
      }
    },
    magicType: {
      title: {
        line: '切换为折线图',
        bar: '切换为柱状图',
        stack: '切换为堆叠',
        tiled: '切换为平铺'
      }
    },
    restore: {
      title: '还原'
    },
    saveAsImage: {
      title: '保存为图片',
      lang: ['右键另存为图片']
    }
  },
  series: {
    typeNames: {
      pie: '饼图',
      bar: '柱状图',
      line: '折线图',
      scatter: '散点图',
      effectScatter: '涟漪散点图',
      radar: '雷达图',
      tree: '树图',
      treemap: '矩形树图',
      boxplot: '箱型图',
      candlestick: 'K线图',
      k: 'K线图',
      heatmap: '热力图',
      map: '地图',
      parallel: '平行坐标图',
      lines: '线图',
      graph: '关系图',
      sankey: '桑基图',
      funnel: '漏斗图',
      gauge: '仪表盘图',
      pictorialBar: '象形柱图',
      themeRiver: '主题河流图',
      sunburst: '旭日图'
    }
  },
  aria: {
    general: {
      withTitle: '这是一个关于“{title}”的图表。',
      withoutTitle: '这是一个图表，'
    },
    series: {
      single: {
        prefix: '',
        withName: '图表类型是{seriesType}，表示{seriesName}。',
        withoutName: '图表类型是{seriesType}。'
      },
      multiple: {
        prefix: '它由{seriesCount}个图表系列组成。',
        withName: '第{seriesId}个系列是一个表示{seriesName}的{seriesType}，',
        withoutName: '第{seriesId}个系列是一个{seriesType}，',
        separator: {
          middle: '；',
          end: '。'
        }
      }
    },
    data: {
      allData: '其数据是——',
      partialData: '其中，前{displayCnt}项是——',
      withName: '{name}的数据是{value}',
      withoutName: '{value}',
      separator: {
        middle: '，',
        end: ''
      }
    }
  }
};

var LOCALE_ZH = 'ZH';
var LOCALE_EN = 'EN';
var DEFAULT_LOCALE = LOCALE_EN;
var localeStorage = {};
var localeModels = {};
var SYSTEM_LANG = !env$1.domSupported ? DEFAULT_LOCALE : function () {
  var langStr = (
  /* eslint-disable-next-line */
  document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase();
  return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}();
function registerLocale(locale, localeObj) {
  locale = locale.toUpperCase();
  localeModels[locale] = new Model$1(localeObj);
  localeStorage[locale] = localeObj;
} // export function getLocale(locale: string) {
//     return localeStorage[locale];
// }

function createLocaleObject(locale) {
  if (isString(locale)) {
    var localeObj = localeStorage[locale.toUpperCase()] || {};

    if (locale === LOCALE_ZH || locale === LOCALE_EN) {
      return clone$3(localeObj);
    } else {
      return merge$1(clone$3(localeObj), clone$3(localeStorage[DEFAULT_LOCALE]), false);
    }
  } else {
    return merge$1(clone$3(locale), clone$3(localeStorage[DEFAULT_LOCALE]), false);
  }
}
function getLocaleModel(lang) {
  return localeModels[lang];
}
function getDefaultLocaleModel() {
  return localeModels[DEFAULT_LOCALE];
} // Default locale

registerLocale(LOCALE_EN, langEN);
registerLocale(LOCALE_ZH, langZH);

var ONE_SECOND = 1000;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24;
var ONE_YEAR = ONE_DAY * 365;
var defaultLeveledFormatter = {
  year: '{yyyy}',
  month: '{MMM}',
  day: '{d}',
  hour: '{HH}:{mm}',
  minute: '{HH}:{mm}',
  second: '{HH}:{mm}:{ss}',
  millisecond: '{HH}:{mm}:{ss} {SSS}',
  none: '{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}'
};
var fullDayFormatter = '{yyyy}-{MM}-{dd}';
var fullLeveledFormatter = {
  year: '{yyyy}',
  month: '{yyyy}-{MM}',
  day: fullDayFormatter,
  hour: fullDayFormatter + ' ' + defaultLeveledFormatter.hour,
  minute: fullDayFormatter + ' ' + defaultLeveledFormatter.minute,
  second: fullDayFormatter + ' ' + defaultLeveledFormatter.second,
  millisecond: defaultLeveledFormatter.none
};
var primaryTimeUnits = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond'];
var timeUnits = ['year', 'half-year', 'quarter', 'month', 'week', 'half-week', 'day', 'half-day', 'quarter-day', 'hour', 'minute', 'second', 'millisecond'];
function pad(str, len) {
  str += '';
  return '0000'.substr(0, len - str.length) + str;
}
function getPrimaryTimeUnit(timeUnit) {
  switch (timeUnit) {
    case 'half-year':
    case 'quarter':
      return 'month';

    case 'week':
    case 'half-week':
      return 'day';

    case 'half-day':
    case 'quarter-day':
      return 'hour';

    default:
      // year, minutes, second, milliseconds
      return timeUnit;
  }
}
function isPrimaryTimeUnit(timeUnit) {
  return timeUnit === getPrimaryTimeUnit(timeUnit);
}
function getDefaultFormatPrecisionOfInterval(timeUnit) {
  switch (timeUnit) {
    case 'year':
    case 'month':
      return 'day';

    case 'millisecond':
      return 'millisecond';

    default:
      // Also for day, hour, minute, second
      return 'second';
  }
}
function format$1( // Note: The result based on `isUTC` are totally different, which can not be just simply
// substituted by the result without `isUTC`. So we make the param `isUTC` mandatory.
time, template, isUTC, lang) {
  var date = parseDate(time);
  var y = date[fullYearGetterName(isUTC)]();
  var M = date[monthGetterName(isUTC)]() + 1;
  var q = Math.floor((M - 1) / 3) + 1;
  var d = date[dateGetterName(isUTC)]();
  var e = date['get' + (isUTC ? 'UTC' : '') + 'Day']();
  var H = date[hoursGetterName(isUTC)]();
  var h = (H - 1) % 12 + 1;
  var m = date[minutesGetterName(isUTC)]();
  var s = date[secondsGetterName(isUTC)]();
  var S = date[millisecondsGetterName(isUTC)]();
  var localeModel = lang instanceof Model$1 ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();
  var timeModel = localeModel.getModel('time');
  var month = timeModel.get('month');
  var monthAbbr = timeModel.get('monthAbbr');
  var dayOfWeek = timeModel.get('dayOfWeek');
  var dayOfWeekAbbr = timeModel.get('dayOfWeekAbbr');
  return (template || '').replace(/{yyyy}/g, y + '').replace(/{yy}/g, y % 100 + '').replace(/{Q}/g, q + '').replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + '').replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + '').replace(/{eeee}/g, dayOfWeek[e]).replace(/{ee}/g, dayOfWeekAbbr[e]).replace(/{e}/g, e + '').replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + '').replace(/{hh}/g, pad(h + '', 2)).replace(/{h}/g, h + '').replace(/{mm}/g, pad(m, 2)).replace(/{m}/g, m + '').replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + '').replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + '');
}
function leveledFormat(tick, idx, formatter, lang, isUTC) {
  var template = null;

  if (isString(formatter)) {
    // Single formatter for all units at all levels
    template = formatter;
  } else if (isFunction(formatter)) {
    // Callback formatter
    template = formatter(tick.value, idx, {
      level: tick.level
    });
  } else {
    var defaults$1 = extend$2({}, defaultLeveledFormatter);

    if (tick.level > 0) {
      for (var i = 0; i < primaryTimeUnits.length; ++i) {
        defaults$1[primaryTimeUnits[i]] = "{primary|" + defaults$1[primaryTimeUnits[i]] + "}";
      }
    }

    var mergedFormatter = formatter ? formatter.inherit === false ? formatter // Use formatter with bigger units
    : defaults(formatter, defaults$1) : defaults$1;
    var unit = getUnitFromValue(tick.value, isUTC);

    if (mergedFormatter[unit]) {
      template = mergedFormatter[unit];
    } else if (mergedFormatter.inherit) {
      // Unit formatter is not defined and should inherit from bigger units
      var targetId = timeUnits.indexOf(unit);

      for (var i = targetId - 1; i >= 0; --i) {
        if (mergedFormatter[unit]) {
          template = mergedFormatter[unit];
          break;
        }
      }

      template = template || defaults$1.none;
    }

    if (isArray$1(template)) {
      var levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template.length + tick.level;
      levelId = Math.min(levelId, template.length - 1);
      template = template[levelId];
    }
  }

  return format$1(new Date(tick.value), template, isUTC, lang);
}
function getUnitFromValue(value, isUTC) {
  var date = parseDate(value);
  var M = date[monthGetterName(isUTC)]() + 1;
  var d = date[dateGetterName(isUTC)]();
  var h = date[hoursGetterName(isUTC)]();
  var m = date[minutesGetterName(isUTC)]();
  var s = date[secondsGetterName(isUTC)]();
  var S = date[millisecondsGetterName(isUTC)]();
  var isSecond = S === 0;
  var isMinute = isSecond && s === 0;
  var isHour = isMinute && m === 0;
  var isDay = isHour && h === 0;
  var isMonth = isDay && d === 1;
  var isYear = isMonth && M === 1;

  if (isYear) {
    return 'year';
  } else if (isMonth) {
    return 'month';
  } else if (isDay) {
    return 'day';
  } else if (isHour) {
    return 'hour';
  } else if (isMinute) {
    return 'minute';
  } else if (isSecond) {
    return 'second';
  } else {
    return 'millisecond';
  }
}
function getUnitValue(value, unit, isUTC) {
  var date = isNumber(value) ? parseDate(value) : value;
  unit = unit || getUnitFromValue(value, isUTC);

  switch (unit) {
    case 'year':
      return date[fullYearGetterName(isUTC)]();

    case 'half-year':
      return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;

    case 'quarter':
      return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);

    case 'month':
      return date[monthGetterName(isUTC)]();

    case 'day':
      return date[dateGetterName(isUTC)]();

    case 'half-day':
      return date[hoursGetterName(isUTC)]() / 24;

    case 'hour':
      return date[hoursGetterName(isUTC)]();

    case 'minute':
      return date[minutesGetterName(isUTC)]();

    case 'second':
      return date[secondsGetterName(isUTC)]();

    case 'millisecond':
      return date[millisecondsGetterName(isUTC)]();
  }
}
function fullYearGetterName(isUTC) {
  return isUTC ? 'getUTCFullYear' : 'getFullYear';
}
function monthGetterName(isUTC) {
  return isUTC ? 'getUTCMonth' : 'getMonth';
}
function dateGetterName(isUTC) {
  return isUTC ? 'getUTCDate' : 'getDate';
}
function hoursGetterName(isUTC) {
  return isUTC ? 'getUTCHours' : 'getHours';
}
function minutesGetterName(isUTC) {
  return isUTC ? 'getUTCMinutes' : 'getMinutes';
}
function secondsGetterName(isUTC) {
  return isUTC ? 'getUTCSeconds' : 'getSeconds';
}
function millisecondsGetterName(isUTC) {
  return isUTC ? 'getUTCMilliseconds' : 'getMilliseconds';
}
function fullYearSetterName(isUTC) {
  return isUTC ? 'setUTCFullYear' : 'setFullYear';
}
function monthSetterName(isUTC) {
  return isUTC ? 'setUTCMonth' : 'setMonth';
}
function dateSetterName(isUTC) {
  return isUTC ? 'setUTCDate' : 'setDate';
}
function hoursSetterName(isUTC) {
  return isUTC ? 'setUTCHours' : 'setHours';
}
function minutesSetterName(isUTC) {
  return isUTC ? 'setUTCMinutes' : 'setMinutes';
}
function secondsSetterName(isUTC) {
  return isUTC ? 'setUTCSeconds' : 'setSeconds';
}
function millisecondsSetterName(isUTC) {
  return isUTC ? 'setUTCMilliseconds' : 'setMilliseconds';
}

function getTextRect(text, font, align, verticalAlign, padding, rich, truncate, lineHeight) {
  var textEl = new ZRText$1({
    style: {
      text: text,
      font: font,
      align: align,
      verticalAlign: verticalAlign,
      padding: padding,
      rich: rich,
      overflow: truncate ? 'truncate' : null,
      lineHeight: lineHeight
    }
  });
  return textEl.getBoundingRect();
}

/**
 * Add a comma each three digit.
 */

function addCommas(x) {
  if (!isNumeric(x)) {
    return isString(x) ? x : '-';
  }

  var parts = (x + '').split('.');
  return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (parts.length > 1 ? '.' + parts[1] : '');
}
function toCamelCase(str, upperCaseFirst) {
  str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {
    return group1.toUpperCase();
  });

  if (upperCaseFirst && str) {
    str = str.charAt(0).toUpperCase() + str.slice(1);
  }

  return str;
}
var normalizeCssArray = normalizeCssArray$1;
/**
 * Make value user readable for tooltip and label.
 * "User readable":
 *     Try to not print programmer-specific text like NaN, Infinity, null, undefined.
 *     Avoid to display an empty string, which users can not recognize there is
 *     a value and it might look like a bug.
 */

function makeValueReadable(value, valueType, useUTC) {
  var USER_READABLE_DEFUALT_TIME_PATTERN = '{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}';

  function stringToUserReadable(str) {
    return str && trim(str) ? str : '-';
  }

  function isNumberUserReadable(num) {
    return !!(num != null && !isNaN(num) && isFinite(num));
  }

  var isTypeTime = valueType === 'time';
  var isValueDate = value instanceof Date;

  if (isTypeTime || isValueDate) {
    var date = isTypeTime ? parseDate(value) : value;

    if (!isNaN(+date)) {
      return format$1(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
    } else if (isValueDate) {
      return '-';
    } // In other cases, continue to try to display the value in the following code.

  }

  if (valueType === 'ordinal') {
    return isStringSafe(value) ? stringToUserReadable(value) : isNumber(value) ? isNumberUserReadable(value) ? value + '' : '-' : '-';
  } // By default.


  var numericResult = numericToNumber(value);
  return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === 'boolean' ? value + '' : '-';
}
var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];

var wrapVar = function (varName, seriesIdx) {
  return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
};
/**
 * Template formatter
 * @param {Array.<Object>|Object} paramsList
 */


function formatTpl(tpl, paramsList, encode) {
  if (!isArray$1(paramsList)) {
    paramsList = [paramsList];
  }

  var seriesLen = paramsList.length;

  if (!seriesLen) {
    return '';
  }

  var $vars = paramsList[0].$vars || [];

  for (var i = 0; i < $vars.length; i++) {
    var alias = TPL_VAR_ALIAS[i];
    tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
  }

  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
    for (var k = 0; k < $vars.length; k++) {
      var val = paramsList[seriesIdx][$vars[k]];
      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
    }
  }

  return tpl;
}
function getTooltipMarker(inOpt, extraCssText) {
  var opt = isString(inOpt) ? {
    color: inOpt,
    extraCssText: extraCssText
  } : inOpt || {};
  var color = opt.color;
  var type = opt.type;
  extraCssText = opt.extraCssText;
  var renderMode = opt.renderMode || 'html';

  if (!color) {
    return '';
  }

  if (renderMode === 'html') {
    return type === 'subItem' ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;' + 'border-radius:4px;width:4px;height:4px;background-color:' // Only support string
    + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>' : '<span style="display:inline-block;margin-right:4px;' + 'border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>';
  } else {
    // Should better not to auto generate style name by auto-increment number here.
    // Because this util is usually called in tooltip formatter, which is probably
    // called repeatly when mouse move and the auto-increment number increases fast.
    // Users can make their own style name by theirselves, make it unique and readable.
    var markerId = opt.markerId || 'markerX';
    return {
      renderMode: renderMode,
      content: '{' + markerId + '|}  ',
      style: type === 'subItem' ? {
        width: 4,
        height: 4,
        borderRadius: 2,
        backgroundColor: color
      } : {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: color
      }
    };
  }
}
/**
 * @deprecated Use `time/format` instead.
 * ISO Date format
 * @param {string} tpl
 * @param {number} value
 * @param {boolean} [isUTC=false] Default in local time.
 *           see `module:echarts/scale/Time`
 *           and `module:echarts/util/number#parseDate`.
 * @inner
 */

function formatTime(tpl, value, isUTC) {
  if (process.env.NODE_ENV !== 'production') {
    deprecateReplaceLog('echarts.format.formatTime', 'echarts.time.format');
  }

  if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {
    tpl = 'MM-dd\nyyyy';
  }

  var date = parseDate(value);
  var getUTC = isUTC ? 'getUTC' : 'get';
  var y = date[getUTC + 'FullYear']();
  var M = date[getUTC + 'Month']() + 1;
  var d = date[getUTC + 'Date']();
  var h = date[getUTC + 'Hours']();
  var m = date[getUTC + 'Minutes']();
  var s = date[getUTC + 'Seconds']();
  var S = date[getUTC + 'Milliseconds']();
  tpl = tpl.replace('MM', pad(M, 2)).replace('M', M).replace('yyyy', y).replace('yy', pad(y % 100 + '', 2)).replace('dd', pad(d, 2)).replace('d', d).replace('hh', pad(h, 2)).replace('h', h).replace('mm', pad(m, 2)).replace('m', m).replace('ss', pad(s, 2)).replace('s', s).replace('SSS', pad(S, 3));
  return tpl;
}
/**
 * Capital first
 * @param {string} str
 * @return {string}
 */

function capitalFirst(str) {
  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
}
/**
 * @return Never be null/undefined.
 */

function convertToColorString(color, defaultColor) {
  defaultColor = defaultColor || 'transparent';
  return isString(color) ? color : isObject$3(color) ? color.colorStops && (color.colorStops[0] || {}).color || defaultColor : defaultColor;
}
/**
 * open new tab
 * @param link url
 * @param target blank or self
 */

function windowOpen(link, target) {
  /* global window */
  if (target === '_blank' || target === 'blank') {
    var blank = window.open();
    blank.opener = null;
    blank.location.href = link;
  } else {
    window.open(link, target);
  }
}

var each$8 = each$9;
/**
 * @public
 */

var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];
/**
 * @public
 */

var HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];

function boxLayout(orient, group, gap, maxWidth, maxHeight) {
  var x = 0;
  var y = 0;

  if (maxWidth == null) {
    maxWidth = Infinity;
  }

  if (maxHeight == null) {
    maxHeight = Infinity;
  }

  var currentLineMaxSize = 0;
  group.eachChild(function (child, idx) {
    var rect = child.getBoundingRect();
    var nextChild = group.childAt(idx + 1);
    var nextChildRect = nextChild && nextChild.getBoundingRect();
    var nextX;
    var nextY;

    if (orient === 'horizontal') {
      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
      nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group
      // FIXME compare before adding gap?

      if (nextX > maxWidth || child.newline) {
        x = 0;
        nextX = moveX;
        y += currentLineMaxSize + gap;
        currentLineMaxSize = rect.height;
      } else {
        // FIXME: consider rect.y is not `0`?
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
      }
    } else {
      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
      nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group

      if (nextY > maxHeight || child.newline) {
        x += currentLineMaxSize + gap;
        y = 0;
        nextY = moveY;
        currentLineMaxSize = rect.width;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
      }
    }

    if (child.newline) {
      return;
    }

    child.x = x;
    child.y = y;
    child.markRedraw();
    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;
  });
}
/**
 * VBox or HBox layouting
 * @param {string} orient
 * @param {module:zrender/graphic/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */


var box = boxLayout;
/**
 * VBox layouting
 * @param {module:zrender/graphic/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */

curry$1(boxLayout, 'vertical');
/**
 * HBox layouting
 * @param {module:zrender/graphic/Group} group
 * @param {number} gap
 * @param {number} [width=Infinity]
 * @param {number} [height=Infinity]
 */

curry$1(boxLayout, 'horizontal');
/**
 * Parse position info.
 */

function getLayoutRect(positionInfo, containerRect, margin) {
  margin = normalizeCssArray(margin || 0);
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var left = parsePercent(positionInfo.left, containerWidth);
  var top = parsePercent(positionInfo.top, containerHeight);
  var right = parsePercent(positionInfo.right, containerWidth);
  var bottom = parsePercent(positionInfo.bottom, containerHeight);
  var width = parsePercent(positionInfo.width, containerWidth);
  var height = parsePercent(positionInfo.height, containerHeight);
  var verticalMargin = margin[2] + margin[0];
  var horizontalMargin = margin[1] + margin[3];
  var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right

  if (isNaN(width)) {
    width = containerWidth - right - horizontalMargin - left;
  }

  if (isNaN(height)) {
    height = containerHeight - bottom - verticalMargin - top;
  }

  if (aspect != null) {
    // If width and height are not given
    // 1. Graph should not exceeds the container
    // 2. Aspect must be keeped
    // 3. Graph should take the space as more as possible
    // FIXME
    // Margin is not considered, because there is no case that both
    // using margin and aspect so far.
    if (isNaN(width) && isNaN(height)) {
      if (aspect > containerWidth / containerHeight) {
        width = containerWidth * 0.8;
      } else {
        height = containerHeight * 0.8;
      }
    } // Calculate width or height with given aspect


    if (isNaN(width)) {
      width = aspect * height;
    }

    if (isNaN(height)) {
      height = width / aspect;
    }
  } // If left is not specified, calculate left from right and width


  if (isNaN(left)) {
    left = containerWidth - right - width - horizontalMargin;
  }

  if (isNaN(top)) {
    top = containerHeight - bottom - height - verticalMargin;
  } // Align left and top


  switch (positionInfo.left || positionInfo.right) {
    case 'center':
      left = containerWidth / 2 - width / 2 - margin[3];
      break;

    case 'right':
      left = containerWidth - width - horizontalMargin;
      break;
  }

  switch (positionInfo.top || positionInfo.bottom) {
    case 'middle':
    case 'center':
      top = containerHeight / 2 - height / 2 - margin[0];
      break;

    case 'bottom':
      top = containerHeight - height - verticalMargin;
      break;
  } // If something is wrong and left, top, width, height are calculated as NaN


  left = left || 0;
  top = top || 0;

  if (isNaN(width)) {
    // Width may be NaN if only one value is given except width
    width = containerWidth - horizontalMargin - left - (right || 0);
  }

  if (isNaN(height)) {
    // Height may be NaN if only one value is given except height
    height = containerHeight - verticalMargin - top - (bottom || 0);
  }

  var rect = new BoundingRect$1(left + margin[3], top + margin[0], width, height);
  rect.margin = margin;
  return rect;
}
/**
 * Position a zr element in viewport
 *  Group position is specified by either
 *  {left, top}, {right, bottom}
 *  If all properties exists, right and bottom will be igonred.
 *
 * Logic:
 *     1. Scale (against origin point in parent coord)
 *     2. Rotate (against origin point in parent coord)
 *     3. Traslate (with el.position by this method)
 * So this method only fixes the last step 'Traslate', which does not affect
 * scaling and rotating.
 *
 * If be called repeatly with the same input el, the same result will be gotten.
 *
 * Return true if the layout happend.
 *
 * @param el Should have `getBoundingRect` method.
 * @param positionInfo
 * @param positionInfo.left
 * @param positionInfo.top
 * @param positionInfo.right
 * @param positionInfo.bottom
 * @param positionInfo.width Only for opt.boundingModel: 'raw'
 * @param positionInfo.height Only for opt.boundingModel: 'raw'
 * @param containerRect
 * @param margin
 * @param opt
 * @param opt.hv Only horizontal or only vertical. Default to be [1, 1]
 * @param opt.boundingMode
 *        Specify how to calculate boundingRect when locating.
 *        'all': Position the boundingRect that is transformed and uioned
 *               both itself and its descendants.
 *               This mode simplies confine the elements in the bounding
 *               of their container (e.g., using 'right: 0').
 *        'raw': Position the boundingRect that is not transformed and only itself.
 *               This mode is useful when you want a element can overflow its
 *               container. (Consider a rotated circle needs to be located in a corner.)
 *               In this mode positionInfo.width/height can only be number.
 */

function positionElement(el, positionInfo, containerRect, margin, opt, out) {
  var h = !opt || !opt.hv || opt.hv[0];
  var v = !opt || !opt.hv || opt.hv[1];
  var boundingMode = opt && opt.boundingMode || 'all';
  out = out || el;
  out.x = el.x;
  out.y = el.y;

  if (!h && !v) {
    return false;
  }

  var rect;

  if (boundingMode === 'raw') {
    rect = el.type === 'group' ? new BoundingRect$1(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
  } else {
    rect = el.getBoundingRect();

    if (el.needLocalTransform()) {
      var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el,
      // which should not be modified.

      rect = rect.clone();
      rect.applyTransform(transform);
    }
  } // The real width and height can not be specified but calculated by the given el.


  var layoutRect = getLayoutRect(defaults({
    width: rect.width,
    height: rect.height
  }, positionInfo), containerRect, margin); // Because 'tranlate' is the last step in transform
  // (see zrender/core/Transformable#getLocalTransform),
  // we can just only modify el.position to get final result.

  var dx = h ? layoutRect.x - rect.x : 0;
  var dy = v ? layoutRect.y - rect.y : 0;

  if (boundingMode === 'raw') {
    out.x = dx;
    out.y = dy;
  } else {
    out.x += dx;
    out.y += dy;
  }

  if (out === el) {
    el.markRedraw();
  }

  return true;
}
function fetchLayoutMode(ins) {
  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;
  return isObject$3(layoutMode) ? layoutMode : layoutMode ? {
    type: layoutMode
  } : null;
}
/**
 * Consider Case:
 * When default option has {left: 0, width: 100}, and we set {right: 0}
 * through setOption or media query, using normal zrUtil.merge will cause
 * {right: 0} does not take effect.
 *
 * @example
 * ComponentModel.extend({
 *     init: function () {
 *         ...
 *         let inputPositionParams = layout.getLayoutParams(option);
 *         this.mergeOption(inputPositionParams);
 *     },
 *     mergeOption: function (newOption) {
 *         newOption && zrUtil.merge(thisOption, newOption, true);
 *         layout.mergeLayoutParam(thisOption, newOption);
 *     }
 * });
 *
 * @param targetOption
 * @param newOption
 * @param opt
 */

function mergeLayoutParam(targetOption, newOption, opt) {
  var ignoreSize = opt && opt.ignoreSize;
  !isArray$1(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
  var hResult = merge(HV_NAMES[0], 0);
  var vResult = merge(HV_NAMES[1], 1);
  copy(HV_NAMES[0], targetOption, hResult);
  copy(HV_NAMES[1], targetOption, vResult);

  function merge(names, hvIdx) {
    var newParams = {};
    var newValueCount = 0;
    var merged = {};
    var mergedValueCount = 0;
    var enoughParamNumber = 2;
    each$8(names, function (name) {
      merged[name] = targetOption[name];
    });
    each$8(names, function (name) {
      // Consider case: newOption.width is null, which is
      // set by user for removing width setting.
      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
      hasValue(newParams, name) && newValueCount++;
      hasValue(merged, name) && mergedValueCount++;
    });

    if (ignoreSize[hvIdx]) {
      // Only one of left/right is premitted to exist.
      if (hasValue(newOption, names[1])) {
        merged[names[2]] = null;
      } else if (hasValue(newOption, names[2])) {
        merged[names[1]] = null;
      }

      return merged;
    } // Case: newOption: {width: ..., right: ...},
    // or targetOption: {right: ...} and newOption: {width: ...},
    // There is no conflict when merged only has params count
    // little than enoughParamNumber.


    if (mergedValueCount === enoughParamNumber || !newValueCount) {
      return merged;
    } // Case: newOption: {width: ..., right: ...},
    // Than we can make sure user only want those two, and ignore
    // all origin params in targetOption.
    else if (newValueCount >= enoughParamNumber) {
        return newParams;
      } else {
        // Chose another param from targetOption by priority.
        for (var i = 0; i < names.length; i++) {
          var name_1 = names[i];

          if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {
            newParams[name_1] = targetOption[name_1];
            break;
          }
        }

        return newParams;
      }
  }

  function hasProp(obj, name) {
    return obj.hasOwnProperty(name);
  }

  function hasValue(obj, name) {
    return obj[name] != null && obj[name] !== 'auto';
  }

  function copy(names, target, source) {
    each$8(names, function (name) {
      target[name] = source[name];
    });
  }
}
/**
 * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
 */

function getLayoutParams(source) {
  return copyLayoutParams({}, source);
}
/**
 * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
 * @param {Object} source
 * @return {Object} Result contains those props.
 */

function copyLayoutParams(target, source) {
  source && target && each$8(LOCATION_PARAMS, function (name) {
    source.hasOwnProperty(name) && (target[name] = source[name]);
  });
  return target;
}

var inner$9 = makeInner();

var ComponentModel =
/** @class */
function (_super) {
  __extends$1(ComponentModel, _super);

  function ComponentModel(option, parentModel, ecModel) {
    var _this = _super.call(this, option, parentModel, ecModel) || this;

    _this.uid = getUID('ec_cpt_model');
    return _this;
  }

  ComponentModel.prototype.init = function (option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  };

  ComponentModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {
    var layoutMode = fetchLayoutMode(this);
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    var themeModel = ecModel.getTheme();
    merge$1(option, themeModel.get(this.mainType));
    merge$1(option, this.getDefaultOption());

    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  };

  ComponentModel.prototype.mergeOption = function (option, ecModel) {
    merge$1(this.option, option, true);
    var layoutMode = fetchLayoutMode(this);

    if (layoutMode) {
      mergeLayoutParam(this.option, option, layoutMode);
    }
  };
  /**
   * Called immediately after `init` or `mergeOption` of this instance called.
   */


  ComponentModel.prototype.optionUpdated = function (newCptOption, isInit) {};
  /**
   * [How to declare defaultOption]:
   *
   * (A) If using class declaration in typescript (since echarts 5):
   * ```ts
   * import {ComponentOption} from '../model/option.js';
   * export interface XxxOption extends ComponentOption {
   *     aaa: number
   * }
   * export class XxxModel extends Component {
   *     static type = 'xxx';
   *     static defaultOption: XxxOption = {
   *         aaa: 123
   *     }
   * }
   * Component.registerClass(XxxModel);
   * ```
   * ```ts
   * import {inheritDefaultOption} from '../util/component.js';
   * import {XxxModel, XxxOption} from './XxxModel.js';
   * export interface XxxSubOption extends XxxOption {
   *     bbb: number
   * }
   * class XxxSubModel extends XxxModel {
   *     static defaultOption: XxxSubOption = inheritDefaultOption(XxxModel.defaultOption, {
   *         bbb: 456
   *     })
   *     fn() {
   *         let opt = this.getDefaultOption();
   *         // opt is {aaa: 123, bbb: 456}
   *     }
   * }
   * ```
   *
   * (B) If using class extend (previous approach in echarts 3 & 4):
   * ```js
   * let XxxComponent = Component.extend({
   *     defaultOption: {
   *         xx: 123
   *     }
   * })
   * ```
   * ```js
   * let XxxSubComponent = XxxComponent.extend({
   *     defaultOption: {
   *         yy: 456
   *     },
   *     fn: function () {
   *         let opt = this.getDefaultOption();
   *         // opt is {xx: 123, yy: 456}
   *     }
   * })
   * ```
   */


  ComponentModel.prototype.getDefaultOption = function () {
    var ctor = this.constructor; // If using class declaration, it is different to travel super class
    // in legacy env and auto merge defaultOption. So if using class
    // declaration, defaultOption should be merged manually.

    if (!isExtendedClass(ctor)) {
      // When using ts class, defaultOption must be declared as static.
      return ctor.defaultOption;
    } // FIXME: remove this approach?


    var fields = inner$9(this);

    if (!fields.defaultOption) {
      var optList = [];
      var clz = ctor;

      while (clz) {
        var opt = clz.prototype.defaultOption;
        opt && optList.push(opt);
        clz = clz.superClass;
      }

      var defaultOption = {};

      for (var i = optList.length - 1; i >= 0; i--) {
        defaultOption = merge$1(defaultOption, optList[i], true);
      }

      fields.defaultOption = defaultOption;
    }

    return fields.defaultOption;
  };
  /**
   * Notice: always force to input param `useDefault` in case that forget to consider it.
   * The same behavior as `modelUtil.parseFinder`.
   *
   * @param useDefault In many cases like series refer axis and axis refer grid,
   *        If axis index / axis id not specified, use the first target as default.
   *        In other cases like dataZoom refer axis, if not specified, measn no refer.
   */


  ComponentModel.prototype.getReferringComponents = function (mainType, opt) {
    var indexKey = mainType + 'Index';
    var idKey = mainType + 'Id';
    return queryReferringComponents(this.ecModel, mainType, {
      index: this.get(indexKey, true),
      id: this.get(idKey, true)
    }, opt);
  };

  ComponentModel.prototype.getBoxLayoutParams = function () {
    // Consider itself having box layout configs.
    var boxLayoutModel = this;
    return {
      left: boxLayoutModel.get('left'),
      top: boxLayoutModel.get('top'),
      right: boxLayoutModel.get('right'),
      bottom: boxLayoutModel.get('bottom'),
      width: boxLayoutModel.get('width'),
      height: boxLayoutModel.get('height')
    };
  };
  /**
   * Get key for zlevel.
   * If developers don't configure zlevel. We will assign zlevel to series based on the key.
   * For example, lines with trail effect and progressive series will in an individual zlevel.
   */


  ComponentModel.prototype.getZLevelKey = function () {
    return '';
  };

  ComponentModel.prototype.setZLevel = function (zlevel) {
    this.option.zlevel = zlevel;
  };

  ComponentModel.protoInitialize = function () {
    var proto = ComponentModel.prototype;
    proto.type = 'component';
    proto.id = '';
    proto.name = '';
    proto.mainType = '';
    proto.subType = '';
    proto.componentIndex = 0;
  }();

  return ComponentModel;
}(Model$1);

mountExtend(ComponentModel, Model$1);
enableClassManagement(ComponentModel);
enableSubTypeDefaulter(ComponentModel);
enableTopologicalTravel(ComponentModel, getDependencies);

function getDependencies(componentType) {
  var deps = [];
  each$9(ComponentModel.getClassesByMainType(componentType), function (clz) {
    deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
  }); // Ensure main type.

  deps = map$1(deps, function (type) {
    return parseClassType(type).main;
  }); // Hack dataset for convenience.

  if (componentType !== 'dataset' && indexOf(deps, 'dataset') <= 0) {
    deps.unshift('dataset');
  }

  return deps;
}

var ComponentModel$1 = ComponentModel;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var platform = ''; // Navigator not exists in node

if (typeof navigator !== 'undefined') {
  /* global navigator */
  platform = navigator.platform || '';
}

var decalColor = 'rgba(0, 0, 0, 0.2)';
var globalDefault = {
  darkMode: 'auto',
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: 'series',
  color: ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc'],
  gradientColor: ['#f6efa6', '#d88273', '#bf444c'],
  aria: {
    decal: {
      decals: [{
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: decalColor,
        symbol: 'circle',
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: decalColor,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: decalColor,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: decalColor,
        symbol: 'triangle',
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: 'normal',
    fontWeight: 'normal'
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: 'cubicOut'
  },
  animation: 'auto',
  animationDuration: 1000,
  animationDurationUpdate: 500,
  animationEasing: 'cubicInOut',
  animationEasingUpdate: 'cubicInOut',
  animationThreshold: 2000,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3000,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3000,
  // See: module:echarts/scale/Time
  useUTC: false
};

var VISUAL_DIMENSIONS = createHashMap(['tooltip', 'label', 'itemName', 'itemId', 'itemGroupId', 'seriesName']);
var SOURCE_FORMAT_ORIGINAL = 'original';
var SOURCE_FORMAT_ARRAY_ROWS = 'arrayRows';
var SOURCE_FORMAT_OBJECT_ROWS = 'objectRows';
var SOURCE_FORMAT_KEYED_COLUMNS = 'keyedColumns';
var SOURCE_FORMAT_TYPED_ARRAY = 'typedArray';
var SOURCE_FORMAT_UNKNOWN = 'unknown';
var SERIES_LAYOUT_BY_COLUMN = 'column';
var SERIES_LAYOUT_BY_ROW = 'row';

var BE_ORDINAL = {
  Must: 1,
  Might: 2,
  Not: 3 // Other cases

};
var innerGlobalModel = makeInner();
/**
 * MUST be called before mergeOption of all series.
 */

function resetSourceDefaulter(ecModel) {
  // `datasetMap` is used to make default encode.
  innerGlobalModel(ecModel).datasetMap = createHashMap();
}
/**
 * [The strategy of the arrengment of data dimensions for dataset]:
 * "value way": all axes are non-category axes. So series one by one take
 *     several (the number is coordSysDims.length) dimensions from dataset.
 *     The result of data arrengment of data dimensions like:
 *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |
 * "category way": at least one axis is category axis. So the the first data
 *     dimension is always mapped to the first category axis and shared by
 *     all of the series. The other data dimensions are taken by series like
 *     "value way" does.
 *     The result of data arrengment of data dimensions like:
 *     | ser_shared_x | ser0_y | ser1_y | ser2_y |
 *
 * @return encode Never be `null/undefined`.
 */

function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
  var encode = {};
  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.

  if (!datasetModel || !coordDimensions) {
    return encode;
  }

  var encodeItemName = [];
  var encodeSeriesName = [];
  var ecModel = seriesModel.ecModel;
  var datasetMap = innerGlobalModel(ecModel).datasetMap;
  var key = datasetModel.uid + '_' + source.seriesLayoutBy;
  var baseCategoryDimIndex;
  var categoryWayValueDimStart;
  coordDimensions = coordDimensions.slice();
  each$9(coordDimensions, function (coordDimInfoLoose, coordDimIdx) {
    var coordDimInfo = isObject$3(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {
      name: coordDimInfoLoose
    };

    if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {
      baseCategoryDimIndex = coordDimIdx;
      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
    }

    encode[coordDimInfo.name] = [];
  });
  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
    categoryWayDim: categoryWayValueDimStart,
    valueWayDim: 0
  }); // TODO
  // Auto detect first time axis and do arrangement.

  each$9(coordDimensions, function (coordDimInfo, coordDimIdx) {
    var coordDimName = coordDimInfo.name;
    var count = getDataDimCountOnCoordDim(coordDimInfo); // In value way.

    if (baseCategoryDimIndex == null) {
      var start = datasetRecord.valueWayDim;
      pushDim(encode[coordDimName], start, count);
      pushDim(encodeSeriesName, start, count);
      datasetRecord.valueWayDim += count; // ??? TODO give a better default series name rule?
      // especially when encode x y specified.
      // consider: when mutiple series share one dimension
      // category axis, series name should better use
      // the other dimsion name. On the other hand, use
      // both dimensions name.
    } // In category way, the first category axis.
    else if (baseCategoryDimIndex === coordDimIdx) {
        pushDim(encode[coordDimName], 0, count);
        pushDim(encodeItemName, 0, count);
      } // In category way, the other axis.
      else {
          var start = datasetRecord.categoryWayDim;
          pushDim(encode[coordDimName], start, count);
          pushDim(encodeSeriesName, start, count);
          datasetRecord.categoryWayDim += count;
        }
  });

  function pushDim(dimIdxArr, idxFrom, idxCount) {
    for (var i = 0; i < idxCount; i++) {
      dimIdxArr.push(idxFrom + i);
    }
  }

  function getDataDimCountOnCoordDim(coordDimInfo) {
    var dimsDef = coordDimInfo.dimsDef;
    return dimsDef ? dimsDef.length : 1;
  }

  encodeItemName.length && (encode.itemName = encodeItemName);
  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
  return encode;
}
/**
 * Work for data like [{name: ..., value: ...}, ...].
 *
 * @return encode Never be `null/undefined`.
 */

function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
  var encode = {};
  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel); // Currently only make default when using dataset, util more reqirements occur.

  if (!datasetModel) {
    return encode;
  }

  var sourceFormat = source.sourceFormat;
  var dimensionsDefine = source.dimensionsDefine;
  var potentialNameDimIndex;

  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    each$9(dimensionsDefine, function (dim, idx) {
      if ((isObject$3(dim) ? dim.name : dim) === 'name') {
        potentialNameDimIndex = idx;
      }
    });
  }

  var idxResult = function () {
    var idxRes0 = {};
    var idxRes1 = {};
    var guessRecords = []; // 5 is an experience value.

    for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {
      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
      guessRecords.push(guessResult);
      var isPureNumber = guessResult === BE_ORDINAL.Not; // [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,
      // and then find a name dim with the priority:
      // "BE_ORDINAL.Might|BE_ORDINAL.Must" > "other dim" > "the value dim itself".

      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
        idxRes0.v = i;
      }

      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
        idxRes0.n = i;
      }

      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
        return idxRes0;
      } // [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),
      // find the first BE_ORDINAL.Might as the value dim,
      // and then find a name dim with the priority:
      // "other dim" > "the value dim itself".
      // That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be
      // treated as number.


      if (!isPureNumber) {
        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
          idxRes1.v = i;
        }

        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
          idxRes1.n = i;
        }
      }
    }

    function fulfilled(idxResult) {
      return idxResult.v != null && idxResult.n != null;
    }

    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
  }();

  if (idxResult) {
    encode.value = [idxResult.v]; // `potentialNameDimIndex` has highest priority.

    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n; // By default, label use itemName in charts.
    // So we dont set encodeLabel here.

    encode.itemName = [nameDimIndex];
    encode.seriesName = [nameDimIndex];
  }

  return encode;
}
/**
 * @return If return null/undefined, indicate that should not use datasetModel.
 */

function querySeriesUpstreamDatasetModel(seriesModel) {
  // Caution: consider the scenario:
  // A dataset is declared and a series is not expected to use the dataset,
  // and at the beginning `setOption({series: { noData })` (just prepare other
  // option but no data), then `setOption({series: {data: [...]}); In this case,
  // the user should set an empty array to avoid that dataset is used by default.
  var thisData = seriesModel.get('data', true);

  if (!thisData) {
    return queryReferringComponents(seriesModel.ecModel, 'dataset', {
      index: seriesModel.get('datasetIndex', true),
      id: seriesModel.get('datasetId', true)
    }, SINGLE_REFERRING).models[0];
  }
}
/**
 * @return Always return an array event empty.
 */

function queryDatasetUpstreamDatasetModels(datasetModel) {
  // Only these attributes declared, we by defualt reference to `datasetIndex: 0`.
  // Otherwise, no reference.
  if (!datasetModel.get('transform', true) && !datasetModel.get('fromTransformResult', true)) {
    return [];
  }

  return queryReferringComponents(datasetModel.ecModel, 'dataset', {
    index: datasetModel.get('fromDatasetIndex', true),
    id: datasetModel.get('fromDatasetId', true)
  }, SINGLE_REFERRING).models;
}
/**
 * The rule should not be complex, otherwise user might not
 * be able to known where the data is wrong.
 * The code is ugly, but how to make it neat?
 */

function guessOrdinal(source, dimIndex) {
  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
} // dimIndex may be overflow source data.
// return {BE_ORDINAL}

function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
  var result; // Experience value.

  var maxLoop = 5;

  if (isTypedArray(data)) {
    return BE_ORDINAL.Not;
  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine
  // always exists in source.


  var dimName;
  var dimType;

  if (dimensionsDefine) {
    var dimDefItem = dimensionsDefine[dimIndex];

    if (isObject$3(dimDefItem)) {
      dimName = dimDefItem.name;
      dimType = dimDefItem.type;
    } else if (isString(dimDefItem)) {
      dimName = dimDefItem;
    }
  }

  if (dimType != null) {
    return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not;
  }

  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var dataArrayRows = data;

    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      var sample = dataArrayRows[dimIndex];

      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
        if ((result = detectValue(sample[startIndex + i])) != null) {
          return result;
        }
      }
    } else {
      for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {
        var row = dataArrayRows[startIndex + i];

        if (row && (result = detectValue(row[dimIndex])) != null) {
          return result;
        }
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    var dataObjectRows = data;

    if (!dimName) {
      return BE_ORDINAL.Not;
    }

    for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {
      var item = dataObjectRows[i];

      if (item && (result = detectValue(item[dimName])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    var dataKeyedColumns = data;

    if (!dimName) {
      return BE_ORDINAL.Not;
    }

    var sample = dataKeyedColumns[dimName];

    if (!sample || isTypedArray(sample)) {
      return BE_ORDINAL.Not;
    }

    for (var i = 0; i < sample.length && i < maxLoop; i++) {
      if ((result = detectValue(sample[i])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var dataOriginal = data;

    for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {
      var item = dataOriginal[i];
      var val = getDataItemValue(item);

      if (!isArray$1(val)) {
        return BE_ORDINAL.Not;
      }

      if ((result = detectValue(val[dimIndex])) != null) {
        return result;
      }
    }
  }

  function detectValue(val) {
    var beStr = isString(val); // Consider usage convenience, '1', '2' will be treated as "number".
    // `isFinit('')` get `true`.

    if (val != null && isFinite(val) && val !== '') {
      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
    } else if (beStr && val !== '-') {
      return BE_ORDINAL.Must;
    }
  }

  return BE_ORDINAL.Not;
}

var internalOptionCreatorMap = createHashMap();
function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
  var internalOptionCreator = internalOptionCreatorMap.get(mainType);

  if (!internalOptionCreator) {
    return newCmptOptionList;
  }

  var internalOptions = internalOptionCreator(ecModel);

  if (!internalOptions) {
    return newCmptOptionList;
  }

  if (process.env.NODE_ENV !== 'production') {
    for (var i = 0; i < internalOptions.length; i++) {
      assert(isComponentIdInternal(internalOptions[i]));
    }
  }

  return newCmptOptionList.concat(internalOptions);
}

var innerColor = makeInner();
makeInner();

var PaletteMixin =
/** @class */
function () {
  function PaletteMixin() {}

  PaletteMixin.prototype.getColorFromPalette = function (name, scope, requestNum) {
    var defaultPalette = normalizeToArray(this.get('color', true));
    var layeredPalette = this.get('colorLayer', true);
    return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);
  };

  PaletteMixin.prototype.clearColorPalette = function () {
    clearPalette(this, innerColor);
  };

  return PaletteMixin;
}();

function getNearestPalette(palettes, requestColorNum) {
  var paletteNum = palettes.length; // TODO palettes must be in order

  for (var i = 0; i < paletteNum; i++) {
    if (palettes[i].length > requestColorNum) {
      return palettes[i];
    }
  }

  return palettes[paletteNum - 1];
}
/**
 * @param name MUST NOT be null/undefined. Otherwise call this function
 *             twise with the same parameters will get different result.
 * @param scope default this.
 * @return Can be null/undefined
 */


function getFromPalette(that, inner, defaultPalette, layeredPalette, name, scope, requestNum) {
  scope = scope || that;
  var scopeFields = inner(scope);
  var paletteIdx = scopeFields.paletteIdx || 0;
  var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {}; // Use `hasOwnProperty` to avoid conflict with Object.prototype.

  if (paletteNameMap.hasOwnProperty(name)) {
    return paletteNameMap[name];
  }

  var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum); // In case can't find in layered color palette.

  palette = palette || defaultPalette;

  if (!palette || !palette.length) {
    return;
  }

  var pickedPaletteItem = palette[paletteIdx];

  if (name) {
    paletteNameMap[name] = pickedPaletteItem;
  }

  scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
  return pickedPaletteItem;
}

function clearPalette(that, inner) {
  inner(that).paletteIdx = 0;
  inner(that).paletteNameMap = {};
}

// Internal method names:
// -----------------------

var reCreateSeriesIndices;
var assertSeriesInitialized;
var initBase;
var OPTION_INNER_KEY = '\0_ec_inner';
var OPTION_INNER_VALUE = 1;
var BUITIN_COMPONENTS_MAP = {
  grid: 'GridComponent',
  polar: 'PolarComponent',
  geo: 'GeoComponent',
  singleAxis: 'SingleAxisComponent',
  parallel: 'ParallelComponent',
  calendar: 'CalendarComponent',
  graphic: 'GraphicComponent',
  toolbox: 'ToolboxComponent',
  tooltip: 'TooltipComponent',
  axisPointer: 'AxisPointerComponent',
  brush: 'BrushComponent',
  title: 'TitleComponent',
  timeline: 'TimelineComponent',
  markPoint: 'MarkPointComponent',
  markLine: 'MarkLineComponent',
  markArea: 'MarkAreaComponent',
  legend: 'LegendComponent',
  dataZoom: 'DataZoomComponent',
  visualMap: 'VisualMapComponent',
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: 'GridComponent',
  yAxis: 'GridComponent',
  angleAxis: 'PolarComponent',
  radiusAxis: 'PolarComponent'
};
var BUILTIN_CHARTS_MAP = {
  line: 'LineChart',
  bar: 'BarChart',
  pie: 'PieChart',
  scatter: 'ScatterChart',
  radar: 'RadarChart',
  map: 'MapChart',
  tree: 'TreeChart',
  treemap: 'TreemapChart',
  graph: 'GraphChart',
  gauge: 'GaugeChart',
  funnel: 'FunnelChart',
  parallel: 'ParallelChart',
  sankey: 'SankeyChart',
  boxplot: 'BoxplotChart',
  candlestick: 'CandlestickChart',
  effectScatter: 'EffectScatterChart',
  lines: 'LinesChart',
  heatmap: 'HeatmapChart',
  pictorialBar: 'PictorialBarChart',
  themeRiver: 'ThemeRiverChart',
  sunburst: 'SunburstChart',
  custom: 'CustomChart'
};
var componetsMissingLogPrinted = {};

function checkMissingComponents(option) {
  each$9(option, function (componentOption, mainType) {
    if (!ComponentModel$1.hasClass(mainType)) {
      var componentImportName = BUITIN_COMPONENTS_MAP[mainType];

      if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {
        error("Component " + mainType + " is used but not imported.\nimport { " + componentImportName + " } from 'echarts/components';\necharts.use([" + componentImportName + "]);");
        componetsMissingLogPrinted[componentImportName] = true;
      }
    }
  });
}

var GlobalModel =
/** @class */
function (_super) {
  __extends$1(GlobalModel, _super);

  function GlobalModel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  GlobalModel.prototype.init = function (option, parentModel, ecModel, theme, locale, optionManager) {
    theme = theme || {};
    this.option = null; // Mark as not initialized.

    this._theme = new Model$1(theme);
    this._locale = new Model$1(locale);
    this._optionManager = optionManager;
  };

  GlobalModel.prototype.setOption = function (option, opts, optionPreprocessorFuncs) {
    if (process.env.NODE_ENV !== 'production') {
      assert(option != null, 'option is null/undefined');
      assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, 'please use chart.getOption()');
    }

    var innerOpt = normalizeSetOptionInput(opts);

    this._optionManager.setOption(option, optionPreprocessorFuncs, innerOpt);

    this._resetOption(null, innerOpt);
  };
  /**
   * @param type null/undefined: reset all.
   *        'recreate': force recreate all.
   *        'timeline': only reset timeline option
   *        'media': only reset media query option
   * @return Whether option changed.
   */


  GlobalModel.prototype.resetOption = function (type, opt) {
    return this._resetOption(type, normalizeSetOptionInput(opt));
  };

  GlobalModel.prototype._resetOption = function (type, opt) {
    var optionChanged = false;
    var optionManager = this._optionManager;

    if (!type || type === 'recreate') {
      var baseOption = optionManager.mountOption(type === 'recreate');

      if (process.env.NODE_ENV !== 'production') {
        checkMissingComponents(baseOption);
      }

      if (!this.option || type === 'recreate') {
        initBase(this, baseOption);
      } else {
        this.restoreData();

        this._mergeOption(baseOption, opt);
      }

      optionChanged = true;
    }

    if (type === 'timeline' || type === 'media') {
      this.restoreData();
    } // By design, if `setOption(option2)` at the second time, and `option2` is a `ECUnitOption`,
    // it should better not have the same props with `MediaUnit['option']`.
    // Becuase either `option2` or `MediaUnit['option']` will be always merged to "current option"
    // rather than original "baseOption". If they both override a prop, the result might be
    // unexpected when media state changed after `setOption` called.
    // If we really need to modify a props in each `MediaUnit['option']`, use the full version
    // (`{baseOption, media}`) in `setOption`.
    // For `timeline`, the case is the same.


    if (!type || type === 'recreate' || type === 'timeline') {
      var timelineOption = optionManager.getTimelineOption(this);

      if (timelineOption) {
        optionChanged = true;

        this._mergeOption(timelineOption, opt);
      }
    }

    if (!type || type === 'recreate' || type === 'media') {
      var mediaOptions = optionManager.getMediaOption(this);

      if (mediaOptions.length) {
        each$9(mediaOptions, function (mediaOption) {
          optionChanged = true;

          this._mergeOption(mediaOption, opt);
        }, this);
      }
    }

    return optionChanged;
  };

  GlobalModel.prototype.mergeOption = function (option) {
    this._mergeOption(option, null);
  };

  GlobalModel.prototype._mergeOption = function (newOption, opt) {
    var option = this.option;
    var componentsMap = this._componentsMap;
    var componentsCount = this._componentsCount;
    var newCmptTypes = [];
    var newCmptTypeMap = createHashMap();
    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
    resetSourceDefaulter(this); // If no component class, merge directly.
    // For example: color, animaiton options, etc.

    each$9(newOption, function (componentOption, mainType) {
      if (componentOption == null) {
        return;
      }

      if (!ComponentModel$1.hasClass(mainType)) {
        // globalSettingTask.dirty();
        option[mainType] = option[mainType] == null ? clone$3(componentOption) : merge$1(option[mainType], componentOption, true);
      } else if (mainType) {
        newCmptTypes.push(mainType);
        newCmptTypeMap.set(mainType, true);
      }
    });

    if (replaceMergeMainTypeMap) {
      // If there is a mainType `xxx` in `replaceMerge` but not declared in option,
      // we trade it as it is declared in option as `{xxx: []}`. Because:
      // (1) for normal merge, `{xxx: null/undefined}` are the same meaning as `{xxx: []}`.
      // (2) some preprocessor may convert some of `{xxx: null/undefined}` to `{xxx: []}`.
      replaceMergeMainTypeMap.each(function (val, mainTypeInReplaceMerge) {
        if (ComponentModel$1.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
          newCmptTypes.push(mainTypeInReplaceMerge);
          newCmptTypeMap.set(mainTypeInReplaceMerge, true);
        }
      });
    }

    ComponentModel$1.topologicalTravel(newCmptTypes, ComponentModel$1.getAllClassMainTypes(), visitComponent, this);

    function visitComponent(mainType) {
      var newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
      var oldCmptList = componentsMap.get(mainType);
      var mergeMode = // `!oldCmptList` means init. See the comment in `mappingToExists`
      !oldCmptList ? 'replaceAll' : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? 'replaceMerge' : 'normalMerge';
      var mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode); // Set mainType and complete subType.

      setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel$1); // Empty it before the travel, in order to prevent `this._componentsMap`
      // from being used in the `init`/`mergeOption`/`optionUpdated` of some
      // components, which is probably incorrect logic.

      option[mainType] = null;
      componentsMap.set(mainType, null);
      componentsCount.set(mainType, 0);
      var optionsByMainType = [];
      var cmptsByMainType = [];
      var cmptsCountByMainType = 0;
      var tooltipExists;
      var tooltipWarningLogged;
      each$9(mappingResult, function (resultItem, index) {
        var componentModel = resultItem.existing;
        var newCmptOption = resultItem.newOption;

        if (!newCmptOption) {
          if (componentModel) {
            // Consider where is no new option and should be merged using {},
            // see removeEdgeAndAdd in topologicalTravel and
            // ComponentModel.getAllClassMainTypes.
            componentModel.mergeOption({}, this);
            componentModel.optionUpdated({}, false);
          } // If no both `resultItem.exist` and `resultItem.option`,
          // either it is in `replaceMerge` and not matched by any id,
          // or it has been removed in previous `replaceMerge` and left a "hole" in this component index.

        } else {
          var isSeriesType = mainType === 'series';
          var ComponentModelClass = ComponentModel$1.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType // Give a more detailed warn later if series don't exists
          );

          if (!ComponentModelClass) {
            if (process.env.NODE_ENV !== 'production') {
              var subType = resultItem.keyInfo.subType;
              var seriesImportName = BUILTIN_CHARTS_MAP[subType];

              if (!componetsMissingLogPrinted[subType]) {
                componetsMissingLogPrinted[subType] = true;

                if (seriesImportName) {
                  error("Series " + subType + " is used but not imported.\nimport { " + seriesImportName + " } from 'echarts/charts';\necharts.use([" + seriesImportName + "]);");
                } else {
                  error("Unkown series " + subType);
                }
              }
            }

            return;
          } // TODO Before multiple tooltips get supported, we do this check to avoid unexpected exception.


          if (mainType === 'tooltip') {
            if (tooltipExists) {
              if (process.env.NODE_ENV !== 'production') {
                if (!tooltipWarningLogged) {
                  warn('Currently only one tooltip component is allowed.');
                  tooltipWarningLogged = true;
                }
              }

              return;
            }

            tooltipExists = true;
          }

          if (componentModel && componentModel.constructor === ComponentModelClass) {
            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();

            componentModel.mergeOption(newCmptOption, this);
            componentModel.optionUpdated(newCmptOption, false);
          } else {
            // PENDING Global as parent ?
            var extraOpt = extend$2({
              componentIndex: index
            }, resultItem.keyInfo);
            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt); // Assign `keyInfo`

            extend$2(componentModel, extraOpt);

            if (resultItem.brandNew) {
              componentModel.__requireNewView = true;
            }

            componentModel.init(newCmptOption, this, this); // Call optionUpdated after init.
            // newCmptOption has been used as componentModel.option
            // and may be merged with theme and default, so pass null
            // to avoid confusion.

            componentModel.optionUpdated(null, true);
          }
        }

        if (componentModel) {
          optionsByMainType.push(componentModel.option);
          cmptsByMainType.push(componentModel);
          cmptsCountByMainType++;
        } else {
          // Always do assign to avoid elided item in array.
          optionsByMainType.push(void 0);
          cmptsByMainType.push(void 0);
        }
      }, this);
      option[mainType] = optionsByMainType;
      componentsMap.set(mainType, cmptsByMainType);
      componentsCount.set(mainType, cmptsCountByMainType); // Backup series for filtering.

      if (mainType === 'series') {
        reCreateSeriesIndices(this);
      }
    } // If no series declared, ensure `_seriesIndices` initialized.


    if (!this._seriesIndices) {
      reCreateSeriesIndices(this);
    }
  };
  /**
   * Get option for output (cloned option and inner info removed)
   */


  GlobalModel.prototype.getOption = function () {
    var option = clone$3(this.option);
    each$9(option, function (optInMainType, mainType) {
      if (ComponentModel$1.hasClass(mainType)) {
        var opts = normalizeToArray(optInMainType); // Inner cmpts need to be removed.
        // Inner cmpts might not be at last since ec5.0, but still
        // compatible for users: if inner cmpt at last, splice the returned array.

        var realLen = opts.length;
        var metNonInner = false;

        for (var i = realLen - 1; i >= 0; i--) {
          // Remove options with inner id.
          if (opts[i] && !isComponentIdInternal(opts[i])) {
            metNonInner = true;
          } else {
            opts[i] = null;
            !metNonInner && realLen--;
          }
        }

        opts.length = realLen;
        option[mainType] = opts;
      }
    });
    delete option[OPTION_INNER_KEY];
    return option;
  };

  GlobalModel.prototype.getTheme = function () {
    return this._theme;
  };

  GlobalModel.prototype.getLocaleModel = function () {
    return this._locale;
  };

  GlobalModel.prototype.setUpdatePayload = function (payload) {
    this._payload = payload;
  };

  GlobalModel.prototype.getUpdatePayload = function () {
    return this._payload;
  };
  /**
   * @param idx If not specified, return the first one.
   */


  GlobalModel.prototype.getComponent = function (mainType, idx) {
    var list = this._componentsMap.get(mainType);

    if (list) {
      var cmpt = list[idx || 0];

      if (cmpt) {
        return cmpt;
      } else if (idx == null) {
        for (var i = 0; i < list.length; i++) {
          if (list[i]) {
            return list[i];
          }
        }
      }
    }
  };
  /**
   * @return Never be null/undefined.
   */


  GlobalModel.prototype.queryComponents = function (condition) {
    var mainType = condition.mainType;

    if (!mainType) {
      return [];
    }

    var index = condition.index;
    var id = condition.id;
    var name = condition.name;

    var cmpts = this._componentsMap.get(mainType);

    if (!cmpts || !cmpts.length) {
      return [];
    }

    var result;

    if (index != null) {
      result = [];
      each$9(normalizeToArray(index), function (idx) {
        cmpts[idx] && result.push(cmpts[idx]);
      });
    } else if (id != null) {
      result = queryByIdOrName('id', id, cmpts);
    } else if (name != null) {
      result = queryByIdOrName('name', name, cmpts);
    } else {
      // Return all non-empty components in that mainType
      result = filter(cmpts, function (cmpt) {
        return !!cmpt;
      });
    }

    return filterBySubType(result, condition);
  };
  /**
   * The interface is different from queryComponents,
   * which is convenient for inner usage.
   *
   * @usage
   * let result = findComponents(
   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
   * );
   * let result = findComponents(
   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
   * );
   * let result = findComponents(
   *     {mainType: 'series',
   *     filter: function (model, index) {...}}
   * );
   * // result like [component0, componnet1, ...]
   */


  GlobalModel.prototype.findComponents = function (condition) {
    var query = condition.query;
    var mainType = condition.mainType;
    var queryCond = getQueryCond(query);
    var result = queryCond ? this.queryComponents(queryCond) // Retrieve all non-empty components.
    : filter(this._componentsMap.get(mainType), function (cmpt) {
      return !!cmpt;
    });
    return doFilter(filterBySubType(result, condition));

    function getQueryCond(q) {
      var indexAttr = mainType + 'Index';
      var idAttr = mainType + 'Id';
      var nameAttr = mainType + 'Name';
      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
        mainType: mainType,
        // subType will be filtered finally.
        index: q[indexAttr],
        id: q[idAttr],
        name: q[nameAttr]
      } : null;
    }

    function doFilter(res) {
      return condition.filter ? filter(res, condition.filter) : res;
    }
  };

  GlobalModel.prototype.eachComponent = function (mainType, cb, context) {
    var componentsMap = this._componentsMap;

    if (isFunction(mainType)) {
      var ctxForAll_1 = cb;
      var cbForAll_1 = mainType;
      componentsMap.each(function (cmpts, componentType) {
        for (var i = 0; cmpts && i < cmpts.length; i++) {
          var cmpt = cmpts[i];
          cmpt && cbForAll_1.call(ctxForAll_1, componentType, cmpt, cmpt.componentIndex);
        }
      });
    } else {
      var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject$3(mainType) ? this.findComponents(mainType) : null;

      for (var i = 0; cmpts && i < cmpts.length; i++) {
        var cmpt = cmpts[i];
        cmpt && cb.call(context, cmpt, cmpt.componentIndex);
      }
    }
  };
  /**
   * Get series list before filtered by name.
   */


  GlobalModel.prototype.getSeriesByName = function (name) {
    var nameStr = convertOptionIdName(name, null);
    return filter(this._componentsMap.get('series'), function (oneSeries) {
      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;
    });
  };
  /**
   * Get series list before filtered by index.
   */


  GlobalModel.prototype.getSeriesByIndex = function (seriesIndex) {
    return this._componentsMap.get('series')[seriesIndex];
  };
  /**
   * Get series list before filtered by type.
   * FIXME: rename to getRawSeriesByType?
   */


  GlobalModel.prototype.getSeriesByType = function (subType) {
    return filter(this._componentsMap.get('series'), function (oneSeries) {
      return !!oneSeries && oneSeries.subType === subType;
    });
  };
  /**
   * Get all series before filtered.
   */


  GlobalModel.prototype.getSeries = function () {
    return filter(this._componentsMap.get('series'), function (oneSeries) {
      return !!oneSeries;
    });
  };
  /**
   * Count series before filtered.
   */


  GlobalModel.prototype.getSeriesCount = function () {
    return this._componentsCount.get('series');
  };
  /**
   * After filtering, series may be different
   * frome raw series.
   */


  GlobalModel.prototype.eachSeries = function (cb, context) {
    assertSeriesInitialized(this);
    each$9(this._seriesIndices, function (rawSeriesIndex) {
      var series = this._componentsMap.get('series')[rawSeriesIndex];

      cb.call(context, series, rawSeriesIndex);
    }, this);
  };
  /**
   * Iterate raw series before filtered.
   *
   * @param {Function} cb
   * @param {*} context
   */


  GlobalModel.prototype.eachRawSeries = function (cb, context) {
    each$9(this._componentsMap.get('series'), function (series) {
      series && cb.call(context, series, series.componentIndex);
    });
  };
  /**
   * After filtering, series may be different.
   * frome raw series.
   */


  GlobalModel.prototype.eachSeriesByType = function (subType, cb, context) {
    assertSeriesInitialized(this);
    each$9(this._seriesIndices, function (rawSeriesIndex) {
      var series = this._componentsMap.get('series')[rawSeriesIndex];

      if (series.subType === subType) {
        cb.call(context, series, rawSeriesIndex);
      }
    }, this);
  };
  /**
   * Iterate raw series before filtered of given type.
   */


  GlobalModel.prototype.eachRawSeriesByType = function (subType, cb, context) {
    return each$9(this.getSeriesByType(subType), cb, context);
  };

  GlobalModel.prototype.isSeriesFiltered = function (seriesModel) {
    assertSeriesInitialized(this);
    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
  };

  GlobalModel.prototype.getCurrentSeriesIndices = function () {
    return (this._seriesIndices || []).slice();
  };

  GlobalModel.prototype.filterSeries = function (cb, context) {
    assertSeriesInitialized(this);
    var newSeriesIndices = [];
    each$9(this._seriesIndices, function (seriesRawIdx) {
      var series = this._componentsMap.get('series')[seriesRawIdx];

      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
    }, this);
    this._seriesIndices = newSeriesIndices;
    this._seriesIndicesMap = createHashMap(newSeriesIndices);
  };

  GlobalModel.prototype.restoreData = function (payload) {
    reCreateSeriesIndices(this);
    var componentsMap = this._componentsMap;
    var componentTypes = [];
    componentsMap.each(function (components, componentType) {
      if (ComponentModel$1.hasClass(componentType)) {
        componentTypes.push(componentType);
      }
    });
    ComponentModel$1.topologicalTravel(componentTypes, ComponentModel$1.getAllClassMainTypes(), function (componentType) {
      each$9(componentsMap.get(componentType), function (component) {
        if (component && (componentType !== 'series' || !isNotTargetSeries(component, payload))) {
          component.restoreData();
        }
      });
    });
  };

  GlobalModel.internalField = function () {
    reCreateSeriesIndices = function (ecModel) {
      var seriesIndices = ecModel._seriesIndices = [];
      each$9(ecModel._componentsMap.get('series'), function (series) {
        // series may have been removed by `replaceMerge`.
        series && seriesIndices.push(series.componentIndex);
      });
      ecModel._seriesIndicesMap = createHashMap(seriesIndices);
    };

    assertSeriesInitialized = function (ecModel) {
      // Components that use _seriesIndices should depends on series component,
      // which make sure that their initialization is after series.
      if (process.env.NODE_ENV !== 'production') {
        if (!ecModel._seriesIndices) {
          throw new Error('Option should contains series.');
        }
      }
    };

    initBase = function (ecModel, baseOption) {
      // Using OPTION_INNER_KEY to mark that this option can not be used outside,
      // i.e. `chart.setOption(chart.getModel().option);` is forbiden.
      ecModel.option = {};
      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE; // Init with series: [], in case of calling findSeries method
      // before series initialized.

      ecModel._componentsMap = createHashMap({
        series: []
      });
      ecModel._componentsCount = createHashMap(); // If user spefied `option.aria`, aria will be enable. This detection should be
      // performed before theme and globalDefault merge.

      var airaOption = baseOption.aria;

      if (isObject$3(airaOption) && airaOption.enabled == null) {
        airaOption.enabled = true;
      }

      mergeTheme(baseOption, ecModel._theme.option); // TODO Needs clone when merging to the unexisted property

      merge$1(baseOption, globalDefault, false);

      ecModel._mergeOption(baseOption, null);
    };
  }();

  return GlobalModel;
}(Model$1);

function isNotTargetSeries(seriesModel, payload) {
  if (payload) {
    var index = payload.seriesIndex;
    var id = payload.seriesId;
    var name_1 = payload.seriesName;
    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;
  }
}

function mergeTheme(option, theme) {
  // PENDING
  // NOT use `colorLayer` in theme if option has `color`
  var notMergeColorLayer = option.color && !option.colorLayer;
  each$9(theme, function (themeItem, name) {
    if (name === 'colorLayer' && notMergeColorLayer) {
      return;
    } // If it is component model mainType, the model handles that merge later.
    // otherwise, merge them here.


    if (!ComponentModel$1.hasClass(name)) {
      if (typeof themeItem === 'object') {
        option[name] = !option[name] ? clone$3(themeItem) : merge$1(option[name], themeItem, false);
      } else {
        if (option[name] == null) {
          option[name] = themeItem;
        }
      }
    }
  });
}

function queryByIdOrName(attr, idOrName, cmpts) {
  // Here is a break from echarts4: string and number are
  // treated as equal.
  if (isArray$1(idOrName)) {
    var keyMap_1 = createHashMap();
    each$9(idOrName, function (idOrNameItem) {
      if (idOrNameItem != null) {
        var idName = convertOptionIdName(idOrNameItem, null);
        idName != null && keyMap_1.set(idOrNameItem, true);
      }
    });
    return filter(cmpts, function (cmpt) {
      return cmpt && keyMap_1.get(cmpt[attr]);
    });
  } else {
    var idName_1 = convertOptionIdName(idOrName, null);
    return filter(cmpts, function (cmpt) {
      return cmpt && idName_1 != null && cmpt[attr] === idName_1;
    });
  }
}

function filterBySubType(components, condition) {
  // Using hasOwnProperty for restrict. Consider
  // subType is undefined in user payload.
  return condition.hasOwnProperty('subType') ? filter(components, function (cmpt) {
    return cmpt && cmpt.subType === condition.subType;
  }) : components;
}

function normalizeSetOptionInput(opts) {
  var replaceMergeMainTypeMap = createHashMap();
  opts && each$9(normalizeToArray(opts.replaceMerge), function (mainType) {
    if (process.env.NODE_ENV !== 'production') {
      assert(ComponentModel$1.hasClass(mainType), '"' + mainType + '" is not valid component main type in "replaceMerge"');
    }

    replaceMergeMainTypeMap.set(mainType, true);
  });
  return {
    replaceMergeMainTypeMap: replaceMergeMainTypeMap
  };
}

mixin(GlobalModel, PaletteMixin);
var GlobalModel$1 = GlobalModel;

var availableMethods = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isSSR', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', // 'getModel',
'getOption', // 'getViewOfComponentModel',
// 'getViewOfSeriesModel',
'getId', 'updateLabelLayout'];

var ExtensionAPI =
/** @class */
function () {
  function ExtensionAPI(ecInstance) {
    each$9(availableMethods, function (methodName) {
      this[methodName] = bind$1(ecInstance[methodName], ecInstance);
    }, this);
  }

  return ExtensionAPI;
}();

var ExtensionAPI$1 = ExtensionAPI;

var coordinateSystemCreators = {};

var CoordinateSystemManager =
/** @class */
function () {
  function CoordinateSystemManager() {
    this._coordinateSystems = [];
  }

  CoordinateSystemManager.prototype.create = function (ecModel, api) {
    var coordinateSystems = [];
    each$9(coordinateSystemCreators, function (creater, type) {
      var list = creater.create(ecModel, api);
      coordinateSystems = coordinateSystems.concat(list || []);
    });
    this._coordinateSystems = coordinateSystems;
  };

  CoordinateSystemManager.prototype.update = function (ecModel, api) {
    each$9(this._coordinateSystems, function (coordSys) {
      coordSys.update && coordSys.update(ecModel, api);
    });
  };

  CoordinateSystemManager.prototype.getCoordinateSystems = function () {
    return this._coordinateSystems.slice();
  };

  CoordinateSystemManager.register = function (type, creator) {
    coordinateSystemCreators[type] = creator;
  };

  CoordinateSystemManager.get = function (type) {
    return coordinateSystemCreators[type];
  };

  return CoordinateSystemManager;
}();

var CoordinateSystem = CoordinateSystemManager;

var QUERY_REG = /^(min|max)?(.+)$/; // Key: mainType
// type FakeComponentsMap = HashMap<(MappingExistingItem & { subType: string })[]>;

/**
 * TERM EXPLANATIONS:
 * See `ECOption` and `ECUnitOption` in `src/util/types.ts`.
 */

var OptionManager =
/** @class */
function () {
  // timeline.notMerge is not supported in ec3. Firstly there is rearly
  // case that notMerge is needed. Secondly supporting 'notMerge' requires
  // rawOption cloned and backuped when timeline changed, which does no
  // good to performance. What's more, that both timeline and setOption
  // method supply 'notMerge' brings complex and some problems.
  // Consider this case:
  // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);
  // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);
  function OptionManager(api) {
    this._timelineOptions = [];
    this._mediaList = [];
    /**
     * -1, means default.
     * empty means no media.
     */

    this._currentMediaIndices = [];
    this._api = api;
  }

  OptionManager.prototype.setOption = function (rawOption, optionPreprocessorFuncs, opt) {
    if (rawOption) {
      // That set dat primitive is dangerous if user reuse the data when setOption again.
      each$9(normalizeToArray(rawOption.series), function (series) {
        series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);
      });
      each$9(normalizeToArray(rawOption.dataset), function (dataset) {
        dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);
      });
    } // Caution: some series modify option data, if do not clone,
    // it should ensure that the repeat modify correctly
    // (create a new object when modify itself).


    rawOption = clone$3(rawOption); // FIXME
    // If some property is set in timeline options or media option but
    // not set in baseOption, a warning should be given.

    var optionBackup = this._optionBackup;
    var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs, !optionBackup);
    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);

    if (optionBackup) {
      // FIXME
      // the restore merge solution is essentially incorrect.
      // the mapping can not be 100% consistent with ecModel, which probably brings
      // potential bug!
      // The first merge is delayed, becuase in most cases, users do not call `setOption` twice.
      // let fakeCmptsMap = this._fakeCmptsMap;
      // if (!fakeCmptsMap) {
      //     fakeCmptsMap = this._fakeCmptsMap = createHashMap();
      //     mergeToBackupOption(fakeCmptsMap, null, optionBackup.baseOption, null);
      // }
      // mergeToBackupOption(
      //     fakeCmptsMap, optionBackup.baseOption, newParsedOption.baseOption, opt
      // );
      // For simplicity, timeline options and media options do not support merge,
      // that is, if you `setOption` twice and both has timeline options, the latter
      // timeline opitons will not be merged to the formers, but just substitude them.
      if (newParsedOption.timelineOptions.length) {
        optionBackup.timelineOptions = newParsedOption.timelineOptions;
      }

      if (newParsedOption.mediaList.length) {
        optionBackup.mediaList = newParsedOption.mediaList;
      }

      if (newParsedOption.mediaDefault) {
        optionBackup.mediaDefault = newParsedOption.mediaDefault;
      }
    } else {
      this._optionBackup = newParsedOption;
    }
  };

  OptionManager.prototype.mountOption = function (isRecreate) {
    var optionBackup = this._optionBackup;
    this._timelineOptions = optionBackup.timelineOptions;
    this._mediaList = optionBackup.mediaList;
    this._mediaDefault = optionBackup.mediaDefault;
    this._currentMediaIndices = [];
    return clone$3(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`
    // called, and is merged into every new option by inner method `mergeToBackupOption`
    // each time `setOption` called, can be only used in `isRecreate`, because
    // its reliability is under suspicion. In other cases option merge is
    // performed by `model.mergeOption`.
    ? optionBackup.baseOption : this._newBaseOption);
  };

  OptionManager.prototype.getTimelineOption = function (ecModel) {
    var option;
    var timelineOptions = this._timelineOptions;

    if (timelineOptions.length) {
      // getTimelineOption can only be called after ecModel inited,
      // so we can get currentIndex from timelineModel.
      var timelineModel = ecModel.getComponent('timeline');

      if (timelineModel) {
        option = clone$3( // FIXME:TS as TimelineModel or quivlant interface
        timelineOptions[timelineModel.getCurrentIndex()]);
      }
    }

    return option;
  };

  OptionManager.prototype.getMediaOption = function (ecModel) {
    var ecWidth = this._api.getWidth();

    var ecHeight = this._api.getHeight();

    var mediaList = this._mediaList;
    var mediaDefault = this._mediaDefault;
    var indices = [];
    var result = []; // No media defined.

    if (!mediaList.length && !mediaDefault) {
      return result;
    } // Multi media may be applied, the latter defined media has higher priority.


    for (var i = 0, len = mediaList.length; i < len; i++) {
      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
        indices.push(i);
      }
    } // FIXME
    // Whether mediaDefault should force users to provide? Otherwise
    // the change by media query can not be recorvered.


    if (!indices.length && mediaDefault) {
      indices = [-1];
    }

    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
      result = map$1(indices, function (index) {
        return clone$3(index === -1 ? mediaDefault.option : mediaList[index].option);
      });
    } // Otherwise return nothing.


    this._currentMediaIndices = indices;
    return result;
  };

  return OptionManager;
}();
/**
 * [RAW_OPTION_PATTERNS]
 * (Note: "series: []" represents all other props in `ECUnitOption`)
 *
 * (1) No prop "baseOption" declared:
 * Root option is used as "baseOption" (except prop "options" and "media").
 * ```js
 * option = {
 *     series: [],
 *     timeline: {},
 *     options: [],
 * };
 * option = {
 *     series: [],
 *     media: {},
 * };
 * option = {
 *     series: [],
 *     timeline: {},
 *     options: [],
 *     media: {},
 * }
 * ```
 *
 * (2) Prop "baseOption" declared:
 * If "baseOption" declared, `ECUnitOption` props can only be declared
 * inside "baseOption" except prop "timeline" (compat ec2).
 * ```js
 * option = {
 *     baseOption: {
 *         timeline: {},
 *         series: [],
 *     },
 *     options: []
 * };
 * option = {
 *     baseOption: {
 *         series: [],
 *     },
 *     media: []
 * };
 * option = {
 *     baseOption: {
 *         timeline: {},
 *         series: [],
 *     },
 *     options: []
 *     media: []
 * };
 * option = {
 *     // ec3 compat ec2: allow (only) `timeline` declared
 *     // outside baseOption. Keep this setting for compat.
 *     timeline: {},
 *     baseOption: {
 *         series: [],
 *     },
 *     options: [],
 *     media: []
 * };
 * ```
 */


function parseRawOption( // `rawOption` May be modified
rawOption, optionPreprocessorFuncs, isNew) {
  var mediaList = [];
  var mediaDefault;
  var baseOption;
  var declaredBaseOption = rawOption.baseOption; // Compatible with ec2, [RAW_OPTION_PATTERNS] above.

  var timelineOnRoot = rawOption.timeline;
  var timelineOptionsOnRoot = rawOption.options;
  var mediaOnRoot = rawOption.media;
  var hasMedia = !!rawOption.media;
  var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);

  if (declaredBaseOption) {
    baseOption = declaredBaseOption; // For merge option.

    if (!baseOption.timeline) {
      baseOption.timeline = timelineOnRoot;
    }
  } // For convenience, enable to use the root option as the `baseOption`:
  // `{ ...normalOptionProps, media: [{ ... }, { ... }] }`
  else {
      if (hasTimeline || hasMedia) {
        rawOption.options = rawOption.media = null;
      }

      baseOption = rawOption;
    }

  if (hasMedia) {
    if (isArray$1(mediaOnRoot)) {
      each$9(mediaOnRoot, function (singleMedia) {
        if (process.env.NODE_ENV !== 'production') {
          // Real case of wrong config.
          if (singleMedia && !singleMedia.option && isObject$3(singleMedia.query) && isObject$3(singleMedia.query.option)) {
            error('Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }');
          }
        }

        if (singleMedia && singleMedia.option) {
          if (singleMedia.query) {
            mediaList.push(singleMedia);
          } else if (!mediaDefault) {
            // Use the first media default.
            mediaDefault = singleMedia;
          }
        }
      });
    } else {
      if (process.env.NODE_ENV !== 'production') {
        // Real case of wrong config.
        error('Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }');
      }
    }
  }

  doPreprocess(baseOption);
  each$9(timelineOptionsOnRoot, function (option) {
    return doPreprocess(option);
  });
  each$9(mediaList, function (media) {
    return doPreprocess(media.option);
  });

  function doPreprocess(option) {
    each$9(optionPreprocessorFuncs, function (preProcess) {
      preProcess(option, isNew);
    });
  }

  return {
    baseOption: baseOption,
    timelineOptions: timelineOptionsOnRoot || [],
    mediaDefault: mediaDefault,
    mediaList: mediaList
  };
}
/**
 * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
 * Support: width, height, aspectRatio
 * Can use max or min as prefix.
 */


function applyMediaQuery(query, ecWidth, ecHeight) {
  var realMap = {
    width: ecWidth,
    height: ecHeight,
    aspectratio: ecWidth / ecHeight // lowser case for convenientce.

  };
  var applicatable = true;
  each$9(query, function (value, attr) {
    var matched = attr.match(QUERY_REG);

    if (!matched || !matched[1] || !matched[2]) {
      return;
    }

    var operator = matched[1];
    var realAttr = matched[2].toLowerCase();

    if (!compare(realMap[realAttr], value, operator)) {
      applicatable = false;
    }
  });
  return applicatable;
}

function compare(real, expect, operator) {
  if (operator === 'min') {
    return real >= expect;
  } else if (operator === 'max') {
    return real <= expect;
  } else {
    // Equals
    return real === expect;
  }
}

function indicesEquals(indices1, indices2) {
  // indices is always order by asc and has only finite number.
  return indices1.join(',') === indices2.join(',');
}
/**
 * Consider case:
 * `chart.setOption(opt1);`
 * Then user do some interaction like dataZoom, dataView changing.
 * `chart.setOption(opt2);`
 * Then user press 'reset button' in toolbox.
 *
 * After doing that all of the interaction effects should be reset, the
 * chart should be the same as the result of invoke
 * `chart.setOption(opt1); chart.setOption(opt2);`.
 *
 * Although it is not able ensure that
 * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
 * `chart.setOption(merge(opt1, opt2));` exactly,
 * this might be the only simple way to implement that feature.
 *
 * MEMO: We've considered some other approaches:
 * 1. Each model handle its self restoration but not uniform treatment.
 *     (Too complex in logic and error-prone)
 * 2. Use a shadow ecModel. (Performace expensive)
 *
 * FIXME: A possible solution:
 * Add a extra level of model for each component model. The inheritance chain would be:
 * ecModel <- componentModel <- componentActionModel <- dataItemModel
 * And all of the actions can only modify the `componentActionModel` rather than
 * `componentModel`. `setOption` will only modify the `ecModel` and `componentModel`.
 * When "resotre" action triggered, model from `componentActionModel` will be discarded
 * instead of recreating the "ecModel" from the "_optionBackup".
 */
// function mergeToBackupOption(
//     fakeCmptsMap: FakeComponentsMap,
//     // `tarOption` Can be null/undefined, means init
//     tarOption: ECUnitOption,
//     newOption: ECUnitOption,
//     // Can be null/undefined
//     opt: InnerSetOptionOpts
// ): void {
//     newOption = newOption || {} as ECUnitOption;
//     const notInit = !!tarOption;
//     each(newOption, function (newOptsInMainType, mainType) {
//         if (newOptsInMainType == null) {
//             return;
//         }
//         if (!ComponentModel.hasClass(mainType)) {
//             if (tarOption) {
//                 tarOption[mainType] = merge(tarOption[mainType], newOptsInMainType, true);
//             }
//         }
//         else {
//             const oldTarOptsInMainType = notInit ? normalizeToArray(tarOption[mainType]) : null;
//             const oldFakeCmptsInMainType = fakeCmptsMap.get(mainType) || [];
//             const resultTarOptsInMainType = notInit ? (tarOption[mainType] = [] as ComponentOption[]) : null;
//             const resultFakeCmptsInMainType = fakeCmptsMap.set(mainType, []);
//             const mappingResult = mappingToExists(
//                 oldFakeCmptsInMainType,
//                 normalizeToArray(newOptsInMainType),
//                 (opt && opt.replaceMergeMainTypeMap.get(mainType)) ? 'replaceMerge' : 'normalMerge'
//             );
//             setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel as ComponentModelConstructor);
//             each(mappingResult, function (resultItem, index) {
//                 // The same logic as `Global.ts#_mergeOption`.
//                 let fakeCmpt = resultItem.existing;
//                 const newOption = resultItem.newOption;
//                 const keyInfo = resultItem.keyInfo;
//                 let fakeCmptOpt;
//                 if (!newOption) {
//                     fakeCmptOpt = oldTarOptsInMainType[index];
//                 }
//                 else {
//                     if (fakeCmpt && fakeCmpt.subType === keyInfo.subType) {
//                         fakeCmpt.name = keyInfo.name;
//                         if (notInit) {
//                             fakeCmptOpt = merge(oldTarOptsInMainType[index], newOption, true);
//                         }
//                     }
//                     else {
//                         fakeCmpt = extend({}, keyInfo);
//                         if (notInit) {
//                             fakeCmptOpt = clone(newOption);
//                         }
//                     }
//                 }
//                 if (fakeCmpt) {
//                     notInit && resultTarOptsInMainType.push(fakeCmptOpt);
//                     resultFakeCmptsInMainType.push(fakeCmpt);
//                 }
//                 else {
//                     notInit && resultTarOptsInMainType.push(void 0);
//                     resultFakeCmptsInMainType.push(void 0);
//                 }
//             });
//         }
//     });
// }


var OptionManager$1 = OptionManager;

var each$7 = each$9;
var isObject$2 = isObject$3;
var POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];

function compatEC2ItemStyle(opt) {
  var itemStyleOpt = opt && opt.itemStyle;

  if (!itemStyleOpt) {
    return;
  }

  for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
    var styleName = POSSIBLE_STYLES[i];
    var normalItemStyleOpt = itemStyleOpt.normal;
    var emphasisItemStyleOpt = itemStyleOpt.emphasis;

    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
      if (process.env.NODE_ENV !== 'production') {
        deprecateReplaceLog("itemStyle.normal." + styleName, styleName);
      }

      opt[styleName] = opt[styleName] || {};

      if (!opt[styleName].normal) {
        opt[styleName].normal = normalItemStyleOpt[styleName];
      } else {
        merge$1(opt[styleName].normal, normalItemStyleOpt[styleName]);
      }

      normalItemStyleOpt[styleName] = null;
    }

    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
      if (process.env.NODE_ENV !== 'production') {
        deprecateReplaceLog("itemStyle.emphasis." + styleName, "emphasis." + styleName);
      }

      opt[styleName] = opt[styleName] || {};

      if (!opt[styleName].emphasis) {
        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
      } else {
        merge$1(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
      }

      emphasisItemStyleOpt[styleName] = null;
    }
  }
}

function convertNormalEmphasis(opt, optType, useExtend) {
  if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
    var normalOpt = opt[optType].normal;
    var emphasisOpt = opt[optType].emphasis;

    if (normalOpt) {
      if (process.env.NODE_ENV !== 'production') {
        // eslint-disable-next-line max-len
        deprecateLog("'normal' hierarchy in " + optType + " has been removed since 4.0. All style properties are configured in " + optType + " directly now.");
      } // Timeline controlStyle has other properties besides normal and emphasis


      if (useExtend) {
        opt[optType].normal = opt[optType].emphasis = null;
        defaults(opt[optType], normalOpt);
      } else {
        opt[optType] = normalOpt;
      }
    }

    if (emphasisOpt) {
      if (process.env.NODE_ENV !== 'production') {
        deprecateLog(optType + ".emphasis has been changed to emphasis." + optType + " since 4.0");
      }

      opt.emphasis = opt.emphasis || {};
      opt.emphasis[optType] = emphasisOpt; // Also compat the case user mix the style and focus together in ec3 style
      // for example: { itemStyle: { normal: {}, emphasis: {focus, shadowBlur} } }

      if (emphasisOpt.focus) {
        opt.emphasis.focus = emphasisOpt.focus;
      }

      if (emphasisOpt.blurScope) {
        opt.emphasis.blurScope = emphasisOpt.blurScope;
      }
    }
  }
}

function removeEC3NormalStatus(opt) {
  convertNormalEmphasis(opt, 'itemStyle');
  convertNormalEmphasis(opt, 'lineStyle');
  convertNormalEmphasis(opt, 'areaStyle');
  convertNormalEmphasis(opt, 'label');
  convertNormalEmphasis(opt, 'labelLine'); // treemap

  convertNormalEmphasis(opt, 'upperLabel'); // graph

  convertNormalEmphasis(opt, 'edgeLabel');
}

function compatTextStyle(opt, propName) {
  // Check whether is not object (string\null\undefined ...)
  var labelOptSingle = isObject$2(opt) && opt[propName];
  var textStyle = isObject$2(labelOptSingle) && labelOptSingle.textStyle;

  if (textStyle) {
    if (process.env.NODE_ENV !== 'production') {
      // eslint-disable-next-line max-len
      deprecateLog("textStyle hierarchy in " + propName + " has been removed since 4.0. All textStyle properties are configured in " + propName + " directly now.");
    }

    for (var i = 0, len = TEXT_STYLE_OPTIONS.length; i < len; i++) {
      var textPropName = TEXT_STYLE_OPTIONS[i];

      if (textStyle.hasOwnProperty(textPropName)) {
        labelOptSingle[textPropName] = textStyle[textPropName];
      }
    }
  }
}

function compatEC3CommonStyles(opt) {
  if (opt) {
    removeEC3NormalStatus(opt);
    compatTextStyle(opt, 'label');
    opt.emphasis && compatTextStyle(opt.emphasis, 'label');
  }
}

function processSeries(seriesOpt) {
  if (!isObject$2(seriesOpt)) {
    return;
  }

  compatEC2ItemStyle(seriesOpt);
  removeEC3NormalStatus(seriesOpt);
  compatTextStyle(seriesOpt, 'label'); // treemap

  compatTextStyle(seriesOpt, 'upperLabel'); // graph

  compatTextStyle(seriesOpt, 'edgeLabel');

  if (seriesOpt.emphasis) {
    compatTextStyle(seriesOpt.emphasis, 'label'); // treemap

    compatTextStyle(seriesOpt.emphasis, 'upperLabel'); // graph

    compatTextStyle(seriesOpt.emphasis, 'edgeLabel');
  }

  var markPoint = seriesOpt.markPoint;

  if (markPoint) {
    compatEC2ItemStyle(markPoint);
    compatEC3CommonStyles(markPoint);
  }

  var markLine = seriesOpt.markLine;

  if (markLine) {
    compatEC2ItemStyle(markLine);
    compatEC3CommonStyles(markLine);
  }

  var markArea = seriesOpt.markArea;

  if (markArea) {
    compatEC3CommonStyles(markArea);
  }

  var data = seriesOpt.data; // Break with ec3: if `setOption` again, there may be no `type` in option,
  // then the backward compat based on option type will not be performed.

  if (seriesOpt.type === 'graph') {
    data = data || seriesOpt.nodes;
    var edgeData = seriesOpt.links || seriesOpt.edges;

    if (edgeData && !isTypedArray(edgeData)) {
      for (var i = 0; i < edgeData.length; i++) {
        compatEC3CommonStyles(edgeData[i]);
      }
    }

    each$9(seriesOpt.categories, function (opt) {
      removeEC3NormalStatus(opt);
    });
  }

  if (data && !isTypedArray(data)) {
    for (var i = 0; i < data.length; i++) {
      compatEC3CommonStyles(data[i]);
    }
  } // mark point data


  markPoint = seriesOpt.markPoint;

  if (markPoint && markPoint.data) {
    var mpData = markPoint.data;

    for (var i = 0; i < mpData.length; i++) {
      compatEC3CommonStyles(mpData[i]);
    }
  } // mark line data


  markLine = seriesOpt.markLine;

  if (markLine && markLine.data) {
    var mlData = markLine.data;

    for (var i = 0; i < mlData.length; i++) {
      if (isArray$1(mlData[i])) {
        compatEC3CommonStyles(mlData[i][0]);
        compatEC3CommonStyles(mlData[i][1]);
      } else {
        compatEC3CommonStyles(mlData[i]);
      }
    }
  } // Series


  if (seriesOpt.type === 'gauge') {
    compatTextStyle(seriesOpt, 'axisLabel');
    compatTextStyle(seriesOpt, 'title');
    compatTextStyle(seriesOpt, 'detail');
  } else if (seriesOpt.type === 'treemap') {
    convertNormalEmphasis(seriesOpt.breadcrumb, 'itemStyle');
    each$9(seriesOpt.levels, function (opt) {
      removeEC3NormalStatus(opt);
    });
  } else if (seriesOpt.type === 'tree') {
    removeEC3NormalStatus(seriesOpt.leaves);
  } // sunburst starts from ec4, so it does not need to compat levels.

}

function toArr(o) {
  return isArray$1(o) ? o : o ? [o] : [];
}

function toObj(o) {
  return (isArray$1(o) ? o[0] : o) || {};
}

function globalCompatStyle(option, isTheme) {
  each$7(toArr(option.series), function (seriesOpt) {
    isObject$2(seriesOpt) && processSeries(seriesOpt);
  });
  var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];
  isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');
  each$7(axes, function (axisName) {
    each$7(toArr(option[axisName]), function (axisOpt) {
      if (axisOpt) {
        compatTextStyle(axisOpt, 'axisLabel');
        compatTextStyle(axisOpt.axisPointer, 'label');
      }
    });
  });
  each$7(toArr(option.parallel), function (parallelOpt) {
    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
    compatTextStyle(parallelAxisDefault, 'axisLabel');
    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');
  });
  each$7(toArr(option.calendar), function (calendarOpt) {
    convertNormalEmphasis(calendarOpt, 'itemStyle');
    compatTextStyle(calendarOpt, 'dayLabel');
    compatTextStyle(calendarOpt, 'monthLabel');
    compatTextStyle(calendarOpt, 'yearLabel');
  }); // radar.name.textStyle

  each$7(toArr(option.radar), function (radarOpt) {
    compatTextStyle(radarOpt, 'name'); // Use axisName instead of name because component has name property

    if (radarOpt.name && radarOpt.axisName == null) {
      radarOpt.axisName = radarOpt.name;
      delete radarOpt.name;

      if (process.env.NODE_ENV !== 'production') {
        deprecateLog('name property in radar component has been changed to axisName');
      }
    }

    if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
      radarOpt.axisNameGap = radarOpt.nameGap;
      delete radarOpt.nameGap;

      if (process.env.NODE_ENV !== 'production') {
        deprecateLog('nameGap property in radar component has been changed to axisNameGap');
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      each$7(radarOpt.indicator, function (indicatorOpt) {
        if (indicatorOpt.text) {
          deprecateReplaceLog('text', 'name', 'radar.indicator');
        }
      });
    }
  });
  each$7(toArr(option.geo), function (geoOpt) {
    if (isObject$2(geoOpt)) {
      compatEC3CommonStyles(geoOpt);
      each$7(toArr(geoOpt.regions), function (regionObj) {
        compatEC3CommonStyles(regionObj);
      });
    }
  });
  each$7(toArr(option.timeline), function (timelineOpt) {
    compatEC3CommonStyles(timelineOpt);
    convertNormalEmphasis(timelineOpt, 'label');
    convertNormalEmphasis(timelineOpt, 'itemStyle');
    convertNormalEmphasis(timelineOpt, 'controlStyle', true);
    var data = timelineOpt.data;
    isArray$1(data) && each$9(data, function (item) {
      if (isObject$3(item)) {
        convertNormalEmphasis(item, 'label');
        convertNormalEmphasis(item, 'itemStyle');
      }
    });
  });
  each$7(toArr(option.toolbox), function (toolboxOpt) {
    convertNormalEmphasis(toolboxOpt, 'iconStyle');
    each$7(toolboxOpt.feature, function (featureOpt) {
      convertNormalEmphasis(featureOpt, 'iconStyle');
    });
  });
  compatTextStyle(toObj(option.axisPointer), 'label');
  compatTextStyle(toObj(option.tooltip).axisPointer, 'label'); // Clean logs
  // storedLogs = {};
}

function get(opt, path) {
  var pathArr = path.split(',');
  var obj = opt;

  for (var i = 0; i < pathArr.length; i++) {
    obj = obj && obj[pathArr[i]];

    if (obj == null) {
      break;
    }
  }

  return obj;
}

function set(opt, path, val, overwrite) {
  var pathArr = path.split(',');
  var obj = opt;
  var key;
  var i = 0;

  for (; i < pathArr.length - 1; i++) {
    key = pathArr[i];

    if (obj[key] == null) {
      obj[key] = {};
    }

    obj = obj[key];
  }

  if (overwrite || obj[pathArr[i]] == null) {
    obj[pathArr[i]] = val;
  }
}

function compatLayoutProperties(option) {
  option && each$9(LAYOUT_PROPERTIES, function (prop) {
    if (prop[0] in option && !(prop[1] in option)) {
      option[prop[1]] = option[prop[0]];
    }
  });
}

var LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];
var COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];
var BAR_ITEM_STYLE_MAP = [['borderRadius', 'barBorderRadius'], ['borderColor', 'barBorderColor'], ['borderWidth', 'barBorderWidth']];

function compatBarItemStyle(option) {
  var itemStyle = option && option.itemStyle;

  if (itemStyle) {
    for (var i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {
      var oldName = BAR_ITEM_STYLE_MAP[i][1];
      var newName = BAR_ITEM_STYLE_MAP[i][0];

      if (itemStyle[oldName] != null) {
        itemStyle[newName] = itemStyle[oldName];

        if (process.env.NODE_ENV !== 'production') {
          deprecateReplaceLog(oldName, newName);
        }
      }
    }
  }
}

function compatPieLabel(option) {
  if (!option) {
    return;
  }

  if (option.alignTo === 'edge' && option.margin != null && option.edgeDistance == null) {
    if (process.env.NODE_ENV !== 'production') {
      deprecateReplaceLog('label.margin', 'label.edgeDistance', 'pie');
    }

    option.edgeDistance = option.margin;
  }
}

function compatSunburstState(option) {
  if (!option) {
    return;
  }

  if (option.downplay && !option.blur) {
    option.blur = option.downplay;

    if (process.env.NODE_ENV !== 'production') {
      deprecateReplaceLog('downplay', 'blur', 'sunburst');
    }
  }
}

function compatGraphFocus(option) {
  if (!option) {
    return;
  }

  if (option.focusNodeAdjacency != null) {
    option.emphasis = option.emphasis || {};

    if (option.emphasis.focus == null) {
      if (process.env.NODE_ENV !== 'production') {
        deprecateReplaceLog('focusNodeAdjacency', 'emphasis: { focus: \'adjacency\'}', 'graph/sankey');
      }

      option.emphasis.focus = 'adjacency';
    }
  }
}

function traverseTree(data, cb) {
  if (data) {
    for (var i = 0; i < data.length; i++) {
      cb(data[i]);
      data[i] && traverseTree(data[i].children, cb);
    }
  }
}

function globalBackwardCompat(option, isTheme) {
  globalCompatStyle(option, isTheme); // Make sure series array for model initialization.

  option.series = normalizeToArray(option.series);
  each$9(option.series, function (seriesOpt) {
    if (!isObject$3(seriesOpt)) {
      return;
    }

    var seriesType = seriesOpt.type;

    if (seriesType === 'line') {
      if (seriesOpt.clipOverflow != null) {
        seriesOpt.clip = seriesOpt.clipOverflow;

        if (process.env.NODE_ENV !== 'production') {
          deprecateReplaceLog('clipOverflow', 'clip', 'line');
        }
      }
    } else if (seriesType === 'pie' || seriesType === 'gauge') {
      if (seriesOpt.clockWise != null) {
        seriesOpt.clockwise = seriesOpt.clockWise;

        if (process.env.NODE_ENV !== 'production') {
          deprecateReplaceLog('clockWise', 'clockwise');
        }
      }

      compatPieLabel(seriesOpt.label);
      var data = seriesOpt.data;

      if (data && !isTypedArray(data)) {
        for (var i = 0; i < data.length; i++) {
          compatPieLabel(data[i]);
        }
      }

      if (seriesOpt.hoverOffset != null) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};

        if (seriesOpt.emphasis.scaleSize = null) {
          if (process.env.NODE_ENV !== 'production') {
            deprecateReplaceLog('hoverOffset', 'emphasis.scaleSize');
          }

          seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
        }
      }
    } else if (seriesType === 'gauge') {
      var pointerColor = get(seriesOpt, 'pointer.color');
      pointerColor != null && set(seriesOpt, 'itemStyle.color', pointerColor);
    } else if (seriesType === 'bar') {
      compatBarItemStyle(seriesOpt);
      compatBarItemStyle(seriesOpt.backgroundStyle);
      compatBarItemStyle(seriesOpt.emphasis);
      var data = seriesOpt.data;

      if (data && !isTypedArray(data)) {
        for (var i = 0; i < data.length; i++) {
          if (typeof data[i] === 'object') {
            compatBarItemStyle(data[i]);
            compatBarItemStyle(data[i] && data[i].emphasis);
          }
        }
      }
    } else if (seriesType === 'sunburst') {
      var highlightPolicy = seriesOpt.highlightPolicy;

      if (highlightPolicy) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};

        if (!seriesOpt.emphasis.focus) {
          seriesOpt.emphasis.focus = highlightPolicy;

          if (process.env.NODE_ENV !== 'production') {
            deprecateReplaceLog('highlightPolicy', 'emphasis.focus', 'sunburst');
          }
        }
      }

      compatSunburstState(seriesOpt);
      traverseTree(seriesOpt.data, compatSunburstState);
    } else if (seriesType === 'graph' || seriesType === 'sankey') {
      compatGraphFocus(seriesOpt); // TODO nodes, edges?
    } else if (seriesType === 'map') {
      if (seriesOpt.mapType && !seriesOpt.map) {
        if (process.env.NODE_ENV !== 'production') {
          deprecateReplaceLog('mapType', 'map', 'map');
        }

        seriesOpt.map = seriesOpt.mapType;
      }

      if (seriesOpt.mapLocation) {
        if (process.env.NODE_ENV !== 'production') {
          deprecateLog('`mapLocation` is not used anymore.');
        }

        defaults(seriesOpt, seriesOpt.mapLocation);
      }
    }

    if (seriesOpt.hoverAnimation != null) {
      seriesOpt.emphasis = seriesOpt.emphasis || {};

      if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
        if (process.env.NODE_ENV !== 'production') {
          deprecateReplaceLog('hoverAnimation', 'emphasis.scale');
        }

        seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
      }
    }

    compatLayoutProperties(seriesOpt);
  }); // dataRange has changed to visualMap

  if (option.dataRange) {
    option.visualMap = option.dataRange;
  }

  each$9(COMPATITABLE_COMPONENTS, function (componentName) {
    var options = option[componentName];

    if (options) {
      if (!isArray$1(options)) {
        options = [options];
      }

      each$9(options, function (option) {
        compatLayoutProperties(option);
      });
    }
  });
}

//     data processing stage is blocked in stream.
//     See <module:echarts/stream/Scheduler#performDataProcessorTasks>
// (2) Only register once when import repeatedly.
//     Should be executed after series is filtered and before stack calculation.

function dataStack$1(ecModel) {
  var stackInfoMap = createHashMap();
  ecModel.eachSeries(function (seriesModel) {
    var stack = seriesModel.get('stack'); // Compatible: when `stack` is set as '', do not stack.

    if (stack) {
      var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
      var data = seriesModel.getData();
      var stackInfo = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: data.getCalculationInfo('stackResultDimension'),
        stackedOverDimension: data.getCalculationInfo('stackedOverDimension'),
        stackedDimension: data.getCalculationInfo('stackedDimension'),
        stackedByDimension: data.getCalculationInfo('stackedByDimension'),
        isStackedByIndex: data.getCalculationInfo('isStackedByIndex'),
        data: data,
        seriesModel: seriesModel
      }; // If stacked on axis that do not support data stack.

      if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
        return;
      }

      stackInfoList.length && data.setCalculationInfo('stackedOnSeries', stackInfoList[stackInfoList.length - 1].seriesModel);
      stackInfoList.push(stackInfo);
    }
  });
  stackInfoMap.each(calculateStack);
}

function calculateStack(stackInfoList) {
  each$9(stackInfoList, function (targetStackInfo, idxInStack) {
    var resultVal = [];
    var resultNaN = [NaN, NaN];
    var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
    var targetData = targetStackInfo.data;
    var isStackedByIndex = targetStackInfo.isStackedByIndex;
    var stackStrategy = targetStackInfo.seriesModel.get('stackStrategy') || 'samesign'; // Should not write on raw data, because stack series model list changes
    // depending on legend selection.

    targetData.modify(dims, function (v0, v1, dataIndex) {
      var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex); // Consider `connectNulls` of line area, if value is NaN, stackedOver
      // should also be NaN, to draw a appropriate belt area.

      if (isNaN(sum)) {
        return resultNaN;
      }

      var byValue;
      var stackedDataRawIndex;

      if (isStackedByIndex) {
        stackedDataRawIndex = targetData.getRawIndex(dataIndex);
      } else {
        byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
      } // If stackOver is NaN, chart view will render point on value start.


      var stackedOver = NaN;

      for (var j = idxInStack - 1; j >= 0; j--) {
        var stackInfo = stackInfoList[j]; // Has been optimized by inverted indices on `stackedByDimension`.

        if (!isStackedByIndex) {
          stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
        }

        if (stackedDataRawIndex >= 0) {
          var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex); // Considering positive stack, negative stack and empty data

          if (stackStrategy === 'all' // single stack group
          || stackStrategy === 'positive' && val > 0 || stackStrategy === 'negative' && val < 0 || stackStrategy === 'samesign' && sum >= 0 && val > 0 // All positive stack
          || stackStrategy === 'samesign' && sum <= 0 && val < 0 // All negative stack
          ) {
              // The sum has to be very small to be affected by the
              // floating arithmetic problem. An incorrect result will probably
              // cause axis min/max to be filtered incorrectly.
              sum = addSafe(sum, val);
              stackedOver = val;
              break;
            }
        }
      }

      resultVal[0] = sum;
      resultVal[1] = stackedOver;
      return resultVal;
    });
  });
}

var SourceImpl =
/** @class */
function () {
  function SourceImpl(fields) {
    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN; // Visit config

    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
    this.startIndex = fields.startIndex || 0;
    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
    this.metaRawOption = fields.metaRawOption;
    var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;

    if (dimensionsDefine) {
      for (var i = 0; i < dimensionsDefine.length; i++) {
        var dim = dimensionsDefine[i];

        if (dim.type == null) {
          if (guessOrdinal(this, i) === BE_ORDINAL.Must) {
            dim.type = 'ordinal';
          }
        }
      }
    }
  }

  return SourceImpl;
}();

function isSourceInstance(val) {
  return val instanceof SourceImpl;
}
/**
 * Create a source from option.
 * NOTE: Created source is immutable. Don't change any properties in it.
 */

function createSource(sourceData, thisMetaRawOption, // can be null. If not provided, auto detect it from `sourceData`.
sourceFormat) {
  sourceFormat = sourceFormat || detectSourceFormat(sourceData);
  var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
  var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
  var source = new SourceImpl({
    data: sourceData,
    sourceFormat: sourceFormat,
    seriesLayoutBy: seriesLayoutBy,
    dimensionsDefine: determined.dimensionsDefine,
    startIndex: determined.startIndex,
    dimensionsDetectedCount: determined.dimensionsDetectedCount,
    metaRawOption: clone$3(thisMetaRawOption)
  });
  return source;
}
/**
 * Wrap original series data for some compatibility cases.
 */

function createSourceFromSeriesDataOption(data) {
  return new SourceImpl({
    data: data,
    sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
  });
}
/**
 * Clone source but excludes source data.
 */

function cloneSourceShallow(source) {
  return new SourceImpl({
    data: source.data,
    sourceFormat: source.sourceFormat,
    seriesLayoutBy: source.seriesLayoutBy,
    dimensionsDefine: clone$3(source.dimensionsDefine),
    startIndex: source.startIndex,
    dimensionsDetectedCount: source.dimensionsDetectedCount
  });
}
/**
 * Note: An empty array will be detected as `SOURCE_FORMAT_ARRAY_ROWS`.
 */

function detectSourceFormat(data) {
  var sourceFormat = SOURCE_FORMAT_UNKNOWN;

  if (isTypedArray(data)) {
    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
  } else if (isArray$1(data)) {
    // FIXME Whether tolerate null in top level array?
    if (data.length === 0) {
      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
    }

    for (var i = 0, len = data.length; i < len; i++) {
      var item = data[i];

      if (item == null) {
        continue;
      } else if (isArray$1(item)) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
        break;
      } else if (isObject$3(item)) {
        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
        break;
      }
    }
  } else if (isObject$3(data)) {
    for (var key in data) {
      if (hasOwn(data, key) && isArrayLike(data[key])) {
        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
        break;
      }
    }
  }

  return sourceFormat;
}
/**
 * Determine the source definitions from data standalone dimensions definitions
 * are not specified.
 */

function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, // standalone raw dimensions definition, like:
// {
//     dimensions: ['aa', 'bb', { name: 'cc', type: 'time' }]
// }
// in `dataset` or `series`
dimensionsDefine) {
  var dimensionsDetectedCount;
  var startIndex; // PEDING: could data be null/undefined here?
  // currently, if `dataset.source` not specified, error thrown.
  // if `series.data` not specified, nothing rendered without error thrown.
  // Should test these cases.

  if (!data) {
    return {
      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
      startIndex: startIndex,
      dimensionsDetectedCount: dimensionsDetectedCount
    };
  }

  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var dataArrayRows = data; // Rule: Most of the first line are string: it is header.
    // Caution: consider a line with 5 string and 1 number,
    // it still can not be sure it is a head, because the
    // 5 string may be 5 values of category columns.

    if (sourceHeader === 'auto' || sourceHeader == null) {
      arrayRowsTravelFirst(function (val) {
        // '-' is regarded as null/undefined.
        if (val != null && val !== '-') {
          if (isString(val)) {
            startIndex == null && (startIndex = 1);
          } else {
            startIndex = 0;
          }
        } // 10 is an experience number, avoid long loop.

      }, seriesLayoutBy, dataArrayRows, 10);
    } else {
      startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
    }

    if (!dimensionsDefine && startIndex === 1) {
      dimensionsDefine = [];
      arrayRowsTravelFirst(function (val, index) {
        dimensionsDefine[index] = val != null ? val + '' : '';
      }, seriesLayoutBy, dataArrayRows, Infinity);
    }

    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    if (!dimensionsDefine) {
      dimensionsDefine = objectRowsCollectDimensions(data);
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    if (!dimensionsDefine) {
      dimensionsDefine = [];
      each$9(data, function (colArr, key) {
        dimensionsDefine.push(key);
      });
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var value0 = getDataItemValue(data[0]);
    dimensionsDetectedCount = isArray$1(value0) && value0.length || 1;
  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
    if (process.env.NODE_ENV !== 'production') {
      assert(!!dimensionsDefine, 'dimensions must be given if data is TypedArray.');
    }
  }

  return {
    startIndex: startIndex,
    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
    dimensionsDetectedCount: dimensionsDetectedCount
  };
}

function objectRowsCollectDimensions(data) {
  var firstIndex = 0;
  var obj;

  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line


  if (obj) {
    var dimensions_1 = [];
    each$9(obj, function (value, key) {
      dimensions_1.push(key);
    });
    return dimensions_1;
  }
} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],
// which is reasonable. But dimension name is duplicated.
// Returns undefined or an array contains only object without null/undefiend or string.


function normalizeDimensionsOption(dimensionsDefine) {
  if (!dimensionsDefine) {
    // The meaning of null/undefined is different from empty array.
    return;
  }

  var nameMap = createHashMap();
  return map$1(dimensionsDefine, function (rawItem, index) {
    rawItem = isObject$3(rawItem) ? rawItem : {
      name: rawItem
    }; // Other fields will be discarded.

    var item = {
      name: rawItem.name,
      displayName: rawItem.displayName,
      type: rawItem.type
    }; // User can set null in dimensions.
    // We dont auto specify name, othewise a given name may
    // cause it be refered unexpectedly.

    if (item.name == null) {
      return item;
    } // Also consider number form like 2012.


    item.name += ''; // User may also specify displayName.
    // displayName will always exists except user not
    // specified or dim name is not specified or detected.
    // (A auto generated dim name will not be used as
    // displayName).

    if (item.displayName == null) {
      item.displayName = item.name;
    }

    var exist = nameMap.get(item.name);

    if (!exist) {
      nameMap.set(item.name, {
        count: 1
      });
    } else {
      item.name += '-' + exist.count++;
    }

    return item;
  });
}

function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
    for (var i = 0; i < data.length && i < maxLoop; i++) {
      cb(data[i] ? data[i][0] : null, i);
    }
  } else {
    var value0 = data[0] || [];

    for (var i = 0; i < value0.length && i < maxLoop; i++) {
      cb(value0[i], i);
    }
  }
}

function shouldRetrieveDataByName(source) {
  var sourceFormat = source.sourceFormat;
  return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
}

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var _a, _b, _c; // TODO
var providerMethods;
var mountMethods;
/**
 * If normal array used, mutable chunk size is supported.
 * If typed array used, chunk size must be fixed.
 */

var DefaultDataProvider =
/** @class */
function () {
  function DefaultDataProvider(sourceParam, dimSize) {
    // let source: Source;
    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam; // declare source is Source;

    this._source = source;
    var data = this._data = source.data; // Typed array. TODO IE10+?

    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      if (process.env.NODE_ENV !== 'production') {
        if (dimSize == null) {
          throw new Error('Typed array data must specify dimension size');
        }
      }

      this._offset = 0;
      this._dimSize = dimSize;
      this._data = data;
    }

    mountMethods(this, data, source);
  }

  DefaultDataProvider.prototype.getSource = function () {
    return this._source;
  };

  DefaultDataProvider.prototype.count = function () {
    return 0;
  };

  DefaultDataProvider.prototype.getItem = function (idx, out) {
    return;
  };

  DefaultDataProvider.prototype.appendData = function (newData) {};

  DefaultDataProvider.prototype.clean = function () {};

  DefaultDataProvider.protoInitialize = function () {
    // PENDING: To avoid potential incompat (e.g., prototype
    // is visited somewhere), still init them on prototype.
    var proto = DefaultDataProvider.prototype;
    proto.pure = false;
    proto.persistent = true;
  }();

  DefaultDataProvider.internalField = function () {
    var _a;

    mountMethods = function (provider, data, source) {
      var sourceFormat = source.sourceFormat;
      var seriesLayoutBy = source.seriesLayoutBy;
      var startIndex = source.startIndex;
      var dimsDef = source.dimensionsDefine;
      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];

      if (process.env.NODE_ENV !== 'production') {
        assert(methods, 'Invalide sourceFormat: ' + sourceFormat);
      }

      extend$2(provider, methods);

      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
        provider.getItem = getItemForTypedArray;
        provider.count = countForTypedArray;
        provider.fillStorage = fillStorageForTypedArray;
      } else {
        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);
        provider.getItem = bind$1(rawItemGetter, null, data, startIndex, dimsDef);
        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);
        provider.count = bind$1(rawCounter, null, data, startIndex, dimsDef);
      }
    };

    var getItemForTypedArray = function (idx, out) {
      idx = idx - this._offset;
      out = out || [];
      var data = this._data;
      var dimSize = this._dimSize;
      var offset = dimSize * idx;

      for (var i = 0; i < dimSize; i++) {
        out[i] = data[offset + i];
      }

      return out;
    };

    var fillStorageForTypedArray = function (start, end, storage, extent) {
      var data = this._data;
      var dimSize = this._dimSize;

      for (var dim = 0; dim < dimSize; dim++) {
        var dimExtent = extent[dim];
        var min = dimExtent[0] == null ? Infinity : dimExtent[0];
        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];
        var count = end - start;
        var arr = storage[dim];

        for (var i = 0; i < count; i++) {
          // appendData with TypedArray will always do replace in provider.
          var val = data[i * dimSize + dim];
          arr[start + i] = val;
          val < min && (min = val);
          val > max && (max = val);
        }

        dimExtent[0] = min;
        dimExtent[1] = max;
      }
    };

    var countForTypedArray = function () {
      return this._data ? this._data.length / this._dimSize : 0;
    };

    providerMethods = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {
      pure: true,
      appendData: appendDataSimply
    }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {
      pure: true,
      appendData: function () {
        throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
      }
    }, _a[SOURCE_FORMAT_OBJECT_ROWS] = {
      pure: true,
      appendData: appendDataSimply
    }, _a[SOURCE_FORMAT_KEYED_COLUMNS] = {
      pure: true,
      appendData: function (newData) {
        var data = this._data;
        each$9(newData, function (newCol, key) {
          var oldCol = data[key] || (data[key] = []);

          for (var i = 0; i < (newCol || []).length; i++) {
            oldCol.push(newCol[i]);
          }
        });
      }
    }, _a[SOURCE_FORMAT_ORIGINAL] = {
      appendData: appendDataSimply
    }, _a[SOURCE_FORMAT_TYPED_ARRAY] = {
      persistent: false,
      pure: true,
      appendData: function (newData) {
        if (process.env.NODE_ENV !== 'production') {
          assert(isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');
        }

        this._data = newData;
      },
      // Clean self if data is already used.
      clean: function () {
        // PENDING
        this._offset += this.count();
        this._data = null;
      }
    }, _a);

    function appendDataSimply(newData) {
      for (var i = 0; i < newData.length; i++) {
        this._data.push(newData[i]);
      }
    }
  }();

  return DefaultDataProvider;
}();

var getItemSimply = function (rawData, startIndex, dimsDef, idx) {
  return rawData[idx];
};

var rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {
  return rawData[idx + startIndex];
}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx, out) {
  idx += startIndex;
  var item = out || [];
  var data = rawData;

  for (var i = 0; i < data.length; i++) {
    var row = data[i];
    item[i] = row ? row[idx] : null;
  }

  return item;
}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx, out) {
  var item = out || [];

  for (var i = 0; i < dimsDef.length; i++) {
    var dimName = dimsDef[i].name;

    if (process.env.NODE_ENV !== 'production') {
      if (dimName == null) {
        throw new Error();
      }
    }

    var col = rawData[dimName];
    item[i] = col ? col[idx] : null;
  }

  return item;
}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);
function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];

  if (process.env.NODE_ENV !== 'production') {
    assert(method, 'Do not support get item on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
  }

  return method;
}

var countSimply = function (rawData, startIndex, dimsDef) {
  return rawData.length;
};

var rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {
  return Math.max(0, rawData.length - startIndex);
}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {
  var row = rawData[0];
  return row ? Math.max(0, row.length - startIndex) : 0;
}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {
  var dimName = dimsDef[0].name;

  if (process.env.NODE_ENV !== 'production') {
    if (dimName == null) {
      throw new Error();
    }
  }

  var col = rawData[dimName];
  return col ? col.length : 0;
}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);
function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];

  if (process.env.NODE_ENV !== 'production') {
    assert(method, 'Do not suppport count on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
  }

  return method;
}

var getRawValueSimply = function (dataItem, dimIndex, property) {
  return dataItem[dimIndex];
};

var rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, property) {
  return dataItem[property];
}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, property) {
  // FIXME: In some case (markpoint in geo (geo-map.html)),
  // dataItem is {coord: [...]}
  var value = getDataItemValue(dataItem);
  return !(value instanceof Array) ? value : value[dimIndex];
}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);
function getRawSourceValueGetter(sourceFormat) {
  var method = rawSourceValueGetterMap[sourceFormat];

  if (process.env.NODE_ENV !== 'production') {
    assert(method, 'Do not suppport get value on "' + sourceFormat + '".');
  }

  return method;
}

function getMethodMapKey(sourceFormat, seriesLayoutBy) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;
} // ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,
// Consider persistent.
// Caution: why use raw value to display on label or tooltip?
// A reason is to avoid format. For example time value we do not know
// how to format is expected. More over, if stack is used, calculated
// value may be 0.91000000001, which have brings trouble to display.
// TODO: consider how to treat null/undefined/NaN when display?


function retrieveRawValue(data, dataIndex, // If dimIndex is null/undefined, return OptionDataItem.
// Otherwise, return OptionDataValue.
dim) {
  if (!data) {
    return;
  } // Consider data may be not persistent.


  var dataItem = data.getRawDataItem(dataIndex);

  if (dataItem == null) {
    return;
  }

  var store = data.getStore();
  var sourceFormat = store.getSource().sourceFormat;

  if (dim != null) {
    var dimIndex = data.getDimensionIndex(dim);
    var property = store.getDimensionProperty(dimIndex);
    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);
  } else {
    var result = dataItem;

    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      result = getDataItemValue(dataItem);
    }

    return result;
  }
}

var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;

var DataFormatMixin =
/** @class */
function () {
  function DataFormatMixin() {}
  /**
   * Get params for formatter
   */


  DataFormatMixin.prototype.getDataParams = function (dataIndex, dataType) {
    var data = this.getData(dataType);
    var rawValue = this.getRawValue(dataIndex, dataType);
    var rawDataIndex = data.getRawIndex(dataIndex);
    var name = data.getName(dataIndex);
    var itemOpt = data.getRawDataItem(dataIndex);
    var style = data.getItemVisual(dataIndex, 'style');
    var color = style && style[data.getItemVisual(dataIndex, 'drawType') || 'fill'];
    var borderColor = style && style.stroke;
    var mainType = this.mainType;
    var isSeries = mainType === 'series';
    var userOutput = data.userOutput && data.userOutput.get();
    return {
      componentType: mainType,
      componentSubType: this.subType,
      componentIndex: this.componentIndex,
      seriesType: isSeries ? this.subType : null,
      seriesIndex: this.seriesIndex,
      seriesId: isSeries ? this.id : null,
      seriesName: isSeries ? this.name : null,
      name: name,
      dataIndex: rawDataIndex,
      data: itemOpt,
      dataType: dataType,
      value: rawValue,
      color: color,
      borderColor: borderColor,
      dimensionNames: userOutput ? userOutput.fullDimensions : null,
      encode: userOutput ? userOutput.encode : null,
      // Param name list for mapping `a`, `b`, `c`, `d`, `e`
      $vars: ['seriesName', 'name', 'value']
    };
  };
  /**
   * Format label
   * @param dataIndex
   * @param status 'normal' by default
   * @param dataType
   * @param labelDimIndex Only used in some chart that
   *        use formatter in different dimensions, like radar.
   * @param formatter Formatter given outside.
   * @return return null/undefined if no formatter
   */


  DataFormatMixin.prototype.getFormattedLabel = function (dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
    status = status || 'normal';
    var data = this.getData(dataType);
    var params = this.getDataParams(dataIndex, dataType);

    if (extendParams) {
      params.value = extendParams.interpolatedValue;
    }

    if (labelDimIndex != null && isArray$1(params.value)) {
      params.value = params.value[labelDimIndex];
    }

    if (!formatter) {
      var itemModel = data.getItemModel(dataIndex); // @ts-ignore

      formatter = itemModel.get(status === 'normal' ? ['label', 'formatter'] : [status, 'label', 'formatter']);
    }

    if (isFunction(formatter)) {
      params.status = status;
      params.dimensionIndex = labelDimIndex;
      return formatter(params);
    } else if (isString(formatter)) {
      var str = formatTpl(formatter, params); // Support 'aaa{@[3]}bbb{@product}ccc'.
      // Do not support '}' in dim name util have to.

      return str.replace(DIMENSION_LABEL_REG, function (origin, dimStr) {
        var len = dimStr.length;
        var dimLoose = dimStr;

        if (dimLoose.charAt(0) === '[' && dimLoose.charAt(len - 1) === ']') {
          dimLoose = +dimLoose.slice(1, len - 1); // Also support: '[]' => 0

          if (process.env.NODE_ENV !== 'production') {
            if (isNaN(dimLoose)) {
              error("Invalide label formatter: @" + dimStr + ", only support @[0], @[1], @[2], ...");
            }
          }
        }

        var val = retrieveRawValue(data, dataIndex, dimLoose);

        if (extendParams && isArray$1(extendParams.interpolatedValue)) {
          var dimIndex = data.getDimensionIndex(dimLoose);

          if (dimIndex >= 0) {
            val = extendParams.interpolatedValue[dimIndex];
          }
        }

        return val != null ? val + '' : '';
      });
    }
  };
  /**
   * Get raw value in option
   */


  DataFormatMixin.prototype.getRawValue = function (idx, dataType) {
    return retrieveRawValue(this.getData(dataType), idx);
  };
  /**
   * Should be implemented.
   * @param {number} dataIndex
   * @param {boolean} [multipleSeries=false]
   * @param {string} [dataType]
   */


  DataFormatMixin.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
    // Empty function
    return;
  };

  return DataFormatMixin;
}();
// but guess little chance has been used outside. Do we need to backward
// compat it?
// type TooltipFormatResultLegacyObject = {
//     // `html` means the markup language text, either in 'html' or 'richText'.
//     // The name `html` is not appropriate becuase in 'richText' it is not a HTML
//     // string. But still support it for backward compat.
//     html: string;
//     markers: Dictionary<ColorString>;
// };

/**
 * For backward compat, normalize the return from `formatTooltip`.
 */

function normalizeTooltipFormatResult(result) {
  var markupText; // let markers: Dictionary<ColorString>;

  var markupFragment;

  if (isObject$3(result)) {
    if (result.type) {
      markupFragment = result;
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.warn('The return type of `formatTooltip` is not supported: ' + makePrintable(result));
      }
    } // else {
    //     markupText = (result as TooltipFormatResultLegacyObject).html;
    //     markers = (result as TooltipFormatResultLegacyObject).markers;
    //     if (markersExisting) {
    //         markers = zrUtil.merge(markersExisting, markers);
    //     }
    // }

  } else {
    markupText = result;
  }

  return {
    text: markupText,
    // markers: markers || markersExisting,
    frag: markupFragment
  };
}

/**
 * @param {Object} define
 * @return See the return of `createTask`.
 */

function createTask(define) {
  return new Task(define);
}

var Task =
/** @class */
function () {
  function Task(define) {
    define = define || {};
    this._reset = define.reset;
    this._plan = define.plan;
    this._count = define.count;
    this._onDirty = define.onDirty;
    this._dirty = true;
  }
  /**
   * @param step Specified step.
   * @param skip Skip customer perform call.
   * @param modBy Sampling window size.
   * @param modDataCount Sampling count.
   * @return whether unfinished.
   */


  Task.prototype.perform = function (performArgs) {
    var upTask = this._upstream;
    var skip = performArgs && performArgs.skip; // TODO some refactor.
    // Pull data. Must pull data each time, because context.data
    // may be updated by Series.setData.

    if (this._dirty && upTask) {
      var context = this.context;
      context.data = context.outputData = upTask.context.outputData;
    }

    if (this.__pipeline) {
      this.__pipeline.currentTask = this;
    }

    var planResult;

    if (this._plan && !skip) {
      planResult = this._plan(this.context);
    } // Support sharding by mod, which changes the render sequence and makes the rendered graphic
    // elements uniformed distributed when progress, especially when moving or zooming.


    var lastModBy = normalizeModBy(this._modBy);
    var lastModDataCount = this._modDataCount || 0;
    var modBy = normalizeModBy(performArgs && performArgs.modBy);
    var modDataCount = performArgs && performArgs.modDataCount || 0;

    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
      planResult = 'reset';
    }

    function normalizeModBy(val) {
      !(val >= 1) && (val = 1); // jshint ignore:line

      return val;
    }

    var forceFirstProgress;

    if (this._dirty || planResult === 'reset') {
      this._dirty = false;
      forceFirstProgress = this._doReset(skip);
    }

    this._modBy = modBy;
    this._modDataCount = modDataCount;
    var step = performArgs && performArgs.step;

    if (upTask) {
      if (process.env.NODE_ENV !== 'production') {
        assert(upTask._outputDueEnd != null);
      }

      this._dueEnd = upTask._outputDueEnd;
    } // DataTask or overallTask
    else {
        if (process.env.NODE_ENV !== 'production') {
          assert(!this._progress || this._count);
        }

        this._dueEnd = this._count ? this._count(this.context) : Infinity;
      } // Note: Stubs, that its host overall task let it has progress, has progress.
    // If no progress, pass index from upstream to downstream each time plan called.


    if (this._progress) {
      var start = this._dueIndex;
      var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);

      if (!skip && (forceFirstProgress || start < end)) {
        var progress = this._progress;

        if (isArray$1(progress)) {
          for (var i = 0; i < progress.length; i++) {
            this._doProgress(progress[i], start, end, modBy, modDataCount);
          }
        } else {
          this._doProgress(progress, start, end, modBy, modDataCount);
        }
      }

      this._dueIndex = end; // If no `outputDueEnd`, assume that output data and
      // input data is the same, so use `dueIndex` as `outputDueEnd`.

      var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;

      if (process.env.NODE_ENV !== 'production') {
        // ??? Can not rollback.
        assert(outputDueEnd >= this._outputDueEnd);
      }

      this._outputDueEnd = outputDueEnd;
    } else {
      // (1) Some overall task has no progress.
      // (2) Stubs, that its host overall task do not let it has progress, has no progress.
      // This should always be performed so it can be passed to downstream.
      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
    }

    return this.unfinished();
  };

  Task.prototype.dirty = function () {
    this._dirty = true;
    this._onDirty && this._onDirty(this.context);
  };

  Task.prototype._doProgress = function (progress, start, end, modBy, modDataCount) {
    iterator.reset(start, end, modBy, modDataCount);
    this._callingProgress = progress;

    this._callingProgress({
      start: start,
      end: end,
      count: end - start,
      next: iterator.next
    }, this.context);
  };

  Task.prototype._doReset = function (skip) {
    this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
    this._settedOutputEnd = null;
    var progress;
    var forceFirstProgress;

    if (!skip && this._reset) {
      progress = this._reset(this.context);

      if (progress && progress.progress) {
        forceFirstProgress = progress.forceFirstProgress;
        progress = progress.progress;
      } // To simplify no progress checking, array must has item.


      if (isArray$1(progress) && !progress.length) {
        progress = null;
      }
    }

    this._progress = progress;
    this._modBy = this._modDataCount = null;
    var downstream = this._downstream;
    downstream && downstream.dirty();
    return forceFirstProgress;
  };

  Task.prototype.unfinished = function () {
    return this._progress && this._dueIndex < this._dueEnd;
  };
  /**
   * @param downTask The downstream task.
   * @return The downstream task.
   */


  Task.prototype.pipe = function (downTask) {
    if (process.env.NODE_ENV !== 'production') {
      assert(downTask && !downTask._disposed && downTask !== this);
    } // If already downstream, do not dirty downTask.


    if (this._downstream !== downTask || this._dirty) {
      this._downstream = downTask;
      downTask._upstream = this;
      downTask.dirty();
    }
  };

  Task.prototype.dispose = function () {
    if (this._disposed) {
      return;
    }

    this._upstream && (this._upstream._downstream = null);
    this._downstream && (this._downstream._upstream = null);
    this._dirty = false;
    this._disposed = true;
  };

  Task.prototype.getUpstream = function () {
    return this._upstream;
  };

  Task.prototype.getDownstream = function () {
    return this._downstream;
  };

  Task.prototype.setOutputEnd = function (end) {
    // This only happend in dataTask, dataZoom, map, currently.
    // where dataZoom do not set end each time, but only set
    // when reset. So we should record the setted end, in case
    // that the stub of dataZoom perform again and earse the
    // setted end by upstream.
    this._outputDueEnd = this._settedOutputEnd = end;
  };

  return Task;
}();

var iterator = function () {
  var end;
  var current;
  var modBy;
  var modDataCount;
  var winCount;
  var it = {
    reset: function (s, e, sStep, sCount) {
      current = s;
      end = e;
      modBy = sStep;
      modDataCount = sCount;
      winCount = Math.ceil(modDataCount / modBy);
      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
    }
  };
  return it;

  function sequentialNext() {
    return current < end ? current++ : null;
  }

  function modNext() {
    var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
    var result = current >= end ? null : dataIndex < modDataCount ? dataIndex // If modDataCount is smaller than data.count() (consider `appendData` case),
    // Use normal linear rendering mode.
    : current;
    current++;
    return result;
  }
}(); ///////////////////////////////////////////////////////////
// For stream debug (Should be commented out after used!)
// @usage: printTask(this, 'begin');
// @usage: printTask(this, null, {someExtraProp});
// @usage: Use `__idxInPipeline` as conditional breakpiont.
//
// window.printTask = function (task: any, prefix: string, extra: { [key: string]: unknown }): void {
//     window.ecTaskUID == null && (window.ecTaskUID = 0);
//     task.uidDebug == null && (task.uidDebug = `task_${window.ecTaskUID++}`);
//     task.agent && task.agent.uidDebug == null && (task.agent.uidDebug = `task_${window.ecTaskUID++}`);
//     let props = [];
//     if (task.__pipeline) {
//         let val = `${task.__idxInPipeline}/${task.__pipeline.tail.__idxInPipeline} ${task.agent ? '(stub)' : ''}`;
//         props.push({text: '__idxInPipeline/total', value: val});
//     } else {
//         let stubCount = 0;
//         task.agentStubMap.each(() => stubCount++);
//         props.push({text: 'idx', value: `overall (stubs: ${stubCount})`});
//     }
//     props.push({text: 'uid', value: task.uidDebug});
//     if (task.__pipeline) {
//         props.push({text: 'pipelineId', value: task.__pipeline.id});
//         task.agent && props.push(
//             {text: 'stubFor', value: task.agent.uidDebug}
//         );
//     }
//     props.push(
//         {text: 'dirty', value: task._dirty},
//         {text: 'dueIndex', value: task._dueIndex},
//         {text: 'dueEnd', value: task._dueEnd},
//         {text: 'outputDueEnd', value: task._outputDueEnd}
//     );
//     if (extra) {
//         Object.keys(extra).forEach(key => {
//             props.push({text: key, value: extra[key]});
//         });
//     }
//     let args = ['color: blue'];
//     let msg = `%c[${prefix || 'T'}] %c` + props.map(item => (
//         args.push('color: green', 'color: red'),
//         `${item.text}: %c${item.value}`
//     )).join('%c, ');
//     console.log.apply(console, [msg].concat(args));
//     // console.log(this);
// };
// window.printPipeline = function (task: any, prefix: string) {
//     const pipeline = task.__pipeline;
//     let currTask = pipeline.head;
//     while (currTask) {
//         window.printTask(currTask, prefix);
//         currTask = currTask._downstream;
//     }
// };
// window.showChain = function (chainHeadTask) {
//     var chain = [];
//     var task = chainHeadTask;
//     while (task) {
//         chain.push({
//             task: task,
//             up: task._upstream,
//             down: task._downstream,
//             idxInPipeline: task.__idxInPipeline
//         });
//         task = task._downstream;
//     }
//     return chain;
// };
// window.findTaskInChain = function (task, chainHeadTask) {
//     let chain = window.showChain(chainHeadTask);
//     let result = [];
//     for (let i = 0; i < chain.length; i++) {
//         let chainItem = chain[i];
//         if (chainItem.task === task) {
//             result.push(i);
//         }
//     }
//     return result;
// };
// window.printChainAEachInChainB = function (chainHeadTaskA, chainHeadTaskB) {
//     let chainA = window.showChain(chainHeadTaskA);
//     for (let i = 0; i < chainA.length; i++) {
//         console.log('chainAIdx:', i, 'inChainB:', window.findTaskInChain(chainA[i].task, chainHeadTaskB));
//     }
// };

/**
 * Convert raw the value in to inner value in List.
 *
 * [Performance sensitive]
 *
 * [Caution]: this is the key logic of user value parser.
 * For backward compatibiliy, do not modify it until have to!
 */

function parseDataValue(value, // For high performance, do not omit the second param.
opt) {
  // Performance sensitive.
  var dimType = opt && opt.type;

  if (dimType === 'ordinal') {
    // If given value is a category string
    return value;
  }

  if (dimType === 'time' // spead up when using timestamp
  && !isNumber(value) && value != null && value !== '-') {
    value = +parseDate(value);
  } // dimType defaults 'number'.
  // If dimType is not ordinal and value is null or undefined or NaN or '-',
  // parse to NaN.
  // number-like string (like ' 123 ') can be converted to a number.
  // where null/undefined or other string will be converted to NaN.


  return value == null || value === '' ? NaN // If string (like '-'), using '+' parse to NaN
  // If object, also parse to NaN
  : +value;
}
createHashMap({
  'number': function (val) {
    // Do not use `numericToNumber` here. We have by defualt `numericToNumber`.
    // Here the number parser can have loose rule:
    // enable to cut suffix: "120px" => 120, "14%" => 14.
    return parseFloat(val);
  },
  'time': function (val) {
    // return timestamp.
    return +parseDate(val);
  },
  'trim': function (val) {
    return isString(val) ? trim(val) : val;
  }
});

var SortOrderComparator =
/** @class */
function () {
  /**
   * @param order by defualt: 'asc'
   * @param incomparable by defualt: Always on the tail.
   *        That is, if 'asc' => 'max', if 'desc' => 'min'
   *        See the definition of "incomparable" in [SORT_COMPARISON_RULE]
   */
  function SortOrderComparator(order, incomparable) {
    var isDesc = order === 'desc';
    this._resultLT = isDesc ? 1 : -1;

    if (incomparable == null) {
      incomparable = isDesc ? 'min' : 'max';
    }

    this._incomparable = incomparable === 'min' ? -Infinity : Infinity;
  } // See [SORT_COMPARISON_RULE].
  // Performance sensitive.


  SortOrderComparator.prototype.evaluate = function (lval, rval) {
    // Most cases is 'number', and typeof maybe 10 times faseter than parseFloat.
    var lvalFloat = isNumber(lval) ? lval : numericToNumber(lval);
    var rvalFloat = isNumber(rval) ? rval : numericToNumber(rval);
    var lvalNotNumeric = isNaN(lvalFloat);
    var rvalNotNumeric = isNaN(rvalFloat);

    if (lvalNotNumeric) {
      lvalFloat = this._incomparable;
    }

    if (rvalNotNumeric) {
      rvalFloat = this._incomparable;
    }

    if (lvalNotNumeric && rvalNotNumeric) {
      var lvalIsStr = isString(lval);
      var rvalIsStr = isString(rval);

      if (lvalIsStr) {
        lvalFloat = rvalIsStr ? lval : 0;
      }

      if (rvalIsStr) {
        rvalFloat = lvalIsStr ? rval : 0;
      }
    }

    return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
  };

  return SortOrderComparator;
}();

/**
 * TODO: disable writable.
 * This structure will be exposed to users.
 */

var ExternalSource =
/** @class */
function () {
  function ExternalSource() {}

  ExternalSource.prototype.getRawData = function () {
    // Only built-in transform available.
    throw new Error('not supported');
  };

  ExternalSource.prototype.getRawDataItem = function (dataIndex) {
    // Only built-in transform available.
    throw new Error('not supported');
  };

  ExternalSource.prototype.cloneRawData = function () {
    return;
  };
  /**
   * @return If dimension not found, return null/undefined.
   */


  ExternalSource.prototype.getDimensionInfo = function (dim) {
    return;
  };
  /**
   * dimensions defined if and only if either:
   * (a) dataset.dimensions are declared.
   * (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).
   * If dimensions are defined, `dimensionInfoAll` is corresponding to
   * the defined dimensions.
   * Otherwise, `dimensionInfoAll` is determined by data columns.
   * @return Always return an array (even empty array).
   */


  ExternalSource.prototype.cloneAllDimensionInfo = function () {
    return;
  };

  ExternalSource.prototype.count = function () {
    return;
  };
  /**
   * Only support by dimension index.
   * No need to support by dimension name in transform function,
   * becuase transform function is not case-specific, no need to use name literally.
   */


  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {
    return;
  };

  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {
    return;
  };

  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {
    return parseDataValue(rawVal, dimInfo);
  };

  return ExternalSource;
}();

function createExternalSource(internalSource, externalTransform) {
  var extSource = new ExternalSource();
  var data = internalSource.data;
  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
  var sourceHeaderCount = internalSource.startIndex;
  var errMsg = '';

  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
    // For the logic simplicity in transformer, only 'culumn' is
    // supported in data transform. Otherwise, the `dimensionsDefine`
    // might be detected by 'row', which probably confuses users.
    if (process.env.NODE_ENV !== 'production') {
      errMsg = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.';
    }

    throwError(errMsg);
  } // [MEMO]
  // Create a new dimensions structure for exposing.
  // Do not expose all dimension info to users directly.
  // Becuase the dimension is probably auto detected from data and not might reliable.
  // Should not lead the transformers to think that is relialbe and return it.
  // See [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.


  var dimensions = [];
  var dimsByName = {};
  var dimsDef = internalSource.dimensionsDefine;

  if (dimsDef) {
    each$9(dimsDef, function (dimDef, idx) {
      var name = dimDef.name;
      var dimDefExt = {
        index: idx,
        name: name,
        displayName: dimDef.displayName
      };
      dimensions.push(dimDefExt); // Users probably not sepcify dimension name. For simplicity, data transform
      // do not generate dimension name.

      if (name != null) {
        // Dimension name should not be duplicated.
        // For simplicity, data transform forbid name duplication, do not generate
        // new name like module `completeDimensions.ts` did, but just tell users.
        var errMsg_1 = '';

        if (hasOwn(dimsByName, name)) {
          if (process.env.NODE_ENV !== 'production') {
            errMsg_1 = 'dimension name "' + name + '" duplicated.';
          }

          throwError(errMsg_1);
        }

        dimsByName[name] = dimDefExt;
      }
    });
  } // If dimension definitions are not defined and can not be detected.
  // e.g., pure data `[[11, 22], ...]`.
  else {
      for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {
        // Do not generete name or anything others. The consequence process in
        // `transform` or `series` probably have there own name generation strategry.
        dimensions.push({
          index: i
        });
      }
    } // Implement public methods:


  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);

  if (externalTransform.__isBuiltIn) {
    extSource.getRawDataItem = function (dataIndex) {
      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    };

    extSource.getRawData = bind$1(getRawData, null, internalSource);
  }

  extSource.cloneRawData = bind$1(cloneRawData, null, internalSource);
  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  extSource.count = bind$1(rawCounter, null, data, sourceHeaderCount, dimensions);
  var rawValueGetter = getRawSourceValueGetter(sourceFormat);

  extSource.retrieveValue = function (dataIndex, dimIndex) {
    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    return retrieveValueFromItem(rawItem, dimIndex);
  };

  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {
    if (dataItem == null) {
      return;
    }

    var dimDef = dimensions[dimIndex]; // When `dimIndex` is `null`, `rawValueGetter` return the whole item.

    if (dimDef) {
      return rawValueGetter(dataItem, dimIndex, dimDef.name);
    }
  };

  extSource.getDimensionInfo = bind$1(getDimensionInfo, null, dimensions, dimsByName);
  extSource.cloneAllDimensionInfo = bind$1(cloneAllDimensionInfo, null, dimensions);
  return extSource;
}

function getRawData(upstream) {
  var sourceFormat = upstream.sourceFormat;

  if (!isSupportedSourceFormat(sourceFormat)) {
    var errMsg = '';

    if (process.env.NODE_ENV !== 'production') {
      errMsg = '`getRawData` is not supported in source format ' + sourceFormat;
    }

    throwError(errMsg);
  }

  return upstream.data;
}

function cloneRawData(upstream) {
  var sourceFormat = upstream.sourceFormat;
  var data = upstream.data;

  if (!isSupportedSourceFormat(sourceFormat)) {
    var errMsg = '';

    if (process.env.NODE_ENV !== 'production') {
      errMsg = '`cloneRawData` is not supported in source format ' + sourceFormat;
    }

    throwError(errMsg);
  }

  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var result = [];

    for (var i = 0, len = data.length; i < len; i++) {
      // Not strictly clone for performance
      result.push(data[i].slice());
    }

    return result;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    var result = [];

    for (var i = 0, len = data.length; i < len; i++) {
      // Not strictly clone for performance
      result.push(extend$2({}, data[i]));
    }

    return result;
  }
}

function getDimensionInfo(dimensions, dimsByName, dim) {
  if (dim == null) {
    return;
  } // Keep the same logic as `List::getDimension` did.


  if (isNumber(dim) // If being a number-like string but not being defined a dimension name.
  || !isNaN(dim) && !hasOwn(dimsByName, dim)) {
    return dimensions[dim];
  } else if (hasOwn(dimsByName, dim)) {
    return dimsByName[dim];
  }
}

function cloneAllDimensionInfo(dimensions) {
  return clone$3(dimensions);
}

var externalTransformMap = createHashMap();
function registerExternalTransform(externalTransform) {
  externalTransform = clone$3(externalTransform);
  var type = externalTransform.type;
  var errMsg = '';

  if (!type) {
    if (process.env.NODE_ENV !== 'production') {
      errMsg = 'Must have a `type` when `registerTransform`.';
    }

    throwError(errMsg);
  }

  var typeParsed = type.split(':');

  if (typeParsed.length !== 2) {
    if (process.env.NODE_ENV !== 'production') {
      errMsg = 'Name must include namespace like "ns:regression".';
    }

    throwError(errMsg);
  } // Namespace 'echarts:xxx' is official namespace, where the transforms should
  // be called directly via 'xxx' rather than 'echarts:xxx'.


  var isBuiltIn = false;

  if (typeParsed[0] === 'echarts') {
    type = typeParsed[1];
    isBuiltIn = true;
  }

  externalTransform.__isBuiltIn = isBuiltIn;
  externalTransformMap.set(type, externalTransform);
}
function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
  var pipedTransOption = normalizeToArray(rawTransOption);
  var pipeLen = pipedTransOption.length;
  var errMsg = '';

  if (!pipeLen) {
    if (process.env.NODE_ENV !== 'production') {
      errMsg = 'If `transform` declared, it should at least contain one transform.';
    }

    throwError(errMsg);
  }

  for (var i = 0, len = pipeLen; i < len; i++) {
    var transOption = pipedTransOption[i];
    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i); // piped transform only support single input, except the fist one.
    // piped transform only support single output, except the last one.

    if (i !== len - 1) {
      sourceList.length = Math.max(sourceList.length, 1);
    }
  }

  return sourceList;
}

function applySingleDataTransform(transOption, upSourceList, infoForPrint, // If `pipeIndex` is null/undefined, no piped transform.
pipeIndex) {
  var errMsg = '';

  if (!upSourceList.length) {
    if (process.env.NODE_ENV !== 'production') {
      errMsg = 'Must have at least one upstream dataset.';
    }

    throwError(errMsg);
  }

  if (!isObject$3(transOption)) {
    if (process.env.NODE_ENV !== 'production') {
      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';
    }

    throwError(errMsg);
  }

  var transType = transOption.type;
  var externalTransform = externalTransformMap.get(transType);

  if (!externalTransform) {
    if (process.env.NODE_ENV !== 'production') {
      errMsg = 'Can not find transform on type "' + transType + '".';
    }

    throwError(errMsg);
  } // Prepare source


  var extUpSourceList = map$1(upSourceList, function (upSource) {
    return createExternalSource(upSource, externalTransform);
  });
  var resultList = normalizeToArray(externalTransform.transform({
    upstream: extUpSourceList[0],
    upstreamList: extUpSourceList,
    config: clone$3(transOption.config)
  }));

  if (process.env.NODE_ENV !== 'production') {
    if (transOption.print) {
      var printStrArr = map$1(resultList, function (extSource) {
        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';
        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', makePrintable(extSource.data), '- transform result dimensions:', makePrintable(extSource.dimensions)].join('\n');
      }).join('\n');
      log(printStrArr);
    }
  }

  return map$1(resultList, function (result, resultIndex) {
    var errMsg = '';

    if (!isObject$3(result)) {
      if (process.env.NODE_ENV !== 'production') {
        errMsg = 'A transform should not return some empty results.';
      }

      throwError(errMsg);
    }

    if (!result.data) {
      if (process.env.NODE_ENV !== 'production') {
        errMsg = 'Transform result data should be not be null or undefined';
      }

      throwError(errMsg);
    }

    var sourceFormat = detectSourceFormat(result.data);

    if (!isSupportedSourceFormat(sourceFormat)) {
      if (process.env.NODE_ENV !== 'production') {
        errMsg = 'Transform result data should be array rows or object rows.';
      }

      throwError(errMsg);
    }

    var resultMetaRawOption;
    var firstUpSource = upSourceList[0];
    /**
     * Intuitively, the end users known the content of the original `dataset.source`,
     * calucating the transform result in mind.
     * Suppose the original `dataset.source` is:
     * ```js
     * [
     *     ['product', '2012', '2013', '2014', '2015'],
     *     ['AAA', 41.1, 30.4, 65.1, 53.3],
     *     ['BBB', 86.5, 92.1, 85.7, 83.1],
     *     ['CCC', 24.1, 67.2, 79.5, 86.4]
     * ]
     * ```
     * The dimension info have to be detected from the source data.
     * Some of the transformers (like filter, sort) will follow the dimension info
     * of upstream, while others use new dimensions (like aggregate).
     * Transformer can output a field `dimensions` to define the its own output dimensions.
     * We also allow transformers to ignore the output `dimensions` field, and
     * inherit the upstream dimensions definition. It can reduce the burden of handling
     * dimensions in transformers.
     *
     * See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.
     */

    if (firstUpSource && resultIndex === 0 // If transformer returns `dimensions`, it means that the transformer has different
    // dimensions definitions. We do not inherit anything from upstream.
    && !result.dimensions) {
      var startIndex = firstUpSource.startIndex; // We copy the header of upstream to the result becuase:
      // (1) The returned data always does not contain header line and can not be used
      // as dimension-detection. In this case we can not use "detected dimensions" of
      // upstream directly, because it might be detected based on different `seriesLayoutBy`.
      // (2) We should support that the series read the upstream source in `seriesLayoutBy: 'row'`.
      // So the original detected header should be add to the result, otherwise they can not be read.

      if (startIndex) {
        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
      }

      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: startIndex,
        dimensions: firstUpSource.metaRawOption.dimensions
      };
    } else {
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: 0,
        dimensions: result.dimensions
      };
    }

    return createSource(result.data, resultMetaRawOption, null);
  });
}

function isSupportedSourceFormat(sourceFormat) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
}

var UNDEFINED = 'undefined';
/* global Float64Array, Int32Array, Uint32Array, Uint16Array */
// Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is
// different from the Ctor of typed array.

var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
var CtorInt32Array$1 = typeof Int32Array === UNDEFINED ? Array : Int32Array;
var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
/**
 * Multi dimensional data store
 */

var dataCtors = {
  'float': CtorFloat64Array,
  'int': CtorInt32Array$1,
  // Ordinal data type can be string or int
  'ordinal': Array,
  'number': Array,
  'time': CtorFloat64Array
};
var defaultDimValueGetters;

function getIndicesCtor(rawCount) {
  // The possible max value in this._indicies is always this._rawCount despite of filtering.
  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
}

function getInitialExtent() {
  return [Infinity, -Infinity];
}

function cloneChunk(originalChunk) {
  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.

  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
}

function prepareStore(store, dimIdx, dimType, end, append) {
  var DataCtor = dataCtors[dimType || 'float'];

  if (append) {
    var oldStore = store[dimIdx];
    var oldLen = oldStore && oldStore.length;

    if (!(oldLen === end)) {
      var newStore = new DataCtor(end); // The cost of the copy is probably inconsiderable
      // within the initial chunkSize.

      for (var j = 0; j < oldLen; j++) {
        newStore[j] = oldStore[j];
      }

      store[dimIdx] = newStore;
    }
  } else {
    store[dimIdx] = new DataCtor(end);
  }
}
/**
 * Basically, DataStore API keep immutable.
 */

var DataStore =
/** @class */
function () {
  function DataStore() {
    this._chunks = []; // It will not be calculated util needed.

    this._rawExtent = [];
    this._extent = [];
    this._count = 0;
    this._rawCount = 0;
    this._calcDimNameToIdx = createHashMap();
  }
  /**
   * Initialize from data
   */


  DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {
    if (process.env.NODE_ENV !== 'production') {
      assert(isFunction(provider.getItem) && isFunction(provider.count), 'Invalid data provider.');
    }

    this._provider = provider; // Clear

    this._chunks = [];
    this._indices = null;
    this.getRawIndex = this._getRawIdxIdentity;
    var source = provider.getSource();
    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat]; // Default dim value getter

    this._dimValueGetter = dimValueGetter || defaultGetter; // Reset raw extent.

    this._rawExtent = [];
    var willRetrieveDataByName = shouldRetrieveDataByName(source);
    this._dimensions = map$1(inputDimensions, function (dim) {
      if (process.env.NODE_ENV !== 'production') {
        if (willRetrieveDataByName) {
          assert(dim.property != null);
        }
      }

      return {
        // Only pick these two props. Not leak other properties like orderMeta.
        type: dim.type,
        property: dim.property
      };
    });

    this._initDataFromProvider(0, provider.count());
  };

  DataStore.prototype.getProvider = function () {
    return this._provider;
  };
  /**
   * Caution: even when a `source` instance owned by a series, the created data store
   * may still be shared by different sereis (the source hash does not use all `source`
   * props, see `sourceManager`). In this case, the `source` props that are not used in
   * hash (like `source.dimensionDefine`) probably only belongs to a certain series and
   * thus should not be fetch here.
   */


  DataStore.prototype.getSource = function () {
    return this._provider.getSource();
  };
  /**
   * @caution Only used in dataStack.
   */


  DataStore.prototype.ensureCalculationDimension = function (dimName, type) {
    var calcDimNameToIdx = this._calcDimNameToIdx;
    var dimensions = this._dimensions;
    var calcDimIdx = calcDimNameToIdx.get(dimName);

    if (calcDimIdx != null) {
      if (dimensions[calcDimIdx].type === type) {
        return calcDimIdx;
      }
    } else {
      calcDimIdx = dimensions.length;
    }

    dimensions[calcDimIdx] = {
      type: type
    };
    calcDimNameToIdx.set(dimName, calcDimIdx);
    this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount);
    this._rawExtent[calcDimIdx] = getInitialExtent();
    return calcDimIdx;
  };

  DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {
    var chunk = this._chunks[dimIdx];
    var dim = this._dimensions[dimIdx];
    var rawExtents = this._rawExtent;
    var offset = dim.ordinalOffset || 0;
    var len = chunk.length;

    if (offset === 0) {
      // We need to reset the rawExtent if collect is from start.
      // Because this dimension may be guessed as number and calcuating a wrong extent.
      rawExtents[dimIdx] = getInitialExtent();
    }

    var dimRawExtent = rawExtents[dimIdx]; // Parse from previous data offset. len may be changed after appendData

    for (var i = offset; i < len; i++) {
      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);

      if (!isNaN(val)) {
        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);
        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);
      }
    }

    dim.ordinalMeta = ordinalMeta;
    dim.ordinalOffset = len;
    dim.type = 'ordinal'; // Force to be ordinal
  };

  DataStore.prototype.getOrdinalMeta = function (dimIdx) {
    var dimInfo = this._dimensions[dimIdx];
    var ordinalMeta = dimInfo.ordinalMeta;
    return ordinalMeta;
  };

  DataStore.prototype.getDimensionProperty = function (dimIndex) {
    var item = this._dimensions[dimIndex];
    return item && item.property;
  };
  /**
   * Caution: Can be only called on raw data (before `this._indices` created).
   */


  DataStore.prototype.appendData = function (data) {
    if (process.env.NODE_ENV !== 'production') {
      assert(!this._indices, 'appendData can only be called on raw data.');
    }

    var provider = this._provider;
    var start = this.count();
    provider.appendData(data);
    var end = provider.count();

    if (!provider.persistent) {
      end += start;
    }

    if (start < end) {
      this._initDataFromProvider(start, end, true);
    }

    return [start, end];
  };

  DataStore.prototype.appendValues = function (values, minFillLen) {
    var chunks = this._chunks;
    var dimensions = this._dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var start = this.count();
    var end = start + Math.max(values.length, minFillLen || 0);

    for (var i = 0; i < dimLen; i++) {
      var dim = dimensions[i];
      prepareStore(chunks, i, dim.type, end, true);
    }

    var emptyDataItem = [];

    for (var idx = start; idx < end; idx++) {
      var sourceIdx = idx - start; // Store the data by dimensions

      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
        var dim = dimensions[dimIdx];
        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
        chunks[dimIdx][idx] = val;
        var dimRawExtent = rawExtent[dimIdx];
        val < dimRawExtent[0] && (dimRawExtent[0] = val);
        val > dimRawExtent[1] && (dimRawExtent[1] = val);
      }
    }

    this._rawCount = this._count = end;
    return {
      start: start,
      end: end
    };
  };

  DataStore.prototype._initDataFromProvider = function (start, end, append) {
    var provider = this._provider;
    var chunks = this._chunks;
    var dimensions = this._dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var dimNames = map$1(dimensions, function (dim) {
      return dim.property;
    });

    for (var i = 0; i < dimLen; i++) {
      var dim = dimensions[i];

      if (!rawExtent[i]) {
        rawExtent[i] = getInitialExtent();
      }

      prepareStore(chunks, i, dim.type, end, append);
    }

    if (provider.fillStorage) {
      provider.fillStorage(start, end, chunks, rawExtent);
    } else {
      var dataItem = [];

      for (var idx = start; idx < end; idx++) {
        // NOTICE: Try not to write things into dataItem
        dataItem = provider.getItem(idx, dataItem); // Each data item is value
        // [1, 2]
        // 2
        // Bar chart, line chart which uses category axis
        // only gives the 'y' value. 'x' value is the indices of category
        // Use a tempValue to normalize the value to be a (x, y) value
        // Store the data by dimensions

        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
          var dimStorage = chunks[dimIdx]; // PENDING NULL is empty or zero

          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);

          dimStorage[idx] = val;
          var dimRawExtent = rawExtent[dimIdx];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }
      }
    }

    if (!provider.persistent && provider.clean) {
      // Clean unused data if data source is typed array.
      provider.clean();
    }

    this._rawCount = this._count = end; // Reset data extent

    this._extent = [];
  };

  DataStore.prototype.count = function () {
    return this._count;
  };
  /**
   * Get value. Return NaN if idx is out of range.
   */


  DataStore.prototype.get = function (dim, idx) {
    if (!(idx >= 0 && idx < this._count)) {
      return NaN;
    }

    var dimStore = this._chunks[dim];
    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
  };

  DataStore.prototype.getValues = function (dimensions, idx) {
    var values = [];
    var dimArr = [];

    if (idx == null) {
      idx = dimensions; // TODO get all from store?

      dimensions = []; // All dimensions

      for (var i = 0; i < this._dimensions.length; i++) {
        dimArr.push(i);
      }
    } else {
      dimArr = dimensions;
    }

    for (var i = 0, len = dimArr.length; i < len; i++) {
      values.push(this.get(dimArr[i], idx));
    }

    return values;
  };
  /**
   * @param dim concrete dim
   */


  DataStore.prototype.getByRawIndex = function (dim, rawIdx) {
    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
      return NaN;
    }

    var dimStore = this._chunks[dim];
    return dimStore ? dimStore[rawIdx] : NaN;
  };
  /**
   * Get sum of data in one dimension
   */


  DataStore.prototype.getSum = function (dim) {
    var dimData = this._chunks[dim];
    var sum = 0;

    if (dimData) {
      for (var i = 0, len = this.count(); i < len; i++) {
        var value = this.get(dim, i);

        if (!isNaN(value)) {
          sum += value;
        }
      }
    }

    return sum;
  };
  /**
   * Get median of data in one dimension
   */


  DataStore.prototype.getMedian = function (dim) {
    var dimDataArray = []; // map all data of one dimension

    this.each([dim], function (val) {
      if (!isNaN(val)) {
        dimDataArray.push(val);
      }
    }); // TODO
    // Use quick select?

    var sortedDimDataArray = dimDataArray.sort(function (a, b) {
      return a - b;
    });
    var len = this.count(); // calculate median

    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;
  };
  /**
   * Retreive the index with given raw data index
   */


  DataStore.prototype.indexOfRawIndex = function (rawIndex) {
    if (rawIndex >= this._rawCount || rawIndex < 0) {
      return -1;
    }

    if (!this._indices) {
      return rawIndex;
    } // Indices are ascending


    var indices = this._indices; // If rawIndex === dataIndex

    var rawDataIndex = indices[rawIndex];

    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
      return rawIndex;
    }

    var left = 0;
    var right = this._count - 1;

    while (left <= right) {
      var mid = (left + right) / 2 | 0;

      if (indices[mid] < rawIndex) {
        left = mid + 1;
      } else if (indices[mid] > rawIndex) {
        right = mid - 1;
      } else {
        return mid;
      }
    }

    return -1;
  };
  /**
   * Retreive the index of nearest value
   * @param dim
   * @param value
   * @param [maxDistance=Infinity]
   * @return If and only if multiple indices has
   *         the same value, they are put to the result.
   */


  DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {
    var chunks = this._chunks;
    var dimData = chunks[dim];
    var nearestIndices = [];

    if (!dimData) {
      return nearestIndices;
    }

    if (maxDistance == null) {
      maxDistance = Infinity;
    }

    var minDist = Infinity;
    var minDiff = -1;
    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/SeriesData.js`.

    for (var i = 0, len = this.count(); i < len; i++) {
      var dataIndex = this.getRawIndex(i);
      var diff = value - dimData[dataIndex];
      var dist = Math.abs(diff);

      if (dist <= maxDistance) {
        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,
        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to
        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).
        // So we chose the one that `diff >= 0` in this csae.
        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them
        // should be push to `nearestIndices`.
        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {
          minDist = dist;
          minDiff = diff;
          nearestIndicesLen = 0;
        }

        if (diff === minDiff) {
          nearestIndices[nearestIndicesLen++] = i;
        }
      }
    }

    nearestIndices.length = nearestIndicesLen;
    return nearestIndices;
  };

  DataStore.prototype.getIndices = function () {
    var newIndices;
    var indices = this._indices;

    if (indices) {
      var Ctor = indices.constructor;
      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.

      if (Ctor === Array) {
        newIndices = new Ctor(thisCount);

        for (var i = 0; i < thisCount; i++) {
          newIndices[i] = indices[i];
        }
      } else {
        newIndices = new Ctor(indices.buffer, 0, thisCount);
      }
    } else {
      var Ctor = getIndicesCtor(this._rawCount);
      newIndices = new Ctor(this.count());

      for (var i = 0; i < newIndices.length; i++) {
        newIndices[i] = i;
      }
    }

    return newIndices;
  };
  /**
   * Data filter.
   */


  DataStore.prototype.filter = function (dims, cb) {
    if (!this._count) {
      return this;
    }

    var newStore = this.clone();
    var count = newStore.count();
    var Ctor = getIndicesCtor(newStore._rawCount);
    var newIndices = new Ctor(count);
    var value = [];
    var dimSize = dims.length;
    var offset = 0;
    var dim0 = dims[0];
    var chunks = newStore._chunks;

    for (var i = 0; i < count; i++) {
      var keep = void 0;
      var rawIdx = newStore.getRawIndex(i); // Simple optimization

      if (dimSize === 0) {
        keep = cb(i);
      } else if (dimSize === 1) {
        var val = chunks[dim0][rawIdx];
        keep = cb(val, i);
      } else {
        var k = 0;

        for (; k < dimSize; k++) {
          value[k] = chunks[dims[k]][rawIdx];
        }

        value[k] = i;
        keep = cb.apply(null, value);
      }

      if (keep) {
        newIndices[offset++] = rawIdx;
      }
    } // Set indices after filtered.


    if (offset < count) {
      newStore._indices = newIndices;
    }

    newStore._count = offset; // Reset data extent

    newStore._extent = [];

    newStore._updateGetRawIdx();

    return newStore;
  };
  /**
   * Select data in range. (For optimization of filter)
   * (Manually inline code, support 5 million data filtering in data zoom.)
   */


  DataStore.prototype.selectRange = function (range) {
    var newStore = this.clone();
    var len = newStore._count;

    if (!len) {
      return this;
    }

    var dims = keys(range);
    var dimSize = dims.length;

    if (!dimSize) {
      return this;
    }

    var originalCount = newStore.count();
    var Ctor = getIndicesCtor(newStore._rawCount);
    var newIndices = new Ctor(originalCount);
    var offset = 0;
    var dim0 = dims[0];
    var min = range[dim0][0];
    var max = range[dim0][1];
    var storeArr = newStore._chunks;
    var quickFinished = false;

    if (!newStore._indices) {
      // Extreme optimization for common case. About 2x faster in chrome.
      var idx = 0;

      if (dimSize === 1) {
        var dimStorage = storeArr[dims[0]];

        for (var i = 0; i < len; i++) {
          var val = dimStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty
          // value indicates the line should be broken. But for the case like
          // scatter plot, a data item with empty value will not be rendered,
          // but the axis extent may be effected if some other dim of the data
          // item has value. Fortunately it is not a significant negative effect.

          if (val >= min && val <= max || isNaN(val)) {
            newIndices[offset++] = idx;
          }

          idx++;
        }

        quickFinished = true;
      } else if (dimSize === 2) {
        var dimStorage = storeArr[dims[0]];
        var dimStorage2 = storeArr[dims[1]];
        var min2 = range[dims[1]][0];
        var max2 = range[dims[1]][1];

        for (var i = 0; i < len; i++) {
          var val = dimStorage[i];
          var val2 = dimStorage2[i]; // Do not filter NaN, see comment above.

          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {
            newIndices[offset++] = idx;
          }

          idx++;
        }

        quickFinished = true;
      }
    }

    if (!quickFinished) {
      if (dimSize === 1) {
        for (var i = 0; i < originalCount; i++) {
          var rawIndex = newStore.getRawIndex(i);
          var val = storeArr[dims[0]][rawIndex]; // Do not filter NaN, see comment above.

          if (val >= min && val <= max || isNaN(val)) {
            newIndices[offset++] = rawIndex;
          }
        }
      } else {
        for (var i = 0; i < originalCount; i++) {
          var keep = true;
          var rawIndex = newStore.getRawIndex(i);

          for (var k = 0; k < dimSize; k++) {
            var dimk = dims[k];
            var val = storeArr[dimk][rawIndex]; // Do not filter NaN, see comment above.

            if (val < range[dimk][0] || val > range[dimk][1]) {
              keep = false;
            }
          }

          if (keep) {
            newIndices[offset++] = newStore.getRawIndex(i);
          }
        }
      }
    } // Set indices after filtered.


    if (offset < originalCount) {
      newStore._indices = newIndices;
    }

    newStore._count = offset; // Reset data extent

    newStore._extent = [];

    newStore._updateGetRawIdx();

    return newStore;
  }; // /**
  //  * Data mapping to a plain array
  //  */
  // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {
  //     const result: any[] = [];
  //     this.each(dims, function () {
  //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));
  //     });
  //     return result;
  // }

  /**
   * Data mapping to a new List with given dimensions
   */


  DataStore.prototype.map = function (dims, cb) {
    // TODO only clone picked chunks.
    var target = this.clone(dims);

    this._updateDims(target, dims, cb);

    return target;
  };
  /**
   * @caution Danger!! Only used in dataStack.
   */


  DataStore.prototype.modify = function (dims, cb) {
    this._updateDims(this, dims, cb);
  };

  DataStore.prototype._updateDims = function (target, dims, cb) {
    var targetChunks = target._chunks;
    var tmpRetValue = [];
    var dimSize = dims.length;
    var dataCount = target.count();
    var values = [];
    var rawExtent = target._rawExtent;

    for (var i = 0; i < dims.length; i++) {
      rawExtent[dims[i]] = getInitialExtent();
    }

    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
      var rawIndex = target.getRawIndex(dataIndex);

      for (var k = 0; k < dimSize; k++) {
        values[k] = targetChunks[dims[k]][rawIndex];
      }

      values[dimSize] = dataIndex;
      var retValue = cb && cb.apply(null, values);

      if (retValue != null) {
        // a number or string (in oridinal dimension)?
        if (typeof retValue !== 'object') {
          tmpRetValue[0] = retValue;
          retValue = tmpRetValue;
        }

        for (var i = 0; i < retValue.length; i++) {
          var dim = dims[i];
          var val = retValue[i];
          var rawExtentOnDim = rawExtent[dim];
          var dimStore = targetChunks[dim];

          if (dimStore) {
            dimStore[rawIndex] = val;
          }

          if (val < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = val;
          }

          if (val > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = val;
          }
        }
      }
    }
  };
  /**
   * Large data down sampling using largest-triangle-three-buckets
   * @param {string} valueDimension
   * @param {number} targetCount
   */


  DataStore.prototype.lttbDownSample = function (valueDimension, rate) {
    var target = this.clone([valueDimension], true);
    var targetStorage = target._chunks;
    var dimStore = targetStorage[valueDimension];
    var len = this.count();
    var sampledIndex = 0;
    var frameSize = Math.floor(1 / rate);
    var currentRawIndex = this.getRawIndex(0);
    var maxArea;
    var area;
    var nextRawIndex;
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len / frameSize) + 2) * 2, len)); // First frame use the first data.

    newIndices[sampledIndex++] = currentRawIndex;

    for (var i = 1; i < len - 1; i += frameSize) {
      var nextFrameStart = Math.min(i + frameSize, len - 1);
      var nextFrameEnd = Math.min(i + frameSize * 2, len);
      var avgX = (nextFrameEnd + nextFrameStart) / 2;
      var avgY = 0;

      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {
        var rawIndex = this.getRawIndex(idx);
        var y = dimStore[rawIndex];

        if (isNaN(y)) {
          continue;
        }

        avgY += y;
      }

      avgY /= nextFrameEnd - nextFrameStart;
      var frameStart = i;
      var frameEnd = Math.min(i + frameSize, len);
      var pointAX = i - 1;
      var pointAY = dimStore[currentRawIndex];
      maxArea = -1;
      nextRawIndex = frameStart;
      var firstNaNIndex = -1;
      var countNaN = 0; // Find a point from current frame that construct a triangel with largest area with previous selected point
      // And the average of next frame.

      for (var idx = frameStart; idx < frameEnd; idx++) {
        var rawIndex = this.getRawIndex(idx);
        var y = dimStore[rawIndex];

        if (isNaN(y)) {
          countNaN++;

          if (firstNaNIndex < 0) {
            firstNaNIndex = rawIndex;
          }

          continue;
        } // Calculate triangle area over three buckets


        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));

        if (area > maxArea) {
          maxArea = area;
          nextRawIndex = rawIndex; // Next a is this b
        }
      }

      if (countNaN > 0 && countNaN < frameEnd - frameStart) {
        // Append first NaN point in every bucket.
        // It is necessary to ensure the correct order of indices.
        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);
        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);
      }

      newIndices[sampledIndex++] = nextRawIndex;
      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)
    } // First frame use the last data.


    newIndices[sampledIndex++] = this.getRawIndex(len - 1);
    target._count = sampledIndex;
    target._indices = newIndices;
    target.getRawIndex = this._getRawIdx;
    return target;
  };
  /**
   * Large data down sampling on given dimension
   * @param sampleIndex Sample index for name and id
   */


  DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {
    var target = this.clone([dimension], true);
    var targetStorage = target._chunks;
    var frameValues = [];
    var frameSize = Math.floor(1 / rate);
    var dimStore = targetStorage[dimension];
    var len = this.count();
    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));
    var offset = 0;

    for (var i = 0; i < len; i += frameSize) {
      // Last frame
      if (frameSize > len - i) {
        frameSize = len - i;
        frameValues.length = frameSize;
      }

      for (var k = 0; k < frameSize; k++) {
        var dataIdx = this.getRawIndex(i + k);
        frameValues[k] = dimStore[dataIdx];
      }

      var value = sampleValue(frameValues);
      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)); // Only write value on the filtered data

      dimStore[sampleFrameIdx] = value;

      if (value < rawExtentOnDim[0]) {
        rawExtentOnDim[0] = value;
      }

      if (value > rawExtentOnDim[1]) {
        rawExtentOnDim[1] = value;
      }

      newIndices[offset++] = sampleFrameIdx;
    }

    target._count = offset;
    target._indices = newIndices;

    target._updateGetRawIdx();

    return target;
  };
  /**
   * Data iteration
   * @param ctx default this
   * @example
   *  list.each('x', function (x, idx) {});
   *  list.each(['x', 'y'], function (x, y, idx) {});
   *  list.each(function (idx) {})
   */


  DataStore.prototype.each = function (dims, cb) {
    if (!this._count) {
      return;
    }

    var dimSize = dims.length;
    var chunks = this._chunks;

    for (var i = 0, len = this.count(); i < len; i++) {
      var rawIdx = this.getRawIndex(i); // Simple optimization

      switch (dimSize) {
        case 0:
          cb(i);
          break;

        case 1:
          cb(chunks[dims[0]][rawIdx], i);
          break;

        case 2:
          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);
          break;

        default:
          var k = 0;
          var value = [];

          for (; k < dimSize; k++) {
            value[k] = chunks[dims[k]][rawIdx];
          } // Index


          value[k] = i;
          cb.apply(null, value);
      }
    }
  };
  /**
   * Get extent of data in one dimension
   */


  DataStore.prototype.getDataExtent = function (dim) {
    // Make sure use concrete dim as cache name.
    var dimData = this._chunks[dim];
    var initialExtent = getInitialExtent();

    if (!dimData) {
      return initialExtent;
    } // Make more strict checkings to ensure hitting cache.


    var currEnd = this.count(); // Consider the most cases when using data zoom, `getDataExtent`
    // happened before filtering. We cache raw extent, which is not
    // necessary to be cleared and recalculated when restore data.

    var useRaw = !this._indices;
    var dimExtent;

    if (useRaw) {
      return this._rawExtent[dim].slice();
    }

    dimExtent = this._extent[dim];

    if (dimExtent) {
      return dimExtent.slice();
    }

    dimExtent = initialExtent;
    var min = dimExtent[0];
    var max = dimExtent[1];

    for (var i = 0; i < currEnd; i++) {
      var rawIdx = this.getRawIndex(i);
      var value = dimData[rawIdx];
      value < min && (min = value);
      value > max && (max = value);
    }

    dimExtent = [min, max];
    this._extent[dim] = dimExtent;
    return dimExtent;
  };
  /**
   * Get raw data item
   */


  DataStore.prototype.getRawDataItem = function (idx) {
    var rawIdx = this.getRawIndex(idx);

    if (!this._provider.persistent) {
      var val = [];
      var chunks = this._chunks;

      for (var i = 0; i < chunks.length; i++) {
        val.push(chunks[i][rawIdx]);
      }

      return val;
    } else {
      return this._provider.getItem(rawIdx);
    }
  };
  /**
   * Clone shallow.
   *
   * @param clonedDims Determine which dims to clone. Will share the data if not specified.
   */


  DataStore.prototype.clone = function (clonedDims, ignoreIndices) {
    var target = new DataStore();
    var chunks = this._chunks;
    var clonedDimsMap = clonedDims && reduce(clonedDims, function (obj, dimIdx) {
      obj[dimIdx] = true;
      return obj;
    }, {});

    if (clonedDimsMap) {
      for (var i = 0; i < chunks.length; i++) {
        // Not clone if dim is not picked.
        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);
      }
    } else {
      target._chunks = chunks;
    }

    this._copyCommonProps(target);

    if (!ignoreIndices) {
      target._indices = this._cloneIndices();
    }

    target._updateGetRawIdx();

    return target;
  };

  DataStore.prototype._copyCommonProps = function (target) {
    target._count = this._count;
    target._rawCount = this._rawCount;
    target._provider = this._provider;
    target._dimensions = this._dimensions;
    target._extent = clone$3(this._extent);
    target._rawExtent = clone$3(this._rawExtent);
  };

  DataStore.prototype._cloneIndices = function () {
    if (this._indices) {
      var Ctor = this._indices.constructor;
      var indices = void 0;

      if (Ctor === Array) {
        var thisCount = this._indices.length;
        indices = new Ctor(thisCount);

        for (var i = 0; i < thisCount; i++) {
          indices[i] = this._indices[i];
        }
      } else {
        indices = new Ctor(this._indices);
      }

      return indices;
    }

    return null;
  };

  DataStore.prototype._getRawIdxIdentity = function (idx) {
    return idx;
  };

  DataStore.prototype._getRawIdx = function (idx) {
    if (idx < this._count && idx >= 0) {
      return this._indices[idx];
    }

    return -1;
  };

  DataStore.prototype._updateGetRawIdx = function () {
    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
  };

  DataStore.internalField = function () {
    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {
      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
    }

    defaultDimValueGetters = {
      arrayRows: getDimValueSimply,
      objectRows: function (dataItem, property, dataIndex, dimIndex) {
        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);
      },
      keyedColumns: getDimValueSimply,
      original: function (dataItem, property, dataIndex, dimIndex) {
        // Performance sensitive, do not use modelUtil.getDataItemValue.
        // If dataItem is an plain object with no value field, the let `value`
        // will be assigned with the object, but it will be tread correctly
        // in the `convertValue`.
        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
        return parseDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.
        : value, this._dimensions[dimIndex]);
      },
      typedArray: function (dataItem, property, dataIndex, dimIndex) {
        return dataItem[dimIndex];
      }
    };
  }();

  return DataStore;
}();

var DataStore$1 = DataStore;

/**
 * [REQUIREMENT_MEMO]:
 * (0) `metaRawOption` means `dimensions`/`sourceHeader`/`seriesLayoutBy` in raw option.
 * (1) Keep support the feature: `metaRawOption` can be specified both on `series` and
 * `root-dataset`. Them on `series` has higher priority.
 * (2) Do not support to set `metaRawOption` on a `non-root-dataset`, because it might
 * confuse users: whether those props indicate how to visit the upstream source or visit
 * the transform result source, and some transforms has nothing to do with these props,
 * and some transforms might have multiple upstream.
 * (3) Transforms should specify `metaRawOption` in each output, just like they can be
 * declared in `root-dataset`.
 * (4) At present only support visit source in `SERIES_LAYOUT_BY_COLUMN` in transforms.
 * That is for reducing complexity in transfroms.
 * PENDING: Whether to provide transposition transform?
 *
 * [IMPLEMENTAION_MEMO]:
 * "sourceVisitConfig" are calculated from `metaRawOption` and `data`.
 * They will not be calculated until `source` is about to be visited (to prevent from
 * duplicate calcuation). `source` is visited only in series and input to transforms.
 *
 * [DIMENSION_INHERIT_RULE]:
 * By default the dimensions are inherited from ancestors, unless a transform return
 * a new dimensions definition.
 * Consider the case:
 * ```js
 * dataset: [{
 *     source: [ ['Product', 'Sales', 'Prise'], ['Cookies', 321, 44.21], ...]
 * }, {
 *     transform: { type: 'filter', ... }
 * }]
 * dataset: [{
 *     dimension: ['Product', 'Sales', 'Prise'],
 *     source: [ ['Cookies', 321, 44.21], ...]
 * }, {
 *     transform: { type: 'filter', ... }
 * }]
 * ```
 * The two types of option should have the same behavior after transform.
 *
 *
 * [SCENARIO]:
 * (1) Provide source data directly:
 * ```js
 * series: {
 *     encode: {...},
 *     dimensions: [...]
 *     seriesLayoutBy: 'row',
 *     data: [[...]]
 * }
 * ```
 * (2) Series refer to dataset.
 * ```js
 * series: [{
 *     encode: {...}
 *     // Ignore datasetIndex means `datasetIndex: 0`
 *     // and the dimensions defination in dataset is used
 * }, {
 *     encode: {...},
 *     seriesLayoutBy: 'column',
 *     datasetIndex: 1
 * }]
 * ```
 * (3) dataset transform
 * ```js
 * dataset: [{
 *     source: [...]
 * }, {
 *     source: [...]
 * }, {
 *     // By default from 0.
 *     transform: { type: 'filter', config: {...} }
 * }, {
 *     // Piped.
 *     transform: [
 *         { type: 'filter', config: {...} },
 *         { type: 'sort', config: {...} }
 *     ]
 * }, {
 *     id: 'regressionData',
 *     fromDatasetIndex: 1,
 *     // Third-party transform
 *     transform: { type: 'ecStat:regression', config: {...} }
 * }, {
 *     // retrieve the extra result.
 *     id: 'regressionFormula',
 *     fromDatasetId: 'regressionData',
 *     fromTransformResult: 1
 * }]
 * ```
 */

var SourceManager =
/** @class */
function () {
  function SourceManager(sourceHost) {
    // Cached source. Do not repeat calculating if not dirty.
    this._sourceList = [];
    this._storeList = []; // version sign of each upstream source manager.

    this._upstreamSignList = [];
    this._versionSignBase = 0;
    this._dirty = true;
    this._sourceHost = sourceHost;
  }
  /**
   * Mark dirty.
   */


  SourceManager.prototype.dirty = function () {
    this._setLocalSource([], []);

    this._storeList = [];
    this._dirty = true;
  };

  SourceManager.prototype._setLocalSource = function (sourceList, upstreamSignList) {
    this._sourceList = sourceList;
    this._upstreamSignList = upstreamSignList;
    this._versionSignBase++;

    if (this._versionSignBase > 9e10) {
      this._versionSignBase = 0;
    }
  };
  /**
   * For detecting whether the upstream source is dirty, so that
   * the local cached source (in `_sourceList`) should be discarded.
   */


  SourceManager.prototype._getVersionSign = function () {
    return this._sourceHost.uid + '_' + this._versionSignBase;
  };
  /**
   * Always return a source instance. Otherwise throw error.
   */


  SourceManager.prototype.prepareSource = function () {
    // For the case that call `setOption` multiple time but no data changed,
    // cache the result source to prevent from repeating transform.
    if (this._isDirty()) {
      this._createSource();

      this._dirty = false;
    }
  };

  SourceManager.prototype._createSource = function () {
    this._setLocalSource([], []);

    var sourceHost = this._sourceHost;

    var upSourceMgrList = this._getUpstreamSourceManagers();

    var hasUpstream = !!upSourceMgrList.length;
    var resultSourceList;
    var upstreamSignList;

    if (isSeries(sourceHost)) {
      var seriesModel = sourceHost;
      var data = void 0;
      var sourceFormat = void 0;
      var upSource = void 0; // Has upstream dataset

      if (hasUpstream) {
        var upSourceMgr = upSourceMgrList[0];
        upSourceMgr.prepareSource();
        upSource = upSourceMgr.getSource();
        data = upSource.data;
        sourceFormat = upSource.sourceFormat;
        upstreamSignList = [upSourceMgr._getVersionSign()];
      } // Series data is from own.
      else {
          data = seriesModel.get('data', true);
          sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
          upstreamSignList = [];
        } // See [REQUIREMENT_MEMO], merge settings on series and parent dataset if it is root.


      var newMetaRawOption = this._getSourceMetaRawOption() || {};
      var upMetaRawOption = upSource && upSource.metaRawOption || {};
      var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
      var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader); // Note here we should not use `upSource.dimensionsDefine`. Consider the case:
      // `upSource.dimensionsDefine` is detected by `seriesLayoutBy: 'column'`,
      // but series need `seriesLayoutBy: 'row'`.

      var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions); // We share source with dataset as much as possible
      // to avoid extra memroy cost of high dimensional data.

      var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;
      resultSourceList = needsCreateSource ? [createSource(data, {
        seriesLayoutBy: seriesLayoutBy,
        sourceHeader: sourceHeader,
        dimensions: dimensions
      }, sourceFormat)] : [];
    } else {
      var datasetModel = sourceHost; // Has upstream dataset.

      if (hasUpstream) {
        var result = this._applyTransform(upSourceMgrList);

        resultSourceList = result.sourceList;
        upstreamSignList = result.upstreamSignList;
      } // Is root dataset.
      else {
          var sourceData = datasetModel.get('source', true);
          resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];
          upstreamSignList = [];
        }
    }

    if (process.env.NODE_ENV !== 'production') {
      assert(resultSourceList && upstreamSignList);
    }

    this._setLocalSource(resultSourceList, upstreamSignList);
  };

  SourceManager.prototype._applyTransform = function (upMgrList) {
    var datasetModel = this._sourceHost;
    var transformOption = datasetModel.get('transform', true);
    var fromTransformResult = datasetModel.get('fromTransformResult', true);

    if (process.env.NODE_ENV !== 'production') {
      assert(fromTransformResult != null || transformOption != null);
    }

    if (fromTransformResult != null) {
      var errMsg = '';

      if (upMgrList.length !== 1) {
        if (process.env.NODE_ENV !== 'production') {
          errMsg = 'When using `fromTransformResult`, there should be only one upstream dataset';
        }

        doThrow(errMsg);
      }
    }

    var sourceList;
    var upSourceList = [];
    var upstreamSignList = [];
    each$9(upMgrList, function (upMgr) {
      upMgr.prepareSource();
      var upSource = upMgr.getSource(fromTransformResult || 0);
      var errMsg = '';

      if (fromTransformResult != null && !upSource) {
        if (process.env.NODE_ENV !== 'production') {
          errMsg = 'Can not retrieve result by `fromTransformResult`: ' + fromTransformResult;
        }

        doThrow(errMsg);
      }

      upSourceList.push(upSource);
      upstreamSignList.push(upMgr._getVersionSign());
    });

    if (transformOption) {
      sourceList = applyDataTransform(transformOption, upSourceList, {
        datasetIndex: datasetModel.componentIndex
      });
    } else if (fromTransformResult != null) {
      sourceList = [cloneSourceShallow(upSourceList[0])];
    }

    return {
      sourceList: sourceList,
      upstreamSignList: upstreamSignList
    };
  };

  SourceManager.prototype._isDirty = function () {
    if (this._dirty) {
      return true;
    } // All sourceList is from the some upsteam.


    var upSourceMgrList = this._getUpstreamSourceManagers();

    for (var i = 0; i < upSourceMgrList.length; i++) {
      var upSrcMgr = upSourceMgrList[i];

      if ( // Consider the case that there is ancestor diry, call it recursively.
      // The performance is probably not an issue because usually the chain is not long.
      upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {
        return true;
      }
    }
  };
  /**
   * @param sourceIndex By defualt 0, means "main source".
   *                    Most cases there is only one source.
   */


  SourceManager.prototype.getSource = function (sourceIndex) {
    sourceIndex = sourceIndex || 0;
    var source = this._sourceList[sourceIndex];

    if (!source) {
      // Series may share source instance with dataset.
      var upSourceMgrList = this._getUpstreamSourceManagers();

      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
    }

    return source;
  };
  /**
   *
   * Get a data store which can be shared across series.
   * Only available for series.
   *
   * @param seriesDimRequest Dimensions that are generated in series.
   *        Should have been sorted by `storeDimIndex` asc.
   */


  SourceManager.prototype.getSharedDataStore = function (seriesDimRequest) {
    if (process.env.NODE_ENV !== 'production') {
      assert(isSeries(this._sourceHost), 'Can only call getDataStore on series source manager.');
    }

    var schema = seriesDimRequest.makeStoreSchema();
    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
  };

  SourceManager.prototype._innerGetDataStore = function (storeDims, seriesSource, sourceReadKey) {
    // TODO Can use other sourceIndex?
    var sourceIndex = 0;
    var storeList = this._storeList;
    var cachedStoreMap = storeList[sourceIndex];

    if (!cachedStoreMap) {
      cachedStoreMap = storeList[sourceIndex] = {};
    }

    var cachedStore = cachedStoreMap[sourceReadKey];

    if (!cachedStore) {
      var upSourceMgr = this._getUpstreamSourceManagers()[0];

      if (isSeries(this._sourceHost) && upSourceMgr) {
        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
      } else {
        cachedStore = new DataStore$1(); // Always create store from source of series.

        cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
      }

      cachedStoreMap[sourceReadKey] = cachedStore;
    }

    return cachedStore;
  };
  /**
   * PEDING: Is it fast enough?
   * If no upstream, return empty array.
   */


  SourceManager.prototype._getUpstreamSourceManagers = function () {
    // Always get the relationship from the raw option.
    // Do not cache the link of the dependency graph, so that
    // no need to update them when change happen.
    var sourceHost = this._sourceHost;

    if (isSeries(sourceHost)) {
      var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
      return !datasetModel ? [] : [datasetModel.getSourceManager()];
    } else {
      return map$1(queryDatasetUpstreamDatasetModels(sourceHost), function (datasetModel) {
        return datasetModel.getSourceManager();
      });
    }
  };

  SourceManager.prototype._getSourceMetaRawOption = function () {
    var sourceHost = this._sourceHost;
    var seriesLayoutBy;
    var sourceHeader;
    var dimensions;

    if (isSeries(sourceHost)) {
      seriesLayoutBy = sourceHost.get('seriesLayoutBy', true);
      sourceHeader = sourceHost.get('sourceHeader', true);
      dimensions = sourceHost.get('dimensions', true);
    } // See [REQUIREMENT_MEMO], `non-root-dataset` do not support them.
    else if (!this._getUpstreamSourceManagers().length) {
        var model = sourceHost;
        seriesLayoutBy = model.get('seriesLayoutBy', true);
        sourceHeader = model.get('sourceHeader', true);
        dimensions = model.get('dimensions', true);
      }

    return {
      seriesLayoutBy: seriesLayoutBy,
      sourceHeader: sourceHeader,
      dimensions: dimensions
    };
  };

  return SourceManager;
}();
// disable the transform merge, but do not disable transfrom clone from rawOption.

function disableTransformOptionMerge(datasetModel) {
  var transformOption = datasetModel.option.transform;
  transformOption && setAsPrimitive(datasetModel.option.transform);
}

function isSeries(sourceHost) {
  // Avoid circular dependency with Series.ts
  return sourceHost.mainType === 'series';
}

function doThrow(errMsg) {
  throw new Error(errMsg);
}

var TOOLTIP_LINE_HEIGHT_CSS = 'line-height:1'; // TODO: more textStyle option

function getTooltipTextStyle(textStyle, renderMode) {
  var nameFontColor = textStyle.color || '#6e7079';
  var nameFontSize = textStyle.fontSize || 12;
  var nameFontWeight = textStyle.fontWeight || '400';
  var valueFontColor = textStyle.color || '#464646';
  var valueFontSize = textStyle.fontSize || 14;
  var valueFontWeight = textStyle.fontWeight || '900';

  if (renderMode === 'html') {
    // `textStyle` is probably from user input, should be encoded to reduce security risk.
    return {
      // eslint-disable-next-line max-len
      nameStyle: "font-size:" + encodeHTML(nameFontSize + '') + "px;color:" + encodeHTML(nameFontColor) + ";font-weight:" + encodeHTML(nameFontWeight + ''),
      // eslint-disable-next-line max-len
      valueStyle: "font-size:" + encodeHTML(valueFontSize + '') + "px;color:" + encodeHTML(valueFontColor) + ";font-weight:" + encodeHTML(valueFontWeight + '')
    };
  } else {
    return {
      nameStyle: {
        fontSize: nameFontSize,
        fill: nameFontColor,
        fontWeight: nameFontWeight
      },
      valueStyle: {
        fontSize: valueFontSize,
        fill: valueFontColor,
        fontWeight: valueFontWeight
      }
    };
  }
} // See `TooltipMarkupLayoutIntent['innerGapLevel']`.
// (value from UI design)


var HTML_GAPS = [0, 10, 20, 30];
var RICH_TEXT_GAPS = ['', '\n', '\n\n', '\n\n\n']; // eslint-disable-next-line max-len

function createTooltipMarkup(type, option) {
  option.type = type;
  return option;
}

function isSectionFragment(frag) {
  return frag.type === 'section';
}

function getBuilder(frag) {
  return isSectionFragment(frag) ? buildSection : buildNameValue;
}

function getBlockGapLevel(frag) {
  if (isSectionFragment(frag)) {
    var gapLevel_1 = 0;
    var subBlockLen = frag.blocks.length;
    var hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
    each$9(frag.blocks, function (subBlock) {
      var subGapLevel = getBlockGapLevel(subBlock); // If the some of the sub-blocks have some gaps (like 10px) inside, this block
      // should use a larger gap (like 20px) to distinguish those sub-blocks.

      if (subGapLevel >= gapLevel_1) {
        gapLevel_1 = subGapLevel + +(hasInnerGap_1 && ( // 0 always can not be readable gap level.
        !subGapLevel // If no header, always keep the sub gap level. Otherwise
        // look weird in case `multipleSeries`.
        || isSectionFragment(subBlock) && !subBlock.noHeader));
      }
    });
    return gapLevel_1;
  }

  return 0;
}

function buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  var noHeader = fragment.noHeader;
  var gaps = getGap(getBlockGapLevel(fragment));
  var subMarkupTextList = [];
  var subBlocks = fragment.blocks || [];
  assert(!subBlocks || isArray$1(subBlocks));
  subBlocks = subBlocks || [];
  var orderMode = ctx.orderMode;

  if (fragment.sortBlocks && orderMode) {
    subBlocks = subBlocks.slice();
    var orderMap = {
      valueAsc: 'asc',
      valueDesc: 'desc'
    };

    if (hasOwn(orderMap, orderMode)) {
      var comparator_1 = new SortOrderComparator(orderMap[orderMode], null);
      subBlocks.sort(function (a, b) {
        return comparator_1.evaluate(a.sortParam, b.sortParam);
      });
    } // FIXME 'seriesDesc' necessary?
    else if (orderMode === 'seriesDesc') {
        subBlocks.reverse();
      }
  }

  each$9(subBlocks, function (subBlock, idx) {
    var valueFormatter = fragment.valueFormatter;
    var subMarkupText = getBuilder(subBlock)( // Inherit valueFormatter
    valueFormatter ? extend$2(extend$2({}, ctx), {
      valueFormatter: valueFormatter
    }) : ctx, subBlock, idx > 0 ? gaps.html : 0, toolTipTextStyle);
    subMarkupText != null && subMarkupTextList.push(subMarkupText);
  });
  var subMarkupText = ctx.renderMode === 'richText' ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(subMarkupTextList.join(''), noHeader ? topMarginForOuterGap : gaps.html);

  if (noHeader) {
    return subMarkupText;
  }

  var displayableHeader = makeValueReadable(fragment.header, 'ordinal', ctx.useUTC);
  var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;

  if (ctx.renderMode === 'richText') {
    return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
  } else {
    return wrapBlockHTML("<div style=\"" + nameStyle + ";" + TOOLTIP_LINE_HEIGHT_CSS + ";\">" + encodeHTML(displayableHeader) + '</div>' + subMarkupText, topMarginForOuterGap);
  }
}

function buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  var renderMode = ctx.renderMode;
  var noName = fragment.noName;
  var noValue = fragment.noValue;
  var noMarker = !fragment.markerType;
  var name = fragment.name;
  var useUTC = ctx.useUTC;

  var valueFormatter = fragment.valueFormatter || ctx.valueFormatter || function (value) {
    value = isArray$1(value) ? value : [value];
    return map$1(value, function (val, idx) {
      return makeValueReadable(val, isArray$1(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);
    });
  };

  if (noName && noValue) {
    return;
  }

  var markerStr = noMarker ? '' : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || '#333', renderMode);
  var readableName = noName ? '' : makeValueReadable(name, 'ordinal', useUTC);
  var valueTypeOption = fragment.valueType;
  var readableValueList = noValue ? [] : valueFormatter(fragment.value);
  var valueAlignRight = !noMarker || !noName; // It little weird if only value next to marker but far from marker.

  var valueCloseToMarker = !noMarker && noName;

  var _a = getTooltipTextStyle(toolTipTextStyle, renderMode),
      nameStyle = _a.nameStyle,
      valueStyle = _a.valueStyle;

  return renderMode === 'richText' ? (noMarker ? '' : markerStr) + (noName ? '' : wrapInlineNameRichText(ctx, readableName, nameStyle)) // Value has commas inside, so use ' ' as delimiter for multiple values.
  + (noValue ? '' : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML((noMarker ? '' : markerStr) + (noName ? '' : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? '' : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
}
/**
 * @return markupText. null/undefined means no content.
 */


function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
  if (!fragment) {
    return;
  }

  var builder = getBuilder(fragment);
  var ctx = {
    useUTC: useUTC,
    renderMode: renderMode,
    orderMode: orderMode,
    markupStyleCreator: markupStyleCreator,
    valueFormatter: fragment.valueFormatter
  };
  return builder(ctx, fragment, 0, toolTipTextStyle);
}

function getGap(gapLevel) {
  return {
    html: HTML_GAPS[gapLevel],
    richText: RICH_TEXT_GAPS[gapLevel]
  };
}

function wrapBlockHTML(encodedContent, topGap) {
  var clearfix = '<div style="clear:both"></div>';
  var marginCSS = "margin: " + topGap + "px 0 0";
  return "<div style=\"" + marginCSS + ";" + TOOLTIP_LINE_HEIGHT_CSS + ";\">" + encodedContent + clearfix + '</div>';
}

function wrapInlineNameHTML(name, leftHasMarker, style) {
  var marginCss = leftHasMarker ? 'margin-left:2px' : '';
  return "<span style=\"" + style + ";" + marginCss + "\">" + encodeHTML(name) + '</span>';
}

function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
  // Do not too close to marker, considering there are multiple values separated by spaces.
  var paddingStr = valueCloseToMarker ? '10px' : '20px';
  var alignCSS = alignRight ? "float:right;margin-left:" + paddingStr : '';
  valueList = isArray$1(valueList) ? valueList : [valueList];
  return "<span style=\"" + alignCSS + ";" + style + "\">" // Value has commas inside, so use '  ' as delimiter for multiple values.
  + map$1(valueList, function (value) {
    return encodeHTML(value);
  }).join('&nbsp;&nbsp;') + '</span>';
}

function wrapInlineNameRichText(ctx, name, style) {
  return ctx.markupStyleCreator.wrapRichTextStyle(name, style);
}

function wrapInlineValueRichText(ctx, values, alignRight, valueCloseToMarker, style) {
  var styles = [style];
  var paddingLeft = valueCloseToMarker ? 10 : 20;
  alignRight && styles.push({
    padding: [0, 0, 0, paddingLeft],
    align: 'right'
  }); // Value has commas inside, so use '  ' as delimiter for multiple values.

  return ctx.markupStyleCreator.wrapRichTextStyle(isArray$1(values) ? values.join('  ') : values, styles);
}

function retrieveVisualColorForTooltipMarker(series, dataIndex) {
  var style = series.getData().getItemVisual(dataIndex, 'style');
  var color = style[series.visualDrawType];
  return convertToColorString(color);
}
function getPaddingFromTooltipModel(model, renderMode) {
  var padding = model.get('padding');
  return padding != null ? padding // We give slightly different to look pretty.
  : renderMode === 'richText' ? [8, 10] : 10;
}
/**
 * The major feature is generate styles for `renderMode: 'richText'`.
 * But it also serves `renderMode: 'html'` to provide
 * "renderMode-independent" API.
 */

var TooltipMarkupStyleCreator =
/** @class */
function () {
  function TooltipMarkupStyleCreator() {
    this.richTextStyles = {}; // Notice that "generate a style name" usuall happens repeatly when mouse moving and
    // displaying a tooltip. So we put the `_nextStyleNameId` as a member of each creator
    // rather than static shared by all creators (which will cause it increase to fast).

    this._nextStyleNameId = getRandomIdBase();
  }

  TooltipMarkupStyleCreator.prototype._generateStyleName = function () {
    return '__EC_aUTo_' + this._nextStyleNameId++;
  };

  TooltipMarkupStyleCreator.prototype.makeTooltipMarker = function (markerType, colorStr, renderMode) {
    var markerId = renderMode === 'richText' ? this._generateStyleName() : null;
    var marker = getTooltipMarker({
      color: colorStr,
      type: markerType,
      renderMode: renderMode,
      markerId: markerId
    });

    if (isString(marker)) {
      return marker;
    } else {
      if (process.env.NODE_ENV !== 'production') {
        assert(markerId);
      }

      this.richTextStyles[markerId] = marker.style;
      return marker.content;
    }
  };
  /**
   * @usage
   * ```ts
   * const styledText = markupStyleCreator.wrapRichTextStyle([
   *     // The styles will be auto merged.
   *     {
   *         fontSize: 12,
   *         color: 'blue'
   *     },
   *     {
   *         padding: 20
   *     }
   * ]);
   * ```
   */


  TooltipMarkupStyleCreator.prototype.wrapRichTextStyle = function (text, styles) {
    var finalStl = {};

    if (isArray$1(styles)) {
      each$9(styles, function (stl) {
        return extend$2(finalStl, stl);
      });
    } else {
      extend$2(finalStl, styles);
    }

    var styleName = this._generateStyleName();

    this.richTextStyles[styleName] = finalStl;
    return "{" + styleName + "|" + text + "}";
  };

  return TooltipMarkupStyleCreator;
}();

function defaultSeriesFormatTooltip(opt) {
  var series = opt.series;
  var dataIndex = opt.dataIndex;
  var multipleSeries = opt.multipleSeries;
  var data = series.getData();
  var tooltipDims = data.mapDimensionsAll('defaultedTooltip');
  var tooltipDimLen = tooltipDims.length;
  var value = series.getRawValue(dataIndex);
  var isValueArr = isArray$1(value);
  var markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex); // Complicated rule for pretty tooltip.

  var inlineValue;
  var inlineValueType;
  var subBlocks;
  var sortParam;

  if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
    var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
    inlineValue = formatArrResult.inlineValues;
    inlineValueType = formatArrResult.inlineValueTypes;
    subBlocks = formatArrResult.blocks; // Only support tooltip sort by the first inline value. It's enough in most cases.

    sortParam = formatArrResult.inlineValues[0];
  } else if (tooltipDimLen) {
    var dimInfo = data.getDimensionInfo(tooltipDims[0]);
    sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);
    inlineValueType = dimInfo.type;
  } else {
    sortParam = inlineValue = isValueArr ? value[0] : value;
  } // Do not show generated series name. It might not be readable.


  var seriesNameSpecified = isNameSpecified(series);
  var seriesName = seriesNameSpecified && series.name || '';
  var itemName = data.getName(dataIndex);
  var inlineName = multipleSeries ? seriesName : itemName;
  return createTooltipMarkup('section', {
    header: seriesName,
    // When series name not specified, do not show a header line with only '-'.
    // This case alway happen in tooltip.trigger: 'item'.
    noHeader: multipleSeries || !seriesNameSpecified,
    sortParam: sortParam,
    blocks: [createTooltipMarkup('nameValue', {
      markerType: 'item',
      markerColor: markerColor,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: inlineName,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !trim(inlineName),
      value: inlineValue,
      valueType: inlineValueType
    })].concat(subBlocks || [])
  });
}

function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
  // check: category-no-encode-has-axis-data in dataset.html
  var data = series.getData();
  var isValueMultipleLine = reduce(value, function (isValueMultipleLine, val, idx) {
    var dimItem = data.getDimensionInfo(idx);
    return isValueMultipleLine = isValueMultipleLine || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
  }, false);
  var inlineValues = [];
  var inlineValueTypes = [];
  var blocks = [];
  tooltipDims.length ? each$9(tooltipDims, function (dim) {
    setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
  }) // By default, all dims is used on tooltip.
  : each$9(value, setEachItem);

  function setEachItem(val, dim) {
    var dimInfo = data.getDimensionInfo(dim); // If `dimInfo.tooltip` is not set, show tooltip.

    if (!dimInfo || dimInfo.otherDims.tooltip === false) {
      return;
    }

    if (isValueMultipleLine) {
      blocks.push(createTooltipMarkup('nameValue', {
        markerType: 'subItem',
        markerColor: colorStr,
        name: dimInfo.displayName,
        value: val,
        valueType: dimInfo.type
      }));
    } else {
      inlineValues.push(val);
      inlineValueTypes.push(dimInfo.type);
    }
  }

  return {
    inlineValues: inlineValues,
    inlineValueTypes: inlineValueTypes,
    blocks: blocks
  };
}

var inner$8 = makeInner();

function getSelectionKey(data, dataIndex) {
  return data.getName(dataIndex) || data.getId(dataIndex);
}

var SERIES_UNIVERSAL_TRANSITION_PROP = '__universalTransitionEnabled';

var SeriesModel =
/** @class */
function (_super) {
  __extends$1(SeriesModel, _super);

  function SeriesModel() {
    // [Caution]: Becuase this class or desecendants can be used as `XXX.extend(subProto)`,
    // the class members must not be initialized in constructor or declaration place.
    // Otherwise there is bad case:
    //   class A {xxx = 1;}
    //   enableClassExtend(A);
    //   class B extends A {}
    //   var C = B.extend({xxx: 5});
    //   var c = new C();
    //   console.log(c.xxx); // expect 5 but always 1.
    var _this = _super !== null && _super.apply(this, arguments) || this; // ---------------------------------------
    // Props about data selection
    // ---------------------------------------


    _this._selectedDataIndicesMap = {};
    return _this;
  }

  SeriesModel.prototype.init = function (option, parentModel, ecModel) {
    this.seriesIndex = this.componentIndex;
    this.dataTask = createTask({
      count: dataTaskCount,
      reset: dataTaskReset
    });
    this.dataTask.context = {
      model: this
    };
    this.mergeDefaultAndTheme(option, ecModel);
    var sourceManager = inner$8(this).sourceManager = new SourceManager(this);
    sourceManager.prepareSource();
    var data = this.getInitialData(option, ecModel);
    wrapData(data, this);
    this.dataTask.context.data = data;

    if (process.env.NODE_ENV !== 'production') {
      assert(data, 'getInitialData returned invalid data.');
    }

    inner$8(this).dataBeforeProcessed = data; // If we reverse the order (make data firstly, and then make
    // dataBeforeProcessed by cloneShallow), cloneShallow will
    // cause data.graph.data !== data when using
    // module:echarts/data/Graph or module:echarts/data/Tree.
    // See module:echarts/data/helper/linkSeriesData
    // Theoretically, it is unreasonable to call `seriesModel.getData()` in the model
    // init or merge stage, because the data can be restored. So we do not `restoreData`
    // and `setData` here, which forbids calling `seriesModel.getData()` in this stage.
    // Call `seriesModel.getRawData()` instead.
    // this.restoreData();

    autoSeriesName(this);

    this._initSelectedMapFromData(data);
  };
  /**
   * Util for merge default and theme to option
   */


  SeriesModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {
    var layoutMode = fetchLayoutMode(this);
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {}; // Backward compat: using subType on theme.
    // But if name duplicate between series subType
    // (for example: parallel) add component mainType,
    // add suffix 'Series'.

    var themeSubType = this.subType;

    if (ComponentModel$1.hasClass(themeSubType)) {
      themeSubType += 'Series';
    }

    merge$1(option, ecModel.getTheme().get(this.subType));
    merge$1(option, this.getDefaultOption()); // Default label emphasis `show`

    defaultEmphasis(option, 'label', ['show']);
    this.fillDataTextStyle(option.data);

    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  };

  SeriesModel.prototype.mergeOption = function (newSeriesOption, ecModel) {
    // this.settingTask.dirty();
    newSeriesOption = merge$1(this.option, newSeriesOption, true);
    this.fillDataTextStyle(newSeriesOption.data);
    var layoutMode = fetchLayoutMode(this);

    if (layoutMode) {
      mergeLayoutParam(this.option, newSeriesOption, layoutMode);
    }

    var sourceManager = inner$8(this).sourceManager;
    sourceManager.dirty();
    sourceManager.prepareSource();
    var data = this.getInitialData(newSeriesOption, ecModel);
    wrapData(data, this);
    this.dataTask.dirty();
    this.dataTask.context.data = data;
    inner$8(this).dataBeforeProcessed = data;
    autoSeriesName(this);

    this._initSelectedMapFromData(data);
  };

  SeriesModel.prototype.fillDataTextStyle = function (data) {
    // Default data label emphasis `show`
    // FIXME Tree structure data ?
    // FIXME Performance ?
    if (data && !isTypedArray(data)) {
      var props = ['show'];

      for (var i = 0; i < data.length; i++) {
        if (data[i] && data[i].label) {
          defaultEmphasis(data[i], 'label', props);
        }
      }
    }
  };
  /**
   * Init a data structure from data related option in series
   * Must be overriden.
   */


  SeriesModel.prototype.getInitialData = function (option, ecModel) {
    return;
  };
  /**
   * Append data to list
   */


  SeriesModel.prototype.appendData = function (params) {
    // FIXME ???
    // (1) If data from dataset, forbidden append.
    // (2) support append data of dataset.
    var data = this.getRawData();
    data.appendData(params.data);
  };
  /**
   * Consider some method like `filter`, `map` need make new data,
   * We should make sure that `seriesModel.getData()` get correct
   * data in the stream procedure. So we fetch data from upstream
   * each time `task.perform` called.
   */


  SeriesModel.prototype.getData = function (dataType) {
    var task = getCurrentTask(this);

    if (task) {
      var data = task.context.data;
      return dataType == null ? data : data.getLinkedData(dataType);
    } else {
      // When series is not alive (that may happen when click toolbox
      // restore or setOption with not merge mode), series data may
      // be still need to judge animation or something when graphic
      // elements want to know whether fade out.
      return inner$8(this).data;
    }
  };

  SeriesModel.prototype.getAllData = function () {
    var mainData = this.getData();
    return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{
      data: mainData
    }];
  };

  SeriesModel.prototype.setData = function (data) {
    var task = getCurrentTask(this);

    if (task) {
      var context = task.context; // Consider case: filter, data sample.
      // FIXME:TS never used, so comment it
      // if (context.data !== data && task.modifyOutputEnd) {
      //     task.setOutputEnd(data.count());
      // }

      context.outputData = data; // Caution: setData should update context.data,
      // Because getData may be called multiply in a
      // single stage and expect to get the data just
      // set. (For example, AxisProxy, x y both call
      // getData and setDate sequentially).
      // So the context.data should be fetched from
      // upstream each time when a stage starts to be
      // performed.

      if (task !== this.dataTask) {
        context.data = data;
      }
    }

    inner$8(this).data = data;
  };

  SeriesModel.prototype.getEncode = function () {
    var encode = this.get('encode', true);

    if (encode) {
      return createHashMap(encode);
    }
  };

  SeriesModel.prototype.getSourceManager = function () {
    return inner$8(this).sourceManager;
  };

  SeriesModel.prototype.getSource = function () {
    return this.getSourceManager().getSource();
  };
  /**
   * Get data before processed
   */


  SeriesModel.prototype.getRawData = function () {
    return inner$8(this).dataBeforeProcessed;
  };

  SeriesModel.prototype.getColorBy = function () {
    var colorBy = this.get('colorBy');
    return colorBy || 'series';
  };

  SeriesModel.prototype.isColorBySeries = function () {
    return this.getColorBy() === 'series';
  };
  /**
   * Get base axis if has coordinate system and has axis.
   * By default use coordSys.getBaseAxis();
   * Can be overrided for some chart.
   * @return {type} description
   */


  SeriesModel.prototype.getBaseAxis = function () {
    var coordSys = this.coordinateSystem; // @ts-ignore

    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
  };
  /**
   * Default tooltip formatter
   *
   * @param dataIndex
   * @param multipleSeries
   * @param dataType
   * @param renderMode valid values: 'html'(by default) and 'richText'.
   *        'html' is used for rendering tooltip in extra DOM form, and the result
   *        string is used as DOM HTML content.
   *        'richText' is used for rendering tooltip in rich text form, for those where
   *        DOM operation is not supported.
   * @return formatted tooltip with `html` and `markers`
   *        Notice: The override method can also return string
   */


  SeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
    return defaultSeriesFormatTooltip({
      series: this,
      dataIndex: dataIndex,
      multipleSeries: multipleSeries
    });
  };

  SeriesModel.prototype.isAnimationEnabled = function () {
    var ecModel = this.ecModel; // Disable animation if using echarts in node but not give ssr flag.
    // In ssr mode, renderToString will generate svg with css animation.

    if (env$1.node && !(ecModel && ecModel.ssr)) {
      return false;
    }

    var animationEnabled = this.getShallow('animation');

    if (animationEnabled) {
      if (this.getData().count() > this.getShallow('animationThreshold')) {
        animationEnabled = false;
      }
    }

    return !!animationEnabled;
  };

  SeriesModel.prototype.restoreData = function () {
    this.dataTask.dirty();
  };

  SeriesModel.prototype.getColorFromPalette = function (name, scope, requestColorNum) {
    var ecModel = this.ecModel; // PENDING

    var color = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);

    if (!color) {
      color = ecModel.getColorFromPalette(name, scope, requestColorNum);
    }

    return color;
  };
  /**
   * Use `data.mapDimensionsAll(coordDim)` instead.
   * @deprecated
   */


  SeriesModel.prototype.coordDimToDataDim = function (coordDim) {
    return this.getRawData().mapDimensionsAll(coordDim);
  };
  /**
   * Get progressive rendering count each step
   */


  SeriesModel.prototype.getProgressive = function () {
    return this.get('progressive');
  };
  /**
   * Get progressive rendering count each step
   */


  SeriesModel.prototype.getProgressiveThreshold = function () {
    return this.get('progressiveThreshold');
  }; // PENGING If selectedMode is null ?


  SeriesModel.prototype.select = function (innerDataIndices, dataType) {
    this._innerSelect(this.getData(dataType), innerDataIndices);
  };

  SeriesModel.prototype.unselect = function (innerDataIndices, dataType) {
    var selectedMap = this.option.selectedMap;

    if (!selectedMap) {
      return;
    }

    var selectedMode = this.option.selectedMode;
    var data = this.getData(dataType);

    if (selectedMode === 'series' || selectedMap === 'all') {
      this.option.selectedMap = {};
      this._selectedDataIndicesMap = {};
      return;
    }

    for (var i = 0; i < innerDataIndices.length; i++) {
      var dataIndex = innerDataIndices[i];
      var nameOrId = getSelectionKey(data, dataIndex);
      selectedMap[nameOrId] = false;
      this._selectedDataIndicesMap[nameOrId] = -1;
    }
  };

  SeriesModel.prototype.toggleSelect = function (innerDataIndices, dataType) {
    var tmpArr = [];

    for (var i = 0; i < innerDataIndices.length; i++) {
      tmpArr[0] = innerDataIndices[i];
      this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr, dataType) : this.select(tmpArr, dataType);
    }
  };

  SeriesModel.prototype.getSelectedDataIndices = function () {
    if (this.option.selectedMap === 'all') {
      return [].slice.call(this.getData().getIndices());
    }

    var selectedDataIndicesMap = this._selectedDataIndicesMap;
    var nameOrIds = keys(selectedDataIndicesMap);
    var dataIndices = [];

    for (var i = 0; i < nameOrIds.length; i++) {
      var dataIndex = selectedDataIndicesMap[nameOrIds[i]];

      if (dataIndex >= 0) {
        dataIndices.push(dataIndex);
      }
    }

    return dataIndices;
  };

  SeriesModel.prototype.isSelected = function (dataIndex, dataType) {
    var selectedMap = this.option.selectedMap;

    if (!selectedMap) {
      return false;
    }

    var data = this.getData(dataType);
    return (selectedMap === 'all' || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(['select', 'disabled']);
  };

  SeriesModel.prototype.isUniversalTransitionEnabled = function () {
    if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {
      return true;
    }

    var universalTransitionOpt = this.option.universalTransition; // Quick reject

    if (!universalTransitionOpt) {
      return false;
    }

    if (universalTransitionOpt === true) {
      return true;
    } // Can be simply 'universalTransition: true'


    return universalTransitionOpt && universalTransitionOpt.enabled;
  };

  SeriesModel.prototype._innerSelect = function (data, innerDataIndices) {
    var _a, _b;

    var option = this.option;
    var selectedMode = option.selectedMode;
    var len = innerDataIndices.length;

    if (!selectedMode || !len) {
      return;
    }

    if (selectedMode === 'series') {
      option.selectedMap = 'all';
    } else if (selectedMode === 'multiple') {
      if (!isObject$3(option.selectedMap)) {
        option.selectedMap = {};
      }

      var selectedMap = option.selectedMap;

      for (var i = 0; i < len; i++) {
        var dataIndex = innerDataIndices[i]; // TODO diffrent types of data share same object.

        var nameOrId = getSelectionKey(data, dataIndex);
        selectedMap[nameOrId] = true;
        this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
      }
    } else if (selectedMode === 'single' || selectedMode === true) {
      var lastDataIndex = innerDataIndices[len - 1];
      var nameOrId = getSelectionKey(data, lastDataIndex);
      option.selectedMap = (_a = {}, _a[nameOrId] = true, _a);
      this._selectedDataIndicesMap = (_b = {}, _b[nameOrId] = data.getRawIndex(lastDataIndex), _b);
    }
  };

  SeriesModel.prototype._initSelectedMapFromData = function (data) {
    // Ignore select info in data if selectedMap exists.
    // NOTE It's only for legacy usage. edge data is not supported.
    if (this.option.selectedMap) {
      return;
    }

    var dataIndices = [];

    if (data.hasItemOption) {
      data.each(function (idx) {
        var rawItem = data.getRawDataItem(idx);

        if (rawItem && rawItem.selected) {
          dataIndices.push(idx);
        }
      });
    }

    if (dataIndices.length > 0) {
      this._innerSelect(data, dataIndices);
    }
  }; // /**
  //  * @see {module:echarts/stream/Scheduler}
  //  */
  // abstract pipeTask: null


  SeriesModel.registerClass = function (clz) {
    return ComponentModel$1.registerClass(clz);
  };

  SeriesModel.protoInitialize = function () {
    var proto = SeriesModel.prototype;
    proto.type = 'series.__base__';
    proto.seriesIndex = 0;
    proto.ignoreStyleOnData = false;
    proto.hasSymbolVisual = false;
    proto.defaultSymbol = 'circle'; // Make sure the values can be accessed!

    proto.visualStyleAccessPath = 'itemStyle';
    proto.visualDrawType = 'fill';
  }();

  return SeriesModel;
}(ComponentModel$1);

mixin(SeriesModel, DataFormatMixin);
mixin(SeriesModel, PaletteMixin);
mountExtend(SeriesModel, ComponentModel$1);
/**
 * MUST be called after `prepareSource` called
 * Here we need to make auto series, especially for auto legend. But we
 * do not modify series.name in option to avoid side effects.
 */

function autoSeriesName(seriesModel) {
  // User specified name has higher priority, otherwise it may cause
  // series can not be queried unexpectedly.
  var name = seriesModel.name;

  if (!isNameSpecified(seriesModel)) {
    seriesModel.name = getSeriesAutoName(seriesModel) || name;
  }
}

function getSeriesAutoName(seriesModel) {
  var data = seriesModel.getRawData();
  var dataDims = data.mapDimensionsAll('seriesName');
  var nameArr = [];
  each$9(dataDims, function (dataDim) {
    var dimInfo = data.getDimensionInfo(dataDim);
    dimInfo.displayName && nameArr.push(dimInfo.displayName);
  });
  return nameArr.join(' ');
}

function dataTaskCount(context) {
  return context.model.getRawData().count();
}

function dataTaskReset(context) {
  var seriesModel = context.model;
  seriesModel.setData(seriesModel.getRawData().cloneShallow());
  return dataTaskProgress;
}

function dataTaskProgress(param, context) {
  // Avoid repead cloneShallow when data just created in reset.
  if (context.outputData && param.end > context.outputData.count()) {
    context.model.getRawData().cloneShallow(context.outputData);
  }
} // TODO refactor


function wrapData(data, seriesModel) {
  each$9(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function (methodName) {
    data.wrapMethod(methodName, curry$1(onDataChange, seriesModel));
  });
}

function onDataChange(seriesModel, newList) {
  var task = getCurrentTask(seriesModel);

  if (task) {
    // Consider case: filter, selectRange
    task.setOutputEnd((newList || this).count());
  }

  return newList;
}

function getCurrentTask(seriesModel) {
  var scheduler = (seriesModel.ecModel || {}).scheduler;
  var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);

  if (pipeline) {
    // When pipline finished, the currrentTask keep the last
    // task (renderTask).
    var task = pipeline.currentTask;

    if (task) {
      var agentStubMap = task.agentStubMap;

      if (agentStubMap) {
        task = agentStubMap.get(seriesModel.uid);
      }
    }

    return task;
  }
}

var SeriesModel$1 = SeriesModel;

var ComponentView =
/** @class */
function () {
  function ComponentView() {
    this.group = new Group$3();
    this.uid = getUID('viewComponent');
  }

  ComponentView.prototype.init = function (ecModel, api) {};

  ComponentView.prototype.render = function (model, ecModel, api, payload) {};

  ComponentView.prototype.dispose = function (ecModel, api) {};

  ComponentView.prototype.updateView = function (model, ecModel, api, payload) {// Do nothing;
  };

  ComponentView.prototype.updateLayout = function (model, ecModel, api, payload) {// Do nothing;
  };

  ComponentView.prototype.updateVisual = function (model, ecModel, api, payload) {// Do nothing;
  };
  /**
   * Hook for toggle blur target series.
   * Can be used in marker for blur or leave blur the markers
   */


  ComponentView.prototype.toggleBlurSeries = function (seriesModels, isBlur, ecModel) {// Do nothing;
  };
  /**
   * Traverse the new rendered elements.
   *
   * It will traverse the new added element in progressive rendering.
   * And traverse all in normal rendering.
   */


  ComponentView.prototype.eachRendered = function (cb) {
    var group = this.group;

    if (group) {
      group.traverse(cb);
    }
  };

  return ComponentView;
}();
enableClassExtend(ComponentView);
enableClassManagement(ComponentView);
var ComponentView$1 = ComponentView;

/**
 * @return {string} If large mode changed, return string 'reset';
 */

function createRenderPlanner() {
  var inner = makeInner();
  return function (seriesModel) {
    var fields = inner(seriesModel);
    var pipelineContext = seriesModel.pipelineContext;
    var originalLarge = !!fields.large;
    var originalProgressive = !!fields.progressiveRender; // FIXME: if the planner works on a filtered series, `pipelineContext` does not
    // exists. See #11611 . Probably we need to modify this structure, see the comment
    // on `performRawSeries` in `Schedular.js`.

    var large = fields.large = !!(pipelineContext && pipelineContext.large);
    var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
    return !!(originalLarge !== large || originalProgressive !== progressive) && 'reset';
  };
}

var inner$7 = makeInner();
var renderPlanner = createRenderPlanner();

var ChartView =
/** @class */
function () {
  function ChartView() {
    this.group = new Group$3();
    this.uid = getUID('viewChart');
    this.renderTask = createTask({
      plan: renderTaskPlan,
      reset: renderTaskReset
    });
    this.renderTask.context = {
      view: this
    };
  }

  ChartView.prototype.init = function (ecModel, api) {};

  ChartView.prototype.render = function (seriesModel, ecModel, api, payload) {
    if (process.env.NODE_ENV !== 'production') {
      throw new Error('render method must been implemented');
    }
  };
  /**
   * Highlight series or specified data item.
   */


  ChartView.prototype.highlight = function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData(payload && payload.dataType);

    if (!data) {
      if (process.env.NODE_ENV !== 'production') {
        error("Unknown dataType " + payload.dataType);
      }

      return;
    }

    toggleHighlight(data, payload, 'emphasis');
  };
  /**
   * Downplay series or specified data item.
   */


  ChartView.prototype.downplay = function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData(payload && payload.dataType);

    if (!data) {
      if (process.env.NODE_ENV !== 'production') {
        error("Unknown dataType " + payload.dataType);
      }

      return;
    }

    toggleHighlight(data, payload, 'normal');
  };
  /**
   * Remove self.
   */


  ChartView.prototype.remove = function (ecModel, api) {
    this.group.removeAll();
  };
  /**
   * Dispose self.
   */


  ChartView.prototype.dispose = function (ecModel, api) {};

  ChartView.prototype.updateView = function (seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  }; // FIXME never used?


  ChartView.prototype.updateLayout = function (seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  }; // FIXME never used?


  ChartView.prototype.updateVisual = function (seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  /**
   * Traverse the new rendered elements.
   *
   * It will traverse the new added element in progressive rendering.
   * And traverse all in normal rendering.
   */


  ChartView.prototype.eachRendered = function (cb) {
    traverseElements(this.group, cb);
  };

  ChartView.markUpdateMethod = function (payload, methodName) {
    inner$7(payload).updateMethod = methodName;
  };

  ChartView.protoInitialize = function () {
    var proto = ChartView.prototype;
    proto.type = 'chart';
  }();

  return ChartView;
}();
/**
 * Set state of single element
 */

function elSetState(el, state, highlightDigit) {
  if (el && isHighDownDispatcher(el)) {
    (state === 'emphasis' ? enterEmphasis : leaveEmphasis)(el, highlightDigit);
  }
}

function toggleHighlight(data, payload, state) {
  var dataIndex = queryDataIndex(data, payload);
  var highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;

  if (dataIndex != null) {
    each$9(normalizeToArray(dataIndex), function (dataIdx) {
      elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
    });
  } else {
    data.eachItemGraphicEl(function (el) {
      elSetState(el, state, highlightDigit);
    });
  }
}

enableClassExtend(ChartView, ['dispose']);
enableClassManagement(ChartView);

function renderTaskPlan(context) {
  return renderPlanner(context.model);
}

function renderTaskReset(context) {
  var seriesModel = context.model;
  var ecModel = context.ecModel;
  var api = context.api;
  var payload = context.payload; // FIXME: remove updateView updateVisual

  var progressiveRender = seriesModel.pipelineContext.progressiveRender;
  var view = context.view;
  var updateMethod = payload && inner$7(payload).updateMethod;
  var methodName = progressiveRender ? 'incrementalPrepareRender' : updateMethod && view[updateMethod] ? updateMethod // `appendData` is also supported when data amount
  // is less than progressive threshold.
  : 'render';

  if (methodName !== 'render') {
    view[methodName](seriesModel, ecModel, api, payload);
  }

  return progressMethodMap[methodName];
}

var progressMethodMap = {
  incrementalPrepareRender: {
    progress: function (params, context) {
      context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: true,
    progress: function (params, context) {
      context.view.render(context.model, context.ecModel, context.api, context.payload);
    }
  }
};
var ChartView$1 = ChartView;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var ORIGIN_METHOD = '\0__throttleOriginMethod';
var RATE = '\0__throttleRate';
var THROTTLE_TYPE = '\0__throttleType';
/**
 * @public
 * @param {(Function)} fn
 * @param {number} [delay=0] Unit: ms.
 * @param {boolean} [debounce=false]
 *        true: If call interval less than `delay`, only the last call works.
 *        false: If call interval less than `delay, call works on fixed rate.
 * @return {(Function)} throttled fn.
 */

function throttle(fn, delay, debounce) {
  var currCall;
  var lastCall = 0;
  var lastExec = 0;
  var timer = null;
  var diff;
  var scope;
  var args;
  var debounceNextCall;
  delay = delay || 0;

  function exec() {
    lastExec = new Date().getTime();
    timer = null;
    fn.apply(scope, args || []);
  }

  var cb = function () {
    var cbArgs = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      cbArgs[_i] = arguments[_i];
    }

    currCall = new Date().getTime();
    scope = this;
    args = cbArgs;
    var thisDelay = debounceNextCall || delay;
    var thisDebounce = debounceNextCall || debounce;
    debounceNextCall = null;
    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
    clearTimeout(timer); // Here we should make sure that: the `exec` SHOULD NOT be called later
    // than a new call of `cb`, that is, preserving the command order. Consider
    // calculating "scale rate" when roaming as an example. When a call of `cb`
    // happens, either the `exec` is called dierectly, or the call is delayed.
    // But the delayed call should never be later than next call of `cb`. Under
    // this assurance, we can simply update view state each time `dispatchAction`
    // triggered by user roaming, but not need to add extra code to avoid the
    // state being "rolled-back".

    if (thisDebounce) {
      timer = setTimeout(exec, thisDelay);
    } else {
      if (diff >= 0) {
        exec();
      } else {
        timer = setTimeout(exec, -diff);
      }
    }

    lastCall = currCall;
  };
  /**
   * Clear throttle.
   * @public
   */


  cb.clear = function () {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  /**
   * Enable debounce once.
   */


  cb.debounceNextCall = function (debounceDelay) {
    debounceNextCall = debounceDelay;
  };

  return cb;
}
/**
 * Create throttle method or update throttle rate.
 *
 * @example
 * ComponentView.prototype.render = function () {
 *     ...
 *     throttle.createOrUpdate(
 *         this,
 *         '_dispatchAction',
 *         this.model.get('throttle'),
 *         'fixRate'
 *     );
 * };
 * ComponentView.prototype.remove = function () {
 *     throttle.clear(this, '_dispatchAction');
 * };
 * ComponentView.prototype.dispose = function () {
 *     throttle.clear(this, '_dispatchAction');
 * };
 *
 */

function createOrUpdate(obj, fnAttr, rate, throttleType) {
  var fn = obj[fnAttr];

  if (!fn) {
    return;
  }

  var originFn = fn[ORIGIN_METHOD] || fn;
  var lastThrottleType = fn[THROTTLE_TYPE];
  var lastRate = fn[RATE];

  if (lastRate !== rate || lastThrottleType !== throttleType) {
    if (rate == null || !throttleType) {
      return obj[fnAttr] = originFn;
    }

    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce');
    fn[ORIGIN_METHOD] = originFn;
    fn[THROTTLE_TYPE] = throttleType;
    fn[RATE] = rate;
  }

  return fn;
}
/**
 * Clear throttle. Example see throttle.createOrUpdate.
 */

function clear(obj, fnAttr) {
  var fn = obj[fnAttr];

  if (fn && fn[ORIGIN_METHOD]) {
    // Clear throttle
    fn.clear && fn.clear();
    obj[fnAttr] = fn[ORIGIN_METHOD];
  }
}

var inner$6 = makeInner();
var defaultStyleMappers = {
  itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
  lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
};
var defaultColorKey = {
  lineStyle: 'stroke',
  itemStyle: 'fill'
};

function getStyleMapper(seriesModel, stylePath) {
  var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];

  if (!styleMapper) {
    console.warn("Unkown style type '" + stylePath + "'.");
    return defaultStyleMappers.itemStyle;
  }

  return styleMapper;
}

function getDefaultColorKey(seriesModel, stylePath) {
  // return defaultColorKey[stylePath] ||
  var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];

  if (!colorKey) {
    console.warn("Unkown style type '" + stylePath + "'.");
    return 'fill';
  }

  return colorKey;
}

var seriesStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function (seriesModel, ecModel) {
    var data = seriesModel.getData();
    var stylePath = seriesModel.visualStyleAccessPath || 'itemStyle'; // Set in itemStyle

    var styleModel = seriesModel.getModel(stylePath);
    var getStyle = getStyleMapper(seriesModel, stylePath);
    var globalStyle = getStyle(styleModel);
    var decalOption = styleModel.getShallow('decal');

    if (decalOption) {
      data.setVisual('decal', decalOption);
      decalOption.dirty = true;
    } // TODO


    var colorKey = getDefaultColorKey(seriesModel, stylePath);
    var color = globalStyle[colorKey]; // TODO style callback

    var colorCallback = isFunction(color) ? color : null;
    var hasAutoColor = globalStyle.fill === 'auto' || globalStyle.stroke === 'auto'; // Get from color palette by default.

    if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
      // Note: if some series has color specified (e.g., by itemStyle.color), we DO NOT
      // make it effect palette. Bacause some scenarios users need to make some series
      // transparent or as background, which should better not effect the palette.
      var colorPalette = seriesModel.getColorFromPalette( // TODO series count changed.
      seriesModel.name, null, ecModel.getSeriesCount());

      if (!globalStyle[colorKey]) {
        globalStyle[colorKey] = colorPalette;
        data.setVisual('colorFromPalette', true);
      }

      globalStyle.fill = globalStyle.fill === 'auto' || isFunction(globalStyle.fill) ? colorPalette : globalStyle.fill;
      globalStyle.stroke = globalStyle.stroke === 'auto' || isFunction(globalStyle.stroke) ? colorPalette : globalStyle.stroke;
    }

    data.setVisual('style', globalStyle);
    data.setVisual('drawType', colorKey); // Only visible series has each data be visual encoded

    if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
      data.setVisual('colorFromPalette', false);
      return {
        dataEach: function (data, idx) {
          var dataParams = seriesModel.getDataParams(idx);
          var itemStyle = extend$2({}, globalStyle);
          itemStyle[colorKey] = colorCallback(dataParams);
          data.setItemVisual(idx, 'style', itemStyle);
        }
      };
    }
  }
};
var sharedModel = new Model$1();
var dataStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function (seriesModel, ecModel) {
    if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }

    var data = seriesModel.getData();
    var stylePath = seriesModel.visualStyleAccessPath || 'itemStyle'; // Set in itemStyle

    var getStyle = getStyleMapper(seriesModel, stylePath);
    var colorKey = data.getVisual('drawType');
    return {
      dataEach: data.hasItemOption ? function (data, idx) {
        // Not use getItemModel for performance considuration
        var rawItem = data.getRawDataItem(idx);

        if (rawItem && rawItem[stylePath]) {
          sharedModel.option = rawItem[stylePath];
          var style = getStyle(sharedModel);
          var existsStyle = data.ensureUniqueItemVisual(idx, 'style');
          extend$2(existsStyle, style);

          if (sharedModel.option.decal) {
            data.setItemVisual(idx, 'decal', sharedModel.option.decal);
            sharedModel.option.decal.dirty = true;
          }

          if (colorKey in style) {
            data.setItemVisual(idx, 'colorFromPalette', false);
          }
        }
      } : null
    };
  }
}; // Pick color from palette for the data which has not been set with color yet.
// Note: do not support stream rendering. No such cases yet.

var dataColorPaletteTask = {
  performRawSeries: true,
  overallReset: function (ecModel) {
    // Each type of series use one scope.
    // Pie and funnel are using diferrent scopes
    var paletteScopeGroupByType = createHashMap();
    ecModel.eachSeries(function (seriesModel) {
      var colorBy = seriesModel.getColorBy();

      if (seriesModel.isColorBySeries()) {
        return;
      }

      var key = seriesModel.type + '-' + colorBy;
      var colorScope = paletteScopeGroupByType.get(key);

      if (!colorScope) {
        colorScope = {};
        paletteScopeGroupByType.set(key, colorScope);
      }

      inner$6(seriesModel).scope = colorScope;
    });
    ecModel.eachSeries(function (seriesModel) {
      if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }

      var dataAll = seriesModel.getRawData();
      var idxMap = {};
      var data = seriesModel.getData();
      var colorScope = inner$6(seriesModel).scope;
      var stylePath = seriesModel.visualStyleAccessPath || 'itemStyle';
      var colorKey = getDefaultColorKey(seriesModel, stylePath);
      data.each(function (idx) {
        var rawIdx = data.getRawIndex(idx);
        idxMap[rawIdx] = idx;
      }); // Iterate on data before filtered. To make sure color from palette can be
      // Consistent when toggling legend.

      dataAll.each(function (rawIdx) {
        var idx = idxMap[rawIdx];
        var fromPalette = data.getItemVisual(idx, 'colorFromPalette'); // Get color from palette for each data only when the color is inherited from series color, which is
        // also picked from color palette. So following situation is not in the case:
        // 1. series.itemStyle.color is set
        // 2. color is encoded by visualMap

        if (fromPalette) {
          var itemStyle = data.ensureUniqueItemVisual(idx, 'style');
          var name_1 = dataAll.getName(rawIdx) || rawIdx + '';
          var dataCount = dataAll.count();
          itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);
        }
      });
    });
  }
};

var PI$1 = Math.PI;
/**
 * @param {module:echarts/ExtensionAPI} api
 * @param {Object} [opts]
 * @param {string} [opts.text]
 * @param {string} [opts.color]
 * @param {string} [opts.textColor]
 * @return {module:zrender/Element}
 */

function defaultLoading(api, opts) {
  opts = opts || {};
  defaults(opts, {
    text: 'loading',
    textColor: '#000',
    fontSize: 12,
    fontWeight: 'normal',
    fontStyle: 'normal',
    fontFamily: 'sans-serif',
    maskColor: 'rgba(255, 255, 255, 0.8)',
    showSpinner: true,
    color: '#5470c6',
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var group = new Group$3();
  var mask = new Rect$1({
    style: {
      fill: opts.maskColor
    },
    zlevel: opts.zlevel,
    z: 10000
  });
  group.add(mask);
  var textContent = new ZRText$1({
    style: {
      text: opts.text,
      fill: opts.textColor,
      fontSize: opts.fontSize,
      fontWeight: opts.fontWeight,
      fontStyle: opts.fontStyle,
      fontFamily: opts.fontFamily
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  var labelRect = new Rect$1({
    style: {
      fill: 'none'
    },
    textContent: textContent,
    textConfig: {
      position: 'right',
      distance: 10
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  group.add(labelRect);
  var arc;

  if (opts.showSpinner) {
    arc = new Arc$1({
      shape: {
        startAngle: -PI$1 / 2,
        endAngle: -PI$1 / 2 + 0.1,
        r: opts.spinnerRadius
      },
      style: {
        stroke: opts.color,
        lineCap: 'round',
        lineWidth: opts.lineWidth
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    arc.animateShape(true).when(1000, {
      endAngle: PI$1 * 3 / 2
    }).start('circularInOut');
    arc.animateShape(true).when(1000, {
      startAngle: PI$1 * 3 / 2
    }).delay(300).start('circularInOut');
    group.add(arc);
  } // Inject resize


  group.resize = function () {
    var textWidth = textContent.getBoundingRect().width;
    var r = opts.showSpinner ? opts.spinnerRadius : 0; // cx = (containerWidth - arcDiameter - textDistance - textWidth) / 2
    // textDistance needs to be calculated when both animation and text exist

    var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) // only show the text
    + (opts.showSpinner ? 0 : textWidth / 2) // only show the spinner
    + (textWidth ? 0 : r);
    var cy = api.getHeight() / 2;
    opts.showSpinner && arc.setShape({
      cx: cx,
      cy: cy
    });
    labelRect.setShape({
      x: cx - r,
      y: cy - r,
      width: r * 2,
      height: r * 2
    });
    mask.setShape({
      x: 0,
      y: 0,
      width: api.getWidth(),
      height: api.getHeight()
    });
  };

  group.resize();
  return group;
}

var Scheduler =
/** @class */
function () {
  function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {
    // key: handlerUID
    this._stageTaskMap = createHashMap();
    this.ecInstance = ecInstance;
    this.api = api; // Fix current processors in case that in some rear cases that
    // processors might be registered after echarts instance created.
    // Register processors incrementally for a echarts instance is
    // not supported by this stream architecture.

    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
    visualHandlers = this._visualHandlers = visualHandlers.slice();
    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
  }

  Scheduler.prototype.restoreData = function (ecModel, payload) {
    // TODO: Only restore needed series and components, but not all components.
    // Currently `restoreData` of all of the series and component will be called.
    // But some independent components like `title`, `legend`, `graphic`, `toolbox`,
    // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,
    // and some components like coordinate system, axes, dataZoom, visualMap only
    // need their target series refresh.
    // (1) If we are implementing this feature some day, we should consider these cases:
    // if a data processor depends on a component (e.g., dataZoomProcessor depends
    // on the settings of `dataZoom`), it should be re-performed if the component
    // is modified by `setOption`.
    // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,
    // it should be re-performed when the result array of `getTargetSeries` changed.
    // We use `dependencies` to cover these issues.
    // (3) How to update target series when coordinate system related components modified.
    // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,
    // and this case all of the tasks will be set as dirty.
    ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also
    // depends on all of the series.
    // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks
    // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure
    // that the overall task is set as dirty and to be performed, otherwise it probably cause
    // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it
    // probably cause state chaos (consider `dataZoomProcessor`).

    this._stageTaskMap.each(function (taskRecord) {
      var overallTask = taskRecord.overallTask;
      overallTask && overallTask.dirty();
    });
  }; // If seriesModel provided, incremental threshold is check by series data.


  Scheduler.prototype.getPerformArgs = function (task, isBlock) {
    // For overall task
    if (!task.__pipeline) {
      return;
    }

    var pipeline = this._pipelineMap.get(task.__pipeline.id);

    var pCtx = pipeline.context;
    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
    var step = incremental ? pipeline.step : null;
    var modDataCount = pCtx && pCtx.modDataCount;
    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
    return {
      step: step,
      modBy: modBy,
      modDataCount: modDataCount
    };
  };

  Scheduler.prototype.getPipeline = function (pipelineId) {
    return this._pipelineMap.get(pipelineId);
  };
  /**
   * Current, progressive rendering starts from visual and layout.
   * Always detect render mode in the same stage, avoiding that incorrect
   * detection caused by data filtering.
   * Caution:
   * `updateStreamModes` use `seriesModel.getData()`.
   */


  Scheduler.prototype.updateStreamModes = function (seriesModel, view) {
    var pipeline = this._pipelineMap.get(seriesModel.uid);

    var data = seriesModel.getData();
    var dataLen = data.count(); // `progressiveRender` means that can render progressively in each
    // animation frame. Note that some types of series do not provide
    // `view.incrementalPrepareRender` but support `chart.appendData`. We
    // use the term `incremental` but not `progressive` to describe the
    // case that `chart.appendData`.

    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
    var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.
    // see `test/candlestick-large3.html`

    var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;
    seriesModel.pipelineContext = pipeline.context = {
      progressiveRender: progressiveRender,
      modDataCount: modDataCount,
      large: large
    };
  };

  Scheduler.prototype.restorePipelines = function (ecModel) {
    var scheduler = this;
    var pipelineMap = scheduler._pipelineMap = createHashMap();
    ecModel.eachSeries(function (seriesModel) {
      var progressive = seriesModel.getProgressive();
      var pipelineId = seriesModel.uid;
      pipelineMap.set(pipelineId, {
        id: pipelineId,
        head: null,
        tail: null,
        threshold: seriesModel.getProgressiveThreshold(),
        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
        blockIndex: -1,
        step: Math.round(progressive || 700),
        count: 0
      });

      scheduler._pipe(seriesModel, seriesModel.dataTask);
    });
  };

  Scheduler.prototype.prepareStageTasks = function () {
    var stageTaskMap = this._stageTaskMap;
    var ecModel = this.api.getModel();
    var api = this.api;
    each$9(this._allHandlers, function (handler) {
      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
      var errMsg = '';

      if (process.env.NODE_ENV !== 'production') {
        // Currently do not need to support to sepecify them both.
        errMsg = '"reset" and "overallReset" must not be both specified.';
      }

      assert(!(handler.reset && handler.overallReset), errMsg);
      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);
      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);
    }, this);
  };

  Scheduler.prototype.prepareView = function (view, model, ecModel, api) {
    var renderTask = view.renderTask;
    var context = renderTask.context;
    context.model = model;
    context.ecModel = ecModel;
    context.api = api;
    renderTask.__block = !view.incrementalPrepareRender;

    this._pipe(model, renderTask);
  };

  Scheduler.prototype.performDataProcessorTasks = function (ecModel, payload) {
    // If we do not use `block` here, it should be considered when to update modes.
    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {
      block: true
    });
  };

  Scheduler.prototype.performVisualTasks = function (ecModel, payload, opt) {
    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
  };

  Scheduler.prototype._performStageTasks = function (stageHandlers, ecModel, payload, opt) {
    opt = opt || {};
    var unfinished = false;
    var scheduler = this;
    each$9(stageHandlers, function (stageHandler, idx) {
      if (opt.visualType && opt.visualType !== stageHandler.visualType) {
        return;
      }

      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);

      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
      var overallTask = stageHandlerRecord.overallTask;

      if (overallTask) {
        var overallNeedDirty_1;
        var agentStubMap = overallTask.agentStubMap;
        agentStubMap.each(function (stub) {
          if (needSetDirty(opt, stub)) {
            stub.dirty();
            overallNeedDirty_1 = true;
          }
        });
        overallNeedDirty_1 && overallTask.dirty();
        scheduler.updatePayload(overallTask, payload);
        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,
        // then execute the overall task. And stub will call seriesModel.setData,
        // which ensures that in the overallTask seriesModel.getData() will not
        // return incorrect data.

        agentStubMap.each(function (stub) {
          stub.perform(performArgs_1);
        });

        if (overallTask.perform(performArgs_1)) {
          unfinished = true;
        }
      } else if (seriesTaskMap) {
        seriesTaskMap.each(function (task, pipelineId) {
          if (needSetDirty(opt, task)) {
            task.dirty();
          }

          var performArgs = scheduler.getPerformArgs(task, opt.block); // FIXME
          // if intending to decalare `performRawSeries` in handlers, only
          // stream-independent (specifically, data item independent) operations can be
          // performed. Because is a series is filtered, most of the tasks will not
          // be performed. A stream-dependent operation probably cause wrong biz logic.
          // Perhaps we should not provide a separate callback for this case instead
          // of providing the config `performRawSeries`. The stream-dependent operaions
          // and stream-independent operations should better not be mixed.

          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
          scheduler.updatePayload(task, payload);

          if (task.perform(performArgs)) {
            unfinished = true;
          }
        });
      }
    });

    function needSetDirty(opt, task) {
      return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));
    }

    this.unfinished = unfinished || this.unfinished;
  };

  Scheduler.prototype.performSeriesTasks = function (ecModel) {
    var unfinished;
    ecModel.eachSeries(function (seriesModel) {
      // Progress to the end for dataInit and dataRestore.
      unfinished = seriesModel.dataTask.perform() || unfinished;
    });
    this.unfinished = unfinished || this.unfinished;
  };

  Scheduler.prototype.plan = function () {
    // Travel pipelines, check block.
    this._pipelineMap.each(function (pipeline) {
      var task = pipeline.tail;

      do {
        if (task.__block) {
          pipeline.blockIndex = task.__idxInPipeline;
          break;
        }

        task = task.getUpstream();
      } while (task);
    });
  };

  Scheduler.prototype.updatePayload = function (task, payload) {
    payload !== 'remain' && (task.context.payload = payload);
  };

  Scheduler.prototype._createSeriesStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {
    var scheduler = this;
    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap; // The count of stages are totally about only several dozen, so
    // do not need to reuse the map.

    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
    var seriesType = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,
    // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,
    // it works but it may cause other irrelevant charts blocked.

    if (stageHandler.createOnAllSeries) {
      ecModel.eachRawSeries(create);
    } else if (seriesType) {
      ecModel.eachRawSeriesByType(seriesType, create);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(create);
    }

    function create(seriesModel) {
      var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.
      // Reuse original task instance.

      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
        plan: seriesTaskPlan,
        reset: seriesTaskReset,
        count: seriesTaskCount
      }));
      task.context = {
        model: seriesModel,
        ecModel: ecModel,
        api: api,
        // PENDING: `useClearVisual` not used?
        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
        plan: stageHandler.plan,
        reset: stageHandler.reset,
        scheduler: scheduler
      };

      scheduler._pipe(seriesModel, task);
    }
  };

  Scheduler.prototype._createOverallStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {
    var scheduler = this;
    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.
    || createTask({
      reset: overallTaskReset
    });
    overallTask.context = {
      ecModel: ecModel,
      api: api,
      overallReset: stageHandler.overallReset,
      scheduler: scheduler
    };
    var oldAgentStubMap = overallTask.agentStubMap; // The count of stages are totally about only several dozen, so
    // do not need to reuse the map.

    var newAgentStubMap = overallTask.agentStubMap = createHashMap();
    var seriesType = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries;
    var overallProgress = true;
    var shouldOverallTaskDirty = false; // FIXME:TS never used, so comment it
    // let modifyOutputEnd = stageHandler.modifyOutputEnd;
    // An overall task with seriesType detected or has `getTargetSeries`, we add
    // stub in each pipelines, it will set the overall task dirty when the pipeline
    // progress. Moreover, to avoid call the overall task each frame (too frequent),
    // we set the pipeline block.

    var errMsg = '';

    if (process.env.NODE_ENV !== 'production') {
      errMsg = '"createOnAllSeries" do not supported for "overallReset", ' + 'becuase it will block all streams.';
    }

    assert(!stageHandler.createOnAllSeries, errMsg);

    if (seriesType) {
      ecModel.eachRawSeriesByType(seriesType, createStub);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(createStub);
    } // Otherwise, (usually it is legancy case), the overall task will only be
    // executed when upstream dirty. Otherwise the progressive rendering of all
    // pipelines will be disabled unexpectedly. But it still needs stubs to receive
    // dirty info from upsteam.
    else {
        overallProgress = false;
        each$9(ecModel.getSeries(), createStub);
      }

    function createStub(seriesModel) {
      var pipelineId = seriesModel.uid;
      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || ( // When the result of `getTargetSeries` changed, the overallTask
      // should be set as dirty and re-performed.
      shouldOverallTaskDirty = true, createTask({
        reset: stubReset,
        onDirty: stubOnDirty
      })));
      stub.context = {
        model: seriesModel,
        overallProgress: overallProgress // FIXME:TS never used, so comment it
        // modifyOutputEnd: modifyOutputEnd

      };
      stub.agent = overallTask;
      stub.__block = overallProgress;

      scheduler._pipe(seriesModel, stub);
    }

    if (shouldOverallTaskDirty) {
      overallTask.dirty();
    }
  };

  Scheduler.prototype._pipe = function (seriesModel, task) {
    var pipelineId = seriesModel.uid;

    var pipeline = this._pipelineMap.get(pipelineId);

    !pipeline.head && (pipeline.head = task);
    pipeline.tail && pipeline.tail.pipe(task);
    pipeline.tail = task;
    task.__idxInPipeline = pipeline.count++;
    task.__pipeline = pipeline;
  };

  Scheduler.wrapStageHandler = function (stageHandler, visualType) {
    if (isFunction(stageHandler)) {
      stageHandler = {
        overallReset: stageHandler,
        seriesType: detectSeriseType(stageHandler)
      };
    }

    stageHandler.uid = getUID('stageHandler');
    visualType && (stageHandler.visualType = visualType);
    return stageHandler;
  };
  return Scheduler;
}();

function overallTaskReset(context) {
  context.overallReset(context.ecModel, context.api, context.payload);
}

function stubReset(context) {
  return context.overallProgress && stubProgress;
}

function stubProgress() {
  this.agent.dirty();
  this.getDownstream().dirty();
}

function stubOnDirty() {
  this.agent && this.agent.dirty();
}

function seriesTaskPlan(context) {
  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
}

function seriesTaskReset(context) {
  if (context.useClearVisual) {
    context.data.clearAllVisual();
  }

  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
  return resetDefines.length > 1 ? map$1(resetDefines, function (v, idx) {
    return makeSeriesTaskProgress(idx);
  }) : singleSeriesTaskProgress;
}

var singleSeriesTaskProgress = makeSeriesTaskProgress(0);

function makeSeriesTaskProgress(resetDefineIdx) {
  return function (params, context) {
    var data = context.data;
    var resetDefine = context.resetDefines[resetDefineIdx];

    if (resetDefine && resetDefine.dataEach) {
      for (var i = params.start; i < params.end; i++) {
        resetDefine.dataEach(data, i);
      }
    } else if (resetDefine && resetDefine.progress) {
      resetDefine.progress(params, data);
    }
  };
}

function seriesTaskCount(context) {
  return context.data.count();
}
/**
 * Only some legacy stage handlers (usually in echarts extensions) are pure function.
 * To ensure that they can work normally, they should work in block mode, that is,
 * they should not be started util the previous tasks finished. So they cause the
 * progressive rendering disabled. We try to detect the series type, to narrow down
 * the block range to only the series type they concern, but not all series.
 */


function detectSeriseType(legacyFunc) {
  seriesType = null;

  try {
    // Assume there is no async when calling `eachSeriesByType`.
    legacyFunc(ecModelMock, apiMock);
  } catch (e) {}

  return seriesType;
}

var ecModelMock = {};
var apiMock = {};
var seriesType;
mockMethods(ecModelMock, GlobalModel$1);
mockMethods(apiMock, ExtensionAPI$1);

ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {
  seriesType = type;
};

ecModelMock.eachComponent = function (cond) {
  if (cond.mainType === 'series' && cond.subType) {
    seriesType = cond.subType;
  }
};

function mockMethods(target, Clz) {
  /* eslint-disable */
  for (var name_1 in Clz.prototype) {
    // Do not use hasOwnProperty
    target[name_1] = noop$1;
  }
  /* eslint-enable */

}

var Scheduler$1 = Scheduler;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var colorAll = ['#37A2DA', '#32C5E9', '#67E0E3', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#E062AE', '#E690D1', '#e7bcf3', '#9d96f5', '#8378EA', '#96BFFF'];
var lightTheme = {
  color: colorAll,
  colorLayer: [['#37A2DA', '#ffd85c', '#fd7b5f'], ['#37A2DA', '#67E0E3', '#FFDB5C', '#ff9f7f', '#E062AE', '#9d96f5'], ['#37A2DA', '#32C5E9', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#e7bcf3', '#8378EA', '#96BFFF'], colorAll]
};

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var contrastColor = '#B9B8CE';
var backgroundColor = '#100C2A';

var axisCommon = function () {
  return {
    axisLine: {
      lineStyle: {
        color: contrastColor
      }
    },
    splitLine: {
      lineStyle: {
        color: '#484753'
      }
    },
    splitArea: {
      areaStyle: {
        color: ['rgba(255,255,255,0.02)', 'rgba(255,255,255,0.05)']
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: '#20203B'
      }
    }
  };
};

var colorPalette = ['#4992ff', '#7cffb2', '#fddd60', '#ff6e76', '#58d9f9', '#05c091', '#ff8a45', '#8d48e3', '#dd79ff'];
var theme = {
  darkMode: true,
  color: colorPalette,
  backgroundColor: backgroundColor,
  axisPointer: {
    lineStyle: {
      color: '#817f91'
    },
    crossStyle: {
      color: '#817f91'
    },
    label: {
      // TODO Contrast of label backgorundColor
      color: '#fff'
    }
  },
  legend: {
    textStyle: {
      color: contrastColor
    }
  },
  textStyle: {
    color: contrastColor
  },
  title: {
    textStyle: {
      color: '#EEF1FA'
    },
    subtextStyle: {
      color: '#B9B8CE'
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: contrastColor
    }
  },
  dataZoom: {
    borderColor: '#71708A',
    textStyle: {
      color: contrastColor
    },
    brushStyle: {
      color: 'rgba(135,163,206,0.3)'
    },
    handleStyle: {
      color: '#353450',
      borderColor: '#C5CBE3'
    },
    moveHandleStyle: {
      color: '#B0B6C3',
      opacity: 0.3
    },
    fillerColor: 'rgba(135,163,206,0.2)',
    emphasis: {
      handleStyle: {
        borderColor: '#91B7F2',
        color: '#4D587D'
      },
      moveHandleStyle: {
        color: '#636D9A',
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: '#71708A',
        width: 1
      },
      areaStyle: {
        color: '#71708A'
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: '#87A3CE'
      },
      areaStyle: {
        color: '#87A3CE'
      }
    }
  },
  visualMap: {
    textStyle: {
      color: contrastColor
    }
  },
  timeline: {
    lineStyle: {
      color: contrastColor
    },
    label: {
      color: contrastColor
    },
    controlStyle: {
      color: contrastColor,
      borderColor: contrastColor
    }
  },
  calendar: {
    itemStyle: {
      color: backgroundColor
    },
    dayLabel: {
      color: contrastColor
    },
    monthLabel: {
      color: contrastColor
    },
    yearLabel: {
      color: contrastColor
    }
  },
  timeAxis: axisCommon(),
  logAxis: axisCommon(),
  valueAxis: axisCommon(),
  categoryAxis: axisCommon(),
  line: {
    symbol: 'circle'
  },
  graph: {
    color: colorPalette
  },
  gauge: {
    title: {
      color: contrastColor
    },
    axisLine: {
      lineStyle: {
        color: [[1, 'rgba(207,212,219,0.2)']]
      }
    },
    axisLabel: {
      color: contrastColor
    },
    detail: {
      color: '#EEF1FA'
    }
  },
  candlestick: {
    itemStyle: {
      color: '#f64e56',
      color0: '#54ea92',
      borderColor: '#f64e56',
      borderColor0: '#54ea92' // borderColor: '#ca2824',
      // borderColor0: '#09a443'

    }
  }
};
theme.categoryAxis.splitLine.show = false;
var darkTheme = theme;

/**
 * Usage of query:
 * `chart.on('click', query, handler);`
 * The `query` can be:
 * + The component type query string, only `mainType` or `mainType.subType`,
 *   like: 'xAxis', 'series', 'xAxis.category' or 'series.line'.
 * + The component query object, like:
 *   `{seriesIndex: 2}`, `{seriesName: 'xx'}`, `{seriesId: 'some'}`,
 *   `{xAxisIndex: 2}`, `{xAxisName: 'xx'}`, `{xAxisId: 'some'}`.
 * + The data query object, like:
 *   `{dataIndex: 123}`, `{dataType: 'link'}`, `{name: 'some'}`.
 * + The other query object (cmponent customized query), like:
 *   `{element: 'some'}` (only available in custom series).
 *
 * Caveat: If a prop in the `query` object is `null/undefined`, it is the
 * same as there is no such prop in the `query` object.
 */

var ECEventProcessor =
/** @class */
function () {
  function ECEventProcessor() {}

  ECEventProcessor.prototype.normalizeQuery = function (query) {
    var cptQuery = {};
    var dataQuery = {};
    var otherQuery = {}; // `query` is `mainType` or `mainType.subType` of component.

    if (isString(query)) {
      var condCptType = parseClassType(query); // `.main` and `.sub` may be ''.

      cptQuery.mainType = condCptType.main || null;
      cptQuery.subType = condCptType.sub || null;
    } // `query` is an object, convert to {mainType, index, name, id}.
    else {
        // `xxxIndex`, `xxxName`, `xxxId`, `name`, `dataIndex`, `dataType` is reserved,
        // can not be used in `compomentModel.filterForExposedEvent`.
        var suffixes_1 = ['Index', 'Name', 'Id'];
        var dataKeys_1 = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        each$9(query, function (val, key) {
          var reserved = false;

          for (var i = 0; i < suffixes_1.length; i++) {
            var propSuffix = suffixes_1[i];
            var suffixPos = key.lastIndexOf(propSuffix);

            if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
              var mainType = key.slice(0, suffixPos); // Consider `dataIndex`.

              if (mainType !== 'data') {
                cptQuery.mainType = mainType;
                cptQuery[propSuffix.toLowerCase()] = val;
                reserved = true;
              }
            }
          }

          if (dataKeys_1.hasOwnProperty(key)) {
            dataQuery[key] = val;
            reserved = true;
          }

          if (!reserved) {
            otherQuery[key] = val;
          }
        });
      }

    return {
      cptQuery: cptQuery,
      dataQuery: dataQuery,
      otherQuery: otherQuery
    };
  };

  ECEventProcessor.prototype.filter = function (eventType, query) {
    // They should be assigned before each trigger call.
    var eventInfo = this.eventInfo;

    if (!eventInfo) {
      return true;
    }

    var targetEl = eventInfo.targetEl;
    var packedEvent = eventInfo.packedEvent;
    var model = eventInfo.model;
    var view = eventInfo.view; // For event like 'globalout'.

    if (!model || !view) {
      return true;
    }

    var cptQuery = query.cptQuery;
    var dataQuery = query.dataQuery;
    return check(cptQuery, model, 'mainType') && check(cptQuery, model, 'subType') && check(cptQuery, model, 'index', 'componentIndex') && check(cptQuery, model, 'name') && check(cptQuery, model, 'id') && check(dataQuery, packedEvent, 'name') && check(dataQuery, packedEvent, 'dataIndex') && check(dataQuery, packedEvent, 'dataType') && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));

    function check(query, host, prop, propOnHost) {
      return query[prop] == null || host[propOnHost || prop] === query[prop];
    }
  };

  ECEventProcessor.prototype.afterTrigger = function () {
    // Make sure the eventInfo wont be used in next trigger.
    this.eventInfo = null;
  };

  return ECEventProcessor;
}();

var SYMBOL_PROPS_WITH_CB = ['symbol', 'symbolSize', 'symbolRotate', 'symbolOffset'];
var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(['symbolKeepAspect']); // Encoding visual for all series include which is filtered for legend drawing

var seriesSymbolTask = {
  createOnAllSeries: true,
  // For legend.
  performRawSeries: true,
  reset: function (seriesModel, ecModel) {
    var data = seriesModel.getData();

    if (seriesModel.legendIcon) {
      data.setVisual('legendIcon', seriesModel.legendIcon);
    }

    if (!seriesModel.hasSymbolVisual) {
      return;
    }

    var symbolOptions = {};
    var symbolOptionsCb = {};
    var hasCallback = false;

    for (var i = 0; i < SYMBOL_PROPS_WITH_CB.length; i++) {
      var symbolPropName = SYMBOL_PROPS_WITH_CB[i];
      var val = seriesModel.get(symbolPropName);

      if (isFunction(val)) {
        hasCallback = true;
        symbolOptionsCb[symbolPropName] = val;
      } else {
        symbolOptions[symbolPropName] = val;
      }
    }

    symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
    data.setVisual(extend$2({
      legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
      symbolKeepAspect: seriesModel.get('symbolKeepAspect')
    }, symbolOptions)); // Only visible series has each data be visual encoded

    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }

    var symbolPropsCb = keys(symbolOptionsCb);

    function dataEach(data, idx) {
      var rawValue = seriesModel.getRawValue(idx);
      var params = seriesModel.getDataParams(idx);

      for (var i = 0; i < symbolPropsCb.length; i++) {
        var symbolPropName = symbolPropsCb[i];
        data.setItemVisual(idx, symbolPropName, symbolOptionsCb[symbolPropName](rawValue, params));
      }
    }

    return {
      dataEach: hasCallback ? dataEach : null
    };
  }
};
var dataSymbolTask = {
  createOnAllSeries: true,
  // For legend.
  performRawSeries: true,
  reset: function (seriesModel, ecModel) {
    if (!seriesModel.hasSymbolVisual) {
      return;
    } // Only visible series has each data be visual encoded


    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }

    var data = seriesModel.getData();

    function dataEach(data, idx) {
      var itemModel = data.getItemModel(idx);

      for (var i = 0; i < SYMBOL_PROPS.length; i++) {
        var symbolPropName = SYMBOL_PROPS[i];
        var val = itemModel.getShallow(symbolPropName, true);

        if (val != null) {
          data.setItemVisual(idx, symbolPropName, val);
        }
      }
    }

    return {
      dataEach: data.hasItemOption ? dataEach : null
    };
  }
};

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function getItemVisualFromData(data, dataIndex, key) {
  switch (key) {
    case 'color':
      var style = data.getItemVisual(dataIndex, 'style');
      return style[data.getVisual('drawType')];

    case 'opacity':
      return data.getItemVisual(dataIndex, 'style').opacity;

    case 'symbol':
    case 'symbolSize':
    case 'liftZ':
      return data.getItemVisual(dataIndex, key);

    default:
      if (process.env.NODE_ENV !== 'production') {
        console.warn("Unknown visual type " + key);
      }

  }
}
function getVisualFromData(data, key) {
  switch (key) {
    case 'color':
      var style = data.getVisual('style');
      return style[data.getVisual('drawType')];

    case 'opacity':
      return data.getVisual('style').opacity;

    case 'symbol':
    case 'symbolSize':
    case 'liftZ':
      return data.getVisual(key);

    default:
      if (process.env.NODE_ENV !== 'production') {
        console.warn("Unknown visual type " + key);
      }

  }
}
function setItemVisualFromData(data, dataIndex, key, value) {
  switch (key) {
    case 'color':
      // Make sure not sharing style object.
      var style = data.ensureUniqueItemVisual(dataIndex, 'style');
      style[data.getVisual('drawType')] = value; // Mark the color has been changed, not from palette anymore

      data.setItemVisual(dataIndex, 'colorFromPalette', false);
      break;

    case 'opacity':
      data.ensureUniqueItemVisual(dataIndex, 'style').opacity = value;
      break;

    case 'symbol':
    case 'symbolSize':
    case 'liftZ':
      data.setItemVisual(dataIndex, key, value);
      break;

    default:
      if (process.env.NODE_ENV !== 'production') {
        console.warn("Unknown visual type " + key);
      }

  }
}

// Inlucdes: pieSelect, pieUnSelect, pieToggleSelect, mapSelect, mapUnSelect, mapToggleSelect

function createLegacyDataSelectAction(seriesType, ecRegisterAction) {
  function getSeriesIndices(ecModel, payload) {
    var seriesIndices = [];
    ecModel.eachComponent({
      mainType: 'series',
      subType: seriesType,
      query: payload
    }, function (seriesModel) {
      seriesIndices.push(seriesModel.seriesIndex);
    });
    return seriesIndices;
  }

  each$9([[seriesType + 'ToggleSelect', 'toggleSelect'], [seriesType + 'Select', 'select'], [seriesType + 'UnSelect', 'unselect']], function (eventsMap) {
    ecRegisterAction(eventsMap[0], function (payload, ecModel, api) {
      payload = extend$2({}, payload);

      if (process.env.NODE_ENV !== 'production') {
        deprecateReplaceLog(payload.type, eventsMap[1]);
      }

      api.dispatchAction(extend$2(payload, {
        type: eventsMap[1],
        seriesIndex: getSeriesIndices(ecModel, payload)
      }));
    });
  });
}

function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
  var legacyEventName = type + eventPostfix;

  if (!ecIns.isSilent(legacyEventName)) {
    if (process.env.NODE_ENV !== 'production') {
      deprecateLog("event " + legacyEventName + " is deprecated.");
    }

    ecModel.eachComponent({
      mainType: 'series',
      subType: 'pie'
    }, function (seriesModel) {
      var seriesIndex = seriesModel.seriesIndex;
      var selectedMap = seriesModel.option.selectedMap;
      var selected = payload.selected;

      for (var i = 0; i < selected.length; i++) {
        if (selected[i].seriesIndex === seriesIndex) {
          var data = seriesModel.getData();
          var dataIndex = queryDataIndex(data, payload.fromActionPayload);
          ecIns.trigger(legacyEventName, {
            type: legacyEventName,
            seriesId: seriesModel.id,
            name: isArray$1(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
            selected: isString(selectedMap) ? selectedMap : extend$2({}, selectedMap)
          });
        }
      }
    });
  }
}

function handleLegacySelectEvents(messageCenter, ecIns, api) {
  messageCenter.on('selectchanged', function (params) {
    var ecModel = api.getModel();

    if (params.isFromClick) {
      handleSeriesLegacySelectEvents('map', 'selectchanged', ecIns, ecModel, params);
      handleSeriesLegacySelectEvents('pie', 'selectchanged', ecIns, ecModel, params);
    } else if (params.fromAction === 'select') {
      handleSeriesLegacySelectEvents('map', 'selected', ecIns, ecModel, params);
      handleSeriesLegacySelectEvents('pie', 'selected', ecIns, ecModel, params);
    } else if (params.fromAction === 'unselect') {
      handleSeriesLegacySelectEvents('map', 'unselected', ecIns, ecModel, params);
      handleSeriesLegacySelectEvents('pie', 'unselected', ecIns, ecModel, params);
    }
  });
}

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function findEventDispatcher(target, det, returnFirstMatch) {
  var found;

  while (target) {
    if (det(target)) {
      found = target;

      if (returnFirstMatch) {
        break;
      }
    }

    target = target.__hostTarget || target.parent;
  }

  return found;
}

var wmUniqueIndex = Math.round(Math.random() * 9);
var supportDefineProperty = typeof Object.defineProperty === 'function';
var WeakMap$1 = (function () {
    function WeakMap() {
        this._id = '__ec_inner_' + wmUniqueIndex++;
    }
    WeakMap.prototype.get = function (key) {
        return this._guard(key)[this._id];
    };
    WeakMap.prototype.set = function (key, value) {
        var target = this._guard(key);
        if (supportDefineProperty) {
            Object.defineProperty(target, this._id, {
                value: value,
                enumerable: false,
                configurable: true
            });
        }
        else {
            target[this._id] = value;
        }
        return this;
    };
    WeakMap.prototype["delete"] = function (key) {
        if (this.has(key)) {
            delete this._guard(key)[this._id];
            return true;
        }
        return false;
    };
    WeakMap.prototype.has = function (key) {
        return !!this._guard(key)[this._id];
    };
    WeakMap.prototype._guard = function (key) {
        if (key !== Object(key)) {
            throw TypeError('Value of WeakMap is not a non-null object.');
        }
        return key;
    };
    return WeakMap;
}());
var WeakMap$2 = WeakMap$1;

/**
 * Triangle shape
 * @inner
 */

var Triangle = Path$1.extend({
  type: 'triangle',
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function (path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy + height);
    path.lineTo(cx - width, cy + height);
    path.closePath();
  }
});
/**
 * Diamond shape
 * @inner
 */

var Diamond = Path$1.extend({
  type: 'diamond',
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function (path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy);
    path.lineTo(cx, cy + height);
    path.lineTo(cx - width, cy);
    path.closePath();
  }
});
/**
 * Pin shape
 * @inner
 */

var Pin = Path$1.extend({
  type: 'pin',
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function (path, shape) {
    var x = shape.x;
    var y = shape.y;
    var w = shape.width / 5 * 3; // Height must be larger than width

    var h = Math.max(w, shape.height);
    var r = w / 2; // Dist on y with tangent point and circle center

    var dy = r * r / (h - r);
    var cy = y - h + r + dy;
    var angle = Math.asin(dy / r); // Dist on x with tangent point and circle center

    var dx = Math.cos(angle) * r;
    var tanX = Math.sin(angle);
    var tanY = Math.cos(angle);
    var cpLen = r * 0.6;
    var cpLen2 = r * 0.7;
    path.moveTo(x - dx, cy + dy);
    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
    path.closePath();
  }
});
/**
 * Arrow shape
 * @inner
 */

var Arrow = Path$1.extend({
  type: 'arrow',
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function (ctx, shape) {
    var height = shape.height;
    var width = shape.width;
    var x = shape.x;
    var y = shape.y;
    var dx = width / 3 * 2;
    ctx.moveTo(x, y);
    ctx.lineTo(x + dx, y + height);
    ctx.lineTo(x, y + height / 4 * 3);
    ctx.lineTo(x - dx, y + height);
    ctx.lineTo(x, y);
    ctx.closePath();
  }
});
/**
 * Map of path contructors
 */
// TODO Use function to build symbol path.

var symbolCtors = {
  line: Line$1,
  rect: Rect$1,
  roundRect: Rect$1,
  square: Rect$1,
  circle: Circle$1,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle
};
var symbolShapeMakers = {
  line: function (x, y, w, h, shape) {
    shape.x1 = x;
    shape.y1 = y + h / 2;
    shape.x2 = x + w;
    shape.y2 = y + h / 2;
  },
  rect: function (x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
  },
  roundRect: function (x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
    shape.r = Math.min(w, h) / 4;
  },
  square: function (x, y, w, h, shape) {
    var size = Math.min(w, h);
    shape.x = x;
    shape.y = y;
    shape.width = size;
    shape.height = size;
  },
  circle: function (x, y, w, h, shape) {
    // Put circle in the center of square
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.r = Math.min(w, h) / 2;
  },
  diamond: function (x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  pin: function (x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  arrow: function (x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  triangle: function (x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  }
};
var symbolBuildProxies = {};
each$9(symbolCtors, function (Ctor, name) {
  symbolBuildProxies[name] = new Ctor();
});
var SymbolClz$1 = Path$1.extend({
  type: 'symbol',
  shape: {
    symbolType: '',
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function (out, config, rect) {
    var res = calculateTextPosition(out, config, rect);
    var shape = this.shape;

    if (shape && shape.symbolType === 'pin' && config.position === 'inside') {
      res.y = rect.y + rect.height * 0.4;
    }

    return res;
  },
  buildPath: function (ctx, shape, inBundle) {
    var symbolType = shape.symbolType;

    if (symbolType !== 'none') {
      var proxySymbol = symbolBuildProxies[symbolType];

      if (!proxySymbol) {
        // Default rect
        symbolType = 'rect';
        proxySymbol = symbolBuildProxies[symbolType];
      }

      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
    }
  }
}); // Provide setColor helper method to avoid determine if set the fill or stroke outside

function symbolPathSetColor(color, innerColor) {
  if (this.type !== 'image') {
    var symbolStyle = this.style;

    if (this.__isEmptyBrush) {
      symbolStyle.stroke = color;
      symbolStyle.fill = innerColor || '#fff'; // TODO Same width with lineStyle in LineView

      symbolStyle.lineWidth = 2;
    } else if (this.shape.symbolType === 'line') {
      symbolStyle.stroke = color;
    } else {
      symbolStyle.fill = color;
    }

    this.markRedraw();
  }
}
/**
 * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
 */


function createSymbol(symbolType, x, y, w, h, color, // whether to keep the ratio of w/h,
keepAspect) {
  // TODO Support image object, DynamicImage.
  var isEmpty = symbolType.indexOf('empty') === 0;

  if (isEmpty) {
    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
  }

  var symbolPath;

  if (symbolType.indexOf('image://') === 0) {
    symbolPath = makeImage(symbolType.slice(8), new BoundingRect$1(x, y, w, h), keepAspect ? 'center' : 'cover');
  } else if (symbolType.indexOf('path://') === 0) {
    symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect$1(x, y, w, h), keepAspect ? 'center' : 'cover');
  } else {
    symbolPath = new SymbolClz$1({
      shape: {
        symbolType: symbolType,
        x: x,
        y: y,
        width: w,
        height: h
      }
    });
  }

  symbolPath.__isEmptyBrush = isEmpty; // TODO Should deprecate setColor

  symbolPath.setColor = symbolPathSetColor;

  if (color) {
    symbolPath.setColor(color);
  }

  return symbolPath;
}
function normalizeSymbolSize(symbolSize) {
  if (!isArray$1(symbolSize)) {
    symbolSize = [+symbolSize, +symbolSize];
  }

  return [symbolSize[0] || 0, symbolSize[1] || 0];
}
function normalizeSymbolOffset(symbolOffset, symbolSize) {
  if (symbolOffset == null) {
    return;
  }

  if (!isArray$1(symbolOffset)) {
    symbolOffset = [symbolOffset, symbolOffset];
  }

  return [parsePercent(symbolOffset[0], symbolSize[0]) || 0, parsePercent(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0];
}

function isSafeNum(num) {
    return isFinite(num);
}
function createLinearGradient(ctx, obj, rect) {
    var x = obj.x == null ? 0 : obj.x;
    var x2 = obj.x2 == null ? 1 : obj.x2;
    var y = obj.y == null ? 0 : obj.y;
    var y2 = obj.y2 == null ? 0 : obj.y2;
    if (!obj.global) {
        x = x * rect.width + rect.x;
        x2 = x2 * rect.width + rect.x;
        y = y * rect.height + rect.y;
        y2 = y2 * rect.height + rect.y;
    }
    x = isSafeNum(x) ? x : 0;
    x2 = isSafeNum(x2) ? x2 : 1;
    y = isSafeNum(y) ? y : 0;
    y2 = isSafeNum(y2) ? y2 : 0;
    var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
    return canvasGradient;
}
function createRadialGradient(ctx, obj, rect) {
    var width = rect.width;
    var height = rect.height;
    var min = Math.min(width, height);
    var x = obj.x == null ? 0.5 : obj.x;
    var y = obj.y == null ? 0.5 : obj.y;
    var r = obj.r == null ? 0.5 : obj.r;
    if (!obj.global) {
        x = x * width + rect.x;
        y = y * height + rect.y;
        r = r * min;
    }
    x = isSafeNum(x) ? x : 0.5;
    y = isSafeNum(y) ? y : 0.5;
    r = r >= 0 && isSafeNum(r) ? r : 0.5;
    var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
    return canvasGradient;
}
function getCanvasGradient(ctx, obj, rect) {
    var canvasGradient = obj.type === 'radial'
        ? createRadialGradient(ctx, obj, rect)
        : createLinearGradient(ctx, obj, rect);
    var colorStops = obj.colorStops;
    for (var i = 0; i < colorStops.length; i++) {
        canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
    }
    return canvasGradient;
}
function isClipPathChanged(clipPaths, prevClipPaths) {
    if (clipPaths === prevClipPaths || (!clipPaths && !prevClipPaths)) {
        return false;
    }
    if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
        return true;
    }
    for (var i = 0; i < clipPaths.length; i++) {
        if (clipPaths[i] !== prevClipPaths[i]) {
            return true;
        }
    }
    return false;
}
function parseInt10(val) {
    return parseInt(val, 10);
}
function getSize(root, whIdx, opts) {
    var wh = ['width', 'height'][whIdx];
    var cwh = ['clientWidth', 'clientHeight'][whIdx];
    var plt = ['paddingLeft', 'paddingTop'][whIdx];
    var prb = ['paddingRight', 'paddingBottom'][whIdx];
    if (opts[wh] != null && opts[wh] !== 'auto') {
        return parseFloat(opts[wh]);
    }
    var stl = document.defaultView.getComputedStyle(root);
    return ((root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))
        - (parseInt10(stl[plt]) || 0)
        - (parseInt10(stl[prb]) || 0)) | 0;
}

function normalizeLineDash(lineType, lineWidth) {
    if (!lineType || lineType === 'solid' || !(lineWidth > 0)) {
        return null;
    }
    return lineType === 'dashed'
        ? [4 * lineWidth, 2 * lineWidth]
        : lineType === 'dotted'
            ? [lineWidth]
            : isNumber(lineType)
                ? [lineType] : isArray$1(lineType) ? lineType : null;
}
function getLineDash(el) {
    var style = el.style;
    var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);
    var lineDashOffset = style.lineDashOffset;
    if (lineDash) {
        var lineScale_1 = (style.strokeNoScale && el.getLineScale) ? el.getLineScale() : 1;
        if (lineScale_1 && lineScale_1 !== 1) {
            lineDash = map$1(lineDash, function (rawVal) {
                return rawVal / lineScale_1;
            });
            lineDashOffset /= lineScale_1;
        }
    }
    return [lineDash, lineDashOffset];
}

var pathProxyForDraw = new PathProxy$1(true);
function styleHasStroke(style) {
    var stroke = style.stroke;
    return !(stroke == null || stroke === 'none' || !(style.lineWidth > 0));
}
function isValidStrokeFillStyle(strokeOrFill) {
    return typeof strokeOrFill === 'string' && strokeOrFill !== 'none';
}
function styleHasFill(style) {
    var fill = style.fill;
    return fill != null && fill !== 'none';
}
function doFillPath(ctx, style) {
    if (style.fillOpacity != null && style.fillOpacity !== 1) {
        var originalGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = style.fillOpacity * style.opacity;
        ctx.fill();
        ctx.globalAlpha = originalGlobalAlpha;
    }
    else {
        ctx.fill();
    }
}
function doStrokePath(ctx, style) {
    if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
        var originalGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = style.strokeOpacity * style.opacity;
        ctx.stroke();
        ctx.globalAlpha = originalGlobalAlpha;
    }
    else {
        ctx.stroke();
    }
}
function createCanvasPattern(ctx, pattern, el) {
    var image = createOrUpdateImage(pattern.image, pattern.__image, el);
    if (isImageReady(image)) {
        var canvasPattern = ctx.createPattern(image, pattern.repeat || 'repeat');
        if (typeof DOMMatrix === 'function'
            && canvasPattern
            && canvasPattern.setTransform) {
            var matrix = new DOMMatrix();
            matrix.translateSelf((pattern.x || 0), (pattern.y || 0));
            matrix.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);
            matrix.scaleSelf((pattern.scaleX || 1), (pattern.scaleY || 1));
            canvasPattern.setTransform(matrix);
        }
        return canvasPattern;
    }
}
function brushPath(ctx, el, style, inBatch) {
    var _a;
    var hasStroke = styleHasStroke(style);
    var hasFill = styleHasFill(style);
    var strokePercent = style.strokePercent;
    var strokePart = strokePercent < 1;
    var firstDraw = !el.path;
    if ((!el.silent || strokePart) && firstDraw) {
        el.createPathProxy();
    }
    var path = el.path || pathProxyForDraw;
    var dirtyFlag = el.__dirty;
    if (!inBatch) {
        var fill = style.fill;
        var stroke = style.stroke;
        var hasFillGradient = hasFill && !!fill.colorStops;
        var hasStrokeGradient = hasStroke && !!stroke.colorStops;
        var hasFillPattern = hasFill && !!fill.image;
        var hasStrokePattern = hasStroke && !!stroke.image;
        var fillGradient = void 0;
        var strokeGradient = void 0;
        var fillPattern = void 0;
        var strokePattern = void 0;
        var rect = void 0;
        if (hasFillGradient || hasStrokeGradient) {
            rect = el.getBoundingRect();
        }
        if (hasFillGradient) {
            fillGradient = dirtyFlag
                ? getCanvasGradient(ctx, fill, rect)
                : el.__canvasFillGradient;
            el.__canvasFillGradient = fillGradient;
        }
        if (hasStrokeGradient) {
            strokeGradient = dirtyFlag
                ? getCanvasGradient(ctx, stroke, rect)
                : el.__canvasStrokeGradient;
            el.__canvasStrokeGradient = strokeGradient;
        }
        if (hasFillPattern) {
            fillPattern = (dirtyFlag || !el.__canvasFillPattern)
                ? createCanvasPattern(ctx, fill, el)
                : el.__canvasFillPattern;
            el.__canvasFillPattern = fillPattern;
        }
        if (hasStrokePattern) {
            strokePattern = (dirtyFlag || !el.__canvasStrokePattern)
                ? createCanvasPattern(ctx, stroke, el)
                : el.__canvasStrokePattern;
            el.__canvasStrokePattern = fillPattern;
        }
        if (hasFillGradient) {
            ctx.fillStyle = fillGradient;
        }
        else if (hasFillPattern) {
            if (fillPattern) {
                ctx.fillStyle = fillPattern;
            }
            else {
                hasFill = false;
            }
        }
        if (hasStrokeGradient) {
            ctx.strokeStyle = strokeGradient;
        }
        else if (hasStrokePattern) {
            if (strokePattern) {
                ctx.strokeStyle = strokePattern;
            }
            else {
                hasStroke = false;
            }
        }
    }
    var scale = el.getGlobalScale();
    path.setScale(scale[0], scale[1], el.segmentIgnoreThreshold);
    var lineDash;
    var lineDashOffset;
    if (ctx.setLineDash && style.lineDash) {
        _a = getLineDash(el), lineDash = _a[0], lineDashOffset = _a[1];
    }
    var needsRebuild = true;
    if (firstDraw || (dirtyFlag & SHAPE_CHANGED_BIT)) {
        path.setDPR(ctx.dpr);
        if (strokePart) {
            path.setContext(null);
        }
        else {
            path.setContext(ctx);
            needsRebuild = false;
        }
        path.reset();
        el.buildPath(path, el.shape, inBatch);
        path.toStatic();
        el.pathUpdated();
    }
    if (needsRebuild) {
        path.rebuildPath(ctx, strokePart ? strokePercent : 1);
    }
    if (lineDash) {
        ctx.setLineDash(lineDash);
        ctx.lineDashOffset = lineDashOffset;
    }
    if (!inBatch) {
        if (style.strokeFirst) {
            if (hasStroke) {
                doStrokePath(ctx, style);
            }
            if (hasFill) {
                doFillPath(ctx, style);
            }
        }
        else {
            if (hasFill) {
                doFillPath(ctx, style);
            }
            if (hasStroke) {
                doStrokePath(ctx, style);
            }
        }
    }
    if (lineDash) {
        ctx.setLineDash([]);
    }
}
function brushImage(ctx, el, style) {
    var image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);
    if (!image || !isImageReady(image)) {
        return;
    }
    var x = style.x || 0;
    var y = style.y || 0;
    var width = el.getWidth();
    var height = el.getHeight();
    var aspect = image.width / image.height;
    if (width == null && height != null) {
        width = height * aspect;
    }
    else if (height == null && width != null) {
        height = width / aspect;
    }
    else if (width == null && height == null) {
        width = image.width;
        height = image.height;
    }
    if (style.sWidth && style.sHeight) {
        var sx = style.sx || 0;
        var sy = style.sy || 0;
        ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
    }
    else if (style.sx && style.sy) {
        var sx = style.sx;
        var sy = style.sy;
        var sWidth = width - sx;
        var sHeight = height - sy;
        ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
    }
    else {
        ctx.drawImage(image, x, y, width, height);
    }
}
function brushText(ctx, el, style) {
    var _a;
    var text = style.text;
    text != null && (text += '');
    if (text) {
        ctx.font = style.font || DEFAULT_FONT;
        ctx.textAlign = style.textAlign;
        ctx.textBaseline = style.textBaseline;
        var lineDash = void 0;
        var lineDashOffset = void 0;
        if (ctx.setLineDash && style.lineDash) {
            _a = getLineDash(el), lineDash = _a[0], lineDashOffset = _a[1];
        }
        if (lineDash) {
            ctx.setLineDash(lineDash);
            ctx.lineDashOffset = lineDashOffset;
        }
        if (style.strokeFirst) {
            if (styleHasStroke(style)) {
                ctx.strokeText(text, style.x, style.y);
            }
            if (styleHasFill(style)) {
                ctx.fillText(text, style.x, style.y);
            }
        }
        else {
            if (styleHasFill(style)) {
                ctx.fillText(text, style.x, style.y);
            }
            if (styleHasStroke(style)) {
                ctx.strokeText(text, style.x, style.y);
            }
        }
        if (lineDash) {
            ctx.setLineDash([]);
        }
    }
}
var SHADOW_NUMBER_PROPS = ['shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];
var STROKE_PROPS = [
    ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]
];
function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
    var styleChanged = false;
    if (!forceSetAll) {
        prevStyle = prevStyle || {};
        if (style === prevStyle) {
            return false;
        }
    }
    if (forceSetAll || style.opacity !== prevStyle.opacity) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
        var opacity = Math.max(Math.min(style.opacity, 1), 0);
        ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;
    }
    if (forceSetAll || style.blend !== prevStyle.blend) {
        if (!styleChanged) {
            flushPathDrawn(ctx, scope);
            styleChanged = true;
        }
        ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;
    }
    for (var i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {
        var propName = SHADOW_NUMBER_PROPS[i];
        if (forceSetAll || style[propName] !== prevStyle[propName]) {
            if (!styleChanged) {
                flushPathDrawn(ctx, scope);
                styleChanged = true;
            }
            ctx[propName] = ctx.dpr * (style[propName] || 0);
        }
    }
    if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
        if (!styleChanged) {
            flushPathDrawn(ctx, scope);
            styleChanged = true;
        }
        ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;
    }
    return styleChanged;
}
function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {
    var style = getStyle(el, scope.inHover);
    var prevStyle = forceSetAll
        ? null
        : (prevEl && getStyle(prevEl, scope.inHover) || {});
    if (style === prevStyle) {
        return false;
    }
    var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
    if (forceSetAll || style.fill !== prevStyle.fill) {
        if (!styleChanged) {
            flushPathDrawn(ctx, scope);
            styleChanged = true;
        }
        isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);
    }
    if (forceSetAll || style.stroke !== prevStyle.stroke) {
        if (!styleChanged) {
            flushPathDrawn(ctx, scope);
            styleChanged = true;
        }
        isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);
    }
    if (forceSetAll || style.opacity !== prevStyle.opacity) {
        if (!styleChanged) {
            flushPathDrawn(ctx, scope);
            styleChanged = true;
        }
        ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
    }
    if (el.hasStroke()) {
        var lineWidth = style.lineWidth;
        var newLineWidth = lineWidth / ((style.strokeNoScale && el.getLineScale) ? el.getLineScale() : 1);
        if (ctx.lineWidth !== newLineWidth) {
            if (!styleChanged) {
                flushPathDrawn(ctx, scope);
                styleChanged = true;
            }
            ctx.lineWidth = newLineWidth;
        }
    }
    for (var i = 0; i < STROKE_PROPS.length; i++) {
        var prop = STROKE_PROPS[i];
        var propName = prop[0];
        if (forceSetAll || style[propName] !== prevStyle[propName]) {
            if (!styleChanged) {
                flushPathDrawn(ctx, scope);
                styleChanged = true;
            }
            ctx[propName] = style[propName] || prop[1];
        }
    }
    return styleChanged;
}
function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {
    return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);
}
function setContextTransform(ctx, el) {
    var m = el.transform;
    var dpr = ctx.dpr || 1;
    if (m) {
        ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
    }
    else {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
}
function updateClipStatus(clipPaths, ctx, scope) {
    var allClipped = false;
    for (var i = 0; i < clipPaths.length; i++) {
        var clipPath = clipPaths[i];
        allClipped = allClipped || clipPath.isZeroArea();
        setContextTransform(ctx, clipPath);
        ctx.beginPath();
        clipPath.buildPath(ctx, clipPath.shape);
        ctx.clip();
    }
    scope.allClipped = allClipped;
}
function isTransformChanged(m0, m1) {
    if (m0 && m1) {
        return m0[0] !== m1[0]
            || m0[1] !== m1[1]
            || m0[2] !== m1[2]
            || m0[3] !== m1[3]
            || m0[4] !== m1[4]
            || m0[5] !== m1[5];
    }
    else if (!m0 && !m1) {
        return false;
    }
    return true;
}
var DRAW_TYPE_PATH = 1;
var DRAW_TYPE_IMAGE = 2;
var DRAW_TYPE_TEXT = 3;
var DRAW_TYPE_INCREMENTAL = 4;
function canPathBatch(style) {
    var hasFill = styleHasFill(style);
    var hasStroke = styleHasStroke(style);
    return !(style.lineDash
        || !(+hasFill ^ +hasStroke)
        || (hasFill && typeof style.fill !== 'string')
        || (hasStroke && typeof style.stroke !== 'string')
        || style.strokePercent < 1
        || style.strokeOpacity < 1
        || style.fillOpacity < 1);
}
function flushPathDrawn(ctx, scope) {
    scope.batchFill && ctx.fill();
    scope.batchStroke && ctx.stroke();
    scope.batchFill = '';
    scope.batchStroke = '';
}
function getStyle(el, inHover) {
    return inHover ? (el.__hoverStyle || el.style) : el.style;
}
function brushSingle(ctx, el) {
    brush(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);
}
function brush(ctx, el, scope, isLast) {
    var m = el.transform;
    if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
        el.__dirty &= ~REDRAW_BIT;
        el.__isRendered = false;
        return;
    }
    var clipPaths = el.__clipPaths;
    var prevElClipPaths = scope.prevElClipPaths;
    var forceSetTransform = false;
    var forceSetStyle = false;
    if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
        if (prevElClipPaths && prevElClipPaths.length) {
            flushPathDrawn(ctx, scope);
            ctx.restore();
            forceSetStyle = forceSetTransform = true;
            scope.prevElClipPaths = null;
            scope.allClipped = false;
            scope.prevEl = null;
        }
        if (clipPaths && clipPaths.length) {
            flushPathDrawn(ctx, scope);
            ctx.save();
            updateClipStatus(clipPaths, ctx, scope);
            forceSetTransform = true;
        }
        scope.prevElClipPaths = clipPaths;
    }
    if (scope.allClipped) {
        el.__isRendered = false;
        return;
    }
    el.beforeBrush && el.beforeBrush();
    el.innerBeforeBrush();
    var prevEl = scope.prevEl;
    if (!prevEl) {
        forceSetStyle = forceSetTransform = true;
    }
    var canBatchPath = el instanceof Path$1
        && el.autoBatch
        && canPathBatch(el.style);
    if (forceSetTransform || isTransformChanged(m, prevEl.transform)) {
        flushPathDrawn(ctx, scope);
        setContextTransform(ctx, el);
    }
    else if (!canBatchPath) {
        flushPathDrawn(ctx, scope);
    }
    var style = getStyle(el, scope.inHover);
    if (el instanceof Path$1) {
        if (scope.lastDrawType !== DRAW_TYPE_PATH) {
            forceSetStyle = true;
            scope.lastDrawType = DRAW_TYPE_PATH;
        }
        bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
        if (!canBatchPath || (!scope.batchFill && !scope.batchStroke)) {
            ctx.beginPath();
        }
        brushPath(ctx, el, style, canBatchPath);
        if (canBatchPath) {
            scope.batchFill = style.fill || '';
            scope.batchStroke = style.stroke || '';
        }
    }
    else {
        if (el instanceof TSpan$1) {
            if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
                forceSetStyle = true;
                scope.lastDrawType = DRAW_TYPE_TEXT;
            }
            bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
            brushText(ctx, el, style);
        }
        else if (el instanceof ZRImage$1) {
            if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
                forceSetStyle = true;
                scope.lastDrawType = DRAW_TYPE_IMAGE;
            }
            bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);
            brushImage(ctx, el, style);
        }
        else if (el.getTemporalDisplayables) {
            if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
                forceSetStyle = true;
                scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
            }
            brushIncremental(ctx, el, scope);
        }
    }
    if (canBatchPath && isLast) {
        flushPathDrawn(ctx, scope);
    }
    el.innerAfterBrush();
    el.afterBrush && el.afterBrush();
    scope.prevEl = el;
    el.__dirty = 0;
    el.__isRendered = true;
}
function brushIncremental(ctx, el, scope) {
    var displayables = el.getDisplayables();
    var temporalDisplayables = el.getTemporalDisplayables();
    ctx.save();
    var innerScope = {
        prevElClipPaths: null,
        prevEl: null,
        allClipped: false,
        viewWidth: scope.viewWidth,
        viewHeight: scope.viewHeight,
        inHover: scope.inHover
    };
    var i;
    var len;
    for (i = el.getCursor(), len = displayables.length; i < len; i++) {
        var displayable = displayables[i];
        displayable.beforeBrush && displayable.beforeBrush();
        displayable.innerBeforeBrush();
        brush(ctx, displayable, innerScope, i === len - 1);
        displayable.innerAfterBrush();
        displayable.afterBrush && displayable.afterBrush();
        innerScope.prevEl = displayable;
    }
    for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {
        var displayable = temporalDisplayables[i_1];
        displayable.beforeBrush && displayable.beforeBrush();
        displayable.innerBeforeBrush();
        brush(ctx, displayable, innerScope, i_1 === len_1 - 1);
        displayable.innerAfterBrush();
        displayable.afterBrush && displayable.afterBrush();
        innerScope.prevEl = displayable;
    }
    el.clearTemporalDisplayables();
    el.notClear = true;
    ctx.restore();
}

var decalMap = new WeakMap$2();
var decalCache = new LRU$1(100);
var decalKeys = ['symbol', 'symbolSize', 'symbolKeepAspect', 'color', 'backgroundColor', 'dashArrayX', 'dashArrayY', 'maxTileWidth', 'maxTileHeight'];
/**
 * Create or update pattern image from decal options
 *
 * @param {InnerDecalObject | 'none'} decalObject decal options, 'none' if no decal
 * @return {Pattern} pattern with generated image, null if no decal
 */

function createOrUpdatePatternFromDecal(decalObject, api) {
  if (decalObject === 'none') {
    return null;
  }

  var dpr = api.getDevicePixelRatio();
  var zr = api.getZr();
  var isSVG = zr.painter.type === 'svg';

  if (decalObject.dirty) {
    decalMap["delete"](decalObject);
  }

  var oldPattern = decalMap.get(decalObject);

  if (oldPattern) {
    return oldPattern;
  }

  var decalOpt = defaults(decalObject, {
    symbol: 'rect',
    symbolSize: 1,
    symbolKeepAspect: true,
    color: 'rgba(0, 0, 0, 0.2)',
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });

  if (decalOpt.backgroundColor === 'none') {
    decalOpt.backgroundColor = null;
  }

  var pattern = {
    repeat: 'repeat'
  };
  setPatternnSource(pattern);
  pattern.rotation = decalOpt.rotation;
  pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr;
  decalMap.set(decalObject, pattern);
  decalObject.dirty = false;
  return pattern;

  function setPatternnSource(pattern) {
    var keys = [dpr];
    var isValidKey = true;

    for (var i = 0; i < decalKeys.length; ++i) {
      var value = decalOpt[decalKeys[i]];

      if (value != null && !isArray$1(value) && !isString(value) && !isNumber(value) && typeof value !== 'boolean') {
        isValidKey = false;
        break;
      }

      keys.push(value);
    }

    var cacheKey;

    if (isValidKey) {
      cacheKey = keys.join(',') + (isSVG ? '-svg' : '');
      var cache = decalCache.get(cacheKey);

      if (cache) {
        isSVG ? pattern.svgElement = cache : pattern.image = cache;
      }
    }

    var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
    var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
    var symbolArray = normalizeSymbolArray(decalOpt.symbol);
    var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
    var lineBlockLengthY = getLineBlockLengthY(dashArrayY);
    var canvas = !isSVG && platformApi.createCanvas();
    var svgRoot = isSVG && {
      tag: 'g',
      attrs: {},
      key: 'dcl',
      children: []
    };
    var pSize = getPatternSize();
    var ctx;

    if (canvas) {
      canvas.width = pSize.width * dpr;
      canvas.height = pSize.height * dpr;
      ctx = canvas.getContext('2d');
    }

    brushDecal();

    if (isValidKey) {
      decalCache.put(cacheKey, canvas || svgRoot);
    }

    pattern.image = canvas;
    pattern.svgElement = svgRoot;
    pattern.svgWidth = pSize.width;
    pattern.svgHeight = pSize.height;
    /**
     * Get minumum length that can make a repeatable pattern.
     *
     * @return {Object} pattern width and height
     */

    function getPatternSize() {
      /**
       * For example, if dash is [[3, 2], [2, 1]] for X, it looks like
       * |---  ---  ---  ---  --- ...
       * |-- -- -- -- -- -- -- -- ...
       * |---  ---  ---  ---  --- ...
       * |-- -- -- -- -- -- -- -- ...
       * So the minumum length of X is 15,
       * which is the least common multiple of `3 + 2` and `2 + 1`
       * |---  ---  ---  |---  --- ...
       * |-- -- -- -- -- |-- -- -- ...
       */
      var width = 1;

      for (var i = 0, xlen = lineBlockLengthsX.length; i < xlen; ++i) {
        width = getLeastCommonMultiple(width, lineBlockLengthsX[i]);
      }

      var symbolRepeats = 1;

      for (var i = 0, xlen = symbolArray.length; i < xlen; ++i) {
        symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i].length);
      }

      width *= symbolRepeats;
      var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;

      if (process.env.NODE_ENV !== 'production') {
        var warn = function (attrName) {
          /* eslint-disable-next-line */
          console.warn("Calculated decal size is greater than " + attrName + " due to decal option settings so " + attrName + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + attrName + " to be larger to avoid incontinuity.");
        };

        if (width > decalOpt.maxTileWidth) {
          warn('maxTileWidth');
        }

        if (height > decalOpt.maxTileHeight) {
          warn('maxTileHeight');
        }
      }

      return {
        width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
        height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
      };
    }

    function brushDecal() {
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (decalOpt.backgroundColor) {
          ctx.fillStyle = decalOpt.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }

      var ySum = 0;

      for (var i = 0; i < dashArrayY.length; ++i) {
        ySum += dashArrayY[i];
      }

      if (ySum <= 0) {
        // dashArrayY is 0, draw nothing
        return;
      }

      var y = -lineBlockLengthY;
      var yId = 0;
      var yIdTotal = 0;
      var xId0 = 0;

      while (y < pSize.height) {
        if (yId % 2 === 0) {
          var symbolYId = yIdTotal / 2 % symbolArray.length;
          var x = 0;
          var xId1 = 0;
          var xId1Total = 0;

          while (x < pSize.width * 2) {
            var xSum = 0;

            for (var i = 0; i < dashArrayX[xId0].length; ++i) {
              xSum += dashArrayX[xId0][i];
            }

            if (xSum <= 0) {
              // Skip empty line
              break;
            } // E.g., [15, 5, 20, 5] draws only for 15 and 20


            if (xId1 % 2 === 0) {
              var size = (1 - decalOpt.symbolSize) * 0.5;
              var left = x + dashArrayX[xId0][xId1] * size;
              var top_1 = y + dashArrayY[yId] * size;
              var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
              var height = dashArrayY[yId] * decalOpt.symbolSize;
              var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
              brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId]);
            }

            x += dashArrayX[xId0][xId1];
            ++xId1Total;
            ++xId1;

            if (xId1 === dashArrayX[xId0].length) {
              xId1 = 0;
            }
          }

          ++xId0;

          if (xId0 === dashArrayX.length) {
            xId0 = 0;
          }
        }

        y += dashArrayY[yId];
        ++yIdTotal;
        ++yId;

        if (yId === dashArrayY.length) {
          yId = 0;
        }
      }

      function brushSymbol(x, y, width, height, symbolType) {
        var scale = isSVG ? 1 : dpr;
        var symbol = createSymbol(symbolType, x * scale, y * scale, width * scale, height * scale, decalOpt.color, decalOpt.symbolKeepAspect);

        if (isSVG) {
          var symbolVNode = zr.painter.renderOneToVNode(symbol);

          if (symbolVNode) {
            svgRoot.children.push(symbolVNode);
          }
        } else {
          // Paint to canvas for all other renderers.
          brushSingle(ctx, symbol);
        }
      }
    }
  }
}
/**
 * Convert symbol array into normalized array
 *
 * @param {string | (string | string[])[]} symbol symbol input
 * @return {string[][]} normolized symbol array
 */

function normalizeSymbolArray(symbol) {
  if (!symbol || symbol.length === 0) {
    return [['rect']];
  }

  if (isString(symbol)) {
    return [[symbol]];
  }

  var isAllString = true;

  for (var i = 0; i < symbol.length; ++i) {
    if (!isString(symbol[i])) {
      isAllString = false;
      break;
    }
  }

  if (isAllString) {
    return normalizeSymbolArray([symbol]);
  }

  var result = [];

  for (var i = 0; i < symbol.length; ++i) {
    if (isString(symbol[i])) {
      result.push([symbol[i]]);
    } else {
      result.push(symbol[i]);
    }
  }

  return result;
}
/**
 * Convert dash input into dashArray
 *
 * @param {DecalDashArrayX} dash dash input
 * @return {number[][]} normolized dash array
 */


function normalizeDashArrayX(dash) {
  if (!dash || dash.length === 0) {
    return [[0, 0]];
  }

  if (isNumber(dash)) {
    var dashValue = Math.ceil(dash);
    return [[dashValue, dashValue]];
  }
  /**
   * [20, 5] should be normalized into [[20, 5]],
   * while [20, [5, 10]] should be normalized into [[20, 20], [5, 10]]
   */


  var isAllNumber = true;

  for (var i = 0; i < dash.length; ++i) {
    if (!isNumber(dash[i])) {
      isAllNumber = false;
      break;
    }
  }

  if (isAllNumber) {
    return normalizeDashArrayX([dash]);
  }

  var result = [];

  for (var i = 0; i < dash.length; ++i) {
    if (isNumber(dash[i])) {
      var dashValue = Math.ceil(dash[i]);
      result.push([dashValue, dashValue]);
    } else {
      var dashValue = map$1(dash[i], function (n) {
        return Math.ceil(n);
      });

      if (dashValue.length % 2 === 1) {
        // [4, 2, 1] means |----  -    -- |----  -    -- |
        // so normalize it to be [4, 2, 1, 4, 2, 1]
        result.push(dashValue.concat(dashValue));
      } else {
        result.push(dashValue);
      }
    }
  }

  return result;
}
/**
 * Convert dash input into dashArray
 *
 * @param {DecalDashArrayY} dash dash input
 * @return {number[]} normolized dash array
 */


function normalizeDashArrayY(dash) {
  if (!dash || typeof dash === 'object' && dash.length === 0) {
    return [0, 0];
  }

  if (isNumber(dash)) {
    var dashValue_1 = Math.ceil(dash);
    return [dashValue_1, dashValue_1];
  }

  var dashValue = map$1(dash, function (n) {
    return Math.ceil(n);
  });
  return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
}
/**
 * Get block length of each line. A block is the length of dash line and space.
 * For example, a line with [4, 1] has a dash line of 4 and a space of 1 after
 * that, so the block length of this line is 5.
 *
 * @param {number[][]} dash dash arrary of X or Y
 * @return {number[]} block length of each line
 */


function getLineBlockLengthX(dash) {
  return map$1(dash, function (line) {
    return getLineBlockLengthY(line);
  });
}

function getLineBlockLengthY(dash) {
  var blockLength = 0;

  for (var i = 0; i < dash.length; ++i) {
    blockLength += dash[i];
  }

  if (dash.length % 2 === 1) {
    // [4, 2, 1] means |----  -    -- |----  -    -- |
    // So total length is (4 + 2 + 1) * 2
    return blockLength * 2;
  }

  return blockLength;
}

function decalVisual(ecModel, api) {
  ecModel.eachRawSeries(function (seriesModel) {
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }

    var data = seriesModel.getData();

    if (data.hasItemVisual()) {
      data.each(function (idx) {
        var decal = data.getItemVisual(idx, 'decal');

        if (decal) {
          var itemStyle = data.ensureUniqueItemVisual(idx, 'style');
          itemStyle.decal = createOrUpdatePatternFromDecal(decal, api);
        }
      });
    }

    var decal = data.getVisual('decal');

    if (decal) {
      var style = data.getVisual('style');
      style.decal = createOrUpdatePatternFromDecal(decal, api);
    }
  });
}

var lifecycle = new Eventful$1();
var lifecycle$1 = lifecycle;

// The implentations will be registered when installing the component.
// Avoid these code being bundled to the core module.

var implsStore = {}; // TODO Type

function registerImpl(name, impl) {
  if (process.env.NODE_ENV !== 'production') {
    if (implsStore[name]) {
      error("Already has an implementation of " + name + ".");
    }
  }

  implsStore[name] = impl;
}
function getImpl(name) {
  if (process.env.NODE_ENV !== 'production') {
    if (!implsStore[name]) {
      error("Implementation of " + name + " doesn't exists.");
    }
  }

  return implsStore[name];
}

var hasWindow = typeof window !== 'undefined';
var version = '5.4.0';
var dependencies = {
  zrender: '5.4.0'
};
var TEST_FRAME_REMAIN_TIME = 1;
var PRIORITY_PROCESSOR_SERIES_FILTER = 800; // Some data processors depends on the stack result dimension (to calculate data extent).
// So data stack stage should be in front of data processing stage.

var PRIORITY_PROCESSOR_DATASTACK = 900; // "Data filter" will block the stream, so it should be
// put at the begining of data processing.

var PRIORITY_PROCESSOR_FILTER = 1000;
var PRIORITY_PROCESSOR_DEFAULT = 2000;
var PRIORITY_PROCESSOR_STATISTIC = 5000;
var PRIORITY_VISUAL_LAYOUT = 1000;
var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
var PRIORITY_VISUAL_GLOBAL = 2000;
var PRIORITY_VISUAL_CHART = 3000;
var PRIORITY_VISUAL_COMPONENT = 4000; // Visual property in data. Greater than `PRIORITY_VISUAL_COMPONENT` to enable to
// overwrite the viusal result of component (like `visualMap`)
// using data item specific setting (like itemStyle.xxx on data item)

var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500; // Greater than `PRIORITY_VISUAL_CHART_DATA_CUSTOM` to enable to layout based on
// visual result like `symbolSize`.

var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
var PRIORITY_VISUAL_BRUSH = 5000;
var PRIORITY_VISUAL_ARIA = 6000;
var PRIORITY_VISUAL_DECAL = 7000;
var PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH,
    CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
    ARIA: PRIORITY_VISUAL_ARIA,
    DECAL: PRIORITY_VISUAL_DECAL
  }
}; // Main process have three entries: `setOption`, `dispatchAction` and `resize`,
// where they must not be invoked nestedly, except the only case: invoke
// dispatchAction with updateMethod "none" in main process.
// This flag is used to carry out this rule.
// All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).

var IN_MAIN_PROCESS_KEY = '__flagInMainProcess';
var PENDING_UPDATE = '__pendingUpdate';
var STATUS_NEEDS_UPDATE_KEY = '__needsUpdateStatus';
var ACTION_REG = /^[a-zA-Z0-9_]+$/;
var CONNECT_STATUS_KEY = '__connectUpdateStatus';
var CONNECT_STATUS_PENDING = 0;
var CONNECT_STATUS_UPDATING = 1;
var CONNECT_STATUS_UPDATED = 2;

function createRegisterEventWithLowercaseECharts(method) {
  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    if (this.isDisposed()) {
      disposedWarning(this.id);
      return;
    }

    return toLowercaseNameAndCallEventful(this, method, args);
  };
}

function createRegisterEventWithLowercaseMessageCenter(method) {
  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    return toLowercaseNameAndCallEventful(this, method, args);
  };
}

function toLowercaseNameAndCallEventful(host, method, args) {
  // `args[0]` is event name. Event name is all lowercase.
  args[0] = args[0] && args[0].toLowerCase();
  return Eventful$1.prototype[method].apply(host, args);
}

var MessageCenter =
/** @class */
function (_super) {
  __extends$1(MessageCenter, _super);

  function MessageCenter() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return MessageCenter;
}(Eventful$1);

var messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter('on');
messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter('off'); // ---------------------------------------
// Internal method names for class ECharts
// ---------------------------------------

var prepare;
var prepareView;
var updateDirectly;
var updateMethods;
var doConvertPixel;
var updateStreamModes;
var doDispatchAction;
var flushPendingActions;
var triggerUpdatedEvent;
var bindRenderedEvent;
var bindMouseEvent;
var render;
var renderComponents;
var renderSeries;
var createExtensionAPI;
var enableConnect;
var markStatusToUpdate;
var applyChangedStates;

var ECharts =
/** @class */
function (_super) {
  __extends$1(ECharts, _super);

  function ECharts(dom, // Theme name or themeOption.
  theme, opts) {
    var _this = _super.call(this, new ECEventProcessor()) || this;

    _this._chartsViews = [];
    _this._chartsMap = {};
    _this._componentsViews = [];
    _this._componentsMap = {}; // Can't dispatch action during rendering procedure

    _this._pendingActions = [];
    opts = opts || {}; // Get theme by name

    if (isString(theme)) {
      theme = themeStorage[theme];
    }

    _this._dom = dom;
    var defaultRenderer = 'canvas';
    var defaultCoarsePointer = 'auto';
    var defaultUseDirtyRect = false;

    if (process.env.NODE_ENV !== 'production') {
      var root =
      /* eslint-disable-next-line */
      hasWindow ? window : global;
      defaultRenderer = root.__ECHARTS__DEFAULT__RENDERER__ || defaultRenderer;
      defaultCoarsePointer = retrieve2(root.__ECHARTS__DEFAULT__COARSE_POINTER, defaultCoarsePointer);
      var devUseDirtyRect = root.__ECHARTS__DEFAULT__USE_DIRTY_RECT__;
      defaultUseDirtyRect = devUseDirtyRect == null ? defaultUseDirtyRect : devUseDirtyRect;
    }

    var zr = _this._zr = init$1(dom, {
      renderer: opts.renderer || defaultRenderer,
      devicePixelRatio: opts.devicePixelRatio,
      width: opts.width,
      height: opts.height,
      ssr: opts.ssr,
      useDirtyRect: retrieve2(opts.useDirtyRect, defaultUseDirtyRect),
      useCoarsePointer: retrieve2(opts.useCoarsePointer, defaultCoarsePointer),
      pointerSize: opts.pointerSize
    });
    _this._ssr = opts.ssr; // Expect 60 fps.

    _this._throttledZrFlush = throttle(bind$1(zr.flush, zr), 17);
    theme = clone$3(theme);
    theme && globalBackwardCompat(theme, true);
    _this._theme = theme;
    _this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
    _this._coordSysMgr = new CoordinateSystem();
    var api = _this._api = createExtensionAPI(_this); // Sort on demand

    function prioritySortFunc(a, b) {
      return a.__prio - b.__prio;
    }

    sort(visualFuncs, prioritySortFunc);
    sort(dataProcessorFuncs, prioritySortFunc);
    _this._scheduler = new Scheduler$1(_this, api, dataProcessorFuncs, visualFuncs);
    _this._messageCenter = new MessageCenter(); // Init mouse events

    _this._initEvents(); // In case some people write `window.onresize = chart.resize`


    _this.resize = bind$1(_this.resize, _this);
    zr.animation.on('frame', _this._onframe, _this);
    bindRenderedEvent(zr, _this);
    bindMouseEvent(zr, _this); // ECharts instance can be used as value.

    setAsPrimitive(_this);
    return _this;
  }

  ECharts.prototype._onframe = function () {
    if (this._disposed) {
      return;
    }

    applyChangedStates(this);
    var scheduler = this._scheduler; // Lazy update

    if (this[PENDING_UPDATE]) {
      var silent = this[PENDING_UPDATE].silent;
      this[IN_MAIN_PROCESS_KEY] = true;

      try {
        prepare(this);
        updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
      } catch (e) {
        this[IN_MAIN_PROCESS_KEY] = false;
        this[PENDING_UPDATE] = null;
        throw e;
      } // At present, in each frame, zrender performs:
      //   (1) animation step forward.
      //   (2) trigger('frame') (where this `_onframe` is called)
      //   (3) zrender flush (render).
      // If we do nothing here, since we use `setToFinal: true`, the step (3) above
      // will render the final state of the elements before the real animation started.


      this._zr.flush();

      this[IN_MAIN_PROCESS_KEY] = false;
      this[PENDING_UPDATE] = null;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    } // Avoid do both lazy update and progress in one frame.
    else if (scheduler.unfinished) {
        // Stream progress.
        var remainTime = TEST_FRAME_REMAIN_TIME;
        var ecModel = this._model;
        var api = this._api;
        scheduler.unfinished = false;

        do {
          var startTime = +new Date();
          scheduler.performSeriesTasks(ecModel); // Currently dataProcessorFuncs do not check threshold.

          scheduler.performDataProcessorTasks(ecModel);
          updateStreamModes(this, ecModel); // Do not update coordinate system here. Because that coord system update in
          // each frame is not a good user experience. So we follow the rule that
          // the extent of the coordinate system is determin in the first frame (the
          // frame is executed immedietely after task reset.
          // this._coordSysMgr.update(ecModel, api);
          // console.log('--- ec frame visual ---', remainTime);

          scheduler.performVisualTasks(ecModel);
          renderSeries(this, this._model, api, 'remain', {});
          remainTime -= +new Date() - startTime;
        } while (remainTime > 0 && scheduler.unfinished); // Call flush explicitly for trigger finished event.


        if (!scheduler.unfinished) {
          this._zr.flush();
        } // Else, zr flushing be ensue within the same frame,
        // because zr flushing is after onframe event.

      }
  };

  ECharts.prototype.getDom = function () {
    return this._dom;
  };

  ECharts.prototype.getId = function () {
    return this.id;
  };

  ECharts.prototype.getZr = function () {
    return this._zr;
  };

  ECharts.prototype.isSSR = function () {
    return this._ssr;
  };
  /* eslint-disable-next-line */


  ECharts.prototype.setOption = function (option, notMerge, lazyUpdate) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      if (process.env.NODE_ENV !== 'production') {
        error('`setOption` should not be called during main process.');
      }

      return;
    }

    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    var silent;
    var replaceMerge;
    var transitionOpt;

    if (isObject$3(notMerge)) {
      lazyUpdate = notMerge.lazyUpdate;
      silent = notMerge.silent;
      replaceMerge = notMerge.replaceMerge;
      transitionOpt = notMerge.transition;
      notMerge = notMerge.notMerge;
    }

    this[IN_MAIN_PROCESS_KEY] = true;

    if (!this._model || notMerge) {
      var optionManager = new OptionManager$1(this._api);
      var theme = this._theme;
      var ecModel = this._model = new GlobalModel$1();
      ecModel.scheduler = this._scheduler;
      ecModel.ssr = this._ssr;
      ecModel.init(null, null, null, theme, this._locale, optionManager);
    }

    this._model.setOption(option, {
      replaceMerge: replaceMerge
    }, optionPreprocessorFuncs);

    var updateParams = {
      seriesTransition: transitionOpt,
      optionChanged: true
    };

    if (lazyUpdate) {
      this[PENDING_UPDATE] = {
        silent: silent,
        updateParams: updateParams
      };
      this[IN_MAIN_PROCESS_KEY] = false; // `setOption(option, {lazyMode: true})` may be called when zrender has been slept.
      // It should wake it up to make sure zrender start to render at the next frame.

      this.getZr().wakeUp();
    } else {
      try {
        prepare(this);
        updateMethods.update.call(this, null, updateParams);
      } catch (e) {
        this[PENDING_UPDATE] = null;
        this[IN_MAIN_PROCESS_KEY] = false;
        throw e;
      } // Ensure zr refresh sychronously, and then pixel in canvas can be
      // fetched after `setOption`.


      if (!this._ssr) {
        // not use flush when using ssr mode.
        this._zr.flush();
      }

      this[PENDING_UPDATE] = null;
      this[IN_MAIN_PROCESS_KEY] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    }
  };
  /**
   * @deprecated
   */


  ECharts.prototype.setTheme = function () {
    deprecateLog('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
  }; // We don't want developers to use getModel directly.


  ECharts.prototype.getModel = function () {
    return this._model;
  };

  ECharts.prototype.getOption = function () {
    return this._model && this._model.getOption();
  };

  ECharts.prototype.getWidth = function () {
    return this._zr.getWidth();
  };

  ECharts.prototype.getHeight = function () {
    return this._zr.getHeight();
  };

  ECharts.prototype.getDevicePixelRatio = function () {
    return this._zr.painter.dpr
    /* eslint-disable-next-line */
    || hasWindow && window.devicePixelRatio || 1;
  };
  /**
   * Get canvas which has all thing rendered
   * @deprecated Use renderToCanvas instead.
   */


  ECharts.prototype.getRenderedCanvas = function (opts) {
    if (process.env.NODE_ENV !== 'production') {
      deprecateReplaceLog('getRenderedCanvas', 'renderToCanvas');
    }

    return this.renderToCanvas(opts);
  };

  ECharts.prototype.renderToCanvas = function (opts) {
    opts = opts || {};
    var painter = this._zr.painter;

    if (process.env.NODE_ENV !== 'production') {
      if (painter.type !== 'canvas') {
        throw new Error('renderToCanvas can only be used in the canvas renderer.');
      }
    }

    return painter.getRenderedCanvas({
      backgroundColor: opts.backgroundColor || this._model.get('backgroundColor'),
      pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
    });
  };

  ECharts.prototype.renderToSVGString = function (opts) {
    opts = opts || {};
    var painter = this._zr.painter;

    if (process.env.NODE_ENV !== 'production') {
      if (painter.type !== 'svg') {
        throw new Error('renderToSVGString can only be used in the svg renderer.');
      }
    }

    return painter.renderToString({
      useViewBox: opts.useViewBox
    });
  };
  /**
   * Get svg data url
   */


  ECharts.prototype.getSvgDataURL = function () {
    if (!env$1.svgSupported) {
      return;
    }

    var zr = this._zr;
    var list = zr.storage.getDisplayList(); // Stop animations

    each$9(list, function (el) {
      el.stopAnimation(null, true);
    });
    return zr.painter.toDataURL();
  };

  ECharts.prototype.getDataURL = function (opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    opts = opts || {};
    var excludeComponents = opts.excludeComponents;
    var ecModel = this._model;
    var excludesComponentViews = [];
    var self = this;
    each$9(excludeComponents, function (componentType) {
      ecModel.eachComponent({
        mainType: componentType
      }, function (component) {
        var view = self._componentsMap[component.__viewId];

        if (!view.group.ignore) {
          excludesComponentViews.push(view);
          view.group.ignore = true;
        }
      });
    });
    var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));
    each$9(excludesComponentViews, function (view) {
      view.group.ignore = false;
    });
    return url;
  };

  ECharts.prototype.getConnectedDataURL = function (opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    var isSvg = opts.type === 'svg';
    var groupId = this.group;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var MAX_NUMBER = Infinity;

    if (connectedGroups[groupId]) {
      var left_1 = MAX_NUMBER;
      var top_1 = MAX_NUMBER;
      var right_1 = -MAX_NUMBER;
      var bottom_1 = -MAX_NUMBER;
      var canvasList_1 = [];
      var dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio();
      each$9(instances, function (chart, id) {
        if (chart.group === groupId) {
          var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone$3(opts));
          var boundingRect = chart.getDom().getBoundingClientRect();
          left_1 = mathMin(boundingRect.left, left_1);
          top_1 = mathMin(boundingRect.top, top_1);
          right_1 = mathMax(boundingRect.right, right_1);
          bottom_1 = mathMax(boundingRect.bottom, bottom_1);
          canvasList_1.push({
            dom: canvas,
            left: boundingRect.left,
            top: boundingRect.top
          });
        }
      });
      left_1 *= dpr_1;
      top_1 *= dpr_1;
      right_1 *= dpr_1;
      bottom_1 *= dpr_1;
      var width = right_1 - left_1;
      var height = bottom_1 - top_1;
      var targetCanvas = platformApi.createCanvas();
      var zr_1 = init$1(targetCanvas, {
        renderer: isSvg ? 'svg' : 'canvas'
      });
      zr_1.resize({
        width: width,
        height: height
      });

      if (isSvg) {
        var content_1 = '';
        each$9(canvasList_1, function (item) {
          var x = item.left - left_1;
          var y = item.top - top_1;
          content_1 += '<g transform="translate(' + x + ',' + y + ')">' + item.dom + '</g>';
        });
        zr_1.painter.getSvgRoot().innerHTML = content_1;

        if (opts.connectedBackgroundColor) {
          zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);
        }

        zr_1.refreshImmediately();
        return zr_1.painter.toDataURL();
      } else {
        // Background between the charts
        if (opts.connectedBackgroundColor) {
          zr_1.add(new Rect$1({
            shape: {
              x: 0,
              y: 0,
              width: width,
              height: height
            },
            style: {
              fill: opts.connectedBackgroundColor
            }
          }));
        }

        each$9(canvasList_1, function (item) {
          var img = new ZRImage$1({
            style: {
              x: item.left * dpr_1 - left_1,
              y: item.top * dpr_1 - top_1,
              image: item.dom
            }
          });
          zr_1.add(img);
        });
        zr_1.refreshImmediately();
        return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));
      }
    } else {
      return this.getDataURL(opts);
    }
  };

  ECharts.prototype.convertToPixel = function (finder, value) {
    return doConvertPixel(this, 'convertToPixel', finder, value);
  };

  ECharts.prototype.convertFromPixel = function (finder, value) {
    return doConvertPixel(this, 'convertFromPixel', finder, value);
  };
  /**
   * Is the specified coordinate systems or components contain the given pixel point.
   * @param {Array|number} value
   * @return {boolean} result
   */


  ECharts.prototype.containPixel = function (finder, value) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    var ecModel = this._model;
    var result;
    var findResult = parseFinder(ecModel, finder);
    each$9(findResult, function (models, key) {
      key.indexOf('Models') >= 0 && each$9(models, function (model) {
        var coordSys = model.coordinateSystem;

        if (coordSys && coordSys.containPoint) {
          result = result || !!coordSys.containPoint(value);
        } else if (key === 'seriesModels') {
          var view = this._chartsMap[model.__viewId];

          if (view && view.containPoint) {
            result = result || view.containPoint(value, model);
          } else {
            if (process.env.NODE_ENV !== 'production') {
              console.warn(key + ': ' + (view ? 'The found component do not support containPoint.' : 'No view mapping to the found component.'));
            }
          }
        } else {
          if (process.env.NODE_ENV !== 'production') {
            console.warn(key + ': containPoint is not supported');
          }
        }
      }, this);
    }, this);
    return !!result;
  };
  /**
   * Get visual from series or data.
   * @param finder
   *        If string, e.g., 'series', means {seriesIndex: 0}.
   *        If Object, could contain some of these properties below:
   *        {
   *            seriesIndex / seriesId / seriesName,
   *            dataIndex / dataIndexInside
   *        }
   *        If dataIndex is not specified, series visual will be fetched,
   *        but not data item visual.
   *        If all of seriesIndex, seriesId, seriesName are not specified,
   *        visual will be fetched from first series.
   * @param visualType 'color', 'symbol', 'symbolSize'
   */


  ECharts.prototype.getVisual = function (finder, visualType) {
    var ecModel = this._model;
    var parsedFinder = parseFinder(ecModel, finder, {
      defaultMainType: 'series'
    });
    var seriesModel = parsedFinder.seriesModel;

    if (process.env.NODE_ENV !== 'production') {
      if (!seriesModel) {
        console.warn('There is no specified seires model');
      }
    }

    var data = seriesModel.getData();
    var dataIndexInside = parsedFinder.hasOwnProperty('dataIndexInside') ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
    return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);
  };
  /**
   * Get view of corresponding component model
   */


  ECharts.prototype.getViewOfComponentModel = function (componentModel) {
    return this._componentsMap[componentModel.__viewId];
  };
  /**
   * Get view of corresponding series model
   */


  ECharts.prototype.getViewOfSeriesModel = function (seriesModel) {
    return this._chartsMap[seriesModel.__viewId];
  };

  ECharts.prototype._initEvents = function () {
    var _this = this;

    each$9(MOUSE_EVENT_NAMES, function (eveName) {
      var handler = function (e) {
        var ecModel = _this.getModel();

        var el = e.target;
        var params;
        var isGlobalOut = eveName === 'globalout'; // no e.target when 'globalout'.

        if (isGlobalOut) {
          params = {};
        } else {
          el && findEventDispatcher(el, function (parent) {
            var ecData = getECData(parent);

            if (ecData && ecData.dataIndex != null) {
              var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
              params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType) || {};
              return true;
            } // If element has custom eventData of components
            else if (ecData.eventData) {
                params = extend$2({}, ecData.eventData);
                return true;
              }
          }, true);
        } // Contract: if params prepared in mouse event,
        // these properties must be specified:
        // {
        //    componentType: string (component main type)
        //    componentIndex: number
        // }
        // Otherwise event query can not work.


        if (params) {
          var componentType = params.componentType;
          var componentIndex = params.componentIndex; // Special handling for historic reason: when trigger by
          // markLine/markPoint/markArea, the componentType is
          // 'markLine'/'markPoint'/'markArea', but we should better
          // enable them to be queried by seriesIndex, since their
          // option is set in each series.

          if (componentType === 'markLine' || componentType === 'markPoint' || componentType === 'markArea') {
            componentType = 'series';
            componentIndex = params.seriesIndex;
          }

          var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
          var view = model && _this[model.mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId];

          if (process.env.NODE_ENV !== 'production') {
            // `event.componentType` and `event[componentTpype + 'Index']` must not
            // be missed, otherwise there is no way to distinguish source component.
            // See `dataFormat.getDataParams`.
            if (!isGlobalOut && !(model && view)) {
              console.warn('model or view can not be found by params');
            }
          }

          params.event = e;
          params.type = eveName;
          _this._$eventProcessor.eventInfo = {
            targetEl: el,
            packedEvent: params,
            model: model,
            view: view
          };

          _this.trigger(eveName, params);
        }
      }; // Consider that some component (like tooltip, brush, ...)
      // register zr event handler, but user event handler might
      // do anything, such as call `setOption` or `dispatchAction`,
      // which probably update any of the content and probably
      // cause problem if it is called previous other inner handlers.


      handler.zrEventfulCallAtLast = true;

      _this._zr.on(eveName, handler, _this);
    });
    each$9(eventActionMap, function (actionType, eventType) {
      _this._messageCenter.on(eventType, function (event) {
        this.trigger(eventType, event);
      }, _this);
    }); // Extra events
    // TODO register?

    each$9(['selectchanged'], function (eventType) {
      _this._messageCenter.on(eventType, function (event) {
        this.trigger(eventType, event);
      }, _this);
    });
    handleLegacySelectEvents(this._messageCenter, this, this._api);
  };

  ECharts.prototype.isDisposed = function () {
    return this._disposed;
  };

  ECharts.prototype.clear = function () {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    this.setOption({
      series: []
    }, true);
  };

  ECharts.prototype.dispose = function () {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    this._disposed = true;
    var dom = this.getDom();

    if (dom) {
      setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, '');
    }

    var chart = this;
    var api = chart._api;
    var ecModel = chart._model;
    each$9(chart._componentsViews, function (component) {
      component.dispose(ecModel, api);
    });
    each$9(chart._chartsViews, function (chart) {
      chart.dispose(ecModel, api);
    }); // Dispose after all views disposed

    chart._zr.dispose(); // Set properties to null.
    // To reduce the memory cost in case the top code still holds this instance unexpectedly.


    chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
    delete instances[chart.id];
  };
  /**
   * Resize the chart
   */


  ECharts.prototype.resize = function (opts) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      if (process.env.NODE_ENV !== 'production') {
        error('`resize` should not be called during main process.');
      }

      return;
    }

    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    this._zr.resize(opts);

    var ecModel = this._model; // Resize loading effect

    this._loadingFX && this._loadingFX.resize();

    if (!ecModel) {
      return;
    }

    var needPrepare = ecModel.resetOption('media');
    var silent = opts && opts.silent; // There is some real cases that:
    // chart.setOption(option, { lazyUpdate: true });
    // chart.resize();

    if (this[PENDING_UPDATE]) {
      if (silent == null) {
        silent = this[PENDING_UPDATE].silent;
      }

      needPrepare = true;
      this[PENDING_UPDATE] = null;
    }

    this[IN_MAIN_PROCESS_KEY] = true;

    try {
      needPrepare && prepare(this);
      updateMethods.update.call(this, {
        type: 'resize',
        animation: extend$2({
          // Disable animation
          duration: 0
        }, opts && opts.animation)
      });
    } catch (e) {
      this[IN_MAIN_PROCESS_KEY] = false;
      throw e;
    }

    this[IN_MAIN_PROCESS_KEY] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };

  ECharts.prototype.showLoading = function (name, cfg) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    if (isObject$3(name)) {
      cfg = name;
      name = '';
    }

    name = name || 'default';
    this.hideLoading();

    if (!loadingEffects[name]) {
      if (process.env.NODE_ENV !== 'production') {
        console.warn('Loading effects ' + name + ' not exists.');
      }

      return;
    }

    var el = loadingEffects[name](this._api, cfg);
    var zr = this._zr;
    this._loadingFX = el;
    zr.add(el);
  };
  /**
   * Hide loading effect
   */


  ECharts.prototype.hideLoading = function () {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    this._loadingFX && this._zr.remove(this._loadingFX);
    this._loadingFX = null;
  };

  ECharts.prototype.makeActionFromEvent = function (eventObj) {
    var payload = extend$2({}, eventObj);
    payload.type = eventActionMap[eventObj.type];
    return payload;
  };
  /**
   * @param opt If pass boolean, means opt.silent
   * @param opt.silent Default `false`. Whether trigger events.
   * @param opt.flush Default `undefined`.
   *        true: Flush immediately, and then pixel in canvas can be fetched
   *            immediately. Caution: it might affect performance.
   *        false: Not flush.
   *        undefined: Auto decide whether perform flush.
   */


  ECharts.prototype.dispatchAction = function (payload, opt) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    if (!isObject$3(opt)) {
      opt = {
        silent: !!opt
      };
    }

    if (!actions[payload.type]) {
      return;
    } // Avoid dispatch action before setOption. Especially in `connect`.


    if (!this._model) {
      return;
    } // May dispatchAction in rendering procedure


    if (this[IN_MAIN_PROCESS_KEY]) {
      this._pendingActions.push(payload);

      return;
    }

    var silent = opt.silent;
    doDispatchAction.call(this, payload, silent);
    var flush = opt.flush;

    if (flush) {
      this._zr.flush();
    } else if (flush !== false && env$1.browser.weChat) {
      // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`
      // hang when sliding page (on touch event), which cause that zr does not
      // refresh util user interaction finished, which is not expected.
      // But `dispatchAction` may be called too frequently when pan on touch
      // screen, which impacts performance if do not throttle them.
      this._throttledZrFlush();
    }

    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };

  ECharts.prototype.updateLabelLayout = function () {
    lifecycle$1.trigger('series:layoutlabels', this._model, this._api, {
      // Not adding series labels.
      // TODO
      updatedSeries: []
    });
  };

  ECharts.prototype.appendData = function (params) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }

    var seriesIndex = params.seriesIndex;
    var ecModel = this.getModel();
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);

    if (process.env.NODE_ENV !== 'production') {
      assert(params.data && seriesModel);
    }

    seriesModel.appendData(params); // Note: `appendData` does not support that update extent of coordinate
    // system, util some scenario require that. In the expected usage of
    // `appendData`, the initial extent of coordinate system should better
    // be fixed by axis `min`/`max` setting or initial data, otherwise if
    // the extent changed while `appendData`, the location of the painted
    // graphic elements have to be changed, which make the usage of
    // `appendData` meaningless.

    this._scheduler.unfinished = true;
    this.getZr().wakeUp();
  }; // A work around for no `internal` modifier in ts yet but
  // need to strictly hide private methods to JS users.


  ECharts.internalField = function () {
    prepare = function (ecIns) {
      var scheduler = ecIns._scheduler;
      scheduler.restorePipelines(ecIns._model);
      scheduler.prepareStageTasks();
      prepareView(ecIns, true);
      prepareView(ecIns, false);
      scheduler.plan();
    };
    /**
     * Prepare view instances of charts and components
     */


    prepareView = function (ecIns, isComponent) {
      var ecModel = ecIns._model;
      var scheduler = ecIns._scheduler;
      var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
      var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
      var zr = ecIns._zr;
      var api = ecIns._api;

      for (var i = 0; i < viewList.length; i++) {
        viewList[i].__alive = false;
      }

      isComponent ? ecModel.eachComponent(function (componentType, model) {
        componentType !== 'series' && doPrepare(model);
      }) : ecModel.eachSeries(doPrepare);

      function doPrepare(model) {
        // By defaut view will be reused if possible for the case that `setOption` with "notMerge"
        // mode and need to enable transition animation. (Usually, when they have the same id, or
        // especially no id but have the same type & name & index. See the `model.id` generation
        // rule in `makeIdAndName` and `viewId` generation rule here).
        // But in `replaceMerge` mode, this feature should be able to disabled when it is clear that
        // the new model has nothing to do with the old model.
        var requireNewView = model.__requireNewView; // This command should not work twice.

        model.__requireNewView = false; // Consider: id same and type changed.

        var viewId = '_ec_' + model.id + '_' + model.type;
        var view = !requireNewView && viewMap[viewId];

        if (!view) {
          var classType = parseClassType(model.type);
          var Clazz = isComponent ? ComponentView$1.getClass(classType.main, classType.sub) : // FIXME:TS
          // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
          // For backward compat, still support a chart type declared as only subType
          // like "liquidfill", but recommend "series.liquidfill"
          // But need a base class to make a type series.
          ChartView$1.getClass(classType.sub);

          if (process.env.NODE_ENV !== 'production') {
            assert(Clazz, classType.sub + ' does not exist.');
          }

          view = new Clazz();
          view.init(ecModel, api);
          viewMap[viewId] = view;
          viewList.push(view);
          zr.add(view.group);
        }

        model.__viewId = view.__id = viewId;
        view.__alive = true;
        view.__model = model;
        view.group.__ecComponentInfo = {
          mainType: model.mainType,
          index: model.componentIndex
        };
        !isComponent && scheduler.prepareView(view, model, ecModel, api);
      }

      for (var i = 0; i < viewList.length;) {
        var view = viewList[i];

        if (!view.__alive) {
          !isComponent && view.renderTask.dispose();
          zr.remove(view.group);
          view.dispose(ecModel, api);
          viewList.splice(i, 1);

          if (viewMap[view.__id] === view) {
            delete viewMap[view.__id];
          }

          view.__id = view.group.__ecComponentInfo = null;
        } else {
          i++;
        }
      }
    };

    updateDirectly = function (ecIns, method, payload, mainType, subType) {
      var ecModel = ecIns._model;
      ecModel.setUpdatePayload(payload); // broadcast

      if (!mainType) {
        // FIXME
        // Chart will not be update directly here, except set dirty.
        // But there is no such scenario now.
        each$9([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
        return;
      }

      var query = {};
      query[mainType + 'Id'] = payload[mainType + 'Id'];
      query[mainType + 'Index'] = payload[mainType + 'Index'];
      query[mainType + 'Name'] = payload[mainType + 'Name'];
      var condition = {
        mainType: mainType,
        query: query
      };
      subType && (condition.subType = subType); // subType may be '' by parseClassType;

      var excludeSeriesId = payload.excludeSeriesId;
      var excludeSeriesIdMap;

      if (excludeSeriesId != null) {
        excludeSeriesIdMap = createHashMap();
        each$9(normalizeToArray(excludeSeriesId), function (id) {
          var modelId = convertOptionIdName(id, null);

          if (modelId != null) {
            excludeSeriesIdMap.set(modelId, true);
          }
        });
      } // If dispatchAction before setOption, do nothing.


      ecModel && ecModel.eachComponent(condition, function (model) {
        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null;

        if (isExcluded) {
          return;
        }

        if (isHighDownPayload(payload)) {
          if (model instanceof SeriesModel$1) {
            if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(['emphasis', 'disabled'])) {
              blurSeriesFromHighlightPayload(model, payload, ecIns._api);
            }
          } else {
            var _a = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api),
                focusSelf = _a.focusSelf,
                dispatchers = _a.dispatchers;

            if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) {
              blurComponent(model.mainType, model.componentIndex, ecIns._api);
            } // PENDING:
            // Whether to put this "enter emphasis" code in `ComponentView`,
            // which will be the same as `ChartView` but might be not necessary
            // and will be far from this logic.


            if (dispatchers) {
              each$9(dispatchers, function (dispatcher) {
                payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
              });
            }
          }
        } else if (isSelectChangePayload(payload)) {
          // TODO geo
          if (model instanceof SeriesModel$1) {
            toggleSelectionFromPayload(model, payload, ecIns._api);
            updateSeriesElementSelection(model);
            markStatusToUpdate(ecIns);
          }
        }
      }, ecIns);
      ecModel && ecModel.eachComponent(condition, function (model) {
        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null;

        if (isExcluded) {
          return;
        }
        callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);
      }, ecIns);

      function callView(view) {
        view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
      }
    };

    updateMethods = {
      prepareAndUpdate: function (payload) {
        prepare(this);
        updateMethods.update.call(this, payload, {
          // Needs to mark option changed if newOption is given.
          // It's from MagicType.
          // TODO If use a separate flag optionChanged in payload?
          optionChanged: payload.newOption != null
        });
      },
      update: function (payload, updateParams) {
        var ecModel = this._model;
        var api = this._api;
        var zr = this._zr;
        var coordSysMgr = this._coordSysMgr;
        var scheduler = this._scheduler; // update before setOption

        if (!ecModel) {
          return;
        }

        ecModel.setUpdatePayload(payload);
        scheduler.restoreData(ecModel, payload);
        scheduler.performSeriesTasks(ecModel); // TODO
        // Save total ecModel here for undo/redo (after restoring data and before processing data).
        // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.
        // Create new coordinate system each update
        // In LineView may save the old coordinate system and use it to get the orignal point

        coordSysMgr.create(ecModel, api);
        scheduler.performDataProcessorTasks(ecModel, payload); // Current stream render is not supported in data process. So we can update
        // stream modes after data processing, where the filtered data is used to
        // deteming whether use progressive rendering.

        updateStreamModes(this, ecModel); // We update stream modes before coordinate system updated, then the modes info
        // can be fetched when coord sys updating (consider the barGrid extent fix). But
        // the drawback is the full coord info can not be fetched. Fortunately this full
        // coord is not requied in stream mode updater currently.

        coordSysMgr.update(ecModel, api);
        clearColorPalette(ecModel);
        scheduler.performVisualTasks(ecModel, payload);
        render(this, ecModel, api, payload, updateParams); // Set background

        var backgroundColor = ecModel.get('backgroundColor') || 'transparent';
        var darkMode = ecModel.get('darkMode');
        zr.setBackgroundColor(backgroundColor); // Force set dark mode.

        if (darkMode != null && darkMode !== 'auto') {
          zr.setDarkMode(darkMode);
        }

        lifecycle$1.trigger('afterupdate', ecModel, api);
      },
      updateTransform: function (payload) {
        var _this = this;

        var ecModel = this._model;
        var api = this._api; // update before setOption

        if (!ecModel) {
          return;
        }

        ecModel.setUpdatePayload(payload); // ChartView.markUpdateMethod(payload, 'updateTransform');

        var componentDirtyList = [];
        ecModel.eachComponent(function (componentType, componentModel) {
          if (componentType === 'series') {
            return;
          }

          var componentView = _this.getViewOfComponentModel(componentModel);

          if (componentView && componentView.__alive) {
            if (componentView.updateTransform) {
              var result = componentView.updateTransform(componentModel, ecModel, api, payload);
              result && result.update && componentDirtyList.push(componentView);
            } else {
              componentDirtyList.push(componentView);
            }
          }
        });
        var seriesDirtyMap = createHashMap();
        ecModel.eachSeries(function (seriesModel) {
          var chartView = _this._chartsMap[seriesModel.__viewId];

          if (chartView.updateTransform) {
            var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
            result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
          } else {
            seriesDirtyMap.set(seriesModel.uid, 1);
          }
        });
        clearColorPalette(ecModel); // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
        // this._scheduler.performVisualTasks(ecModel, payload, 'layout', true);

        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true,
          dirtyMap: seriesDirtyMap
        }); // Currently, not call render of components. Geo render cost a lot.
        // renderComponents(ecIns, ecModel, api, payload, componentDirtyList);


        renderSeries(this, ecModel, api, payload, {}, seriesDirtyMap);
        lifecycle$1.trigger('afterupdate', ecModel, api);
      },
      updateView: function (payload) {
        var ecModel = this._model; // update before setOption

        if (!ecModel) {
          return;
        }

        ecModel.setUpdatePayload(payload);
        ChartView$1.markUpdateMethod(payload, 'updateView');
        clearColorPalette(ecModel); // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.

        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true
        });

        render(this, ecModel, this._api, payload, {});
        lifecycle$1.trigger('afterupdate', ecModel, this._api);
      },
      updateVisual: function (payload) {
        // updateMethods.update.call(this, payload);
        var _this = this;

        var ecModel = this._model; // update before setOption

        if (!ecModel) {
          return;
        }

        ecModel.setUpdatePayload(payload); // clear all visual

        ecModel.eachSeries(function (seriesModel) {
          seriesModel.getData().clearAllVisual();
        }); // Perform visual

        ChartView$1.markUpdateMethod(payload, 'updateVisual');
        clearColorPalette(ecModel); // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.

        this._scheduler.performVisualTasks(ecModel, payload, {
          visualType: 'visual',
          setDirty: true
        });

        ecModel.eachComponent(function (componentType, componentModel) {
          if (componentType !== 'series') {
            var componentView = _this.getViewOfComponentModel(componentModel);

            componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);
          }
        });
        ecModel.eachSeries(function (seriesModel) {
          var chartView = _this._chartsMap[seriesModel.__viewId];
          chartView.updateVisual(seriesModel, ecModel, _this._api, payload);
        });
        lifecycle$1.trigger('afterupdate', ecModel, this._api);
      },
      updateLayout: function (payload) {
        updateMethods.update.call(this, payload);
      }
    };

    doConvertPixel = function (ecIns, methodName, finder, value) {
      if (ecIns._disposed) {
        disposedWarning(ecIns.id);
        return;
      }

      var ecModel = ecIns._model;

      var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();

      var result;
      var parsedFinder = parseFinder(ecModel, finder);

      for (var i = 0; i < coordSysList.length; i++) {
        var coordSys = coordSysList[i];

        if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value)) != null) {
          return result;
        }
      }

      if (process.env.NODE_ENV !== 'production') {
        console.warn('No coordinate system that supports ' + methodName + ' found by the given finder.');
      }
    };

    updateStreamModes = function (ecIns, ecModel) {
      var chartsMap = ecIns._chartsMap;
      var scheduler = ecIns._scheduler;
      ecModel.eachSeries(function (seriesModel) {
        scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
      });
    };

    doDispatchAction = function (payload, silent) {
      var _this = this;

      var ecModel = this.getModel();
      var payloadType = payload.type;
      var escapeConnect = payload.escapeConnect;
      var actionWrap = actions[payloadType];
      var actionInfo = actionWrap.actionInfo;
      var cptTypeTmp = (actionInfo.update || 'update').split(':');
      var updateMethod = cptTypeTmp.pop();
      var cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
      this[IN_MAIN_PROCESS_KEY] = true;
      var payloads = [payload];
      var batched = false; // Batch action

      if (payload.batch) {
        batched = true;
        payloads = map$1(payload.batch, function (item) {
          item = defaults(extend$2({}, item), payload);
          item.batch = null;
          return item;
        });
      }

      var eventObjBatch = [];
      var eventObj;
      var isSelectChange = isSelectChangePayload(payload);
      var isHighDown = isHighDownPayload(payload); // Only leave blur once if there are multiple batches.

      if (isHighDown) {
        allLeaveBlur(this._api);
      }

      each$9(payloads, function (batchItem) {
        // Action can specify the event by return it.
        eventObj = actionWrap.action(batchItem, _this._model, _this._api); // Emit event outside

        eventObj = eventObj || extend$2({}, batchItem); // Convert type to eventType

        eventObj.type = actionInfo.event || eventObj.type;
        eventObjBatch.push(eventObj); // light update does not perform data process, layout and visual.

        if (isHighDown) {
          var _a = preParseFinder(payload),
              queryOptionMap = _a.queryOptionMap,
              mainTypeSpecified = _a.mainTypeSpecified;

          var componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : 'series';
          updateDirectly(_this, updateMethod, batchItem, componentMainType);
          markStatusToUpdate(_this);
        } else if (isSelectChange) {
          // At present `dispatchAction({ type: 'select', ... })` is not supported on components.
          // geo still use 'geoselect'.
          updateDirectly(_this, updateMethod, batchItem, 'series');
          markStatusToUpdate(_this);
        } else if (cptType) {
          updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);
        }
      });

      if (updateMethod !== 'none' && !isHighDown && !isSelectChange && !cptType) {
        try {
          // Still dirty
          if (this[PENDING_UPDATE]) {
            prepare(this);
            updateMethods.update.call(this, payload);
            this[PENDING_UPDATE] = null;
          } else {
            updateMethods[updateMethod].call(this, payload);
          }
        } catch (e) {
          this[IN_MAIN_PROCESS_KEY] = false;
          throw e;
        }
      } // Follow the rule of action batch


      if (batched) {
        eventObj = {
          type: actionInfo.event || payloadType,
          escapeConnect: escapeConnect,
          batch: eventObjBatch
        };
      } else {
        eventObj = eventObjBatch[0];
      }

      this[IN_MAIN_PROCESS_KEY] = false;

      if (!silent) {
        var messageCenter = this._messageCenter;
        messageCenter.trigger(eventObj.type, eventObj); // Extra triggered 'selectchanged' event

        if (isSelectChange) {
          var newObj = {
            type: 'selectchanged',
            escapeConnect: escapeConnect,
            selected: getAllSelectedIndices(ecModel),
            isFromClick: payload.isFromClick || false,
            fromAction: payload.type,
            fromActionPayload: payload
          };
          messageCenter.trigger(newObj.type, newObj);
        }
      }
    };

    flushPendingActions = function (silent) {
      var pendingActions = this._pendingActions;

      while (pendingActions.length) {
        var payload = pendingActions.shift();
        doDispatchAction.call(this, payload, silent);
      }
    };

    triggerUpdatedEvent = function (silent) {
      !silent && this.trigger('updated');
    };
    /**
     * Event `rendered` is triggered when zr
     * rendered. It is useful for realtime
     * snapshot (reflect animation).
     *
     * Event `finished` is triggered when:
     * (1) zrender rendering finished.
     * (2) initial animation finished.
     * (3) progressive rendering finished.
     * (4) no pending action.
     * (5) no delayed setOption needs to be processed.
     */


    bindRenderedEvent = function (zr, ecIns) {
      zr.on('rendered', function (params) {
        ecIns.trigger('rendered', params); // The `finished` event should not be triggered repeatly,
        // so it should only be triggered when rendering indeed happend
        // in zrender. (Consider the case that dipatchAction is keep
        // triggering when mouse move).

        if ( // Although zr is dirty if initial animation is not finished
        // and this checking is called on frame, we also check
        // animation finished for robustness.
        zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
          ecIns.trigger('finished');
        }
      });
    };

    bindMouseEvent = function (zr, ecIns) {
      zr.on('mouseover', function (e) {
        var el = e.target;
        var dispatcher = findEventDispatcher(el, isHighDownDispatcher);

        if (dispatcher) {
          handleGlobalMouseOverForHighDown(dispatcher, e, ecIns._api);
          markStatusToUpdate(ecIns);
        }
      }).on('mouseout', function (e) {
        var el = e.target;
        var dispatcher = findEventDispatcher(el, isHighDownDispatcher);

        if (dispatcher) {
          handleGlobalMouseOutForHighDown(dispatcher, e, ecIns._api);
          markStatusToUpdate(ecIns);
        }
      }).on('click', function (e) {
        var el = e.target;
        var dispatcher = findEventDispatcher(el, function (target) {
          return getECData(target).dataIndex != null;
        }, true);

        if (dispatcher) {
          var actionType = dispatcher.selected ? 'unselect' : 'select';
          var ecData = getECData(dispatcher);

          ecIns._api.dispatchAction({
            type: actionType,
            dataType: ecData.dataType,
            dataIndexInside: ecData.dataIndex,
            seriesIndex: ecData.seriesIndex,
            isFromClick: true
          });
        }
      });
    };

    function clearColorPalette(ecModel) {
      ecModel.clearColorPalette();
      ecModel.eachSeries(function (seriesModel) {
        seriesModel.clearColorPalette();
      });
    }

    function allocateZlevels(ecModel) {
      var componentZLevels = [];
      var seriesZLevels = [];
      var hasSeperateZLevel = false;
      ecModel.eachComponent(function (componentType, componentModel) {
        var zlevel = componentModel.get('zlevel') || 0;
        var z = componentModel.get('z') || 0;
        var zlevelKey = componentModel.getZLevelKey();
        hasSeperateZLevel = hasSeperateZLevel || !!zlevelKey;
        (componentType === 'series' ? seriesZLevels : componentZLevels).push({
          zlevel: zlevel,
          z: z,
          idx: componentModel.componentIndex,
          type: componentType,
          key: zlevelKey
        });
      });

      if (hasSeperateZLevel) {
        // Series after component
        var zLevels = componentZLevels.concat(seriesZLevels);
        var lastSeriesZLevel_1;
        var lastSeriesKey_1;
        sort(zLevels, function (a, b) {
          if (a.zlevel === b.zlevel) {
            return a.z - b.z;
          }

          return a.zlevel - b.zlevel;
        });
        each$9(zLevels, function (item) {
          var componentModel = ecModel.getComponent(item.type, item.idx);
          var zlevel = item.zlevel;
          var key = item.key;

          if (lastSeriesZLevel_1 != null) {
            zlevel = Math.max(lastSeriesZLevel_1, zlevel);
          }

          if (key) {
            if (zlevel === lastSeriesZLevel_1 && key !== lastSeriesKey_1) {
              zlevel++;
            }

            lastSeriesKey_1 = key;
          } else if (lastSeriesKey_1) {
            if (zlevel === lastSeriesZLevel_1) {
              zlevel++;
            }

            lastSeriesKey_1 = '';
          }

          lastSeriesZLevel_1 = zlevel;
          componentModel.setZLevel(zlevel);
        });
      }
    }

    render = function (ecIns, ecModel, api, payload, updateParams) {
      allocateZlevels(ecModel);
      renderComponents(ecIns, ecModel, api, payload, updateParams);
      each$9(ecIns._chartsViews, function (chart) {
        chart.__alive = false;
      });
      renderSeries(ecIns, ecModel, api, payload, updateParams); // Remove groups of unrendered charts

      each$9(ecIns._chartsViews, function (chart) {
        if (!chart.__alive) {
          chart.remove(ecModel, api);
        }
      });
    };

    renderComponents = function (ecIns, ecModel, api, payload, updateParams, dirtyList) {
      each$9(dirtyList || ecIns._componentsViews, function (componentView) {
        var componentModel = componentView.__model;
        clearStates(componentModel, componentView);
        componentView.render(componentModel, ecModel, api, payload);
        updateZ(componentModel, componentView);
        updateStates(componentModel, componentView);
      });
    };
    /**
     * Render each chart and component
     */


    renderSeries = function (ecIns, ecModel, api, payload, updateParams, dirtyMap) {
      // Render all charts
      var scheduler = ecIns._scheduler;
      updateParams = extend$2(updateParams || {}, {
        updatedSeries: ecModel.getSeries()
      }); // TODO progressive?

      lifecycle$1.trigger('series:beforeupdate', ecModel, api, updateParams);
      var unfinished = false;
      ecModel.eachSeries(function (seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        chartView.__alive = true;
        var renderTask = chartView.renderTask;
        scheduler.updatePayload(renderTask, payload); // TODO states on marker.

        clearStates(seriesModel, chartView);

        if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
          renderTask.dirty();
        }

        if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
          unfinished = true;
        }

        chartView.group.silent = !!seriesModel.get('silent'); // Should not call markRedraw on group, because it will disable zrender
        // increamental render (alway render from the __startIndex each frame)
        // chartView.group.markRedraw();

        updateBlend(seriesModel, chartView);
        updateSeriesElementSelection(seriesModel);
      });
      scheduler.unfinished = unfinished || scheduler.unfinished;
      lifecycle$1.trigger('series:layoutlabels', ecModel, api, updateParams); // transition after label is layouted.

      lifecycle$1.trigger('series:transition', ecModel, api, updateParams);
      ecModel.eachSeries(function (seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId]; // Update Z after labels updated. Before applying states.

        updateZ(seriesModel, chartView); // NOTE: Update states after label is updated.
        // label should be in normal status when layouting.

        updateStates(seriesModel, chartView);
      }); // If use hover layer

      updateHoverLayerStatus(ecIns, ecModel);
      lifecycle$1.trigger('series:afterupdate', ecModel, api, updateParams);
    };

    markStatusToUpdate = function (ecIns) {
      ecIns[STATUS_NEEDS_UPDATE_KEY] = true; // Wake up zrender if it's sleep. Let it update states in the next frame.

      ecIns.getZr().wakeUp();
    };

    applyChangedStates = function (ecIns) {
      if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
        return;
      }

      ecIns.getZr().storage.traverse(function (el) {
        // Not applied on removed elements, it may still in fading.
        if (isElementRemoved(el)) {
          return;
        }

        applyElementStates(el);
      });
      ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
    };

    function applyElementStates(el) {
      var newStates = [];
      var oldStates = el.currentStates; // Keep other states.

      for (var i = 0; i < oldStates.length; i++) {
        var stateName = oldStates[i];

        if (!(stateName === 'emphasis' || stateName === 'blur' || stateName === 'select')) {
          newStates.push(stateName);
        }
      } // Only use states when it's exists.


      if (el.selected && el.states.select) {
        newStates.push('select');
      }

      if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) {
        newStates.push('emphasis');
      } else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) {
        newStates.push('blur');
      }

      el.useStates(newStates);
    }

    function updateHoverLayerStatus(ecIns, ecModel) {
      var zr = ecIns._zr;
      var storage = zr.storage;
      var elCount = 0;
      storage.traverse(function (el) {
        if (!el.isGroup) {
          elCount++;
        }
      });

      if (elCount > ecModel.get('hoverLayerThreshold') && !env$1.node && !env$1.worker) {
        ecModel.eachSeries(function (seriesModel) {
          if (seriesModel.preventUsingHoverLayer) {
            return;
          }

          var chartView = ecIns._chartsMap[seriesModel.__viewId];

          if (chartView.__alive) {
            chartView.eachRendered(function (el) {
              if (el.states.emphasis) {
                el.states.emphasis.hoverLayer = true;
              }
            });
          }
        });
      }
    }
    /**
     * Update chart and blend.
     */

    function updateBlend(seriesModel, chartView) {
      var blendMode = seriesModel.get('blendMode') || null;
      chartView.eachRendered(function (el) {
        // FIXME marker and other components
        if (!el.isGroup) {
          // DONT mark the element dirty. In case element is incremental and don't wan't to rerender.
          el.style.blend = blendMode;
        }
      });
    }

    function updateZ(model, view) {
      if (model.preventAutoZ) {
        return;
      }

      var z = model.get('z') || 0;
      var zlevel = model.get('zlevel') || 0; // Set z and zlevel

      view.eachRendered(function (el) {
        doUpdateZ(el, z, zlevel, -Infinity); // Don't traverse the children because it has been traversed in _updateZ.

        return true;
      });
    }

    function doUpdateZ(el, z, zlevel, maxZ2) {
      // Group may also have textContent
      var label = el.getTextContent();
      var labelLine = el.getTextGuideLine();
      var isGroup = el.isGroup;

      if (isGroup) {
        // set z & zlevel of children elements of Group
        var children = el.childrenRef();

        for (var i = 0; i < children.length; i++) {
          maxZ2 = Math.max(doUpdateZ(children[i], z, zlevel, maxZ2), maxZ2);
        }
      } else {
        // not Group
        el.z = z;
        el.zlevel = zlevel;
        maxZ2 = Math.max(el.z2, maxZ2);
      } // always set z and zlevel if label/labelLine exists


      if (label) {
        label.z = z;
        label.zlevel = zlevel; // lift z2 of text content
        // TODO if el.emphasis.z2 is spcefied, what about textContent.

        isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
      }

      if (labelLine) {
        var textGuideLineConfig = el.textGuideLineConfig;
        labelLine.z = z;
        labelLine.zlevel = zlevel;
        isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
      }

      return maxZ2;
    } // Clear states without animation.
    // TODO States on component.


    function clearStates(model, view) {
      view.eachRendered(function (el) {
        // Not applied on removed elements, it may still in fading.
        if (isElementRemoved(el)) {
          return;
        }

        var textContent = el.getTextContent();
        var textGuide = el.getTextGuideLine();

        if (el.stateTransition) {
          el.stateTransition = null;
        }

        if (textContent && textContent.stateTransition) {
          textContent.stateTransition = null;
        }

        if (textGuide && textGuide.stateTransition) {
          textGuide.stateTransition = null;
        } // TODO If el is incremental.


        if (el.hasState()) {
          el.prevStates = el.currentStates;
          el.clearStates();
        } else if (el.prevStates) {
          el.prevStates = null;
        }
      });
    }

    function updateStates(model, view) {
      var stateAnimationModel = model.getModel('stateAnimation');
      var enableAnimation = model.isAnimationEnabled();
      var duration = stateAnimationModel.get('duration');
      var stateTransition = duration > 0 ? {
        duration: duration,
        delay: stateAnimationModel.get('delay'),
        easing: stateAnimationModel.get('easing') // additive: stateAnimationModel.get('additive')

      } : null;
      view.eachRendered(function (el) {
        if (el.states && el.states.emphasis) {
          // Not applied on removed elements, it may still in fading.
          if (isElementRemoved(el)) {
            return;
          }

          if (el instanceof Path$1) {
            savePathStates(el);
          } // Only updated on changed element. In case element is incremental and don't wan't to rerender.
          // TODO, a more proper way?


          if (el.__dirty) {
            var prevStates = el.prevStates; // Restore states without animation

            if (prevStates) {
              el.useStates(prevStates);
            }
          } // Update state transition and enable animation again.


          if (enableAnimation) {
            el.stateTransition = stateTransition;
            var textContent = el.getTextContent();
            var textGuide = el.getTextGuideLine(); // TODO Is it necessary to animate label?

            if (textContent) {
              textContent.stateTransition = stateTransition;
            }

            if (textGuide) {
              textGuide.stateTransition = stateTransition;
            }
          } // The use higlighted and selected flag to toggle states.


          if (el.__dirty) {
            applyElementStates(el);
          }
        }
      });
    }

    createExtensionAPI = function (ecIns) {
      return new (
      /** @class */
      function (_super) {
        __extends$1(class_1, _super);

        function class_1() {
          return _super !== null && _super.apply(this, arguments) || this;
        }

        class_1.prototype.getCoordinateSystems = function () {
          return ecIns._coordSysMgr.getCoordinateSystems();
        };

        class_1.prototype.getComponentByElement = function (el) {
          while (el) {
            var modelInfo = el.__ecComponentInfo;

            if (modelInfo != null) {
              return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
            }

            el = el.parent;
          }
        };

        class_1.prototype.enterEmphasis = function (el, highlightDigit) {
          enterEmphasis(el, highlightDigit);
          markStatusToUpdate(ecIns);
        };

        class_1.prototype.leaveEmphasis = function (el, highlightDigit) {
          leaveEmphasis(el, highlightDigit);
          markStatusToUpdate(ecIns);
        };

        class_1.prototype.enterBlur = function (el) {
          enterBlur(el);
          markStatusToUpdate(ecIns);
        };

        class_1.prototype.leaveBlur = function (el) {
          leaveBlur(el);
          markStatusToUpdate(ecIns);
        };

        class_1.prototype.enterSelect = function (el) {
          enterSelect(el);
          markStatusToUpdate(ecIns);
        };

        class_1.prototype.leaveSelect = function (el) {
          leaveSelect(el);
          markStatusToUpdate(ecIns);
        };

        class_1.prototype.getModel = function () {
          return ecIns.getModel();
        };

        class_1.prototype.getViewOfComponentModel = function (componentModel) {
          return ecIns.getViewOfComponentModel(componentModel);
        };

        class_1.prototype.getViewOfSeriesModel = function (seriesModel) {
          return ecIns.getViewOfSeriesModel(seriesModel);
        };

        return class_1;
      }(ExtensionAPI$1))(ecIns);
    };

    enableConnect = function (chart) {
      function updateConnectedChartsStatus(charts, status) {
        for (var i = 0; i < charts.length; i++) {
          var otherChart = charts[i];
          otherChart[CONNECT_STATUS_KEY] = status;
        }
      }

      each$9(eventActionMap, function (actionType, eventType) {
        chart._messageCenter.on(eventType, function (event) {
          if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
            if (event && event.escapeConnect) {
              return;
            }

            var action_1 = chart.makeActionFromEvent(event);
            var otherCharts_1 = [];
            each$9(instances, function (otherChart) {
              if (otherChart !== chart && otherChart.group === chart.group) {
                otherCharts_1.push(otherChart);
              }
            });
            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);
            each$9(otherCharts_1, function (otherChart) {
              if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {
                otherChart.dispatchAction(action_1);
              }
            });
            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);
          }
        });
      });
    };
  }();

  return ECharts;
}(Eventful$1);

var echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts('on');
echartsProto.off = createRegisterEventWithLowercaseECharts('off');
/**
 * @deprecated
 */
// @ts-ignore

echartsProto.one = function (eventName, cb, ctx) {
  var self = this;
  deprecateLog('ECharts#one is deprecated.');

  function wrapped() {
    var args2 = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }

    cb && cb.apply && cb.apply(this, args2); // @ts-ignore

    self.off(eventName, wrapped);
  }

  this.on.call(this, eventName, wrapped, ctx);
};

var MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];

function disposedWarning(id) {
  if (process.env.NODE_ENV !== 'production') {
    console.warn('Instance ' + id + ' has been disposed');
  }
}

var actions = {};
/**
 * Map eventType to actionType
 */

var eventActionMap = {};
var dataProcessorFuncs = [];
var optionPreprocessorFuncs = [];
var visualFuncs = [];
var themeStorage = {};
var loadingEffects = {};
var instances = {};
var connectedGroups = {};
var idBase = +new Date() - 0;
var groupIdBase = +new Date() - 0;
var DOM_ATTRIBUTE_KEY = '_echarts_instance_';
/**
 * @param opts.devicePixelRatio Use window.devicePixelRatio by default
 * @param opts.renderer Can choose 'canvas' or 'svg' to render the chart.
 * @param opts.width Use clientWidth of the input `dom` by default.
 *        Can be 'auto' (the same as null/undefined)
 * @param opts.height Use clientHeight of the input `dom` by default.
 *        Can be 'auto' (the same as null/undefined)
 * @param opts.locale Specify the locale.
 * @param opts.useDirtyRect Enable dirty rectangle rendering or not.
 */

function init(dom, theme, opts) {
  var isClient = !(opts && opts.ssr);

  if (isClient) {
    if (process.env.NODE_ENV !== 'production') {
      if (!dom) {
        throw new Error('Initialize failed: invalid dom.');
      }
    }

    var existInstance = getInstanceByDom(dom);

    if (existInstance) {
      if (process.env.NODE_ENV !== 'production') {
        console.warn('There is a chart instance already initialized on the dom.');
      }

      return existInstance;
    }

    if (process.env.NODE_ENV !== 'production') {
      if (isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth && (!opts || opts.width == null) || !dom.clientHeight && (!opts || opts.height == null))) {
        console.warn('Can\'t get DOM width or height. Please check ' + 'dom.clientWidth and dom.clientHeight. They should not be 0.' + 'For example, you may need to call this in the callback ' + 'of window.onload.');
      }
    }
  }

  var chart = new ECharts(dom, theme, opts);
  chart.id = 'ec_' + idBase++;
  instances[chart.id] = chart;
  isClient && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
  enableConnect(chart);
  lifecycle$1.trigger('afterinit', chart);
  return chart;
}
/**
 * @usage
 * (A)
 * ```js
 * let chart1 = echarts.init(dom1);
 * let chart2 = echarts.init(dom2);
 * chart1.group = 'xxx';
 * chart2.group = 'xxx';
 * echarts.connect('xxx');
 * ```
 * (B)
 * ```js
 * let chart1 = echarts.init(dom1);
 * let chart2 = echarts.init(dom2);
 * echarts.connect('xxx', [chart1, chart2]);
 * ```
 */

function connect(groupId) {
  // Is array of charts
  if (isArray$1(groupId)) {
    var charts = groupId;
    groupId = null; // If any chart has group

    each$9(charts, function (chart) {
      if (chart.group != null) {
        groupId = chart.group;
      }
    });
    groupId = groupId || 'g_' + groupIdBase++;
    each$9(charts, function (chart) {
      chart.group = groupId;
    });
  }

  connectedGroups[groupId] = true;
  return groupId;
}
/**
 * @deprecated
 */

function disConnect(groupId) {
  connectedGroups[groupId] = false;
}
/**
 * Alias and backword compat
 */

var disconnect = disConnect;
/**
 * Dispose a chart instance
 */

function dispose(chart) {
  if (isString(chart)) {
    chart = instances[chart];
  } else if (!(chart instanceof ECharts)) {
    // Try to treat as dom
    chart = getInstanceByDom(chart);
  }

  if (chart instanceof ECharts && !chart.isDisposed()) {
    chart.dispose();
  }
}
function getInstanceByDom(dom) {
  return instances[getAttribute(dom, DOM_ATTRIBUTE_KEY)];
}
function getInstanceById(key) {
  return instances[key];
}
/**
 * Register theme
 */

function registerTheme(name, theme) {
  themeStorage[name] = theme;
}
/**
 * Register option preprocessor
 */

function registerPreprocessor(preprocessorFunc) {
  if (indexOf(optionPreprocessorFuncs, preprocessorFunc) < 0) {
    optionPreprocessorFuncs.push(preprocessorFunc);
  }
}
function registerProcessor(priority, processor) {
  normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
}
/**
 * Register postIniter
 * @param {Function} postInitFunc
 */

function registerPostInit(postInitFunc) {
  registerUpdateLifecycle('afterinit', postInitFunc);
}
/**
 * Register postUpdater
 * @param {Function} postUpdateFunc
 */

function registerPostUpdate(postUpdateFunc) {
  registerUpdateLifecycle('afterupdate', postUpdateFunc);
}
function registerUpdateLifecycle(name, cb) {
  lifecycle$1.on(name, cb);
}
function registerAction(actionInfo, eventName, action) {
  if (isFunction(eventName)) {
    action = eventName;
    eventName = '';
  }

  var actionType = isObject$3(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
    event: eventName
  }][0]; // Event name is all lowercase

  actionInfo.event = (actionInfo.event || actionType).toLowerCase();
  eventName = actionInfo.event;

  if (eventActionMap[eventName]) {
    // Already registered.
    return;
  } // Validate action type and event name.


  assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));

  if (!actions[actionType]) {
    actions[actionType] = {
      action: action,
      actionInfo: actionInfo
    };
  }

  eventActionMap[eventName] = actionType;
}
function registerCoordinateSystem(type, coordSysCreator) {
  CoordinateSystem.register(type, coordSysCreator);
}
/**
 * Get dimensions of specified coordinate system.
 * @param {string} type
 * @return {Array.<string|Object>}
 */

function getCoordinateSystemDimensions(type) {
  var coordSysCreator = CoordinateSystem.get(type);

  if (coordSysCreator) {
    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
  }
}

function registerLayout(priority, layoutTask) {
  normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, 'layout');
}

function registerVisual(priority, visualTask) {
  normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, 'visual');
}
var registeredTasks = [];

function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
  if (isFunction(priority) || isObject$3(priority)) {
    fn = priority;
    priority = defaultPriority;
  }

  if (process.env.NODE_ENV !== 'production') {
    if (isNaN(priority) || priority == null) {
      throw new Error('Illegal priority');
    } // Check duplicate


    each$9(targetList, function (wrap) {
      assert(wrap.__raw !== fn);
    });
  } // Already registered


  if (indexOf(registeredTasks, fn) >= 0) {
    return;
  }

  registeredTasks.push(fn);
  var stageHandler = Scheduler$1.wrapStageHandler(fn, visualType);
  stageHandler.__prio = priority;
  stageHandler.__raw = fn;
  targetList.push(stageHandler);
}

function registerLoading(name, loadingFx) {
  loadingEffects[name] = loadingFx;
}
/**
 * ZRender need a canvas context to do measureText.
 * But in node environment canvas may be created by node-canvas.
 * So we need to specify how to create a canvas instead of using document.createElement('canvas')
 *
 *
 * @deprecated use setPlatformAPI({ createCanvas }) instead.
 *
 * @example
 *     let Canvas = require('canvas');
 *     let echarts = require('echarts');
 *     echarts.setCanvasCreator(function () {
 *         // Small size is enough.
 *         return new Canvas(32, 32);
 *     });
 */

function setCanvasCreator(creator) {
  if (process.env.NODE_ENV !== 'production') {
    deprecateLog('setCanvasCreator is deprecated. Use setPlatformAPI({ createCanvas }) instead.');
  }

  setPlatformAPI({
    createCanvas: creator
  });
}
/**
 * The parameters and usage: see `geoSourceManager.registerMap`.
 * Compatible with previous `echarts.registerMap`.
 */

function registerMap$1(mapName, geoJson, specialAreas) {
  var registerMap = getImpl('registerMap');
  registerMap && registerMap(mapName, geoJson, specialAreas);
}
function getMap(mapName) {
  var getMap = getImpl('getMap');
  return getMap && getMap(mapName);
}
var registerTransform = registerExternalTransform;
/**
 * Globa dispatchAction to a specified chart instance.
 */
// export function dispatchAction(payload: { chartId: string } & Payload, opt?: Parameters<ECharts['dispatchAction']>[1]) {
//     if (!payload || !payload.chartId) {
//         // Must have chartId to find chart
//         return;
//     }
//     const chart = instances[payload.chartId];
//     if (chart) {
//         chart.dispatchAction(payload, opt);
//     }
// }
// Buitlin global visual

registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
registerPreprocessor(globalBackwardCompat);
registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack$1);
registerLoading('default', defaultLoading); // Default actions

registerAction({
  type: HIGHLIGHT_ACTION_TYPE,
  event: HIGHLIGHT_ACTION_TYPE,
  update: HIGHLIGHT_ACTION_TYPE
}, noop$1);
registerAction({
  type: DOWNPLAY_ACTION_TYPE,
  event: DOWNPLAY_ACTION_TYPE,
  update: DOWNPLAY_ACTION_TYPE
}, noop$1);
registerAction({
  type: SELECT_ACTION_TYPE,
  event: SELECT_ACTION_TYPE,
  update: SELECT_ACTION_TYPE
}, noop$1);
registerAction({
  type: UNSELECT_ACTION_TYPE,
  event: UNSELECT_ACTION_TYPE,
  update: UNSELECT_ACTION_TYPE
}, noop$1);
registerAction({
  type: TOGGLE_SELECT_ACTION_TYPE,
  event: TOGGLE_SELECT_ACTION_TYPE,
  update: TOGGLE_SELECT_ACTION_TYPE
}, noop$1); // Default theme

registerTheme('light', lightTheme);
registerTheme('dark', darkTheme); // For backward compatibility, where the namespace `dataTool` will
// be mounted on `echarts` is the extension `dataTool` is imported.

var dataTool = {};

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
}

function defaultKeyGetter(item) {
  return item;
}

var DataDiffer =
/** @class */
function () {
  /**
   * @param context Can be visited by this.context in callback.
   */
  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context, // By default: 'oneToOne'.
  diffMode) {
    this._old = oldArr;
    this._new = newArr;
    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
    this._newKeyGetter = newKeyGetter || defaultKeyGetter; // Visible in callback via `this.context`;

    this.context = context;
    this._diffModeMultiple = diffMode === 'multiple';
  }
  /**
   * Callback function when add a data
   */


  DataDiffer.prototype.add = function (func) {
    this._add = func;
    return this;
  };
  /**
   * Callback function when update a data
   */


  DataDiffer.prototype.update = function (func) {
    this._update = func;
    return this;
  };
  /**
   * Callback function when update a data and only work in `cbMode: 'byKey'`.
   */


  DataDiffer.prototype.updateManyToOne = function (func) {
    this._updateManyToOne = func;
    return this;
  };
  /**
   * Callback function when update a data and only work in `cbMode: 'byKey'`.
   */


  DataDiffer.prototype.updateOneToMany = function (func) {
    this._updateOneToMany = func;
    return this;
  };
  /**
   * Callback function when update a data and only work in `cbMode: 'byKey'`.
   */


  DataDiffer.prototype.updateManyToMany = function (func) {
    this._updateManyToMany = func;
    return this;
  };
  /**
   * Callback function when remove a data
   */


  DataDiffer.prototype.remove = function (func) {
    this._remove = func;
    return this;
  };

  DataDiffer.prototype.execute = function () {
    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();
  };

  DataDiffer.prototype._executeOneToOne = function () {
    var oldArr = this._old;
    var newArr = this._new;
    var newDataIndexMap = {};
    var oldDataKeyArr = new Array(oldArr.length);
    var newDataKeyArr = new Array(newArr.length);

    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');

    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');

    for (var i = 0; i < oldArr.length; i++) {
      var oldKey = oldDataKeyArr[i];
      var newIdxMapVal = newDataIndexMap[oldKey];
      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal); // idx can never be empty array here. see 'set null' logic below.

      if (newIdxMapValLen > 1) {
        // Consider there is duplicate key (for example, use dataItem.name as key).
        // We should make sure every item in newArr and oldArr can be visited.
        var newIdx = newIdxMapVal.shift();

        if (newIdxMapVal.length === 1) {
          newDataIndexMap[oldKey] = newIdxMapVal[0];
        }

        this._update && this._update(newIdx, i);
      } else if (newIdxMapValLen === 1) {
        newDataIndexMap[oldKey] = null;
        this._update && this._update(newIdxMapVal, i);
      } else {
        this._remove && this._remove(i);
      }
    }

    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  };
  /**
   * For example, consider the case:
   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],
   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],
   * Where:
   *     o0, o1, n0 has key 'a' (many to one)
   *     o5, n4, n5, n6 has key 'b' (one to many)
   *     o2, n1 has key 'c' (one to one)
   *     n2, n3 has key 'd' (add)
   *     o3, o4 has key 'e' (remove)
   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)
   * Then:
   *     (The order of the following directives are not ensured.)
   *     this._updateManyToOne(n0, [o0, o1]);
   *     this._updateOneToMany([n4, n5, n6], o5);
   *     this._update(n1, o2);
   *     this._remove(o3);
   *     this._remove(o4);
   *     this._remove(o6);
   *     this._remove(o7);
   *     this._add(n2);
   *     this._add(n3);
   *     this._add(n7);
   *     this._add(n8);
   */


  DataDiffer.prototype._executeMultiple = function () {
    var oldArr = this._old;
    var newArr = this._new;
    var oldDataIndexMap = {};
    var newDataIndexMap = {};
    var oldDataKeyArr = [];
    var newDataKeyArr = [];

    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');

    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');

    for (var i = 0; i < oldDataKeyArr.length; i++) {
      var oldKey = oldDataKeyArr[i];
      var oldIdxMapVal = oldDataIndexMap[oldKey];
      var newIdxMapVal = newDataIndexMap[oldKey];
      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);

      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
        this._update && this._update(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1) {
        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {
          this._remove && this._remove(oldIdxMapVal[i_1]);
        }
      } else {
        this._remove && this._remove(oldIdxMapVal);
      }
    }

    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  };

  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {
    for (var i = 0; i < newDataKeyArr.length; i++) {
      var newKey = newDataKeyArr[i];
      var newIdxMapVal = newDataIndexMap[newKey];
      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);

      if (idxMapValLen > 1) {
        for (var j = 0; j < idxMapValLen; j++) {
          this._add && this._add(newIdxMapVal[j]);
        }
      } else if (idxMapValLen === 1) {
        this._add && this._add(newIdxMapVal);
      } // Support both `newDataKeyArr` are duplication removed or not removed.


      newDataIndexMap[newKey] = null;
    }
  };

  DataDiffer.prototype._initIndexMap = function (arr, // Can be null.
  map, // In 'byKey', the output `keyArr` is duplication removed.
  // In 'byIndex', the output `keyArr` is not duplication removed and
  //     its indices are accurately corresponding to `arr`.
  keyArr, keyGetterName) {
    var cbModeMultiple = this._diffModeMultiple;

    for (var i = 0; i < arr.length; i++) {
      // Add prefix to avoid conflict with Object.prototype.
      var key = '_ec_' + this[keyGetterName](arr[i], i);

      if (!cbModeMultiple) {
        keyArr[i] = key;
      }

      if (!map) {
        continue;
      }

      var idxMapVal = map[key];
      var idxMapValLen = dataIndexMapValueLength(idxMapVal);

      if (idxMapValLen === 0) {
        // Simple optimize: in most cases, one index has one key,
        // do not need array.
        map[key] = i;

        if (cbModeMultiple) {
          keyArr.push(key);
        }
      } else if (idxMapValLen === 1) {
        map[key] = [idxMapVal, i];
      } else {
        idxMapVal.push(i);
      }
    }
  };

  return DataDiffer;
}();

var DataDiffer$1 = DataDiffer;

var DimensionUserOuput =
/** @class */
function () {
  function DimensionUserOuput(encode, dimRequest) {
    this._encode = encode;
    this._schema = dimRequest;
  }

  DimensionUserOuput.prototype.get = function () {
    return {
      // Do not generate full dimension name until fist used.
      fullDimensions: this._getFullDimensionNames(),
      encode: this._encode
    };
  };
  /**
   * Get all data store dimension names.
   * Theoretically a series data store is defined both by series and used dataset (if any).
   * If some dimensions are omitted for performance reason in `this.dimensions`,
   * the dimension name may not be auto-generated if user does not specify a dimension name.
   * In this case, the dimension name is `null`/`undefined`.
   */


  DimensionUserOuput.prototype._getFullDimensionNames = function () {
    if (!this._cachedDimNames) {
      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
    }

    return this._cachedDimNames;
  };

  return DimensionUserOuput;
}();
function summarizeDimensions(data, schema) {
  var summary = {};
  var encode = summary.encode = {};
  var notExtraCoordDimMap = createHashMap();
  var defaultedLabel = [];
  var defaultedTooltip = [];
  var userOutputEncode = {};
  each$9(data.dimensions, function (dimName) {
    var dimItem = data.getDimensionInfo(dimName);
    var coordDim = dimItem.coordDim;

    if (coordDim) {
      if (process.env.NODE_ENV !== 'production') {
        assert(VISUAL_DIMENSIONS.get(coordDim) == null);
      }

      var coordDimIndex = dimItem.coordDimIndex;
      getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;

      if (!dimItem.isExtraCoord) {
        notExtraCoordDimMap.set(coordDim, 1); // Use the last coord dim (and label friendly) as default label,
        // because when dataset is used, it is hard to guess which dimension
        // can be value dimension. If both show x, y on label is not look good,
        // and conventionally y axis is focused more.

        if (mayLabelDimType(dimItem.type)) {
          defaultedLabel[0] = dimName;
        } // User output encode do not contain generated coords.
        // And it only has index. User can use index to retrieve value from the raw item array.


        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);
      }

      if (dimItem.defaultTooltip) {
        defaultedTooltip.push(dimName);
      }
    }

    VISUAL_DIMENSIONS.each(function (v, otherDim) {
      var encodeArr = getOrCreateEncodeArr(encode, otherDim);
      var dimIndex = dimItem.otherDims[otherDim];

      if (dimIndex != null && dimIndex !== false) {
        encodeArr[dimIndex] = dimItem.name;
      }
    });
  });
  var dataDimsOnCoord = [];
  var encodeFirstDimNotExtra = {};
  notExtraCoordDimMap.each(function (v, coordDim) {
    var dimArr = encode[coordDim];
    encodeFirstDimNotExtra[coordDim] = dimArr[0]; // Not necessary to remove duplicate, because a data
    // dim canot on more than one coordDim.

    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
  });
  summary.dataDimsOnCoord = dataDimsOnCoord;
  summary.dataDimIndicesOnCoord = map$1(dataDimsOnCoord, function (dimName) {
    return data.getDimensionInfo(dimName).storeDimIndex;
  });
  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
  var encodeLabel = encode.label; // FIXME `encode.label` is not recommanded, because formatter can not be set
  // in this way. Use label.formatter instead. May be remove this approach someday.

  if (encodeLabel && encodeLabel.length) {
    defaultedLabel = encodeLabel.slice();
  }

  var encodeTooltip = encode.tooltip;

  if (encodeTooltip && encodeTooltip.length) {
    defaultedTooltip = encodeTooltip.slice();
  } else if (!defaultedTooltip.length) {
    defaultedTooltip = defaultedLabel.slice();
  }

  encode.defaultedLabel = defaultedLabel;
  encode.defaultedTooltip = defaultedTooltip;
  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
  return summary;
}

function getOrCreateEncodeArr(encode, dim) {
  if (!encode.hasOwnProperty(dim)) {
    encode[dim] = [];
  }

  return encode[dim];
} // FIXME:TS should be type `AxisType`


function getDimensionTypeByAxis(axisType) {
  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';
}

function mayLabelDimType(dimType) {
  // In most cases, ordinal and time do not suitable for label.
  // Ordinal info can be displayed on axis. Time is too long.
  return !(dimType === 'ordinal' || dimType === 'time');
} // function findTheLastDimMayLabel(data) {
//     // Get last value dim
//     let dimensions = data.dimensions.slice();
//     let valueType;
//     let valueDim;
//     while (dimensions.length && (
//         valueDim = dimensions.pop(),
//         valueType = data.getDimensionInfo(valueDim).type,
//         valueType === 'ordinal' || valueType === 'time'
//     )) {} // jshint ignore:line
//     return valueDim;
// }

var SeriesDimensionDefine =
/** @class */
function () {
  /**
   * @param opt All of the fields will be shallow copied.
   */
  function SeriesDimensionDefine(opt) {
    /**
     * The format of `otherDims` is:
     * ```js
     * {
     *     tooltip?: number
     *     label?: number
     *     itemName?: number
     *     seriesName?: number
     * }
     * ```
     *
     * A `series.encode` can specified these fields:
     * ```js
     * encode: {
     *     // "3, 1, 5" is the index of data dimension.
     *     tooltip: [3, 1, 5],
     *     label: [0, 3],
     *     ...
     * }
     * ```
     * `otherDims` is the parse result of the `series.encode` above, like:
     * ```js
     * // Suppose the index of this data dimension is `3`.
     * this.otherDims = {
     *     // `3` is at the index `0` of the `encode.tooltip`
     *     tooltip: 0,
     *     // `3` is at the index `1` of the `encode.label`
     *     label: 1
     * };
     * ```
     *
     * This prop should never be `null`/`undefined` after initialized.
     */
    this.otherDims = {};

    if (opt != null) {
      extend$2(this, opt);
    }
  }

  return SeriesDimensionDefine;
}();
var SeriesDimensionDefine$1 = SeriesDimensionDefine;

var inner$5 = makeInner();
var dimTypeShort = {
  float: 'f',
  int: 'i',
  ordinal: 'o',
  number: 'n',
  time: 't'
};
/**
 * Represents the dimension requirement of a series.
 *
 * NOTICE:
 * When there are too many dimensions in dataset and many series, only the used dimensions
 * (i.e., used by coord sys and declared in `series.encode`) are add to `dimensionDefineList`.
 * But users may query data by other unused dimension names.
 * In this case, users can only query data if and only if they have defined dimension names
 * via ec option, so we provide `getDimensionIndexFromSource`, which only query them from
 * `source` dimensions.
 */

var SeriesDataSchema =
/** @class */
function () {
  function SeriesDataSchema(opt) {
    this.dimensions = opt.dimensions;
    this._dimOmitted = opt.dimensionOmitted;
    this.source = opt.source;
    this._fullDimCount = opt.fullDimensionCount;

    this._updateDimOmitted(opt.dimensionOmitted);
  }

  SeriesDataSchema.prototype.isDimensionOmitted = function () {
    return this._dimOmitted;
  };

  SeriesDataSchema.prototype._updateDimOmitted = function (dimensionOmitted) {
    this._dimOmitted = dimensionOmitted;

    if (!dimensionOmitted) {
      return;
    }

    if (!this._dimNameMap) {
      this._dimNameMap = ensureSourceDimNameMap(this.source);
    }
  };
  /**
   * @caution Can only be used when `dimensionOmitted: true`.
   *
   * Get index by user defined dimension name (i.e., not internal generate name).
   * That is, get index from `dimensionsDefine`.
   * If no `dimensionsDefine`, or no name get, return -1.
   */


  SeriesDataSchema.prototype.getSourceDimensionIndex = function (dimName) {
    return retrieve2(this._dimNameMap.get(dimName), -1);
  };
  /**
   * @caution Can only be used when `dimensionOmitted: true`.
   *
   * Notice: may return `null`/`undefined` if user not specify dimension names.
   */


  SeriesDataSchema.prototype.getSourceDimension = function (dimIndex) {
    var dimensionsDefine = this.source.dimensionsDefine;

    if (dimensionsDefine) {
      return dimensionsDefine[dimIndex];
    }
  };

  SeriesDataSchema.prototype.makeStoreSchema = function () {
    var dimCount = this._fullDimCount;
    var willRetrieveDataByName = shouldRetrieveDataByName(this.source);
    var makeHashStrict = !shouldOmitUnusedDimensions(dimCount); // If source don't have dimensions or series don't omit unsed dimensions.
    // Generate from seriesDimList directly

    var dimHash = '';
    var dims = [];

    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
      var property = void 0;
      var type = void 0;
      var ordinalMeta = void 0;
      var seriesDimDef = this.dimensions[seriesDimIdx]; // The list has been sorted by `storeDimIndex` asc.

      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        property = willRetrieveDataByName ? seriesDimDef.name : null;
        type = seriesDimDef.type;
        ordinalMeta = seriesDimDef.ordinalMeta;
        seriesDimIdx++;
      } else {
        var sourceDimDef = this.getSourceDimension(fullDimIdx);

        if (sourceDimDef) {
          property = willRetrieveDataByName ? sourceDimDef.name : null;
          type = sourceDimDef.type;
        }
      }

      dims.push({
        property: property,
        type: type,
        ordinalMeta: ordinalMeta
      }); // If retrieving data by index,
      //   use <index, type, ordinalMeta> to determine whether data can be shared.
      //   (Becuase in this case there might be no dimension name defined in dataset, but indices always exists).
      //   (indices are always 0, 1, 2, ..., so we can ignore them to shorten the hash).
      // Otherwise if retrieving data by property name (like `data: [{aa: 123, bb: 765}, ...]`),
      //   use <property, type, ordinalMeta> in hash.

      if (willRetrieveDataByName && property != null // For data stack, we have make sure each series has its own dim on this store.
      // So we do not add property to hash to make sure they can share this store.
      && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {
        dimHash += makeHashStrict // Use escape character '`' in case that property name contains '$'.
        ? property.replace(/\`/g, '`1').replace(/\$/g, '`2') // For better performance, when there are large dimensions, tolerant this defects that hardly meet.
        : property;
      }

      dimHash += '$';
      dimHash += dimTypeShort[type] || 'f';

      if (ordinalMeta) {
        dimHash += ordinalMeta.uid;
      }

      dimHash += '$';
    } // Source from endpoint(usually series) will be read differently
    // when seriesLayoutBy or startIndex(which is affected by sourceHeader) are different.
    // So we use this three props as key.


    var source = this.source;
    var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join('$$');
    return {
      dimensions: dims,
      hash: hash
    };
  };

  SeriesDataSchema.prototype.makeOutputDimensionNames = function () {
    var result = [];

    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
      var name_1 = void 0;
      var seriesDimDef = this.dimensions[seriesDimIdx]; // The list has been sorted by `storeDimIndex` asc.

      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        if (!seriesDimDef.isCalculationCoord) {
          name_1 = seriesDimDef.name;
        }

        seriesDimIdx++;
      } else {
        var sourceDimDef = this.getSourceDimension(fullDimIdx);

        if (sourceDimDef) {
          name_1 = sourceDimDef.name;
        }
      }

      result.push(name_1);
    }

    return result;
  };

  SeriesDataSchema.prototype.appendCalculationDimension = function (dimDef) {
    this.dimensions.push(dimDef);
    dimDef.isCalculationCoord = true;
    this._fullDimCount++; // If append dimension on a data store, consider the store
    // might be shared by different series, series dimensions not
    // really map to store dimensions.

    this._updateDimOmitted(true);
  };

  return SeriesDataSchema;
}();
function isSeriesDataSchema(schema) {
  return schema instanceof SeriesDataSchema;
}
function createDimNameMap(dimsDef) {
  var dataDimNameMap = createHashMap();

  for (var i = 0; i < (dimsDef || []).length; i++) {
    var dimDefItemRaw = dimsDef[i];
    var userDimName = isObject$3(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;

    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
      dataDimNameMap.set(userDimName, i);
    }
  }

  return dataDimNameMap;
}
function ensureSourceDimNameMap(source) {
  var innerSource = inner$5(source);
  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));
}
function shouldOmitUnusedDimensions(dimCount) {
  return dimCount > 30;
}

var isObject$1 = isObject$3;
var map = map$1;
var CtorInt32Array = typeof Int32Array === 'undefined' ? Array : Int32Array; // Use prefix to avoid index to be the same as otherIdList[idx],
// which will cause weird udpate animation.

var ID_PREFIX = 'e\0\0';
var INDEX_NOT_FOUND = -1; // type SeriesDimensionIndex = DimensionIndex;

var TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];
var CLONE_PROPERTIES = ['_approximateExtent']; // -----------------------------
// Internal method declarations:
// -----------------------------

var prepareInvertedIndex;
var getId;
var getIdNameFromStore;
var normalizeDimensions;
var transferProperties;
var cloneListForMapAndSample;
var makeIdFromName;

var SeriesData =
/** @class */
function () {
  /**
   * @param dimensionsInput.dimensions
   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].
   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
   */
  function SeriesData(dimensionsInput, hostModel) {
    this.type = 'list';
    this._dimOmitted = false;
    this._nameList = [];
    this._idList = []; // Models of data option is stored sparse for optimizing memory cost
    // Never used yet (not used yet).
    // private _optionModels: Model[] = [];
    // Global visual properties after visual coding

    this._visual = {}; // Globel layout properties.

    this._layout = {}; // Item visual properties after visual coding

    this._itemVisuals = []; // Item layout properties after layout

    this._itemLayouts = []; // Graphic elemnents

    this._graphicEls = []; // key: dim, value: extent

    this._approximateExtent = {};
    this._calculationInfo = {}; // Having detected that there is data item is non primitive type
    // (in type `OptionDataItemObject`).
    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`
    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.

    this.hasItemOption = false; // Methods that create a new list based on this list should be listed here.
    // Notice that those method should `RETURN` the new list.

    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map']; // Methods that change indices of this list should be listed here.

    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];
    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];
    var dimensions;
    var assignStoreDimIdx = false;

    if (isSeriesDataSchema(dimensionsInput)) {
      dimensions = dimensionsInput.dimensions;
      this._dimOmitted = dimensionsInput.isDimensionOmitted();
      this._schema = dimensionsInput;
    } else {
      assignStoreDimIdx = true;
      dimensions = dimensionsInput;
    }

    dimensions = dimensions || ['x', 'y'];
    var dimensionInfos = {};
    var dimensionNames = [];
    var invertedIndicesMap = {};
    var needsHasOwn = false;
    var emptyObj = {};

    for (var i = 0; i < dimensions.length; i++) {
      // Use the original dimensions[i], where other flag props may exists.
      var dimInfoInput = dimensions[i];
      var dimensionInfo = isString(dimInfoInput) ? new SeriesDimensionDefine$1({
        name: dimInfoInput
      }) : !(dimInfoInput instanceof SeriesDimensionDefine$1) ? new SeriesDimensionDefine$1(dimInfoInput) : dimInfoInput;
      var dimensionName = dimensionInfo.name;
      dimensionInfo.type = dimensionInfo.type || 'float';

      if (!dimensionInfo.coordDim) {
        dimensionInfo.coordDim = dimensionName;
        dimensionInfo.coordDimIndex = 0;
      }

      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
      dimensionNames.push(dimensionName);
      dimensionInfos[dimensionName] = dimensionInfo;

      if (emptyObj[dimensionName] != null) {
        needsHasOwn = true;
      }

      if (dimensionInfo.createInvertedIndices) {
        invertedIndicesMap[dimensionName] = [];
      }

      if (otherDims.itemName === 0) {
        this._nameDimIdx = i;
      }

      if (otherDims.itemId === 0) {
        this._idDimIdx = i;
      }

      if (process.env.NODE_ENV !== 'production') {
        assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);
      }

      if (assignStoreDimIdx) {
        dimensionInfo.storeDimIndex = i;
      }
    }

    this.dimensions = dimensionNames;
    this._dimInfos = dimensionInfos;

    this._initGetDimensionInfo(needsHasOwn);

    this.hostModel = hostModel;
    this._invertedIndicesMap = invertedIndicesMap;

    if (this._dimOmitted) {
      var dimIdxToName_1 = this._dimIdxToName = createHashMap();
      each$9(dimensionNames, function (dimName) {
        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);
      });
    }
  }
  /**
   *
   * Get concrete dimension name by dimension name or dimension index.
   * If input a dimension name, do not validate whether the dimension name exits.
   *
   * @caution
   * @param dim Must make sure the dimension is `SeriesDimensionLoose`.
   * Because only those dimensions will have auto-generated dimension names if not
   * have a user-specified name, and other dimensions will get a return of null/undefined.
   *
   * @notice Becuause of this reason, should better use `getDimensionIndex` instead, for examples:
   * ```js
   * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);
   * ```
   *
   * @return Concrete dim name.
   */


  SeriesData.prototype.getDimension = function (dim) {
    var dimIdx = this._recognizeDimIndex(dim);

    if (dimIdx == null) {
      return dim;
    }

    dimIdx = dim;

    if (!this._dimOmitted) {
      return this.dimensions[dimIdx];
    } // Retrieve from series dimension definition becuase it probably contains
    // generated dimension name (like 'x', 'y').


    var dimName = this._dimIdxToName.get(dimIdx);

    if (dimName != null) {
      return dimName;
    }

    var sourceDimDef = this._schema.getSourceDimension(dimIdx);

    if (sourceDimDef) {
      return sourceDimDef.name;
    }
  };
  /**
   * Get dimension index in data store. Return -1 if not found.
   * Can be used to index value from getRawValue.
   */


  SeriesData.prototype.getDimensionIndex = function (dim) {
    var dimIdx = this._recognizeDimIndex(dim);

    if (dimIdx != null) {
      return dimIdx;
    }

    if (dim == null) {
      return -1;
    }

    var dimInfo = this._getDimInfo(dim);

    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
  };
  /**
   * The meanings of the input parameter `dim`:
   *
   * + If dim is a number (e.g., `1`), it means the index of the dimension.
   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.
   * + If dim is a number-like string (e.g., `"1"`):
   *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,
   *        it means that concrete name.
   *     + If not, it will be converted to a number, which means the index of the dimension.
   *        (why? because of the backward compatbility. We have been tolerating number-like string in
   *        dimension setting, although now it seems that it is not a good idea.)
   *     For example, `visualMap[i].dimension: "1"` is the same meaning as `visualMap[i].dimension: 1`,
   *     if no dimension name is defined as `"1"`.
   * + If dim is a not-number-like string, it means the concrete dim name.
   *   For example, it can be be default name `"x"`, `"y"`, `"z"`, `"lng"`, `"lat"`, `"angle"`, `"radius"`,
   *   or customized in `dimensions` property of option like `"age"`.
   *
   * @return recogonized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).
   */


  SeriesData.prototype._recognizeDimIndex = function (dim) {
    if (isNumber(dim) // If being a number-like string but not being defined as a dimension name.
    || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {
      return +dim;
    }
  };

  SeriesData.prototype._getStoreDimIndex = function (dim) {
    var dimIdx = this.getDimensionIndex(dim);

    if (process.env.NODE_ENV !== 'production') {
      if (dimIdx == null) {
        throw new Error('Unkown dimension ' + dim);
      }
    }

    return dimIdx;
  };
  /**
   * Get type and calculation info of particular dimension
   * @param dim
   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
   */


  SeriesData.prototype.getDimensionInfo = function (dim) {
    // Do not clone, because there may be categories in dimInfo.
    return this._getDimInfo(this.getDimension(dim));
  };

  SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {
    var dimensionInfos = this._dimInfos;
    this._getDimInfo = needsHasOwn ? function (dimName) {
      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;
    } : function (dimName) {
      return dimensionInfos[dimName];
    };
  };
  /**
   * concrete dimension name list on coord.
   */


  SeriesData.prototype.getDimensionsOnCoord = function () {
    return this._dimSummary.dataDimsOnCoord.slice();
  };

  SeriesData.prototype.mapDimension = function (coordDim, idx) {
    var dimensionsSummary = this._dimSummary;

    if (idx == null) {
      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
    }

    var dims = dimensionsSummary.encode[coordDim];
    return dims ? dims[idx] : null;
  };

  SeriesData.prototype.mapDimensionsAll = function (coordDim) {
    var dimensionsSummary = this._dimSummary;
    var dims = dimensionsSummary.encode[coordDim];
    return (dims || []).slice();
  };

  SeriesData.prototype.getStore = function () {
    return this._store;
  };
  /**
   * Initialize from data
   * @param data source or data or data store.
   * @param nameList The name of a datum is used on data diff and
   *        default label/tooltip.
   *        A name can be specified in encode.itemName,
   *        or dataItem.name (only for series option data),
   *        or provided in nameList from outside.
   */


  SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {
    var _this = this;

    var store;

    if (data instanceof DataStore$1) {
      store = data;
    }

    if (!store) {
      var dimensions = this.dimensions;
      var provider = isSourceInstance(data) || isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;
      store = new DataStore$1();
      var dimensionInfos = map(dimensions, function (dimName) {
        return {
          type: _this._dimInfos[dimName].type,
          property: dimName
        };
      });
      store.initData(provider, dimensionInfos, dimValueGetter);
    }

    this._store = store; // Reset

    this._nameList = (nameList || []).slice();
    this._idList = [];
    this._nameRepeatCount = {};

    this._doInit(0, store.count()); // Cache summary info for fast visit. See "dimensionHelper".
    // Needs to be initialized after store is prepared.


    this._dimSummary = summarizeDimensions(this, this._schema);
    this.userOutput = this._dimSummary.userOutput;
  };
  /**
   * Caution: Can be only called on raw data (before `this._indices` created).
   */


  SeriesData.prototype.appendData = function (data) {
    var range = this._store.appendData(data);

    this._doInit(range[0], range[1]);
  };
  /**
   * Caution: Can be only called on raw data (before `this._indices` created).
   * This method does not modify `rawData` (`dataProvider`), but only
   * add values to store.
   *
   * The final count will be increased by `Math.max(values.length, names.length)`.
   *
   * @param values That is the SourceType: 'arrayRows', like
   *        [
   *            [12, 33, 44],
   *            [NaN, 43, 1],
   *            ['-', 'asdf', 0]
   *        ]
   *        Each item is exaclty cooresponding to a dimension.
   */


  SeriesData.prototype.appendValues = function (values, names) {
    var _a = this._store.appendValues(values, names.length),
        start = _a.start,
        end = _a.end;

    var shouldMakeIdFromName = this._shouldMakeIdFromName();

    this._updateOrdinalMeta();

    if (names) {
      for (var idx = start; idx < end; idx++) {
        var sourceIdx = idx - start;
        this._nameList[idx] = names[sourceIdx];

        if (shouldMakeIdFromName) {
          makeIdFromName(this, idx);
        }
      }
    }
  };

  SeriesData.prototype._updateOrdinalMeta = function () {
    var store = this._store;
    var dimensions = this.dimensions;

    for (var i = 0; i < dimensions.length; i++) {
      var dimInfo = this._dimInfos[dimensions[i]];

      if (dimInfo.ordinalMeta) {
        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
      }
    }
  };

  SeriesData.prototype._shouldMakeIdFromName = function () {
    var provider = this._store.getProvider();

    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
  };

  SeriesData.prototype._doInit = function (start, end) {
    if (start >= end) {
      return;
    }

    var store = this._store;
    var provider = store.getProvider();

    this._updateOrdinalMeta();

    var nameList = this._nameList;
    var idList = this._idList;
    var sourceFormat = provider.getSource().sourceFormat;
    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL; // Each data item is value
    // [1, 2]
    // 2
    // Bar chart, line chart which uses category axis
    // only gives the 'y' value. 'x' value is the indices of category
    // Use a tempValue to normalize the value to be a (x, y) value
    // If dataItem is {name: ...} or {id: ...}, it has highest priority.
    // This kind of ids and names are always stored `_nameList` and `_idList`.

    if (isFormatOriginal && !provider.pure) {
      var sharedDataItem = [];

      for (var idx = start; idx < end; idx++) {
        // NOTICE: Try not to write things into dataItem
        var dataItem = provider.getItem(idx, sharedDataItem);

        if (!this.hasItemOption && isDataItemOption(dataItem)) {
          this.hasItemOption = true;
        }

        if (dataItem) {
          var itemName = dataItem.name;

          if (nameList[idx] == null && itemName != null) {
            nameList[idx] = convertOptionIdName(itemName, null);
          }

          var itemId = dataItem.id;

          if (idList[idx] == null && itemId != null) {
            idList[idx] = convertOptionIdName(itemId, null);
          }
        }
      }
    }

    if (this._shouldMakeIdFromName()) {
      for (var idx = start; idx < end; idx++) {
        makeIdFromName(this, idx);
      }
    }

    prepareInvertedIndex(this);
  };
  /**
   * PENDING: In fact currently this function is only used to short-circuit
   * the calling of `scale.unionExtentFromData` when data have been filtered by modules
   * like "dataZoom". `scale.unionExtentFromData` is used to calculate data extent for series on
   * an axis, but if a "axis related data filter module" is used, the extent of the axis have
   * been fixed and no need to calling `scale.unionExtentFromData` actually.
   * But if we add "custom data filter" in future, which is not "axis related", this method may
   * be still needed.
   *
   * Optimize for the scenario that data is filtered by a given extent.
   * Consider that if data amount is more than hundreds of thousand,
   * extent calculation will cost more than 10ms and the cache will
   * be erased because of the filtering.
   */


  SeriesData.prototype.getApproximateExtent = function (dim) {
    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
  };
  /**
   * Calculate extent on a filtered data might be time consuming.
   * Approximate extent is only used for: calculte extent of filtered data outside.
   */


  SeriesData.prototype.setApproximateExtent = function (extent, dim) {
    dim = this.getDimension(dim);
    this._approximateExtent[dim] = extent.slice();
  };

  SeriesData.prototype.getCalculationInfo = function (key) {
    return this._calculationInfo[key];
  };

  SeriesData.prototype.setCalculationInfo = function (key, value) {
    isObject$1(key) ? extend$2(this._calculationInfo, key) : this._calculationInfo[key] = value;
  };
  /**
   * @return Never be null/undefined. `number` will be converted to string. Becuase:
   * In most cases, name is used in display, where returning a string is more convenient.
   * In other cases, name is used in query (see `indexOfName`), where we can keep the
   * rule that name `2` equals to name `'2'`.
   */


  SeriesData.prototype.getName = function (idx) {
    var rawIndex = this.getRawIndex(idx);
    var name = this._nameList[rawIndex];

    if (name == null && this._nameDimIdx != null) {
      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
    }

    if (name == null) {
      name = '';
    }

    return name;
  };

  SeriesData.prototype._getCategory = function (dimIdx, idx) {
    var ordinal = this._store.get(dimIdx, idx);

    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);

    if (ordinalMeta) {
      return ordinalMeta.categories[ordinal];
    }

    return ordinal;
  };
  /**
   * @return Never null/undefined. `number` will be converted to string. Becuase:
   * In all cases having encountered at present, id is used in making diff comparison, which
   * are usually based on hash map. We can keep the rule that the internal id are always string
   * (treat `2` is the same as `'2'`) to make the related logic simple.
   */


  SeriesData.prototype.getId = function (idx) {
    return getId(this, this.getRawIndex(idx));
  };

  SeriesData.prototype.count = function () {
    return this._store.count();
  };
  /**
   * Get value. Return NaN if idx is out of range.
   *
   * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.
   */


  SeriesData.prototype.get = function (dim, idx) {
    var store = this._store;
    var dimInfo = this._dimInfos[dim];

    if (dimInfo) {
      return store.get(dimInfo.storeDimIndex, idx);
    }
  };
  /**
   * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.
   */


  SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {
    var store = this._store;
    var dimInfo = this._dimInfos[dim];

    if (dimInfo) {
      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
    }
  };

  SeriesData.prototype.getIndices = function () {
    return this._store.getIndices();
  };

  SeriesData.prototype.getDataExtent = function (dim) {
    return this._store.getDataExtent(this._getStoreDimIndex(dim));
  };

  SeriesData.prototype.getSum = function (dim) {
    return this._store.getSum(this._getStoreDimIndex(dim));
  };

  SeriesData.prototype.getMedian = function (dim) {
    return this._store.getMedian(this._getStoreDimIndex(dim));
  };

  SeriesData.prototype.getValues = function (dimensions, idx) {
    var _this = this;

    var store = this._store;
    return isArray$1(dimensions) ? store.getValues(map(dimensions, function (dim) {
      return _this._getStoreDimIndex(dim);
    }), idx) : store.getValues(dimensions);
  };
  /**
   * If value is NaN. Inlcuding '-'
   * Only check the coord dimensions.
   */


  SeriesData.prototype.hasValue = function (idx) {
    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;

    for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {
      // Ordinal type originally can be string or number.
      // But when an ordinal type is used on coord, it can
      // not be string but only number. So we can also use isNaN.
      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {
        return false;
      }
    }

    return true;
  };
  /**
   * Retreive the index with given name
   */


  SeriesData.prototype.indexOfName = function (name) {
    for (var i = 0, len = this._store.count(); i < len; i++) {
      if (this.getName(i) === name) {
        return i;
      }
    }

    return -1;
  };

  SeriesData.prototype.getRawIndex = function (idx) {
    return this._store.getRawIndex(idx);
  };

  SeriesData.prototype.indexOfRawIndex = function (rawIndex) {
    return this._store.indexOfRawIndex(rawIndex);
  };
  /**
   * Only support the dimension which inverted index created.
   * Do not support other cases until required.
   * @param dim concrete dim
   * @param value ordinal index
   * @return rawIndex
   */


  SeriesData.prototype.rawIndexOf = function (dim, value) {
    var invertedIndices = dim && this._invertedIndicesMap[dim];

    if (process.env.NODE_ENV !== 'production') {
      if (!invertedIndices) {
        throw new Error('Do not supported yet');
      }
    }

    var rawIndex = invertedIndices[value];

    if (rawIndex == null || isNaN(rawIndex)) {
      return INDEX_NOT_FOUND;
    }

    return rawIndex;
  };
  /**
   * Retreive the index of nearest value
   * @param dim
   * @param value
   * @param [maxDistance=Infinity]
   * @return If and only if multiple indices has
   *         the same value, they are put to the result.
   */


  SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {
    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);
  };

  SeriesData.prototype.each = function (dims, cb, ctx) {

    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    } // ctxCompat just for compat echarts3


    var fCtx = ctx || this;
    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);

    this._store.each(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
  };

  SeriesData.prototype.filterSelf = function (dims, cb, ctx) {

    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    } // ctxCompat just for compat echarts3


    var fCtx = ctx || this;
    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store = this._store.filter(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
    return this;
  };
  /**
   * Select data in range. (For optimization of filter)
   * (Manually inline code, support 5 million data filtering in data zoom.)
   */


  SeriesData.prototype.selectRange = function (range) {

    var _this = this;

    var innerRange = {};
    var dims = keys(range);
    each$9(dims, function (dim) {
      var dimIdx = _this._getStoreDimIndex(dim);

      innerRange[dimIdx] = range[dim];
    });
    this._store = this._store.selectRange(innerRange);
    return this;
  };
  /* eslint-enable max-len */


  SeriesData.prototype.mapArray = function (dims, cb, ctx) {

    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    } // ctxCompat just for compat echarts3


    ctx = ctx || this;
    var result = [];
    this.each(dims, function () {
      result.push(cb && cb.apply(this, arguments));
    }, ctx);
    return result;
  };

  SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {

    var fCtx = ctx || ctxCompat || this;
    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
    var list = cloneListForMapAndSample(this);
    list._store = this._store.map(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
    return list;
  };

  SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {
    var _this = this; // ctxCompat just for compat echarts3


    var fCtx = ctx || ctxCompat || this;

    if (process.env.NODE_ENV !== 'production') {
      each$9(normalizeDimensions(dims), function (dim) {
        var dimInfo = _this.getDimensionInfo(dim);

        if (!dimInfo.isCalculationCoord) {
          console.error('Danger: only stack dimension can be modified');
        }
      });
    }

    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this); // If do shallow clone here, if there are too many stacked series,
    // it still cost lots of memory, becuase `_store.dimensions` are not shared.
    // We should consider there probably be shallow clone happen in each sereis
    // in consequent filter/map.

    this._store.modify(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
  };
  /**
   * Large data down sampling on given dimension
   * @param sampleIndex Sample index for name and id
   */


  SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {
    var list = cloneListForMapAndSample(this);
    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
    return list;
  };
  /**
   * Large data down sampling using largest-triangle-three-buckets
   * @param {string} valueDimension
   * @param {number} targetCount
   */


  SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {
    var list = cloneListForMapAndSample(this);
    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
    return list;
  };

  SeriesData.prototype.getRawDataItem = function (idx) {
    return this._store.getRawDataItem(idx);
  };
  /**
   * Get model of one data item.
   */
  // TODO: Type of data item


  SeriesData.prototype.getItemModel = function (idx) {
    var hostModel = this.hostModel;
    var dataItem = this.getRawDataItem(idx);
    return new Model$1(dataItem, hostModel, hostModel && hostModel.ecModel);
  };
  /**
   * Create a data differ
   */


  SeriesData.prototype.diff = function (otherList) {
    var thisList = this;
    return new DataDiffer$1(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {
      return getId(otherList, idx);
    }, function (idx) {
      return getId(thisList, idx);
    });
  };
  /**
   * Get visual property.
   */


  SeriesData.prototype.getVisual = function (key) {
    var visual = this._visual;
    return visual && visual[key];
  };

  SeriesData.prototype.setVisual = function (kvObj, val) {
    this._visual = this._visual || {};

    if (isObject$1(kvObj)) {
      extend$2(this._visual, kvObj);
    } else {
      this._visual[kvObj] = val;
    }
  };
  /**
   * Get visual property of single data item
   */
  // eslint-disable-next-line


  SeriesData.prototype.getItemVisual = function (idx, key) {
    var itemVisual = this._itemVisuals[idx];
    var val = itemVisual && itemVisual[key];

    if (val == null) {
      // Use global visual property
      return this.getVisual(key);
    }

    return val;
  };
  /**
   * If exists visual property of single data item
   */


  SeriesData.prototype.hasItemVisual = function () {
    return this._itemVisuals.length > 0;
  };
  /**
   * Make sure itemVisual property is unique
   */
  // TODO: use key to save visual to reduce memory.


  SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {
    var itemVisuals = this._itemVisuals;
    var itemVisual = itemVisuals[idx];

    if (!itemVisual) {
      itemVisual = itemVisuals[idx] = {};
    }

    var val = itemVisual[key];

    if (val == null) {
      val = this.getVisual(key); // TODO Performance?

      if (isArray$1(val)) {
        val = val.slice();
      } else if (isObject$1(val)) {
        val = extend$2({}, val);
      }

      itemVisual[key] = val;
    }

    return val;
  }; // eslint-disable-next-line


  SeriesData.prototype.setItemVisual = function (idx, key, value) {
    var itemVisual = this._itemVisuals[idx] || {};
    this._itemVisuals[idx] = itemVisual;

    if (isObject$1(key)) {
      extend$2(itemVisual, key);
    } else {
      itemVisual[key] = value;
    }
  };
  /**
   * Clear itemVisuals and list visual.
   */


  SeriesData.prototype.clearAllVisual = function () {
    this._visual = {};
    this._itemVisuals = [];
  };

  SeriesData.prototype.setLayout = function (key, val) {
    isObject$1(key) ? extend$2(this._layout, key) : this._layout[key] = val;
  };
  /**
   * Get layout property.
   */


  SeriesData.prototype.getLayout = function (key) {
    return this._layout[key];
  };
  /**
   * Get layout of single data item
   */


  SeriesData.prototype.getItemLayout = function (idx) {
    return this._itemLayouts[idx];
  };
  /**
   * Set layout of single data item
   */


  SeriesData.prototype.setItemLayout = function (idx, layout, merge) {
    this._itemLayouts[idx] = merge ? extend$2(this._itemLayouts[idx] || {}, layout) : layout;
  };
  /**
   * Clear all layout of single data item
   */


  SeriesData.prototype.clearItemLayouts = function () {
    this._itemLayouts.length = 0;
  };
  /**
   * Set graphic element relative to data. It can be set as null
   */


  SeriesData.prototype.setItemGraphicEl = function (idx, el) {
    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;
    setCommonECData(seriesIndex, this.dataType, idx, el);
    this._graphicEls[idx] = el;
  };

  SeriesData.prototype.getItemGraphicEl = function (idx) {
    return this._graphicEls[idx];
  };

  SeriesData.prototype.eachItemGraphicEl = function (cb, context) {
    each$9(this._graphicEls, function (el, idx) {
      if (el) {
        cb && cb.call(context, el, idx);
      }
    });
  };
  /**
   * Shallow clone a new list except visual and layout properties, and graph elements.
   * New list only change the indices.
   */


  SeriesData.prototype.cloneShallow = function (list) {
    if (!list) {
      list = new SeriesData(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);
    }

    transferProperties(list, this);
    list._store = this._store;
    return list;
  };
  /**
   * Wrap some method to add more feature
   */


  SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {
    var originalMethod = this[methodName];

    if (!isFunction(originalMethod)) {
      return;
    }

    this.__wrappedMethods = this.__wrappedMethods || [];

    this.__wrappedMethods.push(methodName);

    this[methodName] = function () {
      var res = originalMethod.apply(this, arguments);
      return injectFunction.apply(this, [res].concat(slice(arguments)));
    };
  }; // ----------------------------------------------------------
  // A work around for internal method visiting private member.
  // ----------------------------------------------------------


  SeriesData.internalField = function () {
    prepareInvertedIndex = function (data) {
      var invertedIndicesMap = data._invertedIndicesMap;
      each$9(invertedIndicesMap, function (invertedIndices, dim) {
        var dimInfo = data._dimInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.

        var ordinalMeta = dimInfo.ordinalMeta;
        var store = data._store;

        if (ordinalMeta) {
          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss
          // mapping to 0, we should set it as INDEX_NOT_FOUND.

          for (var i = 0; i < invertedIndices.length; i++) {
            invertedIndices[i] = INDEX_NOT_FOUND;
          }

          for (var i = 0; i < store.count(); i++) {
            // Only support the case that all values are distinct.
            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;
          }
        }
      });
    };

    getIdNameFromStore = function (data, dimIdx, idx) {
      return convertOptionIdName(data._getCategory(dimIdx, idx), null);
    };
    /**
     * @see the comment of `List['getId']`.
     */


    getId = function (data, rawIndex) {
      var id = data._idList[rawIndex];

      if (id == null && data._idDimIdx != null) {
        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);
      }

      if (id == null) {
        id = ID_PREFIX + rawIndex;
      }

      return id;
    };

    normalizeDimensions = function (dimensions) {
      if (!isArray$1(dimensions)) {
        dimensions = dimensions != null ? [dimensions] : [];
      }

      return dimensions;
    };
    /**
     * Data in excludeDimensions is copied, otherwise transfered.
     */


    cloneListForMapAndSample = function (original) {
      var list = new SeriesData(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked

      transferProperties(list, original);
      return list;
    };

    transferProperties = function (target, source) {
      each$9(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {
        if (source.hasOwnProperty(propName)) {
          target[propName] = source[propName];
        }
      });
      target.__wrappedMethods = source.__wrappedMethods;
      each$9(CLONE_PROPERTIES, function (propName) {
        target[propName] = clone$3(source[propName]);
      });
      target._calculationInfo = extend$2({}, source._calculationInfo);
    };

    makeIdFromName = function (data, idx) {
      var nameList = data._nameList;
      var idList = data._idList;
      var nameDimIdx = data._nameDimIdx;
      var idDimIdx = data._idDimIdx;
      var name = nameList[idx];
      var id = idList[idx];

      if (name == null && nameDimIdx != null) {
        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);
      }

      if (id == null && idDimIdx != null) {
        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);
      }

      if (id == null && name != null) {
        var nameRepeatCount = data._nameRepeatCount;
        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;
        id = name;

        if (nmCnt > 1) {
          id += '__ec__' + nmCnt;
        }

        idList[idx] = id;
      }
    };
  }();

  return SeriesData;
}();

var SeriesData$1 = SeriesData;

/**
 * For outside usage compat (like echarts-gl are using it).
 */

function createDimensions(source, opt) {
  return prepareSeriesDataSchema(source, opt).dimensions;
}
/**
 * This method builds the relationship between:
 * + "what the coord sys or series requires (see `coordDimensions`)",
 * + "what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)"
 * + "what the data source provids (see `source`)".
 *
 * Some guess strategy will be adapted if user does not define something.
 * If no 'value' dimension specified, the first no-named dimension will be
 * named as 'value'.
 *
 * @return The results are always sorted by `storeDimIndex` asc.
 */

function prepareSeriesDataSchema( // TODO: TYPE completeDimensions type
source, opt) {
  if (!isSourceInstance(source)) {
    source = createSourceFromSeriesDataOption(source);
  }

  opt = opt || {};
  var sysDims = opt.coordDimensions || [];
  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];
  var coordDimNameMap = createHashMap();
  var resultList = [];
  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount); // Try to ignore unsed dimensions if sharing a high dimension datastore
  // 30 is an experience value.

  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);
  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;
  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);
  var encodeDef = opt.encodeDefine;

  if (!encodeDef && opt.encodeDefaulter) {
    encodeDef = opt.encodeDefaulter(source, dimCount);
  }

  var encodeDefMap = createHashMap(encodeDef);
  var indicesMap = new CtorInt32Array$1(dimCount);

  for (var i = 0; i < indicesMap.length; i++) {
    indicesMap[i] = -1;
  }

  function getResultItem(dimIdx) {
    var idx = indicesMap[dimIdx];

    if (idx < 0) {
      var dimDefItemRaw = dimsDef[dimIdx];
      var dimDefItem = isObject$3(dimDefItemRaw) ? dimDefItemRaw : {
        name: dimDefItemRaw
      };
      var resultItem = new SeriesDimensionDefine$1();
      var userDimName = dimDefItem.name;

      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {
        // Only if `series.dimensions` is defined in option
        // displayName, will be set, and dimension will be diplayed vertically in
        // tooltip by default.
        resultItem.name = resultItem.displayName = userDimName;
      }

      dimDefItem.type != null && (resultItem.type = dimDefItem.type);
      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);
      var newIdx = resultList.length;
      indicesMap[dimIdx] = newIdx;
      resultItem.storeDimIndex = dimIdx;
      resultList.push(resultItem);
      return resultItem;
    }

    return resultList[idx];
  }

  if (!omitUnusedDimensions) {
    for (var i = 0; i < dimCount; i++) {
      getResultItem(i);
    }
  } // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.


  encodeDefMap.each(function (dataDimsRaw, coordDim) {
    var dataDims = normalizeToArray(dataDimsRaw).slice(); // Note: It is allowed that `dataDims.length` is `0`, e.g., options is
    // `{encode: {x: -1, y: 1}}`. Should not filter anything in
    // this case.

    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {
      encodeDefMap.set(coordDim, false);
      return;
    }

    var validDataDims = encodeDefMap.set(coordDim, []);
    each$9(dataDims, function (resultDimIdxOrName, idx) {
      // The input resultDimIdx can be dim name or index.
      var resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;

      if (resultDimIdx != null && resultDimIdx < dimCount) {
        validDataDims[idx] = resultDimIdx;
        applyDim(getResultItem(resultDimIdx), coordDim, idx);
      }
    });
  }); // Apply templetes and default order from `sysDims`.

  var availDimIdx = 0;
  each$9(sysDims, function (sysDimItemRaw) {
    var coordDim;
    var sysDimItemDimsDef;
    var sysDimItemOtherDims;
    var sysDimItem;

    if (isString(sysDimItemRaw)) {
      coordDim = sysDimItemRaw;
      sysDimItem = {};
    } else {
      sysDimItem = sysDimItemRaw;
      coordDim = sysDimItem.name;
      var ordinalMeta = sysDimItem.ordinalMeta;
      sysDimItem.ordinalMeta = null;
      sysDimItem = extend$2({}, sysDimItem);
      sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.

      sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemOtherDims = sysDimItem.otherDims;
      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
    }

    var dataDims = encodeDefMap.get(coordDim); // negative resultDimIdx means no need to mapping.

    if (dataDims === false) {
      return;
    }

    dataDims = normalizeToArray(dataDims); // dimensions provides default dim sequences.

    if (!dataDims.length) {
      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {
        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {
          availDimIdx++;
        }

        availDimIdx < dimCount && dataDims.push(availDimIdx++);
      }
    } // Apply templates.


    each$9(dataDims, function (resultDimIdx, coordDimIndex) {
      var resultItem = getResultItem(resultDimIdx); // Coordinate system has a higher priority on dim type than source.

      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {
        resultItem.type = sysDimItem.type;
      }

      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);

      if (resultItem.name == null && sysDimItemDimsDef) {
        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
        !isObject$3(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
          name: sysDimItemDimsDefItem
        });
        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;
        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
      } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}


      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);
    });
  });

  function applyDim(resultItem, coordDim, coordDimIndex) {
    if (VISUAL_DIMENSIONS.get(coordDim) != null) {
      resultItem.otherDims[coordDim] = coordDimIndex;
    } else {
      resultItem.coordDim = coordDim;
      resultItem.coordDimIndex = coordDimIndex;
      coordDimNameMap.set(coordDim, true);
    }
  } // Make sure the first extra dim is 'value'.


  var generateCoord = opt.generateCoord;
  var generateCoordCount = opt.generateCoordCount;
  var fromZero = generateCoordCount != null;
  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
  var extra = generateCoord || 'value';

  function ifNoNameFillWithCoordName(resultItem) {
    if (resultItem.name == null) {
      // Duplication will be removed in the next step.
      resultItem.name = resultItem.coordDim;
    }
  } // Set dim `name` and other `coordDim` and other props.


  if (!omitUnusedDimensions) {
    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
      var resultItem = getResultItem(resultDimIdx);
      var coordDim = resultItem.coordDim;

      if (coordDim == null) {
        // TODO no need to generate coordDim for isExtraCoord?
        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);
        resultItem.coordDimIndex = 0; // Series specified generateCoord is using out.

        if (!generateCoord || generateCoordCount <= 0) {
          resultItem.isExtraCoord = true;
        }

        generateCoordCount--;
      }

      ifNoNameFillWithCoordName(resultItem);

      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must // Consider the case:
      // {
      //    dataset: {source: [
      //        ['2001', 123],
      //        ['2002', 456],
      //        ...
      //        ['The others', 987],
      //    ]},
      //    series: {type: 'pie'}
      // }
      // The first colum should better be treated as a "ordinal" although it
      // might not able to be detected as an "ordinal" by `guessOrdinal`.
      || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
        resultItem.type = 'ordinal';
      }
    }
  } else {
    each$9(resultList, function (resultItem) {
      // PENDING: guessOrdinal or let user specify type: 'ordinal' manually?
      ifNoNameFillWithCoordName(resultItem);
    }); // Sort dimensions: there are some rule that use the last dim as label,
    // and for some latter travel process easier.

    resultList.sort(function (item0, item1) {
      return item0.storeDimIndex - item1.storeDimIndex;
    });
  }

  removeDuplication(resultList);
  return new SeriesDataSchema({
    source: source,
    dimensions: resultList,
    fullDimensionCount: dimCount,
    dimensionOmitted: omitUnusedDimensions
  });
}

function removeDuplication(result) {
  var duplicationMap = createHashMap();

  for (var i = 0; i < result.length; i++) {
    var dim = result[i];
    var dimOriginalName = dim.name;
    var count = duplicationMap.get(dimOriginalName) || 0;

    if (count > 0) {
      // Starts from 0.
      dim.name = dimOriginalName + (count - 1);
    }

    count++;
    duplicationMap.set(dimOriginalName, count);
  }
} // ??? TODO
// Originally detect dimCount by data[0]. Should we
// optimize it to only by sysDims and dimensions and encode.
// So only necessary dims will be initialized.
// But
// (1) custom series should be considered. where other dims
// may be visited.
// (2) sometimes user need to calcualte bubble size or use visualMap
// on other dimensions besides coordSys needed.
// So, dims that is not used by system, should be shared in data store?


function getDimCount(source, sysDims, dimsDef, optDimCount) {
  // Note that the result dimCount should not small than columns count
  // of data, otherwise `dataDimNameMap` checking will be incorrect.
  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
  each$9(sysDims, function (sysDimItem) {
    var sysDimItemDimsDef;

    if (isObject$3(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
    }
  });
  return dimCount;
}

function genCoordDimName(name, map, fromZero) {
  var mapData = map.data;

  if (fromZero || mapData.hasOwnProperty(name)) {
    var i = 0;

    while (mapData.hasOwnProperty(name + i)) {
      i++;
    }

    name += i;
  }

  map.set(name, true);
  return name;
}

/**
 * @class
 * For example:
 * {
 *     coordSysName: 'cartesian2d',
 *     coordSysDims: ['x', 'y', ...],
 *     axisMap: HashMap({
 *         x: xAxisModel,
 *         y: yAxisModel
 *     }),
 *     categoryAxisMap: HashMap({
 *         x: xAxisModel,
 *         y: undefined
 *     }),
 *     // The index of the first category axis in `coordSysDims`.
 *     // `null/undefined` means no category axis exists.
 *     firstCategoryDimIndex: 1,
 *     // To replace user specified encode.
 * }
 */

var CoordSysInfo =
/** @class */
function () {
  function CoordSysInfo(coordSysName) {
    this.coordSysDims = [];
    this.axisMap = createHashMap();
    this.categoryAxisMap = createHashMap();
    this.coordSysName = coordSysName;
  }

  return CoordSysInfo;
}();

function getCoordSysInfoBySeries(seriesModel) {
  var coordSysName = seriesModel.get('coordinateSystem');
  var result = new CoordSysInfo(coordSysName);
  var fetch = fetchers[coordSysName];

  if (fetch) {
    fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
    return result;
  }
}
var fetchers = {
  cartesian2d: function (seriesModel, result, axisMap, categoryAxisMap) {
    var xAxisModel = seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0];
    var yAxisModel = seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0];

    if (process.env.NODE_ENV !== 'production') {
      if (!xAxisModel) {
        throw new Error('xAxis "' + retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '" not found');
      }

      if (!yAxisModel) {
        throw new Error('yAxis "' + retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '" not found');
      }
    }

    result.coordSysDims = ['x', 'y'];
    axisMap.set('x', xAxisModel);
    axisMap.set('y', yAxisModel);

    if (isCategory(xAxisModel)) {
      categoryAxisMap.set('x', xAxisModel);
      result.firstCategoryDimIndex = 0;
    }

    if (isCategory(yAxisModel)) {
      categoryAxisMap.set('y', yAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  singleAxis: function (seriesModel, result, axisMap, categoryAxisMap) {
    var singleAxisModel = seriesModel.getReferringComponents('singleAxis', SINGLE_REFERRING).models[0];

    if (process.env.NODE_ENV !== 'production') {
      if (!singleAxisModel) {
        throw new Error('singleAxis should be specified.');
      }
    }

    result.coordSysDims = ['single'];
    axisMap.set('single', singleAxisModel);

    if (isCategory(singleAxisModel)) {
      categoryAxisMap.set('single', singleAxisModel);
      result.firstCategoryDimIndex = 0;
    }
  },
  polar: function (seriesModel, result, axisMap, categoryAxisMap) {
    var polarModel = seriesModel.getReferringComponents('polar', SINGLE_REFERRING).models[0];
    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');
    var angleAxisModel = polarModel.findAxisModel('angleAxis');

    if (process.env.NODE_ENV !== 'production') {
      if (!angleAxisModel) {
        throw new Error('angleAxis option not found');
      }

      if (!radiusAxisModel) {
        throw new Error('radiusAxis option not found');
      }
    }

    result.coordSysDims = ['radius', 'angle'];
    axisMap.set('radius', radiusAxisModel);
    axisMap.set('angle', angleAxisModel);

    if (isCategory(radiusAxisModel)) {
      categoryAxisMap.set('radius', radiusAxisModel);
      result.firstCategoryDimIndex = 0;
    }

    if (isCategory(angleAxisModel)) {
      categoryAxisMap.set('angle', angleAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  geo: function (seriesModel, result, axisMap, categoryAxisMap) {
    result.coordSysDims = ['lng', 'lat'];
  },
  parallel: function (seriesModel, result, axisMap, categoryAxisMap) {
    var ecModel = seriesModel.ecModel;
    var parallelModel = ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));
    var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
    each$9(parallelModel.parallelAxisIndex, function (axisIndex, index) {
      var axisModel = ecModel.getComponent('parallelAxis', axisIndex);
      var axisDim = coordSysDims[index];
      axisMap.set(axisDim, axisModel);

      if (isCategory(axisModel)) {
        categoryAxisMap.set(axisDim, axisModel);

        if (result.firstCategoryDimIndex == null) {
          result.firstCategoryDimIndex = index;
        }
      }
    });
  }
};

function isCategory(axisModel) {
  return axisModel.get('type') === 'category';
}

/**
 * Note that it is too complicated to support 3d stack by value
 * (have to create two-dimension inverted index), so in 3d case
 * we just support that stacked by index.
 *
 * @param seriesModel
 * @param dimensionsInput The same as the input of <module:echarts/data/SeriesData>.
 *        The input will be modified.
 * @param opt
 * @param opt.stackedCoordDimension Specify a coord dimension if needed.
 * @param opt.byIndex=false
 * @return calculationInfo
 * {
 *     stackedDimension: string
 *     stackedByDimension: string
 *     isStackedByIndex: boolean
 *     stackedOverDimension: string
 *     stackResultDimension: string
 * }
 */

function enableDataStack(seriesModel, dimensionsInput, opt) {
  opt = opt || {};
  var byIndex = opt.byIndex;
  var stackedCoordDimension = opt.stackedCoordDimension;
  var dimensionDefineList;
  var schema;
  var store;

  if (isLegacyDimensionsInput(dimensionsInput)) {
    dimensionDefineList = dimensionsInput;
  } else {
    schema = dimensionsInput.schema;
    dimensionDefineList = schema.dimensions;
    store = dimensionsInput.store;
  } // Compatibal: when `stack` is set as '', do not stack.


  var mayStack = !!(seriesModel && seriesModel.get('stack'));
  var stackedByDimInfo;
  var stackedDimInfo;
  var stackResultDimension;
  var stackedOverDimension;
  each$9(dimensionDefineList, function (dimensionInfo, index) {
    if (isString(dimensionInfo)) {
      dimensionDefineList[index] = dimensionInfo = {
        name: dimensionInfo
      };
    }

    if (mayStack && !dimensionInfo.isExtraCoord) {
      // Find the first ordinal dimension as the stackedByDimInfo.
      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
        stackedByDimInfo = dimensionInfo;
      } // Find the first stackable dimension as the stackedDimInfo.


      if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
        stackedDimInfo = dimensionInfo;
      }
    }
  });

  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
    // Compatible with previous design, value axis (time axis) only stack by index.
    // It may make sense if the user provides elaborately constructed data.
    byIndex = true;
  } // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.
  // That put stack logic in List is for using conveniently in echarts extensions, but it
  // might not be a good way.


  if (stackedDimInfo) {
    // Use a weird name that not duplicated with other names.
    // Also need to use seriesModel.id as postfix because different
    // series may share same data store. The stack dimension needs to be distinguished.
    stackResultDimension = '__\0ecstackresult_' + seriesModel.id;
    stackedOverDimension = '__\0ecstackedover_' + seriesModel.id; // Create inverted index to fast query index by value.

    if (stackedByDimInfo) {
      stackedByDimInfo.createInvertedIndices = true;
    }

    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;
    var stackedDimType = stackedDimInfo.type;
    var stackedDimCoordIndex_1 = 0;
    each$9(dimensionDefineList, function (dimensionInfo) {
      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {
        stackedDimCoordIndex_1++;
      }
    });
    var stackedOverDimensionDefine = {
      name: stackResultDimension,
      coordDim: stackedDimCoordDim_1,
      coordDimIndex: stackedDimCoordIndex_1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length
    };
    var stackResultDimensionDefine = {
      name: stackedOverDimension,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: stackedOverDimension,
      coordDimIndex: stackedDimCoordIndex_1 + 1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length + 1
    };

    if (schema) {
      if (store) {
        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
      }

      schema.appendCalculationDimension(stackedOverDimensionDefine);
      schema.appendCalculationDimension(stackResultDimensionDefine);
    } else {
      dimensionDefineList.push(stackedOverDimensionDefine);
      dimensionDefineList.push(stackResultDimensionDefine);
    }
  }

  return {
    stackedDimension: stackedDimInfo && stackedDimInfo.name,
    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
    isStackedByIndex: byIndex,
    stackedOverDimension: stackedOverDimension,
    stackResultDimension: stackResultDimension
  };
}

function isLegacyDimensionsInput(dimensionsInput) {
  return !isSeriesDataSchema(dimensionsInput.schema);
}

function isDimensionStacked(data, stackedDim) {
  // Each single series only maps to one pair of axis. So we do not need to
  // check stackByDim, whatever stacked by a dimension or stacked by index.
  return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension');
}
function getStackedDimension(data, targetDim) {
  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;
}

function getCoordSysDimDefs(seriesModel, coordSysInfo) {
  var coordSysName = seriesModel.get('coordinateSystem');
  var registeredCoordSys = CoordinateSystem.get(coordSysName);
  var coordSysDimDefs;

  if (coordSysInfo && coordSysInfo.coordSysDims) {
    coordSysDimDefs = map$1(coordSysInfo.coordSysDims, function (dim) {
      var dimInfo = {
        name: dim
      };
      var axisModel = coordSysInfo.axisMap.get(dim);

      if (axisModel) {
        var axisType = axisModel.get('type');
        dimInfo.type = getDimensionTypeByAxis(axisType);
      }

      return dimInfo;
    });
  }

  if (!coordSysDimDefs) {
    // Get dimensions from registered coordinate system
    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];
  }

  return coordSysDimDefs;
}

function injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {
  var firstCategoryDimIndex;
  var hasNameEncode;
  coordSysInfo && each$9(dimInfoList, function (dimInfo, dimIndex) {
    var coordDim = dimInfo.coordDim;
    var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);

    if (categoryAxisModel) {
      if (firstCategoryDimIndex == null) {
        firstCategoryDimIndex = dimIndex;
      }

      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();

      if (createInvertedIndices) {
        dimInfo.createInvertedIndices = true;
      }
    }

    if (dimInfo.otherDims.itemName != null) {
      hasNameEncode = true;
    }
  });

  if (!hasNameEncode && firstCategoryDimIndex != null) {
    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
  }

  return firstCategoryDimIndex;
}
/**
 * Caution: there are side effects to `sourceManager` in this method.
 * Should better only be called in `Series['getInitialData']`.
 */


function createSeriesData(sourceRaw, seriesModel, opt) {
  opt = opt || {};
  var sourceManager = seriesModel.getSourceManager();
  var source;
  var isOriginalSource = false;

  if (sourceRaw) {
    isOriginalSource = true;
    source = createSourceFromSeriesDataOption(sourceRaw);
  } else {
    source = sourceManager.getSource(); // Is series.data. not dataset.

    isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;
  }

  var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
  var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);
  var useEncodeDefaulter = opt.useEncodeDefaulter;
  var encodeDefaulter = isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry$1(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;
  var createDimensionOptions = {
    coordDimensions: coordSysDimDefs,
    generateCoord: opt.generateCoord,
    encodeDefine: seriesModel.getEncode(),
    encodeDefaulter: encodeDefaulter,
    canOmitUnusedDimensions: !isOriginalSource
  };
  var schema = prepareSeriesDataSchema(source, createDimensionOptions);
  var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);
  var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;
  var stackCalculationInfo = enableDataStack(seriesModel, {
    schema: schema,
    store: store
  });
  var data = new SeriesData$1(schema, seriesModel);
  data.setCalculationInfo(stackCalculationInfo);
  var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function (itemOpt, dimName, dataIndex, dimIndex) {
    // Use dataIndex as ordinal value in categoryAxis
    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
  } : null;
  data.hasItemOption = false;
  data.initData( // Try to reuse the data store in sourceManager if using dataset.
  isOriginalSource ? source : store, null, dimValueGetter);
  return data;
}

function isNeedCompleteOrdinalData(source) {
  if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var sampleItem = firstDataNotNull(source.data || []);
    return !isArray$1(getDataItemValue(sampleItem));
  }
}

function firstDataNotNull(arr) {
  var i = 0;

  while (i < arr.length && arr[i] == null) {
    i++;
  }

  return arr[i];
}

var Scale =
/** @class */
function () {
  function Scale(setting) {
    this._setting = setting || {};
    this._extent = [Infinity, -Infinity];
  }

  Scale.prototype.getSetting = function (name) {
    return this._setting[name];
  };
  /**
   * Set extent from data
   */


  Scale.prototype.unionExtent = function (other) {
    var extent = this._extent;
    other[0] < extent[0] && (extent[0] = other[0]);
    other[1] > extent[1] && (extent[1] = other[1]); // not setExtent because in log axis it may transformed to power
    // this.setExtent(extent[0], extent[1]);
  };
  /**
   * Set extent from data
   */


  Scale.prototype.unionExtentFromData = function (data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  /**
   * Get extent
   *
   * Extent is always in increase order.
   */


  Scale.prototype.getExtent = function () {
    return this._extent.slice();
  };
  /**
   * Set extent
   */


  Scale.prototype.setExtent = function (start, end) {
    var thisExtent = this._extent;

    if (!isNaN(start)) {
      thisExtent[0] = start;
    }

    if (!isNaN(end)) {
      thisExtent[1] = end;
    }
  };
  /**
   * If value is in extent range
   */


  Scale.prototype.isInExtentRange = function (value) {
    return this._extent[0] <= value && this._extent[1] >= value;
  };
  /**
   * When axis extent depends on data and no data exists,
   * axis ticks should not be drawn, which is named 'blank'.
   */


  Scale.prototype.isBlank = function () {
    return this._isBlank;
  };
  /**
   * When axis extent depends on data and no data exists,
   * axis ticks should not be drawn, which is named 'blank'.
   */


  Scale.prototype.setBlank = function (isBlank) {
    this._isBlank = isBlank;
  };

  return Scale;
}();

enableClassManagement(Scale);
var Scale$1 = Scale;

var uidBase = 0;

var OrdinalMeta =
/** @class */
function () {
  function OrdinalMeta(opt) {
    this.categories = opt.categories || [];
    this._needCollect = opt.needCollect;
    this._deduplication = opt.deduplication;
    this.uid = ++uidBase;
  }

  OrdinalMeta.createByAxisModel = function (axisModel) {
    var option = axisModel.option;
    var data = option.data;
    var categories = data && map$1(data, getName);
    return new OrdinalMeta({
      categories: categories,
      needCollect: !categories,
      // deduplication is default in axis.
      deduplication: option.dedplication !== false
    });
  };

  OrdinalMeta.prototype.getOrdinal = function (category) {
    // @ts-ignore
    return this._getOrCreateMap().get(category);
  };
  /**
   * @return The ordinal. If not found, return NaN.
   */


  OrdinalMeta.prototype.parseAndCollect = function (category) {
    var index;
    var needCollect = this._needCollect; // The value of category dim can be the index of the given category set.
    // This feature is only supported when !needCollect, because we should
    // consider a common case: a value is 2017, which is a number but is
    // expected to be tread as a category. This case usually happen in dataset,
    // where it happent to be no need of the index feature.

    if (!isString(category) && !needCollect) {
      return category;
    } // Optimize for the scenario:
    // category is ['2012-01-01', '2012-01-02', ...], where the input
    // data has been ensured not duplicate and is large data.
    // Notice, if a dataset dimension provide categroies, usually echarts
    // should remove duplication except user tell echarts dont do that
    // (set axis.deduplication = false), because echarts do not know whether
    // the values in the category dimension has duplication (consider the
    // parallel-aqi example)


    if (needCollect && !this._deduplication) {
      index = this.categories.length;
      this.categories[index] = category;
      return index;
    }

    var map = this._getOrCreateMap(); // @ts-ignore


    index = map.get(category);

    if (index == null) {
      if (needCollect) {
        index = this.categories.length;
        this.categories[index] = category; // @ts-ignore

        map.set(category, index);
      } else {
        index = NaN;
      }
    }

    return index;
  }; // Consider big data, do not create map until needed.


  OrdinalMeta.prototype._getOrCreateMap = function () {
    return this._map || (this._map = createHashMap(this.categories));
  };

  return OrdinalMeta;
}();

function getName(obj) {
  if (isObject$3(obj) && obj.value != null) {
    return obj.value;
  } else {
    return obj + '';
  }
}

var OrdinalMeta$1 = OrdinalMeta;

function isValueNice(val) {
  var exp10 = Math.pow(10, quantityExponent(Math.abs(val)));
  var f = Math.abs(val / exp10);
  return f === 0 || f === 1 || f === 2 || f === 3 || f === 5;
}
function isIntervalOrLogScale(scale) {
  return scale.type === 'interval' || scale.type === 'log';
}
/**
 * @param extent Both extent[0] and extent[1] should be valid number.
 *               Should be extent[0] < extent[1].
 * @param splitNumber splitNumber should be >= 1.
 */

function intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {
  var result = {};
  var span = extent[1] - extent[0];
  var interval = result.interval = nice(span / splitNumber, true);

  if (minInterval != null && interval < minInterval) {
    interval = result.interval = minInterval;
  }

  if (maxInterval != null && interval > maxInterval) {
    interval = result.interval = maxInterval;
  } // Tow more digital for tick.


  var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent

  var niceTickExtent = result.niceTickExtent = [round$1(Math.ceil(extent[0] / interval) * interval, precision), round$1(Math.floor(extent[1] / interval) * interval, precision)];
  fixExtent(niceTickExtent, extent);
  return result;
}
function increaseInterval(interval) {
  var exp10 = Math.pow(10, quantityExponent(interval)); // Increase interval

  var f = interval / exp10;

  if (!f) {
    f = 1;
  } else if (f === 2) {
    f = 3;
  } else if (f === 3) {
    f = 5;
  } else {
    // f is 1 or 5
    f *= 2;
  }

  return round$1(f * exp10);
}
/**
 * @return interval precision
 */

function getIntervalPrecision(interval) {
  // Tow more digital for tick.
  return getPrecision(interval) + 2;
}

function clamp(niceTickExtent, idx, extent) {
  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
} // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.


function fixExtent(niceTickExtent, extent) {
  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
  clamp(niceTickExtent, 0, extent);
  clamp(niceTickExtent, 1, extent);

  if (niceTickExtent[0] > niceTickExtent[1]) {
    niceTickExtent[0] = niceTickExtent[1];
  }
}
function contain$1(val, extent) {
  return val >= extent[0] && val <= extent[1];
}
function normalize(val, extent) {
  if (extent[1] === extent[0]) {
    return 0.5;
  }

  return (val - extent[0]) / (extent[1] - extent[0]);
}
function scale(val, extent) {
  return val * (extent[1] - extent[0]) + extent[0];
}

var OrdinalScale =
/** @class */
function (_super) {
  __extends$1(OrdinalScale, _super);

  function OrdinalScale(setting) {
    var _this = _super.call(this, setting) || this;

    _this.type = 'ordinal';

    var ordinalMeta = _this.getSetting('ordinalMeta'); // Caution: Should not use instanceof, consider ec-extensions using
    // import approach to get OrdinalMeta class.


    if (!ordinalMeta) {
      ordinalMeta = new OrdinalMeta$1({});
    }

    if (isArray$1(ordinalMeta)) {
      ordinalMeta = new OrdinalMeta$1({
        categories: map$1(ordinalMeta, function (item) {
          return isObject$3(item) ? item.value : item;
        })
      });
    }

    _this._ordinalMeta = ordinalMeta;
    _this._extent = _this.getSetting('extent') || [0, ordinalMeta.categories.length - 1];
    return _this;
  }

  OrdinalScale.prototype.parse = function (val) {
    // Caution: Math.round(null) will return `0` rather than `NaN`
    if (val == null) {
      return NaN;
    }

    return isString(val) ? this._ordinalMeta.getOrdinal(val) // val might be float.
    : Math.round(val);
  };

  OrdinalScale.prototype.contain = function (rank) {
    rank = this.parse(rank);
    return contain$1(rank, this._extent) && this._ordinalMeta.categories[rank] != null;
  };
  /**
   * Normalize given rank or name to linear [0, 1]
   * @param val raw ordinal number.
   * @return normalized value in [0, 1].
   */


  OrdinalScale.prototype.normalize = function (val) {
    val = this._getTickNumber(this.parse(val));
    return normalize(val, this._extent);
  };
  /**
   * @param val normalized value in [0, 1].
   * @return raw ordinal number.
   */


  OrdinalScale.prototype.scale = function (val) {
    val = Math.round(scale(val, this._extent));
    return this.getRawOrdinalNumber(val);
  };

  OrdinalScale.prototype.getTicks = function () {
    var ticks = [];
    var extent = this._extent;
    var rank = extent[0];

    while (rank <= extent[1]) {
      ticks.push({
        value: rank
      });
      rank++;
    }

    return ticks;
  };

  OrdinalScale.prototype.getMinorTicks = function (splitNumber) {
    // Not support.
    return;
  };
  /**
   * @see `Ordinal['_ordinalNumbersByTick']`
   */


  OrdinalScale.prototype.setSortInfo = function (info) {
    if (info == null) {
      this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
      return;
    }

    var infoOrdinalNumbers = info.ordinalNumbers;
    var ordinalsByTick = this._ordinalNumbersByTick = [];
    var ticksByOrdinal = this._ticksByOrdinalNumber = []; // Unnecessary support negative tick in `realtimeSort`.

    var tickNum = 0;
    var allCategoryLen = this._ordinalMeta.categories.length;

    for (var len = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len; ++tickNum) {
      var ordinalNumber = infoOrdinalNumbers[tickNum];
      ordinalsByTick[tickNum] = ordinalNumber;
      ticksByOrdinal[ordinalNumber] = tickNum;
    } // Handle that `series.data` only covers part of the `axis.category.data`.


    var unusedOrdinal = 0;

    for (; tickNum < allCategoryLen; ++tickNum) {
      while (ticksByOrdinal[unusedOrdinal] != null) {
        unusedOrdinal++;
      }
      ordinalsByTick.push(unusedOrdinal);
      ticksByOrdinal[unusedOrdinal] = tickNum;
    }
  };

  OrdinalScale.prototype._getTickNumber = function (ordinal) {
    var ticksByOrdinalNumber = this._ticksByOrdinalNumber; // also support ordinal out of range of `ordinalMeta.categories.length`,
    // where ordinal numbers are used as tick value directly.

    return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
  };
  /**
   * @usage
   * ```js
   * const ordinalNumber = ordinalScale.getRawOrdinalNumber(tickVal);
   *
   * // case0
   * const rawOrdinalValue = axisModel.getCategories()[ordinalNumber];
   * // case1
   * const rawOrdinalValue = this._ordinalMeta.categories[ordinalNumber];
   * // case2
   * const coord = axis.dataToCoord(ordinalNumber);
   * ```
   *
   * @param {OrdinalNumber} tickNumber index of display
   */


  OrdinalScale.prototype.getRawOrdinalNumber = function (tickNumber) {
    var ordinalNumbersByTick = this._ordinalNumbersByTick; // tickNumber may be out of range, e.g., when axis max is larger than `ordinalMeta.categories.length`.,
    // where ordinal numbers are used as tick value directly.

    return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
  };
  /**
   * Get item on tick
   */


  OrdinalScale.prototype.getLabel = function (tick) {
    if (!this.isBlank()) {
      var ordinalNumber = this.getRawOrdinalNumber(tick.value);
      var cateogry = this._ordinalMeta.categories[ordinalNumber]; // Note that if no data, ordinalMeta.categories is an empty array.
      // Return empty if it's not exist.

      return cateogry == null ? '' : cateogry + '';
    }
  };

  OrdinalScale.prototype.count = function () {
    return this._extent[1] - this._extent[0] + 1;
  };

  OrdinalScale.prototype.unionExtentFromData = function (data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  /**
   * @override
   * If value is in extent range
   */


  OrdinalScale.prototype.isInExtentRange = function (value) {
    value = this._getTickNumber(value);
    return this._extent[0] <= value && this._extent[1] >= value;
  };

  OrdinalScale.prototype.getOrdinalMeta = function () {
    return this._ordinalMeta;
  };

  OrdinalScale.prototype.calcNiceTicks = function () {};

  OrdinalScale.prototype.calcNiceExtent = function () {};

  OrdinalScale.type = 'ordinal';
  return OrdinalScale;
}(Scale$1);

Scale$1.registerClass(OrdinalScale);
var OrdinalScale$1 = OrdinalScale;

var roundNumber = round$1;

var IntervalScale =
/** @class */
function (_super) {
  __extends$1(IntervalScale, _super);

  function IntervalScale() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'interval'; // Step is calculated in adjustExtent.

    _this._interval = 0;
    _this._intervalPrecision = 2;
    return _this;
  }

  IntervalScale.prototype.parse = function (val) {
    return val;
  };

  IntervalScale.prototype.contain = function (val) {
    return contain$1(val, this._extent);
  };

  IntervalScale.prototype.normalize = function (val) {
    return normalize(val, this._extent);
  };

  IntervalScale.prototype.scale = function (val) {
    return scale(val, this._extent);
  };

  IntervalScale.prototype.setExtent = function (start, end) {
    var thisExtent = this._extent; // start,end may be a Number like '25',so...

    if (!isNaN(start)) {
      thisExtent[0] = parseFloat(start);
    }

    if (!isNaN(end)) {
      thisExtent[1] = parseFloat(end);
    }
  };

  IntervalScale.prototype.unionExtent = function (other) {
    var extent = this._extent;
    other[0] < extent[0] && (extent[0] = other[0]);
    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes

    this.setExtent(extent[0], extent[1]);
  };

  IntervalScale.prototype.getInterval = function () {
    return this._interval;
  };

  IntervalScale.prototype.setInterval = function (interval) {
    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent
    // We assume user wan't to set both interval, min, max to get a better result

    this._niceExtent = this._extent.slice();
    this._intervalPrecision = getIntervalPrecision(interval);
  };
  /**
   * @param expandToNicedExtent Whether expand the ticks to niced extent.
   */


  IntervalScale.prototype.getTicks = function (expandToNicedExtent) {
    var interval = this._interval;
    var extent = this._extent;
    var niceTickExtent = this._niceExtent;
    var intervalPrecision = this._intervalPrecision;
    var ticks = []; // If interval is 0, return [];

    if (!interval) {
      return ticks;
    } // Consider this case: using dataZoom toolbox, zoom and zoom.


    var safeLimit = 10000;

    if (extent[0] < niceTickExtent[0]) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent[0]
        });
      }
    }

    var tick = niceTickExtent[0];

    while (tick <= niceTickExtent[1]) {
      ticks.push({
        value: tick
      }); // Avoid rounding error

      tick = roundNumber(tick + interval, intervalPrecision);

      if (tick === ticks[ticks.length - 1].value) {
        // Consider out of safe float point, e.g.,
        // -3711126.9907707 + 2e-10 === -3711126.9907707
        break;
      }

      if (ticks.length > safeLimit) {
        return [];
      }
    } // Consider this case: the last item of ticks is smaller
    // than niceTickExtent[1] and niceTickExtent[1] === extent[1].


    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];

    if (extent[1] > lastNiceTick) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(lastNiceTick + interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent[1]
        });
      }
    }

    return ticks;
  };

  IntervalScale.prototype.getMinorTicks = function (splitNumber) {
    var ticks = this.getTicks(true);
    var minorTicks = [];
    var extent = this.getExtent();

    for (var i = 1; i < ticks.length; i++) {
      var nextTick = ticks[i];
      var prevTick = ticks[i - 1];
      var count = 0;
      var minorTicksGroup = [];
      var interval = nextTick.value - prevTick.value;
      var minorInterval = interval / splitNumber;

      while (count < splitNumber - 1) {
        var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval); // For the first and last interval. The count may be less than splitNumber.

        if (minorTick > extent[0] && minorTick < extent[1]) {
          minorTicksGroup.push(minorTick);
        }

        count++;
      }

      minorTicks.push(minorTicksGroup);
    }

    return minorTicks;
  };
  /**
   * @param opt.precision If 'auto', use nice presision.
   * @param opt.pad returns 1.50 but not 1.5 if precision is 2.
   */


  IntervalScale.prototype.getLabel = function (data, opt) {
    if (data == null) {
      return '';
    }

    var precision = opt && opt.precision;

    if (precision == null) {
      precision = getPrecision(data.value) || 0;
    } else if (precision === 'auto') {
      // Should be more precise then tick.
      precision = this._intervalPrecision;
    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.
    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.


    var dataNum = roundNumber(data.value, precision, true);
    return addCommas(dataNum);
  };
  /**
   * @param splitNumber By default `5`.
   */


  IntervalScale.prototype.calcNiceTicks = function (splitNumber, minInterval, maxInterval) {
    splitNumber = splitNumber || 5;
    var extent = this._extent;
    var span = extent[1] - extent[0];

    if (!isFinite(span)) {
      return;
    } // User may set axis min 0 and data are all negative
    // FIXME If it needs to reverse ?


    if (span < 0) {
      span = -span;
      extent.reverse();
    }

    var result = intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);
    this._intervalPrecision = result.intervalPrecision;
    this._interval = result.interval;
    this._niceExtent = result.niceTickExtent;
  };

  IntervalScale.prototype.calcNiceExtent = function (opt) {
    var extent = this._extent; // If extent start and end are same, expand them

    if (extent[0] === extent[1]) {
      if (extent[0] !== 0) {
        // Expand extent
        // Note that extents can be both negative. See #13154
        var expandSize = Math.abs(extent[0]); // In the fowllowing case
        //      Axis has been fixed max 100
        //      Plus data are all 100 and axis extent are [100, 100].
        // Extend to the both side will cause expanded max is larger than fixed max.
        // So only expand to the smaller side.

        if (!opt.fixMax) {
          extent[1] += expandSize / 2;
          extent[0] -= expandSize / 2;
        } else {
          extent[0] -= expandSize / 2;
        }
      } else {
        extent[1] = 1;
      }
    }

    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]

    if (!isFinite(span)) {
      extent[0] = 0;
      extent[1] = 1;
    }

    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // let extent = this._extent;

    var interval = this._interval;

    if (!opt.fixMin) {
      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);
    }

    if (!opt.fixMax) {
      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);
    }
  };

  IntervalScale.prototype.setNiceExtent = function (min, max) {
    this._niceExtent = [min, max];
  };

  IntervalScale.type = 'interval';
  return IntervalScale;
}(Scale$1);

Scale$1.registerClass(IntervalScale);
var IntervalScale$1 = IntervalScale;

/* global Float32Array */

var supportFloat32Array = typeof Float32Array !== 'undefined';
var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
function createFloat32Array(arg) {
  if (isArray$1(arg)) {
    // Return self directly if don't support TypedArray.
    return supportFloat32Array ? new Float32Array(arg) : arg;
  } // Else is number


  return new Float32ArrayCtor(arg);
}

var STACK_PREFIX = '__ec_stack_';

function getSeriesStackId(seriesModel) {
  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;
}

function getAxisKey(axis) {
  return axis.dim + axis.index;
}
function prepareLayoutBarSeries(seriesType, ecModel) {
  var seriesModels = [];
  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
    // Check series coordinate, do layout for cartesian2d only
    if (isOnCartesian(seriesModel)) {
      seriesModels.push(seriesModel);
    }
  });
  return seriesModels;
}
/**
 * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent
 * values.
 * This works for time axes, value axes, and log axes.
 * For a single time axis, return value is in the form like
 * {'x_0': [1000000]}.
 * The value of 1000000 is in milliseconds.
 */

function getValueAxesMinGaps(barSeries) {
  /**
   * Map from axis.index to values.
   * For a single time axis, axisValues is in the form like
   * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.
   * Items in axisValues[x], e.g. 1495555200000, are time values of all
   * series.
   */
  var axisValues = {};
  each$9(barSeries, function (seriesModel) {
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();

    if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {
      return;
    }

    var data = seriesModel.getData();
    var key = baseAxis.dim + '_' + baseAxis.index;
    var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
    var store = data.getStore();

    for (var i = 0, cnt = store.count(); i < cnt; ++i) {
      var value = store.get(dimIdx, i);

      if (!axisValues[key]) {
        // No previous data for the axis
        axisValues[key] = [value];
      } else {
        // No value in previous series
        axisValues[key].push(value);
      } // Ignore duplicated time values in the same axis

    }
  });
  var axisMinGaps = {};

  for (var key in axisValues) {
    if (axisValues.hasOwnProperty(key)) {
      var valuesInAxis = axisValues[key];

      if (valuesInAxis) {
        // Sort axis values into ascending order to calculate gaps
        valuesInAxis.sort(function (a, b) {
          return a - b;
        });
        var min = null;

        for (var j = 1; j < valuesInAxis.length; ++j) {
          var delta = valuesInAxis[j] - valuesInAxis[j - 1];

          if (delta > 0) {
            // Ignore 0 delta because they are of the same axis value
            min = min === null ? delta : Math.min(min, delta);
          }
        } // Set to null if only have one data


        axisMinGaps[key] = min;
      }
    }
  }

  return axisMinGaps;
}

function makeColumnLayout(barSeries) {
  var axisMinGaps = getValueAxesMinGaps(barSeries);
  var seriesInfoList = [];
  each$9(barSeries, function (seriesModel) {
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var axisExtent = baseAxis.getExtent();
    var bandWidth;

    if (baseAxis.type === 'category') {
      bandWidth = baseAxis.getBandWidth();
    } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {
      var key = baseAxis.dim + '_' + baseAxis.index;
      var minGap = axisMinGaps[key];
      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
      var scale = baseAxis.scale.getExtent();
      var scaleSpan = Math.abs(scale[1] - scale[0]);
      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan; // When there is only one data value
    } else {
      var data = seriesModel.getData();
      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    }

    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);
    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);
    var barMinWidth = parsePercent( // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
    // the auto-calculated bar width might be less than 0.5 / 1.
    seriesModel.get('barMinWidth') || (isInLargeMode(seriesModel) ? 0.5 : 1), bandWidth);
    var barGap = seriesModel.get('barGap');
    var barCategoryGap = seriesModel.get('barCategoryGap');
    seriesInfoList.push({
      bandWidth: bandWidth,
      barWidth: barWidth,
      barMaxWidth: barMaxWidth,
      barMinWidth: barMinWidth,
      barGap: barGap,
      barCategoryGap: barCategoryGap,
      axisKey: getAxisKey(baseAxis),
      stackId: getSeriesStackId(seriesModel)
    });
  });
  return doCalBarWidthAndOffset(seriesInfoList);
}

function doCalBarWidthAndOffset(seriesInfoList) {
  // Columns info on each category axis. Key is cartesian name
  var columnsMap = {};
  each$9(seriesInfoList, function (seriesInfo, idx) {
    var axisKey = seriesInfo.axisKey;
    var bandWidth = seriesInfo.bandWidth;
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth: bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: null,
      gap: '20%',
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = seriesInfo.stackId;

    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }

    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    }; // Caution: In a single coordinate system, these barGrid attributes
    // will be shared by series. Consider that they have default values,
    // only the attributes set on the last series will work.
    // Do not change this fact unless there will be a break change.

    var barWidth = seriesInfo.barWidth;

    if (barWidth && !stacks[stackId].width) {
      // See #6312, do not restrict width.
      stacks[stackId].width = barWidth;
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      columnsOnAxis.remainedWidth -= barWidth;
    }

    var barMaxWidth = seriesInfo.barMaxWidth;
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    var barMinWidth = seriesInfo.barMinWidth;
    barMinWidth && (stacks[stackId].minWidth = barMinWidth);
    var barGap = seriesInfo.barGap;
    barGap != null && (columnsOnAxis.gap = barGap);
    var barCategoryGap = seriesInfo.barCategoryGap;
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  each$9(columnsMap, function (columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGapPercent = columnsOnAxis.categoryGap;

    if (categoryGapPercent == null) {
      var columnCount = keys(stacks).length; // More columns in one group
      // the spaces between group is smaller. Or the column will be too thin.

      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + '%';
    }

    var categoryGap = parsePercent(categoryGapPercent, bandWidth);
    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth

    each$9(stacks, function (column) {
      var maxWidth = column.maxWidth;
      var minWidth = column.minWidth;

      if (!column.width) {
        var finalWidth = autoWidth;

        if (maxWidth && maxWidth < finalWidth) {
          finalWidth = Math.min(maxWidth, remainedWidth);
        } // `minWidth` has higher priority. `minWidth` decide that wheter the
        // bar is able to be visible. So `minWidth` should not be restricted
        // by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In
        // the extreme cases for `value` axis, bars are allowed to overlap
        // with each other if `minWidth` specified.


        if (minWidth && minWidth > finalWidth) {
          finalWidth = minWidth;
        }

        if (finalWidth !== autoWidth) {
          column.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      } else {
        // `barMinWidth/barMaxWidth` has higher priority than `barWidth`, as
        // CSS does. Becuase barWidth can be a percent value, where
        // `barMaxWidth` can be used to restrict the final width.
        var finalWidth = column.width;

        if (maxWidth) {
          finalWidth = Math.min(finalWidth, maxWidth);
        } // `minWidth` has higher priority, as described above


        if (minWidth) {
          finalWidth = Math.max(finalWidth, minWidth);
        }

        column.width = finalWidth;
        remainedWidth -= finalWidth + barGapPercent * finalWidth;
        autoWidthCount--;
      }
    }); // Recalculate width again

    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    each$9(stacks, function (column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }

      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });

    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }

    var offset = -widthSum / 2;
    each$9(stacks, function (column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        bandWidth: bandWidth,
        offset: offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}

function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
  if (barWidthAndOffset && axis) {
    var result = barWidthAndOffset[getAxisKey(axis)];

    if (result != null && seriesModel != null) {
      return result[getSeriesStackId(seriesModel)];
    }

    return result;
  }
}
function layout$1(seriesType, ecModel) {
  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);
  var barWidthAndOffset = makeColumnLayout(seriesModels);
  each$9(seriesModels, function (seriesModel) {
    var data = seriesModel.getData();
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var stackId = getSeriesStackId(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    data.setLayout({
      bandWidth: columnLayoutInfo.bandWidth,
      offset: columnOffset,
      size: columnWidth
    });
  });
} // TODO: Do not support stack in large mode yet.

function createProgressiveLayout(seriesType) {
  return {
    seriesType: seriesType,
    plan: createRenderPlanner(),
    reset: function (seriesModel) {
      if (!isOnCartesian(seriesModel)) {
        return;
      }

      var data = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var valueAxis = cartesian.getOtherAxis(baseAxis);
      var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis.dim));
      var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
      var drawBackground = seriesModel.get('showBackground', true);
      var valueDim = data.mapDimension(valueAxis.dim);
      var stackResultDim = data.getCalculationInfo('stackResultDimension');
      var stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo('stackedOnSeries');
      var isValueAxisH = valueAxis.isHorizontal();
      var valueAxisStart = getValueAxisStart(baseAxis, valueAxis);
      var isLarge = isInLargeMode(seriesModel);
      var barMinHeight = seriesModel.get('barMinHeight') || 0;
      var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim); // Layout info.

      var columnWidth = data.getLayout('size');
      var columnOffset = data.getLayout('offset');
      return {
        progress: function (params, data) {
          var count = params.count;
          var largePoints = isLarge && createFloat32Array(count * 3);
          var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count * 3);
          var largeDataIndices = isLarge && createFloat32Array(count);
          var coordLayout = cartesian.master.getRect();
          var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;
          var dataIndex;
          var store = data.getStore();
          var idxOffset = 0;

          while ((dataIndex = params.next()) != null) {
            var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);
            var baseValue = store.get(baseDimIdx, dataIndex);
            var baseCoord = valueAxisStart;
            var startValue = void 0; // Because of the barMinHeight, we can not use the value in
            // stackResultDimension directly.

            if (stacked) {
              startValue = +value - store.get(valueDimIdx, dataIndex);
            }

            var x = void 0;
            var y = void 0;
            var width = void 0;
            var height = void 0;

            if (isValueAxisH) {
              var coord = cartesian.dataToPoint([value, baseValue]);

              if (stacked) {
                var startCoord = cartesian.dataToPoint([startValue, baseValue]);
                baseCoord = startCoord[0];
              }

              x = baseCoord;
              y = coord[1] + columnOffset;
              width = coord[0] - baseCoord;
              height = columnWidth;

              if (Math.abs(width) < barMinHeight) {
                width = (width < 0 ? -1 : 1) * barMinHeight;
              }
            } else {
              var coord = cartesian.dataToPoint([baseValue, value]);

              if (stacked) {
                var startCoord = cartesian.dataToPoint([baseValue, startValue]);
                baseCoord = startCoord[1];
              }

              x = coord[0] + columnOffset;
              y = baseCoord;
              width = columnWidth;
              height = coord[1] - baseCoord;

              if (Math.abs(height) < barMinHeight) {
                // Include zero to has a positive bar
                height = (height <= 0 ? -1 : 1) * barMinHeight;
              }
            }

            if (!isLarge) {
              data.setItemLayout(dataIndex, {
                x: x,
                y: y,
                width: width,
                height: height
              });
            } else {
              largePoints[idxOffset] = x;
              largePoints[idxOffset + 1] = y;
              largePoints[idxOffset + 2] = isValueAxisH ? width : height;

              if (largeBackgroundPoints) {
                largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x;
                largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y;
                largeBackgroundPoints[idxOffset + 2] = bgSize;
              }

              largeDataIndices[dataIndex] = dataIndex;
            }

            idxOffset += 3;
          }

          if (isLarge) {
            data.setLayout({
              largePoints: largePoints,
              largeDataIndices: largeDataIndices,
              largeBackgroundPoints: largeBackgroundPoints,
              valueAxisHorizontal: isValueAxisH
            });
          }
        }
      };
    }
  };
}

function isOnCartesian(seriesModel) {
  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';
}

function isInLargeMode(seriesModel) {
  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
} // See cases in `test/bar-start.html` and `#7412`, `#8747`.


function getValueAxisStart(baseAxis, valueAxis) {
  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));
}

var bisect = function (a, x, lo, hi) {
  while (lo < hi) {
    var mid = lo + hi >>> 1;

    if (a[mid][1] < x) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }

  return lo;
};

var TimeScale =
/** @class */
function (_super) {
  __extends$1(TimeScale, _super);

  function TimeScale(settings) {
    var _this = _super.call(this, settings) || this;

    _this.type = 'time';
    return _this;
  }
  /**
   * Get label is mainly for other components like dataZoom, tooltip.
   */


  TimeScale.prototype.getLabel = function (tick) {
    var useUTC = this.getSetting('useUTC');
    return format$1(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting('locale'));
  };

  TimeScale.prototype.getFormattedLabel = function (tick, idx, labelFormatter) {
    var isUTC = this.getSetting('useUTC');
    var lang = this.getSetting('locale');
    return leveledFormat(tick, idx, labelFormatter, lang, isUTC);
  };
  /**
   * @override
   */


  TimeScale.prototype.getTicks = function () {
    var interval = this._interval;
    var extent = this._extent;
    var ticks = []; // If interval is 0, return [];

    if (!interval) {
      return ticks;
    }

    ticks.push({
      value: extent[0],
      level: 0
    });
    var useUTC = this.getSetting('useUTC');
    var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent);
    ticks = ticks.concat(innerTicks);
    ticks.push({
      value: extent[1],
      level: 0
    });
    return ticks;
  };

  TimeScale.prototype.calcNiceExtent = function (opt) {
    var extent = this._extent; // If extent start and end are same, expand them

    if (extent[0] === extent[1]) {
      // Expand extent
      extent[0] -= ONE_DAY;
      extent[1] += ONE_DAY;
    } // If there are no data and extent are [Infinity, -Infinity]


    if (extent[1] === -Infinity && extent[0] === Infinity) {
      var d = new Date();
      extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
      extent[0] = extent[1] - ONE_DAY;
    }

    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
  };

  TimeScale.prototype.calcNiceTicks = function (approxTickNum, minInterval, maxInterval) {
    approxTickNum = approxTickNum || 10;
    var extent = this._extent;
    var span = extent[1] - extent[0];
    this._approxInterval = span / approxTickNum;

    if (minInterval != null && this._approxInterval < minInterval) {
      this._approxInterval = minInterval;
    }

    if (maxInterval != null && this._approxInterval > maxInterval) {
      this._approxInterval = maxInterval;
    }

    var scaleIntervalsLen = scaleIntervals.length;
    var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1); // Interval that can be used to calculate ticks

    this._interval = scaleIntervals[idx][1]; // Min level used when picking ticks from top down.
    // We check one more level to avoid the ticks are to sparse in some case.

    this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
  };

  TimeScale.prototype.parse = function (val) {
    // val might be float.
    return isNumber(val) ? val : +parseDate(val);
  };

  TimeScale.prototype.contain = function (val) {
    return contain$1(this.parse(val), this._extent);
  };

  TimeScale.prototype.normalize = function (val) {
    return normalize(this.parse(val), this._extent);
  };

  TimeScale.prototype.scale = function (val) {
    return scale(val, this._extent);
  };

  TimeScale.type = 'time';
  return TimeScale;
}(IntervalScale$1);
/**
 * This implementation was originally copied from "d3.js"
 * <https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/time/scale.js>
 * with some modifications made for this program.
 * See the license statement at the head of this file.
 */


var scaleIntervals = [// Format                           interval
['second', ONE_SECOND], ['minute', ONE_MINUTE], ['hour', ONE_HOUR], ['quarter-day', ONE_HOUR * 6], ['half-day', ONE_HOUR * 12], ['day', ONE_DAY * 1.2], ['half-week', ONE_DAY * 3.5], ['week', ONE_DAY * 7], ['month', ONE_DAY * 31], ['quarter', ONE_DAY * 95], ['half-year', ONE_YEAR / 2], ['year', ONE_YEAR] // 1Y
];

function isUnitValueSame(unit, valueA, valueB, isUTC) {
  var dateA = parseDate(valueA);
  var dateB = parseDate(valueB);

  var isSame = function (unit) {
    return getUnitValue(dateA, unit, isUTC) === getUnitValue(dateB, unit, isUTC);
  };

  var isSameYear = function () {
    return isSame('year');
  }; // const isSameHalfYear = () => isSameYear() && isSame('half-year');
  // const isSameQuater = () => isSameYear() && isSame('quarter');


  var isSameMonth = function () {
    return isSameYear() && isSame('month');
  };

  var isSameDay = function () {
    return isSameMonth() && isSame('day');
  }; // const isSameHalfDay = () => isSameDay() && isSame('half-day');


  var isSameHour = function () {
    return isSameDay() && isSame('hour');
  };

  var isSameMinute = function () {
    return isSameHour() && isSame('minute');
  };

  var isSameSecond = function () {
    return isSameMinute() && isSame('second');
  };

  var isSameMilliSecond = function () {
    return isSameSecond() && isSame('millisecond');
  };

  switch (unit) {
    case 'year':
      return isSameYear();

    case 'month':
      return isSameMonth();

    case 'day':
      return isSameDay();

    case 'hour':
      return isSameHour();

    case 'minute':
      return isSameMinute();

    case 'second':
      return isSameSecond();

    case 'millisecond':
      return isSameMilliSecond();
  }
} // const primaryUnitGetters = {
//     year: fullYearGetterName(),
//     month: monthGetterName(),
//     day: dateGetterName(),
//     hour: hoursGetterName(),
//     minute: minutesGetterName(),
//     second: secondsGetterName(),
//     millisecond: millisecondsGetterName()
// };
// const primaryUnitUTCGetters = {
//     year: fullYearGetterName(true),
//     month: monthGetterName(true),
//     day: dateGetterName(true),
//     hour: hoursGetterName(true),
//     minute: minutesGetterName(true),
//     second: secondsGetterName(true),
//     millisecond: millisecondsGetterName(true)
// };
// function moveTick(date: Date, unitName: TimeUnit, step: number, isUTC: boolean) {
//     step = step || 1;
//     switch (getPrimaryTimeUnit(unitName)) {
//         case 'year':
//             date[fullYearSetterName(isUTC)](date[fullYearGetterName(isUTC)]() + step);
//             break;
//         case 'month':
//             date[monthSetterName(isUTC)](date[monthGetterName(isUTC)]() + step);
//             break;
//         case 'day':
//             date[dateSetterName(isUTC)](date[dateGetterName(isUTC)]() + step);
//             break;
//         case 'hour':
//             date[hoursSetterName(isUTC)](date[hoursGetterName(isUTC)]() + step);
//             break;
//         case 'minute':
//             date[minutesSetterName(isUTC)](date[minutesGetterName(isUTC)]() + step);
//             break;
//         case 'second':
//             date[secondsSetterName(isUTC)](date[secondsGetterName(isUTC)]() + step);
//             break;
//         case 'millisecond':
//             date[millisecondsSetterName(isUTC)](date[millisecondsGetterName(isUTC)]() + step);
//             break;
//     }
//     return date.getTime();
// }
// const DATE_INTERVALS = [[8, 7.5], [4, 3.5], [2, 1.5]];
// const MONTH_INTERVALS = [[6, 5.5], [3, 2.5], [2, 1.5]];
// const MINUTES_SECONDS_INTERVALS = [[30, 30], [20, 20], [15, 15], [10, 10], [5, 5], [2, 2]];


function getDateInterval(approxInterval, daysInMonth) {
  approxInterval /= ONE_DAY;
  return approxInterval > 16 ? 16 // Math.floor(daysInMonth / 2) + 1  // In this case we only want one tick betwen two month.
  : approxInterval > 7.5 ? 7 // TODO week 7 or day 8?
  : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
}

function getMonthInterval(approxInterval) {
  var APPROX_ONE_MONTH = 30 * ONE_DAY;
  approxInterval /= APPROX_ONE_MONTH;
  return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
}

function getHourInterval(approxInterval) {
  approxInterval /= ONE_HOUR;
  return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
}

function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
  approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
  return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
}

function getMillisecondsInterval(approxInterval) {
  return nice(approxInterval, true);
}

function getFirstTimestampOfUnit(date, unitName, isUTC) {
  var outDate = new Date(date);

  switch (getPrimaryTimeUnit(unitName)) {
    case 'year':
    case 'month':
      outDate[monthSetterName(isUTC)](0);

    case 'day':
      outDate[dateSetterName(isUTC)](1);

    case 'hour':
      outDate[hoursSetterName(isUTC)](0);

    case 'minute':
      outDate[minutesSetterName(isUTC)](0);

    case 'second':
      outDate[secondsSetterName(isUTC)](0);
      outDate[millisecondsSetterName(isUTC)](0);
  }

  return outDate.getTime();
}

function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent) {
  var safeLimit = 10000;
  var unitNames = timeUnits;
  var iter = 0;

  function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out) {
    var date = new Date(minTimestamp);
    var dateTime = minTimestamp;
    var d = date[getMethodName](); // if (isDate) {
    //     d -= 1; // Starts with 0;   PENDING
    // }

    while (dateTime < maxTimestamp && dateTime <= extent[1]) {
      out.push({
        value: dateTime
      });
      d += interval;
      date[setMethodName](d);
      dateTime = date.getTime();
    } // This extra tick is for calcuating ticks of next level. Will not been added to the final result


    out.push({
      value: dateTime,
      notAdd: true
    });
  }

  function addLevelTicks(unitName, lastLevelTicks, levelTicks) {
    var newAddedTicks = [];
    var isFirstLevel = !lastLevelTicks.length;

    if (isUnitValueSame(getPrimaryTimeUnit(unitName), extent[0], extent[1], isUTC)) {
      return;
    }

    if (isFirstLevel) {
      lastLevelTicks = [{
        // TODO Optimize. Not include so may ticks.
        value: getFirstTimestampOfUnit(new Date(extent[0]), unitName, isUTC)
      }, {
        value: extent[1]
      }];
    }

    for (var i = 0; i < lastLevelTicks.length - 1; i++) {
      var startTick = lastLevelTicks[i].value;
      var endTick = lastLevelTicks[i + 1].value;

      if (startTick === endTick) {
        continue;
      }

      var interval = void 0;
      var getterName = void 0;
      var setterName = void 0;
      var isDate = false;

      switch (unitName) {
        case 'year':
          interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
          getterName = fullYearGetterName(isUTC);
          setterName = fullYearSetterName(isUTC);
          break;

        case 'half-year':
        case 'quarter':
        case 'month':
          interval = getMonthInterval(approxInterval);
          getterName = monthGetterName(isUTC);
          setterName = monthSetterName(isUTC);
          break;

        case 'week': // PENDING If week is added. Ignore day.

        case 'half-week':
        case 'day':
          interval = getDateInterval(approxInterval); // Use 32 days and let interval been 16

          getterName = dateGetterName(isUTC);
          setterName = dateSetterName(isUTC);
          isDate = true;
          break;

        case 'half-day':
        case 'quarter-day':
        case 'hour':
          interval = getHourInterval(approxInterval);
          getterName = hoursGetterName(isUTC);
          setterName = hoursSetterName(isUTC);
          break;

        case 'minute':
          interval = getMinutesAndSecondsInterval(approxInterval, true);
          getterName = minutesGetterName(isUTC);
          setterName = minutesSetterName(isUTC);
          break;

        case 'second':
          interval = getMinutesAndSecondsInterval(approxInterval, false);
          getterName = secondsGetterName(isUTC);
          setterName = secondsSetterName(isUTC);
          break;

        case 'millisecond':
          interval = getMillisecondsInterval(approxInterval);
          getterName = millisecondsGetterName(isUTC);
          setterName = millisecondsSetterName(isUTC);
          break;
      }

      addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);

      if (unitName === 'year' && levelTicks.length > 1 && i === 0) {
        // Add nearest years to the left extent.
        levelTicks.unshift({
          value: levelTicks[0].value - interval
        });
      }
    }

    for (var i = 0; i < newAddedTicks.length; i++) {
      levelTicks.push(newAddedTicks[i]);
    } // newAddedTicks.length && console.log(unitName, newAddedTicks);


    return newAddedTicks;
  }

  var levelsTicks = [];
  var currentLevelTicks = [];
  var tickCount = 0;
  var lastLevelTickCount = 0;

  for (var i = 0; i < unitNames.length && iter++ < safeLimit; ++i) {
    var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i]);

    if (!isPrimaryTimeUnit(unitNames[i])) {
      // TODO
      continue;
    }

    addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
    var nextPrimaryTimeUnit = unitNames[i + 1] ? getPrimaryTimeUnit(unitNames[i + 1]) : null;

    if (primaryTimeUnit !== nextPrimaryTimeUnit) {
      if (currentLevelTicks.length) {
        lastLevelTickCount = tickCount; // Remove the duplicate so the tick count can be precisely.

        currentLevelTicks.sort(function (a, b) {
          return a.value - b.value;
        });
        var levelTicksRemoveDuplicated = [];

        for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {
          var tickValue = currentLevelTicks[i_1].value;

          if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
            levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);

            if (tickValue >= extent[0] && tickValue <= extent[1]) {
              tickCount++;
            }
          }
        }

        var targetTickNum = (extent[1] - extent[0]) / approxInterval; // Added too much in this level and not too less in last level

        if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
          break;
        } // Only treat primary time unit as one level.


        levelsTicks.push(levelTicksRemoveDuplicated);

        if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {
          break;
        }
      } // Reset if next unitName is primary


      currentLevelTicks = [];
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    if (iter >= safeLimit) {
      warn('Exceed safe limit.');
    }
  }

  var levelsTicksInExtent = filter(map$1(levelsTicks, function (levelTicks) {
    return filter(levelTicks, function (tick) {
      return tick.value >= extent[0] && tick.value <= extent[1] && !tick.notAdd;
    });
  }), function (levelTicks) {
    return levelTicks.length > 0;
  });
  var ticks = [];
  var maxLevel = levelsTicksInExtent.length - 1;

  for (var i = 0; i < levelsTicksInExtent.length; ++i) {
    var levelTicks = levelsTicksInExtent[i];

    for (var k = 0; k < levelTicks.length; ++k) {
      ticks.push({
        value: levelTicks[k].value,
        level: maxLevel - i
      });
    }
  }

  ticks.sort(function (a, b) {
    return a.value - b.value;
  }); // Remove duplicates

  var result = [];

  for (var i = 0; i < ticks.length; ++i) {
    if (i === 0 || ticks[i].value !== ticks[i - 1].value) {
      result.push(ticks[i]);
    }
  }

  return result;
}

Scale$1.registerClass(TimeScale);
var TimeScale$1 = TimeScale;

var scaleProto = Scale$1.prototype; // FIXME:TS refactor: not good to call it directly with `this`?

var intervalScaleProto = IntervalScale$1.prototype;
var roundingErrorFix = round$1;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var mathPow = Math.pow;
var mathLog$1 = Math.log;

var LogScale =
/** @class */
function (_super) {
  __extends$1(LogScale, _super);

  function LogScale() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'log';
    _this.base = 10;
    _this._originalScale = new IntervalScale$1(); // FIXME:TS actually used by `IntervalScale`

    _this._interval = 0;
    return _this;
  }
  /**
   * @param Whether expand the ticks to niced extent.
   */


  LogScale.prototype.getTicks = function (expandToNicedExtent) {
    var originalScale = this._originalScale;
    var extent = this._extent;
    var originalExtent = originalScale.getExtent();
    var ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent);
    return map$1(ticks, function (tick) {
      var val = tick.value;
      var powVal = round$1(mathPow(this.base, val)); // Fix #4158

      powVal = val === extent[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
      powVal = val === extent[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
      return {
        value: powVal
      };
    }, this);
  };

  LogScale.prototype.setExtent = function (start, end) {
    var base = mathLog$1(this.base); // log(-Infinity) is NaN, so safe guard here

    start = mathLog$1(Math.max(0, start)) / base;
    end = mathLog$1(Math.max(0, end)) / base;
    intervalScaleProto.setExtent.call(this, start, end);
  };
  /**
   * @return {number} end
   */


  LogScale.prototype.getExtent = function () {
    var base = this.base;
    var extent = scaleProto.getExtent.call(this);
    extent[0] = mathPow(base, extent[0]);
    extent[1] = mathPow(base, extent[1]); // Fix #4158

    var originalScale = this._originalScale;
    var originalExtent = originalScale.getExtent();
    this._fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
    this._fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
    return extent;
  };

  LogScale.prototype.unionExtent = function (extent) {
    this._originalScale.unionExtent(extent);

    var base = this.base;
    extent[0] = mathLog$1(extent[0]) / mathLog$1(base);
    extent[1] = mathLog$1(extent[1]) / mathLog$1(base);
    scaleProto.unionExtent.call(this, extent);
  };

  LogScale.prototype.unionExtentFromData = function (data, dim) {
    // TODO
    // filter value that <= 0
    this.unionExtent(data.getApproximateExtent(dim));
  };
  /**
   * Update interval and extent of intervals for nice ticks
   * @param approxTickNum default 10 Given approx tick number
   */


  LogScale.prototype.calcNiceTicks = function (approxTickNum) {
    approxTickNum = approxTickNum || 10;
    var extent = this._extent;
    var span = extent[1] - extent[0];

    if (span === Infinity || span <= 0) {
      return;
    }

    var interval = quantity(span);
    var err = approxTickNum / span * interval; // Filter ticks to get closer to the desired count.

    if (err <= 0.5) {
      interval *= 10;
    } // Interval should be integer


    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
      interval *= 10;
    }

    var niceExtent = [round$1(mathCeil(extent[0] / interval) * interval), round$1(mathFloor(extent[1] / interval) * interval)];
    this._interval = interval;
    this._niceExtent = niceExtent;
  };

  LogScale.prototype.calcNiceExtent = function (opt) {
    intervalScaleProto.calcNiceExtent.call(this, opt);
    this._fixMin = opt.fixMin;
    this._fixMax = opt.fixMax;
  };

  LogScale.prototype.parse = function (val) {
    return val;
  };

  LogScale.prototype.contain = function (val) {
    val = mathLog$1(val) / mathLog$1(this.base);
    return contain$1(val, this._extent);
  };

  LogScale.prototype.normalize = function (val) {
    val = mathLog$1(val) / mathLog$1(this.base);
    return normalize(val, this._extent);
  };

  LogScale.prototype.scale = function (val) {
    val = scale(val, this._extent);
    return mathPow(this.base, val);
  };

  LogScale.type = 'log';
  return LogScale;
}(Scale$1);

var proto = LogScale.prototype;
proto.getMinorTicks = intervalScaleProto.getMinorTicks;
proto.getLabel = intervalScaleProto.getLabel;

function fixRoundingError(val, originalVal) {
  return roundingErrorFix(val, getPrecision(originalVal));
}

Scale$1.registerClass(LogScale);
var LogScale$1 = LogScale;

var ScaleRawExtentInfo =
/** @class */
function () {
  function ScaleRawExtentInfo(scale, model, // Usually: data extent from all series on this axis.
  originalExtent) {
    this._prepareParams(scale, model, originalExtent);
  }
  /**
   * Parameters depending on ouside (like model, user callback)
   * are prepared and fixed here.
   */


  ScaleRawExtentInfo.prototype._prepareParams = function (scale, model, // Usually: data extent from all series on this axis.
  dataExtent) {
    if (dataExtent[1] < dataExtent[0]) {
      dataExtent = [NaN, NaN];
    }

    this._dataMin = dataExtent[0];
    this._dataMax = dataExtent[1];
    var isOrdinal = this._isOrdinal = scale.type === 'ordinal';
    this._needCrossZero = scale.type === 'interval' && model.getNeedCrossZero && model.getNeedCrossZero();
    var modelMinRaw = this._modelMinRaw = model.get('min', true);

    if (isFunction(modelMinRaw)) {
      // This callback alway provide users the full data extent (before data filtered).
      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMinRaw !== 'dataMin') {
      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw);
    }

    var modelMaxRaw = this._modelMaxRaw = model.get('max', true);

    if (isFunction(modelMaxRaw)) {
      // This callback alway provide users the full data extent (before data filtered).
      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMaxRaw !== 'dataMax') {
      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw);
    }

    if (isOrdinal) {
      // FIXME: there is a flaw here: if there is no "block" data processor like `dataZoom`,
      // and progressive rendering is using, here the category result might just only contain
      // the processed chunk rather than the entire result.
      this._axisDataLen = model.getCategories().length;
    } else {
      var boundaryGap = model.get('boundaryGap');
      var boundaryGapArr = isArray$1(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];

      if (typeof boundaryGapArr[0] === 'boolean' || typeof boundaryGapArr[1] === 'boolean') {
        if (process.env.NODE_ENV !== 'production') {
          console.warn('Boolean type for boundaryGap is only ' + 'allowed for ordinal axis. Please use string in ' + 'percentage instead, e.g., "20%". Currently, ' + 'boundaryGap is set to be 0.');
        }

        this._boundaryGapInner = [0, 0];
      } else {
        this._boundaryGapInner = [parsePercent$1(boundaryGapArr[0], 1), parsePercent$1(boundaryGapArr[1], 1)];
      }
    }
  };
  /**
   * Calculate extent by prepared parameters.
   * This method has no external dependency and can be called duplicatedly,
   * getting the same result.
   * If parameters changed, should call this method to recalcuate.
   */


  ScaleRawExtentInfo.prototype.calculate = function () {
    // Notice: When min/max is not set (that is, when there are null/undefined,
    // which is the most common case), these cases should be ensured:
    // (1) For 'ordinal', show all axis.data.
    // (2) For others:
    //      + `boundaryGap` is applied (if min/max set, boundaryGap is
    //      disabled).
    //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should
    //      be the result that originalExtent enlarged by boundaryGap.
    // (3) If no data, it should be ensured that `scale.setBlank` is set.
    var isOrdinal = this._isOrdinal;
    var dataMin = this._dataMin;
    var dataMax = this._dataMax;
    var axisDataLen = this._axisDataLen;
    var boundaryGapInner = this._boundaryGapInner;
    var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null; // Currently if a `'value'` axis model min is specified as 'dataMin'/'dataMax',
    // `boundaryGap` will not be used. It's the different from specifying as `null`/`undefined`.

    var min = this._modelMinRaw === 'dataMin' ? dataMin : this._modelMinNum;
    var max = this._modelMaxRaw === 'dataMax' ? dataMax : this._modelMaxNum; // If `_modelMinNum`/`_modelMaxNum` is `null`/`undefined`, should not be fixed.

    var minFixed = min != null;
    var maxFixed = max != null;

    if (min == null) {
      min = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
    }

    if (max == null) {
      max = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
    }

    (min == null || !isFinite(min)) && (min = NaN);
    (max == null || !isFinite(max)) && (max = NaN);
    var isBlank = eqNaN(min) || eqNaN(max) || isOrdinal && !axisDataLen; // If data extent modified, need to recalculated to ensure cross zero.

    if (this._needCrossZero) {
      // Axis is over zero and min is not set
      if (min > 0 && max > 0 && !minFixed) {
        min = 0; // minFixed = true;
      } // Axis is under zero and max is not set


      if (min < 0 && max < 0 && !maxFixed) {
        max = 0; // maxFixed = true;
      } // PENDING:
      // When `needCrossZero` and all data is positive/negative, should it be ensured
      // that the results processed by boundaryGap are positive/negative?
      // If so, here `minFixed`/`maxFixed` need to be set.

    }

    var determinedMin = this._determinedMin;
    var determinedMax = this._determinedMax;

    if (determinedMin != null) {
      min = determinedMin;
      minFixed = true;
    }

    if (determinedMax != null) {
      max = determinedMax;
      maxFixed = true;
    } // Ensure min/max be finite number or NaN here. (not to be null/undefined)
    // `NaN` means min/max axis is blank.


    return {
      min: min,
      max: max,
      minFixed: minFixed,
      maxFixed: maxFixed,
      isBlank: isBlank
    };
  };

  ScaleRawExtentInfo.prototype.modifyDataMinMax = function (minMaxName, val) {
    if (process.env.NODE_ENV !== 'production') {
      assert(!this.frozen);
    }

    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
  };

  ScaleRawExtentInfo.prototype.setDeterminedMinMax = function (minMaxName, val) {
    var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];

    if (process.env.NODE_ENV !== 'production') {
      assert(!this.frozen // Earse them usually means logic flaw.
      && this[attr] == null);
    }

    this[attr] = val;
  };

  ScaleRawExtentInfo.prototype.freeze = function () {
    // @ts-ignore
    this.frozen = true;
  };

  return ScaleRawExtentInfo;
}();
var DETERMINED_MIN_MAX_ATTR = {
  min: '_determinedMin',
  max: '_determinedMax'
};
var DATA_MIN_MAX_ATTR = {
  min: '_dataMin',
  max: '_dataMax'
};
/**
 * Get scale min max and related info only depends on model settings.
 * This method can be called after coordinate system created.
 * For example, in data processing stage.
 *
 * Scale extent info probably be required multiple times during a workflow.
 * For example:
 * (1) `dataZoom` depends it to get the axis extent in "100%" state.
 * (2) `processor/extentCalculator` depends it to make sure whether axis extent is specified.
 * (3) `coordSys.update` use it to finally decide the scale extent.
 * But the callback of `min`/`max` should not be called multiple times.
 * The code below should not be implemented repeatedly either.
 * So we cache the result in the scale instance, which will be recreated at the begining
 * of the workflow (because `scale` instance will be recreated each round of the workflow).
 */

function ensureScaleRawExtentInfo(scale, model, // Usually: data extent from all series on this axis.
originalExtent) {
  // Do not permit to recreate.
  var rawExtentInfo = scale.rawExtentInfo;

  if (rawExtentInfo) {
    return rawExtentInfo;
  }

  rawExtentInfo = new ScaleRawExtentInfo(scale, model, originalExtent); // @ts-ignore

  scale.rawExtentInfo = rawExtentInfo;
  return rawExtentInfo;
}
function parseAxisModelMinMax(scale, minMax) {
  return minMax == null ? null : eqNaN(minMax) ? NaN : scale.parse(minMax);
}

/**
 * Get axis scale extent before niced.
 * Item of returned array can only be number (including Infinity and NaN).
 *
 * Caution:
 * Precondition of calling this method:
 * The scale extent has been initialized using series data extent via
 * `scale.setExtent` or `scale.unionExtentFromData`;
 */

function getScaleExtent(scale, model) {
  var scaleType = scale.type;
  var rawExtentResult = ensureScaleRawExtentInfo(scale, model, scale.getExtent()).calculate();
  scale.setBlank(rawExtentResult.isBlank);
  var min = rawExtentResult.min;
  var max = rawExtentResult.max; // If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis
  // is base axis
  // FIXME
  // (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.
  // (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?
  //     Should not depend on series type `bar`?
  // (3) Fix that might overlap when using dataZoom.
  // (4) Consider other chart types using `barGrid`?
  // See #6728, #4862, `test/bar-overflow-time-plot.html`

  var ecModel = model.ecModel;

  if (ecModel && scaleType === 'time'
  /*|| scaleType === 'interval' */
  ) {
    var barSeriesModels = prepareLayoutBarSeries('bar', ecModel);
    var isBaseAxisAndHasBarSeries_1 = false;
    each$9(barSeriesModels, function (seriesModel) {
      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;
    });

    if (isBaseAxisAndHasBarSeries_1) {
      // Calculate placement of bars on axis. TODO should be decoupled
      // with barLayout
      var barWidthAndOffset = makeColumnLayout(barSeriesModels); // Adjust axis min and max to account for overflow

      var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);
      min = adjustedScale.min;
      max = adjustedScale.max;
    }
  }

  return {
    extent: [min, max],
    // "fix" means "fixed", the value should not be
    // changed in the subsequent steps.
    fixMin: rawExtentResult.minFixed,
    fixMax: rawExtentResult.maxFixed
  };
}

function adjustScaleForOverflow(min, max, model, // Only support cartesian coord yet.
barWidthAndOffset) {
  // Get Axis Length
  var axisExtent = model.axis.getExtent();
  var axisLength = axisExtent[1] - axisExtent[0]; // Get bars on current base axis and calculate min and max overflow

  var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);

  if (barsOnCurrentAxis === undefined) {
    return {
      min: min,
      max: max
    };
  }

  var minOverflow = Infinity;
  each$9(barsOnCurrentAxis, function (item) {
    minOverflow = Math.min(item.offset, minOverflow);
  });
  var maxOverflow = -Infinity;
  each$9(barsOnCurrentAxis, function (item) {
    maxOverflow = Math.max(item.offset + item.width, maxOverflow);
  });
  minOverflow = Math.abs(minOverflow);
  maxOverflow = Math.abs(maxOverflow);
  var totalOverFlow = minOverflow + maxOverflow; // Calculate required buffer based on old range and overflow

  var oldRange = max - min;
  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
  max += overflowBuffer * (maxOverflow / totalOverFlow);
  min -= overflowBuffer * (minOverflow / totalOverFlow);
  return {
    min: min,
    max: max
  };
} // Precondition of calling this method:
// The scale extent has been initailized using series data extent via
// `scale.setExtent` or `scale.unionExtentFromData`;


function niceScaleExtent(scale, inModel) {
  var model = inModel;
  var extentInfo = getScaleExtent(scale, model);
  var extent = extentInfo.extent;
  var splitNumber = model.get('splitNumber');

  if (scale instanceof LogScale$1) {
    scale.base = model.get('logBase');
  }

  var scaleType = scale.type;
  var interval = model.get('interval');
  var isIntervalOrTime = scaleType === 'interval' || scaleType === 'time';
  scale.setExtent(extent[0], extent[1]);
  scale.calcNiceExtent({
    splitNumber: splitNumber,
    fixMin: extentInfo.fixMin,
    fixMax: extentInfo.fixMax,
    minInterval: isIntervalOrTime ? model.get('minInterval') : null,
    maxInterval: isIntervalOrTime ? model.get('maxInterval') : null
  }); // If some one specified the min, max. And the default calculated interval
  // is not good enough. He can specify the interval. It is often appeared
  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard
  // to be 60.
  // FIXME

  if (interval != null) {
    scale.setInterval && scale.setInterval(interval);
  }
}
/**
 * @param axisType Default retrieve from model.type
 */

function createScaleByModel(model, axisType) {
  axisType = axisType || model.get('type');

  if (axisType) {
    switch (axisType) {
      // Buildin scale
      case 'category':
        return new OrdinalScale$1({
          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
          extent: [Infinity, -Infinity]
        });

      case 'time':
        return new TimeScale$1({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get('useUTC')
        });

      default:
        // case 'value'/'interval', 'log', or others.
        return new (Scale$1.getClass(axisType) || IntervalScale$1)();
    }
  }
}
/**
 * Check if the axis cross 0
 */

function ifAxisCrossZero(axis) {
  var dataExtent = axis.scale.getExtent();
  var min = dataExtent[0];
  var max = dataExtent[1];
  return !(min > 0 && max > 0 || min < 0 && max < 0);
}
/**
 * @param axis
 * @return Label formatter function.
 *         param: {number} tickValue,
 *         param: {number} idx, the index in all ticks.
 *                         If category axis, this param is not required.
 *         return: {string} label string.
 */

function makeLabelFormatter(axis) {
  var labelFormatter = axis.getLabelModel().get('formatter');
  var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;

  if (axis.scale.type === 'time') {
    return function (tpl) {
      return function (tick, idx) {
        return axis.scale.getFormattedLabel(tick, idx, tpl);
      };
    }(labelFormatter);
  } else if (isString(labelFormatter)) {
    return function (tpl) {
      return function (tick) {
        // For category axis, get raw value; for numeric axis,
        // get formatted label like '1,333,444'.
        var label = axis.scale.getLabel(tick);
        var text = tpl.replace('{value}', label != null ? label : '');
        return text;
      };
    }(labelFormatter);
  } else if (isFunction(labelFormatter)) {
    return function (cb) {
      return function (tick, idx) {
        // The original intention of `idx` is "the index of the tick in all ticks".
        // But the previous implementation of category axis do not consider the
        // `axisLabel.interval`, which cause that, for example, the `interval` is
        // `1`, then the ticks "name5", "name7", "name9" are displayed, where the
        // corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep
        // the definition here for back compatibility.
        if (categoryTickStart != null) {
          idx = tick.value - categoryTickStart;
        }

        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {
          level: tick.level
        } : null);
      };
    }(labelFormatter);
  } else {
    return function (tick) {
      return axis.scale.getLabel(tick);
    };
  }
}
function getAxisRawValue(axis, tick) {
  // In category axis with data zoom, tick is not the original
  // index of axis.data. So tick should not be exposed to user
  // in category axis.
  return axis.type === 'category' ? axis.scale.getLabel(tick) : tick.value;
}
/**
 * @param axis
 * @return Be null/undefined if no labels.
 */

function estimateLabelUnionRect(axis) {
  var axisModel = axis.model;
  var scale = axis.scale;

  if (!axisModel.get(['axisLabel', 'show']) || scale.isBlank()) {
    return;
  }

  var realNumberScaleTicks;
  var tickCount;
  var categoryScaleExtent = scale.getExtent(); // Optimize for large category data, avoid call `getTicks()`.

  if (scale instanceof OrdinalScale$1) {
    tickCount = scale.count();
  } else {
    realNumberScaleTicks = scale.getTicks();
    tickCount = realNumberScaleTicks.length;
  }

  var axisLabelModel = axis.getLabelModel();
  var labelFormatter = makeLabelFormatter(axis);
  var rect;
  var step = 1; // Simple optimization for large amount of labels

  if (tickCount > 40) {
    step = Math.ceil(tickCount / 40);
  }

  for (var i = 0; i < tickCount; i += step) {
    var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {
      value: categoryScaleExtent[0] + i
    };
    var label = labelFormatter(tick, i);
    var unrotatedSingleRect = axisLabelModel.getTextRect(label);
    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);
    rect ? rect.union(singleRect) : rect = singleRect;
  }

  return rect;
}

function rotateTextRect(textRect, rotate) {
  var rotateRadians = rotate * Math.PI / 180;
  var beforeWidth = textRect.width;
  var beforeHeight = textRect.height;
  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
  var rotatedRect = new BoundingRect$1(textRect.x, textRect.y, afterWidth, afterHeight);
  return rotatedRect;
}
/**
 * @param model axisLabelModel or axisTickModel
 * @return {number|String} Can be null|'auto'|number|function
 */


function getOptionCategoryInterval(model) {
  var interval = model.get('interval');
  return interval == null ? 'auto' : interval;
}
/**
 * Set `categoryInterval` as 0 implicitly indicates that
 * show all labels reguardless of overlap.
 * @param {Object} axis axisModel.axis
 */

function shouldShowAllLabels(axis) {
  return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(data, axisDim) {
  // Remove duplicated dat dimensions caused by `getStackedDimension`.
  var dataDimMap = {}; // Currently `mapDimensionsAll` will contain stack result dimension ('__\0ecstackresult').
  // PENDING: is it reasonable? Do we need to remove the original dim from "coord dim" since
  // there has been stacked result dim?

  each$9(data.mapDimensionsAll(axisDim), function (dataDim) {
    // For example, the extent of the original dimension
    // is [0.1, 0.5], the extent of the `stackResultDimension`
    // is [7, 9], the final extent should NOT include [0.1, 0.5],
    // because there is no graphic corresponding to [0.1, 0.5].
    // See the case in `test/area-stack.html` `main1`, where area line
    // stack needs `yAxis` not start from 0.
    dataDimMap[getStackedDimension(data, dataDim)] = true;
  });
  return keys(dataDimMap);
}

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// eslint-disable-next-line @typescript-eslint/no-unused-vars
var AxisModelCommonMixin =
/** @class */
function () {
  function AxisModelCommonMixin() {}

  AxisModelCommonMixin.prototype.getNeedCrossZero = function () {
    var option = this.option;
    return !option.scale;
  };
  /**
   * Should be implemented by each axis model if necessary.
   * @return coordinate system model
   */


  AxisModelCommonMixin.prototype.getCoordSysModel = function () {
    return;
  };

  return AxisModelCommonMixin;
}();

/**
 * Create a muti dimension List structure from seriesModel.
 */

function createList(seriesModel) {
  return createSeriesData(null, seriesModel);
} // export function createGraph(seriesModel) {
var dataStack = {
  isDimensionStacked: isDimensionStacked,
  enableDataStack: enableDataStack,
  getStackedDimension: getStackedDimension
};
/**
 * Create scale
 * @param {Array.<number>} dataExtent
 * @param {Object|module:echarts/Model} option If `optoin.type`
 *        is secified, it can only be `'value'` currently.
 */

function createScale(dataExtent, option) {
  var axisModel = option;

  if (!(option instanceof Model$1)) {
    axisModel = new Model$1(option); // FIXME
    // Currently AxisModelCommonMixin has nothing to do with the
    // the requirements of `axisHelper.createScaleByModel`. For
    // example the method `getCategories` and `getOrdinalMeta`
    // are required for `'category'` axis, and ecModel are required
    // for `'time'` axis. But occationally echarts-gl happened
    // to only use `'value'` axis.
    // zrUtil.mixin(axisModel, AxisModelCommonMixin);
  }

  var scale = createScaleByModel(axisModel);
  scale.setExtent(dataExtent[0], dataExtent[1]);
  niceScaleExtent(scale, axisModel);
  return scale;
}
/**
 * Mixin common methods to axis model,
 *
 * Inlcude methods
 * `getFormattedLabels() => Array.<string>`
 * `getCategories() => Array.<string>`
 * `getMin(origin: boolean) => number`
 * `getMax(origin: boolean) => number`
 * `getNeedCrossZero() => boolean`
 */

function mixinAxisModelCommonMethods(Model) {
  mixin(Model, AxisModelCommonMixin);
}
function createTextStyle(textStyleModel, opts) {
  opts = opts || {};
  return createTextStyle$1(textStyleModel, null, null, opts.state !== 'normal');
}

var helper = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createList: createList,
  getLayoutRect: getLayoutRect,
  dataStack: dataStack,
  createScale: createScale,
  mixinAxisModelCommonMethods: mixinAxisModelCommonMethods,
  getECData: getECData,
  createTextStyle: createTextStyle,
  createDimensions: createDimensions,
  createSymbol: createSymbol,
  enableHoverEmphasis: enableHoverEmphasis
});

var extensions = [];
var extensionRegisters = {
  registerPreprocessor: registerPreprocessor,
  registerProcessor: registerProcessor,
  registerPostInit: registerPostInit,
  registerPostUpdate: registerPostUpdate,
  registerUpdateLifecycle: registerUpdateLifecycle,
  registerAction: registerAction,
  registerCoordinateSystem: registerCoordinateSystem,
  registerLayout: registerLayout,
  registerVisual: registerVisual,
  registerTransform: registerTransform,
  registerLoading: registerLoading,
  registerMap: registerMap$1,
  registerImpl: registerImpl,
  PRIORITY: PRIORITY,
  ComponentModel: ComponentModel$1,
  ComponentView: ComponentView$1,
  SeriesModel: SeriesModel$1,
  ChartView: ChartView$1,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function (ComponentModelClass) {
    ComponentModel$1.registerClass(ComponentModelClass);
  },
  registerComponentView: function (ComponentViewClass) {
    ComponentView$1.registerClass(ComponentViewClass);
  },
  registerSeriesModel: function (SeriesModelClass) {
    SeriesModel$1.registerClass(SeriesModelClass);
  },
  registerChartView: function (ChartViewClass) {
    ChartView$1.registerClass(ChartViewClass);
  },
  registerSubTypeDefaulter: function (componentType, defaulter) {
    ComponentModel$1.registerSubTypeDefaulter(componentType, defaulter);
  },
  registerPainter: function (painterType, PainterCtor) {
    registerPainter(painterType, PainterCtor);
  }
};
function use(ext) {
  if (isArray$1(ext)) {
    // use([ChartLine, ChartBar]);
    each$9(ext, function (singleExt) {
      use(singleExt);
    });
    return;
  }

  if (indexOf(extensions, ext) >= 0) {
    return;
  }

  extensions.push(ext);

  if (isFunction(ext)) {
    ext = {
      install: ext
    };
  }

  ext.install(extensionRegisters);
}

var EPSILON = 1e-8;
function isAroundEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
}
function contain(points, x, y) {
    var w = 0;
    var p = points[0];
    if (!p) {
        return false;
    }
    for (var i = 1; i < points.length; i++) {
        var p2 = points[i];
        w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
        p = p2;
    }
    var p0 = points[0];
    if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {
        w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
    }
    return w !== 0;
}

var TMP_TRANSFORM = [];

function transformPoints(points, transform) {
  for (var p = 0; p < points.length; p++) {
    applyTransform$1(points[p], points[p], transform);
  }
}

function updateBBoxFromPoints(points, min, max, projection) {
  for (var i = 0; i < points.length; i++) {
    var p = points[i];

    if (projection) {
      // projection may return null point.
      p = projection.project(p);
    }

    if (p && isFinite(p[0]) && isFinite(p[1])) {
      min$1(min, min, p);
      max$1(max, max, p);
    }
  }
}

function centroid(points) {
  var signedArea = 0;
  var cx = 0;
  var cy = 0;
  var len = points.length;
  var x0 = points[len - 1][0];
  var y0 = points[len - 1][1]; // Polygon should been closed.

  for (var i = 0; i < len; i++) {
    var x1 = points[i][0];
    var y1 = points[i][1];
    var a = x0 * y1 - x1 * y0;
    signedArea += a;
    cx += (x0 + x1) * a;
    cy += (y0 + y1) * a;
    x0 = x1;
    y0 = y1;
  }

  return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points[0][0] || 0, points[0][1] || 0];
}

var Region =
/** @class */
function () {
  function Region(name) {
    this.name = name;
  }

  Region.prototype.setCenter = function (center) {
    this._center = center;
  };
  /**
   * Get center point in data unit. That is,
   * for GeoJSONRegion, the unit is lat/lng,
   * for GeoSVGRegion, the unit is SVG local coord.
   */


  Region.prototype.getCenter = function () {
    var center = this._center;

    if (!center) {
      // In most cases there are no need to calculate this center.
      // So calculate only when called.
      center = this._center = this.calcCenter();
    }

    return center;
  };

  return Region;
}();

var GeoJSONPolygonGeometry =
/** @class */
function () {
  function GeoJSONPolygonGeometry(exterior, interiors) {
    this.type = 'polygon';
    this.exterior = exterior;
    this.interiors = interiors;
  }

  return GeoJSONPolygonGeometry;
}();

var GeoJSONLineStringGeometry =
/** @class */
function () {
  function GeoJSONLineStringGeometry(points) {
    this.type = 'linestring';
    this.points = points;
  }

  return GeoJSONLineStringGeometry;
}();

var GeoJSONRegion =
/** @class */
function (_super) {
  __extends$1(GeoJSONRegion, _super);

  function GeoJSONRegion(name, geometries, cp) {
    var _this = _super.call(this, name) || this;

    _this.type = 'geoJSON';
    _this.geometries = geometries;
    _this._center = cp && [cp[0], cp[1]];
    return _this;
  }

  GeoJSONRegion.prototype.calcCenter = function () {
    var geometries = this.geometries;
    var largestGeo;
    var largestGeoSize = 0;

    for (var i = 0; i < geometries.length; i++) {
      var geo = geometries[i];
      var exterior = geo.exterior; // Simple trick to use points count instead of polygon area as region size.
      // Ignore linestring

      var size = exterior && exterior.length;

      if (size > largestGeoSize) {
        largestGeo = geo;
        largestGeoSize = size;
      }
    }

    if (largestGeo) {
      return centroid(largestGeo.exterior);
    } // from bounding rect by default.


    var rect = this.getBoundingRect();
    return [rect.x + rect.width / 2, rect.y + rect.height / 2];
  };

  GeoJSONRegion.prototype.getBoundingRect = function (projection) {
    var rect = this._rect; // Always recalculate if using projection.

    if (rect && !projection) {
      return rect;
    }

    var min = [Infinity, Infinity];
    var max = [-Infinity, -Infinity];
    var geometries = this.geometries;
    each$9(geometries, function (geo) {
      if (geo.type === 'polygon') {
        // Doesn't consider hole
        updateBBoxFromPoints(geo.exterior, min, max, projection);
      } else {
        each$9(geo.points, function (points) {
          updateBBoxFromPoints(points, min, max, projection);
        });
      }
    }); // Normalie invalid bounding.

    if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {
      min[0] = min[1] = max[0] = max[1] = 0;
    }

    rect = new BoundingRect$1(min[0], min[1], max[0] - min[0], max[1] - min[1]);

    if (!projection) {
      this._rect = rect;
    }

    return rect;
  };

  GeoJSONRegion.prototype.contain = function (coord) {
    var rect = this.getBoundingRect();
    var geometries = this.geometries;

    if (!rect.contain(coord[0], coord[1])) {
      return false;
    }

    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {
      var geo = geometries[i]; // Only support polygon.

      if (geo.type !== 'polygon') {
        continue;
      }

      var exterior = geo.exterior;
      var interiors = geo.interiors;

      if (contain(exterior, coord[0], coord[1])) {
        // Not in the region if point is in the hole.
        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
          if (contain(interiors[k], coord[0], coord[1])) {
            continue loopGeo;
          }
        }

        return true;
      }
    }

    return false;
  };
  /**
   * Transform the raw coords to target bounding.
   * @param x
   * @param y
   * @param width
   * @param height
   */


  GeoJSONRegion.prototype.transformTo = function (x, y, width, height) {
    var rect = this.getBoundingRect();
    var aspect = rect.width / rect.height;

    if (!width) {
      width = aspect * height;
    } else if (!height) {
      height = width / aspect;
    }

    var target = new BoundingRect$1(x, y, width, height);
    var transform = rect.calculateTransform(target);
    var geometries = this.geometries;

    for (var i = 0; i < geometries.length; i++) {
      var geo = geometries[i];

      if (geo.type === 'polygon') {
        transformPoints(geo.exterior, transform);
        each$9(geo.interiors, function (interior) {
          transformPoints(interior, transform);
        });
      } else {
        each$9(geo.points, function (points) {
          transformPoints(points, transform);
        });
      }
    }

    rect = this._rect;
    rect.copy(target); // Update center

    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  };

  GeoJSONRegion.prototype.cloneShallow = function (name) {
    name == null && (name = this.name);
    var newRegion = new GeoJSONRegion(name, this.geometries, this._center);
    newRegion._rect = this._rect;
    newRegion.transformTo = null; // Simply avoid to be called.

    return newRegion;
  };

  return GeoJSONRegion;
}(Region);

var GeoSVGRegion =
/** @class */
function (_super) {
  __extends$1(GeoSVGRegion, _super);

  function GeoSVGRegion(name, elOnlyForCalculate) {
    var _this = _super.call(this, name) || this;

    _this.type = 'geoSVG';
    _this._elOnlyForCalculate = elOnlyForCalculate;
    return _this;
  }

  GeoSVGRegion.prototype.calcCenter = function () {
    var el = this._elOnlyForCalculate;
    var rect = el.getBoundingRect();
    var center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    var mat = identity(TMP_TRANSFORM);
    var target = el;

    while (target && !target.isGeoSVGGraphicRoot) {
      mul(mat, target.getLocalTransform(), mat);
      target = target.parent;
    }

    invert(mat, mat);
    applyTransform$1(center, center, mat);
    return center;
  };

  return GeoSVGRegion;
}(Region);

function decode(json) {
  if (!json.UTF8Encoding) {
    return json;
  }

  var jsonCompressed = json;
  var encodeScale = jsonCompressed.UTF8Scale;

  if (encodeScale == null) {
    encodeScale = 1024;
  }

  var features = jsonCompressed.features;
  each$9(features, function (feature) {
    var geometry = feature.geometry;
    var encodeOffsets = geometry.encodeOffsets;
    var coordinates = geometry.coordinates; // Geometry may be appeded manually in the script after json loaded.
    // In this case this geometry is usually not encoded.

    if (!encodeOffsets) {
      return;
    }

    switch (geometry.type) {
      case 'LineString':
        geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);
        break;

      case 'Polygon':
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;

      case 'MultiLineString':
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;

      case 'MultiPolygon':
        each$9(coordinates, function (rings, idx) {
          return decodeRings(rings, encodeOffsets[idx], encodeScale);
        });
    }
  }); // Has been decoded

  jsonCompressed.UTF8Encoding = false;
  return jsonCompressed;
}

function decodeRings(rings, encodeOffsets, encodeScale) {
  for (var c = 0; c < rings.length; c++) {
    rings[c] = decodeRing(rings[c], encodeOffsets[c], encodeScale);
  }
}

function decodeRing(coordinate, encodeOffsets, encodeScale) {
  var result = [];
  var prevX = encodeOffsets[0];
  var prevY = encodeOffsets[1];

  for (var i = 0; i < coordinate.length; i += 2) {
    var x = coordinate.charCodeAt(i) - 64;
    var y = coordinate.charCodeAt(i + 1) - 64; // ZigZag decoding

    x = x >> 1 ^ -(x & 1);
    y = y >> 1 ^ -(y & 1); // Delta deocding

    x += prevX;
    y += prevY;
    prevX = x;
    prevY = y; // Dequantize

    result.push([x / encodeScale, y / encodeScale]);
  }

  return result;
}

function parseGeoJSON(geoJson, nameProperty) {
  geoJson = decode(geoJson);
  return map$1(filter(geoJson.features, function (featureObj) {
    // Output of mapshaper may have geometry null
    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
  }), function (featureObj) {
    var properties = featureObj.properties;
    var geo = featureObj.geometry;
    var geometries = [];

    switch (geo.type) {
      case 'Polygon':
        var coordinates = geo.coordinates; // According to the GeoJSON specification.
        // First must be exterior, and the rest are all interior(holes).

        geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)));
        break;

      case 'MultiPolygon':
        each$9(geo.coordinates, function (item) {
          if (item[0]) {
            geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)));
          }
        });
        break;

      case 'LineString':
        geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]));
        break;

      case 'MultiLineString':
        geometries.push(new GeoJSONLineStringGeometry(geo.coordinates));
    }

    var region = new GeoJSONRegion(properties[nameProperty || 'name'], geometries, properties.cp);
    region.properties = properties;
    return region;
  });
}

var number = /*#__PURE__*/Object.freeze({
  __proto__: null,
  linearMap: linearMap$2,
  round: round$1,
  asc: asc$1,
  getPrecision: getPrecision,
  getPrecisionSafe: getPrecisionSafe,
  getPixelPrecision: getPixelPrecision,
  getPercentWithPrecision: getPercentWithPrecision,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
  remRadian: remRadian,
  isRadianAroundZero: isRadianAroundZero,
  parseDate: parseDate,
  quantity: quantity,
  quantityExponent: quantityExponent,
  nice: nice,
  quantile: quantile,
  reformIntervals: reformIntervals,
  isNumeric: isNumeric,
  numericToNumber: numericToNumber
});

var time = /*#__PURE__*/Object.freeze({
  __proto__: null,
  parse: parseDate,
  format: format$1
});

var graphic = /*#__PURE__*/Object.freeze({
  __proto__: null,
  extendShape: extendShape,
  extendPath: extendPath,
  makePath: makePath,
  makeImage: makeImage,
  mergePath: mergePath,
  resizePath: resizePath,
  createIcon: createIcon,
  updateProps: updateProps$1,
  initProps: initProps,
  getTransform: getTransform,
  clipPointsByRect: clipPointsByRect,
  clipRectByRect: clipRectByRect,
  registerShape: registerShape,
  getShapeClass: getShapeClass,
  Group: Group$3,
  Image: ZRImage$1,
  Text: ZRText$1,
  Circle: Circle$1,
  Ellipse: Ellipse$1,
  Sector: Sector$1,
  Ring: Ring$1,
  Polygon: Polygon$1,
  Polyline: Polyline$1,
  Rect: Rect$1,
  Line: Line$1,
  BezierCurve: BezierCurve$1,
  Arc: Arc$1,
  IncrementalDisplayable: IncrementalDisplayable$1,
  CompoundPath: CompoundPath$1,
  LinearGradient: LinearGradient$1,
  RadialGradient: RadialGradient$1,
  BoundingRect: BoundingRect$1
});

var format = /*#__PURE__*/Object.freeze({
  __proto__: null,
  addCommas: addCommas,
  toCamelCase: toCamelCase,
  normalizeCssArray: normalizeCssArray,
  encodeHTML: encodeHTML,
  formatTpl: formatTpl,
  getTooltipMarker: getTooltipMarker,
  formatTime: formatTime,
  capitalFirst: capitalFirst,
  truncateText: truncateText,
  getTextRect: getTextRect
});

var util = /*#__PURE__*/Object.freeze({
  __proto__: null,
  map: map$1,
  each: each$9,
  indexOf: indexOf,
  inherits: inherits,
  reduce: reduce,
  filter: filter,
  bind: bind$1,
  curry: curry$1,
  isArray: isArray$1,
  isString: isString,
  isObject: isObject$3,
  isFunction: isFunction,
  extend: extend$2,
  defaults: defaults,
  clone: clone$3,
  merge: merge$1
});

var inner$4 = makeInner();
function createAxisLabels(axis) {
  // Only ordinal scale support tick interval
  return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
}
/**
 * @param {module:echats/coord/Axis} axis
 * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.
 * @return {Object} {
 *     ticks: Array.<number>
 *     tickCategoryInterval: number
 * }
 */

function createAxisTicks(axis, tickModel) {
  // Only ordinal scale support tick interval
  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {
    ticks: map$1(axis.scale.getTicks(), function (tick) {
      return tick.value;
    })
  };
}

function makeCategoryLabels(axis) {
  var labelModel = axis.getLabelModel();
  var result = makeCategoryLabelsActually(axis, labelModel);
  return !labelModel.get('show') || axis.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: result.labelCategoryInterval
  } : result;
}

function makeCategoryLabelsActually(axis, labelModel) {
  var labelsCache = getListCache(axis, 'labels');
  var optionLabelInterval = getOptionCategoryInterval(labelModel);
  var result = listCacheGet(labelsCache, optionLabelInterval);

  if (result) {
    return result;
  }

  var labels;
  var numericLabelInterval;

  if (isFunction(optionLabelInterval)) {
    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
  } else {
    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;
    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
  } // Cache to avoid calling interval function repeatly.


  return listCacheSet(labelsCache, optionLabelInterval, {
    labels: labels,
    labelCategoryInterval: numericLabelInterval
  });
}

function makeCategoryTicks(axis, tickModel) {
  var ticksCache = getListCache(axis, 'ticks');
  var optionTickInterval = getOptionCategoryInterval(tickModel);
  var result = listCacheGet(ticksCache, optionTickInterval);

  if (result) {
    return result;
  }

  var ticks;
  var tickCategoryInterval; // Optimize for the case that large category data and no label displayed,
  // we should not return all ticks.

  if (!tickModel.get('show') || axis.scale.isBlank()) {
    ticks = [];
  }

  if (isFunction(optionTickInterval)) {
    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
  } // Always use label interval by default despite label show. Consider this
  // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows
  // labels. `splitLine` and `axisTick` should be consistent in this case.
  else if (optionTickInterval === 'auto') {
      var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
      tickCategoryInterval = labelsResult.labelCategoryInterval;
      ticks = map$1(labelsResult.labels, function (labelItem) {
        return labelItem.tickValue;
      });
    } else {
      tickCategoryInterval = optionTickInterval;
      ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
    } // Cache to avoid calling interval function repeatly.


  return listCacheSet(ticksCache, optionTickInterval, {
    ticks: ticks,
    tickCategoryInterval: tickCategoryInterval
  });
}

function makeRealNumberLabels(axis) {
  var ticks = axis.scale.getTicks();
  var labelFormatter = makeLabelFormatter(axis);
  return {
    labels: map$1(ticks, function (tick, idx) {
      return {
        level: tick.level,
        formattedLabel: labelFormatter(tick, idx),
        rawLabel: axis.scale.getLabel(tick),
        tickValue: tick.value
      };
    })
  };
}

function getListCache(axis, prop) {
  // Because key can be funciton, and cache size always be small, we use array cache.
  return inner$4(axis)[prop] || (inner$4(axis)[prop] = []);
}

function listCacheGet(cache, key) {
  for (var i = 0; i < cache.length; i++) {
    if (cache[i].key === key) {
      return cache[i].value;
    }
  }
}

function listCacheSet(cache, key, value) {
  cache.push({
    key: key,
    value: value
  });
  return value;
}

function makeAutoCategoryInterval(axis) {
  var result = inner$4(axis).autoInterval;
  return result != null ? result : inner$4(axis).autoInterval = axis.calculateCategoryInterval();
}
/**
 * Calculate interval for category axis ticks and labels.
 * To get precise result, at least one of `getRotate` and `isHorizontal`
 * should be implemented in axis.
 */


function calculateCategoryInterval(axis) {
  var params = fetchAutoCategoryIntervalCalculationParams(axis);
  var labelFormatter = makeLabelFormatter(axis);
  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:
  // avoid generating a long array by `getTicks`
  // in large category data case.

  var tickCount = ordinalScale.count();

  if (ordinalExtent[1] - ordinalExtent[0] < 1) {
    return 0;
  }

  var step = 1; // Simple optimization. Empirical value: tick count should less than 40.

  if (tickCount > 40) {
    step = Math.max(1, Math.floor(tickCount / 40));
  }

  var tickValue = ordinalExtent[0];
  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
  var unitW = Math.abs(unitSpan * Math.cos(rotation));
  var unitH = Math.abs(unitSpan * Math.sin(rotation));
  var maxW = 0;
  var maxH = 0; // Caution: Performance sensitive for large category data.
  // Consider dataZoom, we should make appropriate step to avoid O(n) loop.

  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    var width = 0;
    var height = 0; // Not precise, do not consider align and vertical align
    // and each distance from axis line yet.

    var rect = getBoundingRect(labelFormatter({
      value: tickValue
    }), params.font, 'center', 'top'); // Magic number

    width = rect.width * 1.3;
    height = rect.height * 1.3; // Min size, void long loop.

    maxW = Math.max(maxW, width, 7);
    maxH = Math.max(maxH, height, 7);
  }

  var dw = maxW / unitW;
  var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.

  isNaN(dw) && (dw = Infinity);
  isNaN(dh) && (dh = Infinity);
  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
  var cache = inner$4(axis.model);
  var axisExtent = axis.getExtent();
  var lastAutoInterval = cache.lastAutoInterval;
  var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,
  // otherwise the calculated interval might jitter when the zoom
  // window size is close to the interval-changing size.
  // For example, if all of the axis labels are `a, b, c, d, e, f, g`.
  // The jitter will cause that sometimes the displayed labels are
  // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).

  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical
  // point is not the same when zooming in or zooming out.
  && lastAutoInterval > interval // If the axis change is caused by chart resize, the cache should not
  // be used. Otherwise some hiden labels might not be shown again.
  && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {
    interval = lastAutoInterval;
  } // Only update cache if cache not used, otherwise the
  // changing of interval is too insensitive.
  else {
      cache.lastTickCount = tickCount;
      cache.lastAutoInterval = interval;
      cache.axisExtent0 = axisExtent[0];
      cache.axisExtent1 = axisExtent[1];
    }

  return interval;
}

function fetchAutoCategoryIntervalCalculationParams(axis) {
  var labelModel = axis.getLabelModel();
  return {
    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
    labelRotate: labelModel.get('rotate') || 0,
    font: labelModel.getFont()
  };
}

function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
  var labelFormatter = makeLabelFormatter(axis);
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent();
  var labelModel = axis.getLabelModel();
  var result = []; // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...

  var step = Math.max((categoryInterval || 0) + 1, 1);
  var startTick = ordinalExtent[0];
  var tickCount = ordinalScale.count(); // Calculate start tick based on zero if possible to keep label consistent
  // while zooming and moving while interval > 0. Otherwise the selection
  // of displayable ticks and symbols probably keep changing.
  // 3 is empirical value.

  if (startTick !== 0 && step > 1 && tickCount / step > 2) {
    startTick = Math.round(Math.ceil(startTick / step) * step);
  } // (1) Only add min max label here but leave overlap checking
  // to render stage, which also ensure the returned list
  // suitable for splitLine and splitArea rendering.
  // (2) Scales except category always contain min max label so
  // do not need to perform this process.


  var showAllLabel = shouldShowAllLabels(axis);
  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;
  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;

  if (includeMinLabel && startTick !== ordinalExtent[0]) {
    addItem(ordinalExtent[0]);
  } // Optimize: avoid generating large array by `ordinalScale.getTicks()`.


  var tickValue = startTick;

  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    addItem(tickValue);
  }

  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
    addItem(ordinalExtent[1]);
  }

  function addItem(tickValue) {
    var tickObj = {
      value: tickValue
    };
    result.push(onlyTick ? tickValue : {
      formattedLabel: labelFormatter(tickObj),
      rawLabel: ordinalScale.getLabel(tickObj),
      tickValue: tickValue
    });
  }

  return result;
}

function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
  var ordinalScale = axis.scale;
  var labelFormatter = makeLabelFormatter(axis);
  var result = [];
  each$9(ordinalScale.getTicks(), function (tick) {
    var rawLabel = ordinalScale.getLabel(tick);
    var tickValue = tick.value;

    if (categoryInterval(tick.value, rawLabel)) {
      result.push(onlyTick ? tickValue : {
        formattedLabel: labelFormatter(tick),
        rawLabel: rawLabel,
        tickValue: tickValue
      });
    }
  });
  return result;
}

var NORMALIZED_EXTENT = [0, 1];
/**
 * Base class of Axis.
 */

var Axis =
/** @class */
function () {
  function Axis(dim, scale, extent) {
    this.onBand = false;
    this.inverse = false;
    this.dim = dim;
    this.scale = scale;
    this._extent = extent || [0, 0];
  }
  /**
   * If axis extent contain given coord
   */


  Axis.prototype.contain = function (coord) {
    var extent = this._extent;
    var min = Math.min(extent[0], extent[1]);
    var max = Math.max(extent[0], extent[1]);
    return coord >= min && coord <= max;
  };
  /**
   * If axis extent contain given data
   */


  Axis.prototype.containData = function (data) {
    return this.scale.contain(data);
  };
  /**
   * Get coord extent.
   */


  Axis.prototype.getExtent = function () {
    return this._extent.slice();
  };
  /**
   * Get precision used for formatting
   */


  Axis.prototype.getPixelPrecision = function (dataExtent) {
    return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
  };
  /**
   * Set coord extent
   */


  Axis.prototype.setExtent = function (start, end) {
    var extent = this._extent;
    extent[0] = start;
    extent[1] = end;
  };
  /**
   * Convert data to coord. Data is the rank if it has an ordinal scale
   */


  Axis.prototype.dataToCoord = function (data, clamp) {
    var extent = this._extent;
    var scale = this.scale;
    data = scale.normalize(data);

    if (this.onBand && scale.type === 'ordinal') {
      extent = extent.slice();
      fixExtentWithBands(extent, scale.count());
    }

    return linearMap$2(data, NORMALIZED_EXTENT, extent, clamp);
  };
  /**
   * Convert coord to data. Data is the rank if it has an ordinal scale
   */


  Axis.prototype.coordToData = function (coord, clamp) {
    var extent = this._extent;
    var scale = this.scale;

    if (this.onBand && scale.type === 'ordinal') {
      extent = extent.slice();
      fixExtentWithBands(extent, scale.count());
    }

    var t = linearMap$2(coord, extent, NORMALIZED_EXTENT, clamp);
    return this.scale.scale(t);
  };
  /**
   * Convert pixel point to data in axis
   */


  Axis.prototype.pointToData = function (point, clamp) {
    // Should be implemented in derived class if necessary.
    return;
  };
  /**
   * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,
   * `axis.getTicksCoords` considers `onBand`, which is used by
   * `boundaryGap:true` of category axis and splitLine and splitArea.
   * @param opt.tickModel default: axis.model.getModel('axisTick')
   * @param opt.clamp If `true`, the first and the last
   *        tick must be at the axis end points. Otherwise, clip ticks
   *        that outside the axis extent.
   */


  Axis.prototype.getTicksCoords = function (opt) {
    opt = opt || {};
    var tickModel = opt.tickModel || this.getTickModel();
    var result = createAxisTicks(this, tickModel);
    var ticks = result.ticks;
    var ticksCoords = map$1(ticks, function (tickVal) {
      return {
        coord: this.dataToCoord(this.scale.type === 'ordinal' ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
        tickValue: tickVal
      };
    }, this);
    var alignWithLabel = tickModel.get('alignWithLabel');
    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
    return ticksCoords;
  };

  Axis.prototype.getMinorTicksCoords = function () {
    if (this.scale.type === 'ordinal') {
      // Category axis doesn't support minor ticks
      return [];
    }

    var minorTickModel = this.model.getModel('minorTick');
    var splitNumber = minorTickModel.get('splitNumber'); // Protection.

    if (!(splitNumber > 0 && splitNumber < 100)) {
      splitNumber = 5;
    }

    var minorTicks = this.scale.getMinorTicks(splitNumber);
    var minorTicksCoords = map$1(minorTicks, function (minorTicksGroup) {
      return map$1(minorTicksGroup, function (minorTick) {
        return {
          coord: this.dataToCoord(minorTick),
          tickValue: minorTick
        };
      }, this);
    }, this);
    return minorTicksCoords;
  };

  Axis.prototype.getViewLabels = function () {
    return createAxisLabels(this).labels;
  };

  Axis.prototype.getLabelModel = function () {
    return this.model.getModel('axisLabel');
  };
  /**
   * Notice here we only get the default tick model. For splitLine
   * or splitArea, we should pass the splitLineModel or splitAreaModel
   * manually when calling `getTicksCoords`.
   * In GL, this method may be overrided to:
   * `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`
   */


  Axis.prototype.getTickModel = function () {
    return this.model.getModel('axisTick');
  };
  /**
   * Get width of band
   */


  Axis.prototype.getBandWidth = function () {
    var axisExtent = this._extent;
    var dataExtent = this.scale.getExtent();
    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.

    len === 0 && (len = 1);
    var size = Math.abs(axisExtent[1] - axisExtent[0]);
    return Math.abs(size) / len;
  };
  /**
   * Only be called in category axis.
   * Can be overrided, consider other axes like in 3D.
   * @return Auto interval for cateogry axis tick and label
   */


  Axis.prototype.calculateCategoryInterval = function () {
    return calculateCategoryInterval(this);
  };

  return Axis;
}();

function fixExtentWithBands(extent, nTick) {
  var size = extent[1] - extent[0];
  var len = nTick;
  var margin = size / len / 2;
  extent[0] += margin;
  extent[1] -= margin;
} // If axis has labels [1, 2, 3, 4]. Bands on the axis are
// |---1---|---2---|---3---|---4---|.
// So the displayed ticks and splitLine/splitArea should between
// each data item, otherwise cause misleading (e.g., split tow bars
// of a single data item when there are two bar series).
// Also consider if tickCategoryInterval > 0 and onBand, ticks and
// splitLine/spliteArea should layout appropriately corresponding
// to displayed labels. (So we should not use `getBandWidth` in this
// case).


function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp) {
  var ticksLen = ticksCoords.length;

  if (!axis.onBand || alignWithLabel || !ticksLen) {
    return;
  }

  var axisExtent = axis.getExtent();
  var last;
  var diffSize;

  if (ticksLen === 1) {
    ticksCoords[0].coord = axisExtent[0];
    last = ticksCoords[1] = {
      coord: axisExtent[0]
    };
  } else {
    var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
    var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
    each$9(ticksCoords, function (ticksItem) {
      ticksItem.coord -= shift_1 / 2;
    });
    var dataExtent = axis.scale.getExtent();
    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
    last = {
      coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize
    };
    ticksCoords.push(last);
  }

  var inverse = axisExtent[0] > axisExtent[1]; // Handling clamp.

  if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
    clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
  }

  if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {
    ticksCoords.unshift({
      coord: axisExtent[0]
    });
  }

  if (littleThan(axisExtent[1], last.coord)) {
    clamp ? last.coord = axisExtent[1] : ticksCoords.pop();
  }

  if (clamp && littleThan(last.coord, axisExtent[1])) {
    ticksCoords.push({
      coord: axisExtent[1]
    });
  }

  function littleThan(a, b) {
    // Avoid rounding error cause calculated tick coord different with extent.
    // It may cause an extra unecessary tick added.
    a = round$1(a);
    b = round$1(b);
    return inverse ? a > b : a < b;
  }
}

var Axis$1 = Axis;

// Should use `ComponentModel.extend` or `class XXXX extend ComponentModel` to create class.
// Then use `registerComponentModel` in `install` parameter when `use` this extension. For example:
// class Bar3DModel extends ComponentModel {}
// export function install(registers) { regsiters.registerComponentModel(Bar3DModel); }
// echarts.use(install);

function extendComponentModel(proto) {
  var Model = ComponentModel$1.extend(proto);
  ComponentModel$1.registerClass(Model);
  return Model;
}
function extendComponentView(proto) {
  var View = ComponentView$1.extend(proto);
  ComponentView$1.registerClass(View);
  return View;
}
function extendSeriesModel(proto) {
  var Model = SeriesModel$1.extend(proto);
  SeriesModel$1.registerClass(Model);
  return Model;
}
function extendChartView(proto) {
  var View = ChartView$1.extend(proto);
  ChartView$1.registerClass(View);
  return View;
}

PathProxy$1.CMD;

function projectPointToLine(x1, y1, x2, y2, x, y, out, limitToEnds) {
  var dx = x - x1;
  var dy = y - y1;
  var dx1 = x2 - x1;
  var dy1 = y2 - y1;
  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  dx1 /= lineLen;
  dy1 /= lineLen; // dot product

  var projectedLen = dx * dx1 + dy * dy1;
  var t = projectedLen / lineLen;

  if (limitToEnds) {
    t = Math.min(Math.max(t, 0), 1);
  }

  t *= lineLen;
  var ox = out[0] = x1 + t * dx1;
  var oy = out[1] = y1 + t * dy1;
  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
}


var pt0 = new Point$1();
var pt1 = new Point$1();
var pt2 = new Point$1();
var dir = new Point$1();
var dir2 = new Point$1();

var tmpArr = [];
var tmpProjPoint = new Point$1();
/**
 * Reduce the line segment attached to the label to limit the turn angle between two segments.
 * @param linePoints
 * @param minTurnAngle Radian of minimum turn angle. 0 - 180
 */

function limitTurnAngle(linePoints, minTurnAngle) {
  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {
    return;
  }

  minTurnAngle = minTurnAngle / 180 * Math.PI; // The line points can be
  //      /pt1----pt2 (label)
  //     /
  // pt0/

  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point$1.sub(dir, pt0, pt1);
  Point$1.sub(dir2, pt2, pt1);
  var len1 = dir.len();
  var len2 = dir2.len();

  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }

  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  var angleCos = dir.dot(dir2);
  var minTurnAngleCos = Math.cos(minTurnAngle);

  if (minTurnAngleCos < angleCos) {
    // Smaller than minTurnAngle
    // Calculate project point of pt0 on pt1-pt2
    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr); // Calculate new projected length with limited minTurnAngle and get the new connect point

    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle)); // Limit the new calculated connect point between pt1 and pt2.

    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);

    if (isNaN(t)) {
      return;
    }

    if (t < 0) {
      Point$1.copy(tmpProjPoint, pt1);
    } else if (t > 1) {
      Point$1.copy(tmpProjPoint, pt2);
    }

    tmpProjPoint.toArray(linePoints[1]);
  }
}
/**
 * Limit the angle of line and the surface
 * @param maxSurfaceAngle Radian of minimum turn angle. 0 - 180. 0 is same direction to normal. 180 is opposite
 */

function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {
  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {
    return;
  }

  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point$1.sub(dir, pt1, pt0);
  Point$1.sub(dir2, pt2, pt1);
  var len1 = dir.len();
  var len2 = dir2.len();

  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }

  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  var angleCos = dir.dot(surfaceNormal);
  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);

  if (angleCos < maxSurfaceAngleCos) {
    // Calculate project point of pt0 on pt1-pt2
    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    var HALF_PI = Math.PI / 2;
    var angle2 = Math.acos(dir2.dot(surfaceNormal));
    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;

    if (newAngle >= HALF_PI) {
      // parallel
      Point$1.copy(tmpProjPoint, pt2);
    } else {
      // Calculate new projected length with limited minTurnAngle and get the new connect point
      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle)); // Limit the new calculated connect point between pt1 and pt2.

      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);

      if (isNaN(t)) {
        return;
      }

      if (t < 0) {
        Point$1.copy(tmpProjPoint, pt1);
      } else if (t > 1) {
        Point$1.copy(tmpProjPoint, pt2);
      }
    }

    tmpProjPoint.toArray(linePoints[1]);
  }
}

function setLabelLineState(labelLine, ignore, stateName, stateModel) {
  var isNormal = stateName === 'normal';
  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName); // Make sure display.

  stateObj.ignore = ignore; // Set smooth

  var smooth = stateModel.get('smooth');

  if (smooth && smooth === true) {
    smooth = 0.3;
  }

  stateObj.shape = stateObj.shape || {};

  if (smooth > 0) {
    stateObj.shape.smooth = smooth;
  }

  var styleObj = stateModel.getModel('lineStyle').getLineStyle();
  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;
}

function buildLabelLinePath(path, shape) {
  var smooth = shape.smooth;
  var points = shape.points;

  if (!points) {
    return;
  }

  path.moveTo(points[0][0], points[0][1]);

  if (smooth > 0 && points.length >= 3) {
    var len1 = dist$1(points[0], points[1]);
    var len2 = dist$1(points[1], points[2]);

    if (!len1 || !len2) {
      path.lineTo(points[1][0], points[1][1]);
      path.lineTo(points[2][0], points[2][1]);
      return;
    }

    var moveLen = Math.min(len1, len2) * smooth;
    var midPoint0 = lerp$1([], points[1], points[0], moveLen / len1);
    var midPoint2 = lerp$1([], points[1], points[2], moveLen / len2);
    var midPoint1 = lerp$1([], midPoint0, midPoint2, 0.5);
    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);
    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1]);
  } else {
    for (var i = 1; i < points.length; i++) {
      path.lineTo(points[i][0], points[i][1]);
    }
  }
}
/**
 * Create a label line if necessary and set it's style.
 */


function setLabelLineStyle(targetEl, statesModels, defaultStyle) {
  var labelLine = targetEl.getTextGuideLine();
  var label = targetEl.getTextContent();

  if (!label) {
    // Not show label line if there is no label.
    if (labelLine) {
      targetEl.removeTextGuideLine();
    }

    return;
  }

  var normalModel = statesModels.normal;
  var showNormal = normalModel.get('show');
  var labelIgnoreNormal = label.ignore;

  for (var i = 0; i < DISPLAY_STATES.length; i++) {
    var stateName = DISPLAY_STATES[i];
    var stateModel = statesModels[stateName];
    var isNormal = stateName === 'normal';

    if (stateModel) {
      var stateShow = stateModel.get('show');
      var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);

      if (isLabelIgnored // Not show when label is not shown in this state.
      || !retrieve2(stateShow, showNormal) // Use normal state by default if not set.
      ) {
          var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];

          if (stateObj) {
            stateObj.ignore = true;
          }

          continue;
        } // Create labelLine if not exists


      if (!labelLine) {
        labelLine = new Polyline$1();
        targetEl.setTextGuideLine(labelLine); // Reset state of normal because it's new created.
        // NOTE: NORMAL should always been the first!

        if (!isNormal && (labelIgnoreNormal || !showNormal)) {
          setLabelLineState(labelLine, true, 'normal', statesModels.normal);
        } // Use same state proxy.


        if (targetEl.stateProxy) {
          labelLine.stateProxy = targetEl.stateProxy;
        }
      }

      setLabelLineState(labelLine, false, stateName, stateModel);
    }
  }

  if (labelLine) {
    defaults(labelLine.style, defaultStyle); // Not fill.

    labelLine.style.fill = null;
    var showAbove = normalModel.get('showAbove');
    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};
    labelLineConfig.showAbove = showAbove || false; // Custom the buildPath.

    labelLine.buildPath = buildLabelLinePath;
  }
}
function getLabelLineStatesModels(itemModel, labelLineName) {
  labelLineName = labelLineName || 'labelLine';
  var statesModels = {
    normal: itemModel.getModel(labelLineName)
  };

  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);
  }

  return statesModels;
}

function prepareLayoutList(input) {
  var list = [];

  for (var i = 0; i < input.length; i++) {
    var rawItem = input[i];

    if (rawItem.defaultAttr.ignore) {
      continue;
    }

    var label = rawItem.label;
    var transform = label.getComputedTransform(); // NOTE: Get bounding rect after getComputedTransform, or label may not been updated by the host el.

    var localRect = label.getBoundingRect();
    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;
    var minMargin = label.style.margin || 0;
    var globalRect = localRect.clone();
    globalRect.applyTransform(transform);
    globalRect.x -= minMargin / 2;
    globalRect.y -= minMargin / 2;
    globalRect.width += minMargin;
    globalRect.height += minMargin;
    var obb = isAxisAligned ? new OrientedBoundingRect$1(localRect, transform) : null;
    list.push({
      label: label,
      labelLine: rawItem.labelLine,
      rect: globalRect,
      localRect: localRect,
      obb: obb,
      priority: rawItem.priority,
      defaultAttr: rawItem.defaultAttr,
      layoutOption: rawItem.computedLayoutOption,
      axisAligned: isAxisAligned,
      transform: transform
    });
  }

  return list;
}

function shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {
  var len = list.length;

  if (len < 2) {
    return;
  }

  list.sort(function (a, b) {
    return a.rect[xyDim] - b.rect[xyDim];
  });
  var lastPos = 0;
  var delta;
  var adjusted = false;
  var totalShifts = 0;

  for (var i = 0; i < len; i++) {
    var item = list[i];
    var rect = item.rect;
    delta = rect[xyDim] - lastPos;

    if (delta < 0) {
      // shiftForward(i, len, -delta);
      rect[xyDim] -= delta;
      item.label[xyDim] -= delta;
      adjusted = true;
    }

    var shift = Math.max(-delta, 0);
    totalShifts += shift;
    lastPos = rect[xyDim] + rect[sizeDim];
  }

  if (totalShifts > 0 && balanceShift) {
    // Shift back to make the distribution more equally.
    shiftList(-totalShifts / len, 0, len);
  } // TODO bleedMargin?


  var first = list[0];
  var last = list[len - 1];
  var minGap;
  var maxGap;
  updateMinMaxGap(); // If ends exceed two bounds, squeeze at most 80%, then take the gap of two bounds.

  minGap < 0 && squeezeGaps(-minGap, 0.8);
  maxGap < 0 && squeezeGaps(maxGap, 0.8);
  updateMinMaxGap();
  takeBoundsGap(minGap, maxGap, 1);
  takeBoundsGap(maxGap, minGap, -1); // Handle bailout when there is not enough space.

  updateMinMaxGap();

  if (minGap < 0) {
    squeezeWhenBailout(-minGap);
  }

  if (maxGap < 0) {
    squeezeWhenBailout(maxGap);
  }

  function updateMinMaxGap() {
    minGap = first.rect[xyDim] - minBound;
    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];
  }

  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {
    if (gapThisBound < 0) {
      // Move from other gap if can.
      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);

      if (moveFromMaxGap > 0) {
        shiftList(moveFromMaxGap * moveDir, 0, len);
        var remained = moveFromMaxGap + gapThisBound;

        if (remained < 0) {
          squeezeGaps(-remained * moveDir, 1);
        }
      } else {
        squeezeGaps(-gapThisBound * moveDir, 1);
      }
    }
  }

  function shiftList(delta, start, end) {
    if (delta !== 0) {
      adjusted = true;
    }

    for (var i = start; i < end; i++) {
      var item = list[i];
      var rect = item.rect;
      rect[xyDim] += delta;
      item.label[xyDim] += delta;
    }
  } // Squeeze gaps if the labels exceed margin.


  function squeezeGaps(delta, maxSqeezePercent) {
    var gaps = [];
    var totalGaps = 0;

    for (var i = 1; i < len; i++) {
      var prevItemRect = list[i - 1].rect;
      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);
      gaps.push(gap);
      totalGaps += gap;
    }

    if (!totalGaps) {
      return;
    }

    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);

    if (delta > 0) {
      for (var i = 0; i < len - 1; i++) {
        // Distribute the shift delta to all gaps.
        var movement = gaps[i] * squeezePercent; // Forward

        shiftList(movement, 0, i + 1);
      }
    } else {
      // Backward
      for (var i = len - 1; i > 0; i--) {
        // Distribute the shift delta to all gaps.
        var movement = gaps[i - 1] * squeezePercent;
        shiftList(-movement, i, len);
      }
    }
  }
  /**
   * Squeeze to allow overlap if there is no more space available.
   * Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.
   */


  function squeezeWhenBailout(delta) {
    var dir = delta < 0 ? -1 : 1;
    delta = Math.abs(delta);
    var moveForEachLabel = Math.ceil(delta / (len - 1));

    for (var i = 0; i < len - 1; i++) {
      if (dir > 0) {
        // Forward
        shiftList(moveForEachLabel, 0, i + 1);
      } else {
        // Backward
        shiftList(-moveForEachLabel, len - i - 1, len);
      }

      delta -= moveForEachLabel;

      if (delta <= 0) {
        return;
      }
    }
  }

  return adjusted;
}
/**
 * Adjust labels on y direction to avoid overlap.
 */

function shiftLayoutOnY(list, topBound, bottomBound, // If average the shifts on all labels and add them to 0
balanceShift) {
  return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);
}
function hideOverlap(labelList) {
  var displayedLabels = []; // TODO, render overflow visible first, put in the displayedLabels.

  labelList.sort(function (a, b) {
    return b.priority - a.priority;
  });
  var globalRect = new BoundingRect$1(0, 0, 0, 0);

  function hideEl(el) {
    if (!el.ignore) {
      // Show on emphasis.
      var emphasisState = el.ensureState('emphasis');

      if (emphasisState.ignore == null) {
        emphasisState.ignore = false;
      }
    }

    el.ignore = true;
  }

  for (var i = 0; i < labelList.length; i++) {
    var labelItem = labelList[i];
    var isAxisAligned = labelItem.axisAligned;
    var localRect = labelItem.localRect;
    var transform = labelItem.transform;
    var label = labelItem.label;
    var labelLine = labelItem.labelLine;
    globalRect.copy(labelItem.rect); // Add a threshold because layout may be aligned precisely.

    globalRect.width -= 0.1;
    globalRect.height -= 0.1;
    globalRect.x += 0.05;
    globalRect.y += 0.05;
    var obb = labelItem.obb;
    var overlapped = false;

    for (var j = 0; j < displayedLabels.length; j++) {
      var existsTextCfg = displayedLabels[j]; // Fast rejection.

      if (!globalRect.intersect(existsTextCfg.rect)) {
        continue;
      }

      if (isAxisAligned && existsTextCfg.axisAligned) {
        // Is overlapped
        overlapped = true;
        break;
      }

      if (!existsTextCfg.obb) {
        // If self is not axis aligned. But other is.
        existsTextCfg.obb = new OrientedBoundingRect$1(existsTextCfg.localRect, existsTextCfg.transform);
      }

      if (!obb) {
        // If self is axis aligned. But other is not.
        obb = new OrientedBoundingRect$1(localRect, transform);
      }

      if (obb.intersect(existsTextCfg.obb)) {
        overlapped = true;
        break;
      }
    } // TODO Callback to determine if this overlap should be handled?


    if (overlapped) {
      hideEl(label);
      labelLine && hideEl(labelLine);
    } else {
      label.attr('ignore', labelItem.defaultAttr.ignore);
      labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);
      displayedLabels.push(labelItem);
    }
  }
}

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

var echarts = /*#__PURE__*/Object.freeze({
  __proto__: null,
  registerLocale: registerLocale,
  version: version,
  dependencies: dependencies,
  PRIORITY: PRIORITY,
  init: init,
  connect: connect,
  disConnect: disConnect,
  disconnect: disconnect,
  dispose: dispose,
  getInstanceByDom: getInstanceByDom,
  getInstanceById: getInstanceById,
  registerTheme: registerTheme,
  registerPreprocessor: registerPreprocessor,
  registerProcessor: registerProcessor,
  registerPostInit: registerPostInit,
  registerPostUpdate: registerPostUpdate,
  registerUpdateLifecycle: registerUpdateLifecycle,
  registerAction: registerAction,
  registerCoordinateSystem: registerCoordinateSystem,
  getCoordinateSystemDimensions: getCoordinateSystemDimensions,
  registerLayout: registerLayout,
  registerVisual: registerVisual,
  registerLoading: registerLoading,
  setCanvasCreator: setCanvasCreator,
  registerMap: registerMap$1,
  getMap: getMap,
  registerTransform: registerTransform,
  dataTool: dataTool,
  throttle: throttle,
  use: use,
  setPlatformAPI: setPlatformAPI,
  parseGeoJSON: parseGeoJSON,
  parseGeoJson: parseGeoJSON,
  env: env$1,
  Model: Model$1,
  Axis: Axis$1,
  innerDrawElementOnCanvas: brushSingle,
  zrender: zrender,
  matrix: matrix,
  vector: vector,
  zrUtil: util$1,
  color: color,
  helper: helper,
  number: number,
  time: time,
  graphic: graphic,
  format: format,
  util: util,
  List: SeriesData$1,
  ComponentModel: ComponentModel$1,
  ComponentView: ComponentView$1,
  SeriesModel: SeriesModel$1,
  ChartView: ChartView$1,
  extendComponentModel: extendComponentModel,
  extendComponentView: extendComponentView,
  extendSeriesModel: extendSeriesModel,
  extendChartView: extendChartView
});

var LineSeriesModel =
/** @class */
function (_super) {
  __extends$1(LineSeriesModel, _super);

  function LineSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = LineSeriesModel.type;
    _this.hasSymbolVisual = true;
    return _this;
  }

  LineSeriesModel.prototype.getInitialData = function (option) {
    if (process.env.NODE_ENV !== 'production') {
      var coordSys = option.coordinateSystem;

      if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {
        throw new Error('Line not support coordinateSystem besides cartesian and polar');
      }
    }

    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };

  LineSeriesModel.prototype.getLegendIcon = function (opt) {
    var group = new Group$3();
    var line = createSymbol('line', 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);
    group.add(line);
    line.setStyle(opt.lineStyle);
    var visualType = this.getData().getVisual('symbol');
    var visualRotate = this.getData().getVisual('symbolRotate');
    var symbolType = visualType === 'none' ? 'circle' : visualType; // Symbol size is 80% when there is a line

    var size = opt.itemHeight * 0.8;
    var symbol = createSymbol(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);
    group.add(symbol);
    symbol.setStyle(opt.itemStyle);
    var symbolRotate = opt.iconRotate === 'inherit' ? visualRotate : opt.iconRotate || 0;
    symbol.rotation = symbolRotate * Math.PI / 180;
    symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);

    if (symbolType.indexOf('empty') > -1) {
      symbol.style.stroke = symbol.style.fill;
      symbol.style.fill = '#fff';
      symbol.style.lineWidth = 2;
    }

    return group;
  };

  LineSeriesModel.type = 'series.line';
  LineSeriesModel.dependencies = ['grid', 'polar'];
  LineSeriesModel.defaultOption = {
    // zlevel: 0,
    z: 3,
    coordinateSystem: 'cartesian2d',
    legendHoverLink: true,
    clip: true,
    label: {
      position: 'top'
    },
    // itemStyle: {
    // },
    endLabel: {
      show: false,
      valueAnimation: true,
      distance: 8
    },
    lineStyle: {
      width: 2,
      type: 'solid'
    },
    emphasis: {
      scale: true
    },
    // areaStyle: {
    // origin of areaStyle. Valid values:
    // `'auto'/null/undefined`: from axisLine to data
    // `'start'`: from min to data
    // `'end'`: from data to max
    // origin: 'auto'
    // },
    // false, 'start', 'end', 'middle'
    step: false,
    // Disabled if step is true
    smooth: false,
    smoothMonotone: null,
    symbol: 'emptyCircle',
    symbolSize: 4,
    symbolRotate: null,
    showSymbol: true,
    // `false`: follow the label interval strategy.
    // `true`: show all symbols.
    // `'auto'`: If possible, show all symbols, otherwise
    //           follow the label interval strategy.
    showAllSymbol: 'auto',
    // Whether to connect break point.
    connectNulls: false,
    // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
    sampling: 'none',
    animationEasing: 'linear',
    // Disable progressive
    progressive: 0,
    hoverLayerThreshold: Infinity,
    universalTransition: {
      divideShape: 'clone'
    },
    triggerLineEvent: false
  };
  return LineSeriesModel;
}(SeriesModel$1);

var LineSeries = LineSeriesModel;

/**
 * @return label string. Not null/undefined
 */

function getDefaultLabel(data, dataIndex) {
  var labelDims = data.mapDimensionsAll('defaultedLabel');
  var len = labelDims.length; // Simple optimization (in lots of cases, label dims length is 1)

  if (len === 1) {
    var rawVal = retrieveRawValue(data, dataIndex, labelDims[0]);
    return rawVal != null ? rawVal + '' : null;
  } else if (len) {
    var vals = [];

    for (var i = 0; i < labelDims.length; i++) {
      vals.push(retrieveRawValue(data, dataIndex, labelDims[i]));
    }

    return vals.join(' ');
  }
}
function getDefaultInterpolatedLabel(data, interpolatedValue) {
  var labelDims = data.mapDimensionsAll('defaultedLabel');

  if (!isArray$1(interpolatedValue)) {
    return interpolatedValue + '';
  }

  var vals = [];

  for (var i = 0; i < labelDims.length; i++) {
    var dimIndex = data.getDimensionIndex(labelDims[i]);

    if (dimIndex >= 0) {
      vals.push(interpolatedValue[dimIndex]);
    }
  }

  return vals.join(' ');
}

var Symbol$1 =
/** @class */
function (_super) {
  __extends$1(Symbol, _super);

  function Symbol(data, idx, seriesScope, opts) {
    var _this = _super.call(this) || this;

    _this.updateData(data, idx, seriesScope, opts);

    return _this;
  }

  Symbol.prototype._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {
    // Remove paths created before
    this.removeAll(); // let symbolPath = createSymbol(
    //     symbolType, -0.5, -0.5, 1, 1, color
    // );
    // If width/height are set too small (e.g., set to 1) on ios10
    // and macOS Sierra, a circle stroke become a rect, no matter what
    // the scale is set. So we set width/height as 2. See #4150.

    var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect);
    symbolPath.attr({
      z2: 100,
      culling: true,
      scaleX: symbolSize[0] / 2,
      scaleY: symbolSize[1] / 2
    }); // Rewrite drift method

    symbolPath.drift = driftSymbol;
    this._symbolType = symbolType;
    this.add(symbolPath);
  };
  /**
   * Stop animation
   * @param {boolean} toLastFrame
   */


  Symbol.prototype.stopSymbolAnimation = function (toLastFrame) {
    this.childAt(0).stopAnimation(null, toLastFrame);
  };

  Symbol.prototype.getSymbolType = function () {
    return this._symbolType;
  };
  /**
   * FIXME:
   * Caution: This method breaks the encapsulation of this module,
   * but it indeed brings convenience. So do not use the method
   * unless you detailedly know all the implements of `Symbol`,
   * especially animation.
   *
   * Get symbol path element.
   */


  Symbol.prototype.getSymbolPath = function () {
    return this.childAt(0);
  };
  /**
   * Highlight symbol
   */


  Symbol.prototype.highlight = function () {
    enterEmphasis(this.childAt(0));
  };
  /**
   * Downplay symbol
   */


  Symbol.prototype.downplay = function () {
    leaveEmphasis(this.childAt(0));
  };
  /**
   * @param {number} zlevel
   * @param {number} z
   */


  Symbol.prototype.setZ = function (zlevel, z) {
    var symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z;
  };

  Symbol.prototype.setDraggable = function (draggable, hasCursorOption) {
    var symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = !hasCursorOption && draggable ? 'move' : symbolPath.cursor;
  };
  /**
   * Update symbol properties
   */


  Symbol.prototype.updateData = function (data, idx, seriesScope, opts) {
    this.silent = false;
    var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
    var seriesModel = data.hostModel;
    var symbolSize = Symbol.getSymbolSize(data, idx);
    var isInit = symbolType !== this._symbolType;
    var disableAnimation = opts && opts.disableAnimation;

    if (isInit) {
      var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');

      this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
    } else {
      var symbolPath = this.childAt(0);
      symbolPath.silent = false;
      var target = {
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2
      };
      disableAnimation ? symbolPath.attr(target) : updateProps$1(symbolPath, target, seriesModel, idx);
      saveOldStyle(symbolPath);
    }

    this._updateCommon(data, idx, symbolSize, seriesScope, opts);

    if (isInit) {
      var symbolPath = this.childAt(0);

      if (!disableAnimation) {
        var target = {
          scaleX: this._sizeX,
          scaleY: this._sizeY,
          style: {
            // Always fadeIn. Because it has fadeOut animation when symbol is removed..
            opacity: symbolPath.style.opacity
          }
        };
        symbolPath.scaleX = symbolPath.scaleY = 0;
        symbolPath.style.opacity = 0;
        initProps(symbolPath, target, seriesModel, idx);
      }
    }

    if (disableAnimation) {
      // Must stop leave transition manually if don't call initProps or updateProps.
      this.childAt(0).stopAnimation('leave');
    }
  };

  Symbol.prototype._updateCommon = function (data, idx, symbolSize, seriesScope, opts) {
    var symbolPath = this.childAt(0);
    var seriesModel = data.hostModel;
    var emphasisItemStyle;
    var blurItemStyle;
    var selectItemStyle;
    var focus;
    var blurScope;
    var emphasisDisabled;
    var labelStatesModels;
    var hoverScale;
    var cursorStyle;

    if (seriesScope) {
      emphasisItemStyle = seriesScope.emphasisItemStyle;
      blurItemStyle = seriesScope.blurItemStyle;
      selectItemStyle = seriesScope.selectItemStyle;
      focus = seriesScope.focus;
      blurScope = seriesScope.blurScope;
      labelStatesModels = seriesScope.labelStatesModels;
      hoverScale = seriesScope.hoverScale;
      cursorStyle = seriesScope.cursorStyle;
      emphasisDisabled = seriesScope.emphasisDisabled;
    }

    if (!seriesScope || data.hasItemOption) {
      var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
      var emphasisModel = itemModel.getModel('emphasis');
      emphasisItemStyle = emphasisModel.getModel('itemStyle').getItemStyle();
      selectItemStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();
      blurItemStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();
      focus = emphasisModel.get('focus');
      blurScope = emphasisModel.get('blurScope');
      emphasisDisabled = emphasisModel.get('disabled');
      labelStatesModels = getLabelStatesModels(itemModel);
      hoverScale = emphasisModel.getShallow('scale');
      cursorStyle = itemModel.getShallow('cursor');
    }

    var symbolRotate = data.getItemVisual(idx, 'symbolRotate');
    symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);
    var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, 'symbolOffset'), symbolSize);

    if (symbolOffset) {
      symbolPath.x = symbolOffset[0];
      symbolPath.y = symbolOffset[1];
    }

    cursorStyle && symbolPath.attr('cursor', cursorStyle);
    var symbolStyle = data.getItemVisual(idx, 'style');
    var visualColor = symbolStyle.fill;

    if (symbolPath instanceof ZRImage$1) {
      var pathStyle = symbolPath.style;
      symbolPath.useStyle(extend$2({
        // TODO other properties like x, y ?
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolStyle));
    } else {
      if (symbolPath.__isEmptyBrush) {
        // fill and stroke will be swapped if it's empty.
        // So we cloned a new style to avoid it affecting the original style in visual storage.
        // TODO Better implementation. No empty logic!
        symbolPath.useStyle(extend$2({}, symbolStyle));
      } else {
        symbolPath.useStyle(symbolStyle);
      } // Disable decal because symbol scale will been applied on the decal.


      symbolPath.style.decal = null;
      symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
      symbolPath.style.strokeNoScale = true;
    }

    var liftZ = data.getItemVisual(idx, 'liftZ');
    var z2Origin = this._z2;

    if (liftZ != null) {
      if (z2Origin == null) {
        this._z2 = symbolPath.z2;
        symbolPath.z2 += liftZ;
      }
    } else if (z2Origin != null) {
      symbolPath.z2 = z2Origin;
      this._z2 = null;
    }

    var useNameLabel = opts && opts.useNameLabel;
    setLabelStyle(symbolPath, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: getLabelDefaultText,
      inheritColor: visualColor,
      defaultOpacity: symbolStyle.opacity
    }); // Do not execute util needed.

    function getLabelDefaultText(idx) {
      return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);
    }

    this._sizeX = symbolSize[0] / 2;
    this._sizeY = symbolSize[1] / 2;
    var emphasisState = symbolPath.ensureState('emphasis');
    emphasisState.style = emphasisItemStyle;
    symbolPath.ensureState('select').style = selectItemStyle;
    symbolPath.ensureState('blur').style = blurItemStyle; // null / undefined / true means to use default strategy.
    // 0 / false / negative number / NaN / Infinity means no scale.

    var scaleRatio = hoverScale == null || hoverScale === true ? Math.max(1.1, 3 / this._sizeY) // PENDING: restrict hoverScale > 1? It seems unreasonable to scale down
    : isFinite(hoverScale) && hoverScale > 0 ? +hoverScale : 1; // always set scale to allow resetting

    emphasisState.scaleX = this._sizeX * scaleRatio;
    emphasisState.scaleY = this._sizeY * scaleRatio;
    this.setSymbolScale(1);
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  };

  Symbol.prototype.setSymbolScale = function (scale) {
    this.scaleX = this.scaleY = scale;
  };

  Symbol.prototype.fadeOut = function (cb, seriesModel, opt) {
    var symbolPath = this.childAt(0);
    var dataIndex = getECData(this).dataIndex;
    var animationOpt = opt && opt.animation; // Avoid mistaken hover when fading out

    this.silent = symbolPath.silent = true; // Not show text when animating

    if (opt && opt.fadeLabel) {
      var textContent = symbolPath.getTextContent();

      if (textContent) {
        removeElement(textContent, {
          style: {
            opacity: 0
          }
        }, seriesModel, {
          dataIndex: dataIndex,
          removeOpt: animationOpt,
          cb: function () {
            symbolPath.removeTextContent();
          }
        });
      }
    } else {
      symbolPath.removeTextContent();
    }

    removeElement(symbolPath, {
      style: {
        opacity: 0
      },
      scaleX: 0,
      scaleY: 0
    }, seriesModel, {
      dataIndex: dataIndex,
      cb: cb,
      removeOpt: animationOpt
    });
  };

  Symbol.getSymbolSize = function (data, idx) {
    return normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
  };

  return Symbol;
}(Group$3);

function driftSymbol(dx, dy) {
  this.parent.drift(dx, dy);
}

var SymbolClz = Symbol$1;

function symbolNeedsDraw(data, point, idx, opt) {
  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of
  // the symbol element shape. We use the same clip shape here as
  // the line clip.
  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';
}

function normalizeUpdateOpt(opt) {
  if (opt != null && !isObject$3(opt)) {
    opt = {
      isIgnore: opt
    };
  }

  return opt || {};
}

function makeSeriesScope(data) {
  var seriesModel = data.hostModel;
  var emphasisModel = seriesModel.getModel('emphasis');
  return {
    emphasisItemStyle: emphasisModel.getModel('itemStyle').getItemStyle(),
    blurItemStyle: seriesModel.getModel(['blur', 'itemStyle']).getItemStyle(),
    selectItemStyle: seriesModel.getModel(['select', 'itemStyle']).getItemStyle(),
    focus: emphasisModel.get('focus'),
    blurScope: emphasisModel.get('blurScope'),
    emphasisDisabled: emphasisModel.get('disabled'),
    hoverScale: emphasisModel.get('scale'),
    labelStatesModels: getLabelStatesModels(seriesModel),
    cursorStyle: seriesModel.get('cursor')
  };
}

var SymbolDraw =
/** @class */
function () {
  function SymbolDraw(SymbolCtor) {
    this.group = new Group$3();
    this._SymbolCtor = SymbolCtor || SymbolClz;
  }
  /**
   * Update symbols draw by new data
   */


  SymbolDraw.prototype.updateData = function (data, opt) {
    // Remove progressive els.
    this._progressiveEls = null;
    opt = normalizeUpdateOpt(opt);
    var group = this.group;
    var seriesModel = data.hostModel;
    var oldData = this._data;
    var SymbolCtor = this._SymbolCtor;
    var disableAnimation = opt.disableAnimation;
    var seriesScope = makeSeriesScope(data);
    var symbolUpdateOpt = {
      disableAnimation: disableAnimation
    };

    var getSymbolPoint = opt.getSymbolPoint || function (idx) {
      return data.getItemLayout(idx);
    }; // There is no oldLineData only when first rendering or switching from
    // stream mode to normal mode, where previous elements should be removed.


    if (!oldData) {
      group.removeAll();
    }

    data.diff(oldData).add(function (newIdx) {
      var point = getSymbolPoint(newIdx);

      if (symbolNeedsDraw(data, point, newIdx, opt)) {
        var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function (newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      var point = getSymbolPoint(newIdx);

      if (!symbolNeedsDraw(data, point, newIdx, opt)) {
        group.remove(symbolEl);
        return;
      }

      var newSymbolType = data.getItemVisual(newIdx, 'symbol') || 'circle';
      var oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();

      if (!symbolEl // Create a new if symbol type changed.
      || oldSymbolType && oldSymbolType !== newSymbolType) {
        group.remove(symbolEl);
        symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
      } else {
        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
        var target = {
          x: point[0],
          y: point[1]
        };
        disableAnimation ? symbolEl.attr(target) : updateProps$1(symbolEl, target, seriesModel);
      } // Add back


      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function (oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && el.fadeOut(function () {
        group.remove(el);
      }, seriesModel);
    }).execute();
    this._getSymbolPoint = getSymbolPoint;
    this._data = data;
  };

  SymbolDraw.prototype.updateLayout = function () {
    var _this = this;

    var data = this._data;

    if (data) {
      // Not use animation
      data.eachItemGraphicEl(function (el, idx) {
        var point = _this._getSymbolPoint(idx);

        el.setPosition(point);
        el.markRedraw();
      });
    }
  };

  SymbolDraw.prototype.incrementalPrepareUpdate = function (data) {
    this._seriesScope = makeSeriesScope(data);
    this._data = null;
    this.group.removeAll();
  };
  /**
   * Update symbols draw by new data
   */

  SymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {
    // Clear
    this._progressiveEls = [];
    opt = normalizeUpdateOpt(opt);

    function updateIncrementalAndHover(el) {
      if (!el.isGroup) {
        el.incremental = true;
        el.ensureState('emphasis').hoverLayer = true;
      }
    }

    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var point = data.getItemLayout(idx);

      if (symbolNeedsDraw(data, point, idx, opt)) {
        var el = new this._SymbolCtor(data, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        el.setPosition(point);
        this.group.add(el);
        data.setItemGraphicEl(idx, el);

        this._progressiveEls.push(el);
      }
    }
  };

  SymbolDraw.prototype.eachRendered = function (cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };

  SymbolDraw.prototype.remove = function (enableAnimation) {
    var group = this.group;
    var data = this._data; // Incremental model do not have this._data.

    if (data && enableAnimation) {
      data.eachItemGraphicEl(function (el) {
        el.fadeOut(function () {
          group.remove(el);
        }, data.hostModel);
      });
    } else {
      group.removeAll();
    }
  };
  return SymbolDraw;
}();

var SymbolDraw$1 = SymbolDraw;

function prepareDataCoordInfo(coordSys, data, valueOrigin) {
  var baseAxis = coordSys.getBaseAxis();
  var valueAxis = coordSys.getOtherAxis(baseAxis);
  var valueStart = getValueStart(valueAxis, valueOrigin);
  var baseAxisDim = baseAxis.dim;
  var valueAxisDim = valueAxis.dim;
  var valueDim = data.mapDimension(valueAxisDim);
  var baseDim = data.mapDimension(baseAxisDim);
  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;
  var dims = map$1(coordSys.dimensions, function (coordDim) {
    return data.mapDimension(coordDim);
  });
  var stacked = false;
  var stackResultDim = data.getCalculationInfo('stackResultDimension');

  if (isDimensionStacked(data, dims[0]
  /*, dims[1]*/
  )) {
    // jshint ignore:line
    stacked = true;
    dims[0] = stackResultDim;
  }

  if (isDimensionStacked(data, dims[1]
  /*, dims[0]*/
  )) {
    // jshint ignore:line
    stacked = true;
    dims[1] = stackResultDim;
  }

  return {
    dataDimsForPoint: dims,
    valueStart: valueStart,
    valueAxisDim: valueAxisDim,
    baseAxisDim: baseAxisDim,
    stacked: !!stacked,
    valueDim: valueDim,
    baseDim: baseDim,
    baseDataOffset: baseDataOffset,
    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')
  };
}

function getValueStart(valueAxis, valueOrigin) {
  var valueStart = 0;
  var extent = valueAxis.scale.getExtent();

  if (valueOrigin === 'start') {
    valueStart = extent[0];
  } else if (valueOrigin === 'end') {
    valueStart = extent[1];
  } // If origin is specified as a number, use it as
  // valueStart directly
  else if (isNumber(valueOrigin) && !isNaN(valueOrigin)) {
      valueStart = valueOrigin;
    } // auto
    else {
        // Both positive
        if (extent[0] > 0) {
          valueStart = extent[0];
        } // Both negative
        else if (extent[1] < 0) {
            valueStart = extent[1];
          } // If is one positive, and one negative, onZero shall be true

      }

  return valueStart;
}

function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
  var value = NaN;

  if (dataCoordInfo.stacked) {
    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);
  }

  if (isNaN(value)) {
    value = dataCoordInfo.valueStart;
  }

  var baseDataOffset = dataCoordInfo.baseDataOffset;
  var stackedData = [];
  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
  stackedData[1 - baseDataOffset] = value;
  return coordSys.dataToPoint(stackedData);
}

function diffData(oldData, newData) {
  var diffResult = [];
  newData.diff(oldData).add(function (idx) {
    diffResult.push({
      cmd: '+',
      idx: idx
    });
  }).update(function (newIdx, oldIdx) {
    diffResult.push({
      cmd: '=',
      idx: oldIdx,
      idx1: newIdx
    });
  }).remove(function (idx) {
    diffResult.push({
      cmd: '-',
      idx: idx
    });
  }).execute();
  return diffResult;
}

function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
  var diff = diffData(oldData, newData); // let newIdList = newData.mapArray(newData.getId);
  // let oldIdList = oldData.mapArray(oldData.getId);
  // convertToIntId(newIdList, oldIdList);
  // // FIXME One data ?
  // diff = arrayDiff(oldIdList, newIdList);

  var currPoints = [];
  var nextPoints = []; // Points for stacking base line

  var currStackedPoints = [];
  var nextStackedPoints = [];
  var status = [];
  var sortedIndices = [];
  var rawIndices = [];
  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin); // const oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);

  var oldPoints = oldData.getLayout('points') || [];
  var newPoints = newData.getLayout('points') || [];

  for (var i = 0; i < diff.length; i++) {
    var diffItem = diff[i];
    var pointAdded = true;
    var oldIdx2 = void 0;
    var newIdx2 = void 0; // FIXME, animation is not so perfect when dataZoom window moves fast
    // Which is in case remvoing or add more than one data in the tail or head

    switch (diffItem.cmd) {
      case '=':
        oldIdx2 = diffItem.idx * 2;
        newIdx2 = diffItem.idx1 * 2;
        var currentX = oldPoints[oldIdx2];
        var currentY = oldPoints[oldIdx2 + 1];
        var nextX = newPoints[newIdx2];
        var nextY = newPoints[newIdx2 + 1]; // If previous data is NaN, use next point directly

        if (isNaN(currentX) || isNaN(currentY)) {
          currentX = nextX;
          currentY = nextY;
        }

        currPoints.push(currentX, currentY);
        nextPoints.push(nextX, nextY);
        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(diffItem.idx1));
        break;

      case '+':
        var newIdx = diffItem.idx;
        var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
        var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);
        newIdx2 = newIdx * 2;
        currPoints.push(oldPt[0], oldPt[1]);
        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
        var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(newIdx));
        break;

      case '-':
        pointAdded = false;
    } // Original indices


    if (pointAdded) {
      status.push(diffItem);
      sortedIndices.push(sortedIndices.length);
    }
  } // Diff result may be crossed if all items are changed
  // Sort by data index


  sortedIndices.sort(function (a, b) {
    return rawIndices[a] - rawIndices[b];
  });
  var len = currPoints.length;
  var sortedCurrPoints = createFloat32Array(len);
  var sortedNextPoints = createFloat32Array(len);
  var sortedCurrStackedPoints = createFloat32Array(len);
  var sortedNextStackedPoints = createFloat32Array(len);
  var sortedStatus = [];

  for (var i = 0; i < sortedIndices.length; i++) {
    var idx = sortedIndices[i];
    var i2 = i * 2;
    var idx2 = idx * 2;
    sortedCurrPoints[i2] = currPoints[idx2];
    sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];
    sortedNextPoints[i2] = nextPoints[idx2];
    sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];
    sortedCurrStackedPoints[i2] = currStackedPoints[idx2];
    sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];
    sortedNextStackedPoints[i2] = nextStackedPoints[idx2];
    sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];
    sortedStatus[i] = status[idx];
  }

  return {
    current: sortedCurrPoints,
    next: sortedNextPoints,
    stackedOnCurrent: sortedCurrStackedPoints,
    stackedOnNext: sortedNextStackedPoints,
    status: sortedStatus
  };
}

var mathMin$2 = Math.min;
var mathMax$2 = Math.max;

function isPointNull$1(x, y) {
  return isNaN(x) || isNaN(y);
}
/**
 * Draw smoothed line in non-monotone, in may cause undesired curve in extreme
 * situations. This should be used when points are non-monotone neither in x or
 * y dimension.
 */


function drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {
  var prevX;
  var prevY;
  var cpx0;
  var cpy0;
  var cpx1;
  var cpy1;
  var idx = start;
  var k = 0;

  for (; k < segLen; k++) {
    var x = points[idx * 2];
    var y = points[idx * 2 + 1];

    if (idx >= allLen || idx < 0) {
      break;
    }

    if (isPointNull$1(x, y)) {
      if (connectNulls) {
        idx += dir;
        continue;
      }

      break;
    }

    if (idx === start) {
      ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);
      cpx0 = x;
      cpy0 = y;
    } else {
      var dx = x - prevX;
      var dy = y - prevY; // Ignore tiny segment.

      if (dx * dx + dy * dy < 0.5) {
        idx += dir;
        continue;
      }

      if (smooth > 0) {
        var nextIdx = idx + dir;
        var nextX = points[nextIdx * 2];
        var nextY = points[nextIdx * 2 + 1]; // Ignore duplicate point

        while (nextX === x && nextY === y && k < segLen) {
          k++;
          nextIdx += dir;
          idx += dir;
          nextX = points[nextIdx * 2];
          nextY = points[nextIdx * 2 + 1];
          x = points[idx * 2];
          y = points[idx * 2 + 1];
          dx = x - prevX;
          dy = y - prevY;
        }

        var tmpK = k + 1;

        if (connectNulls) {
          // Find next point not null
          while (isPointNull$1(nextX, nextY) && tmpK < segLen) {
            tmpK++;
            nextIdx += dir;
            nextX = points[nextIdx * 2];
            nextY = points[nextIdx * 2 + 1];
          }
        }

        var ratioNextSeg = 0.5;
        var vx = 0;
        var vy = 0;
        var nextCpx0 = void 0;
        var nextCpy0 = void 0; // Is last point

        if (tmpK >= segLen || isPointNull$1(nextX, nextY)) {
          cpx1 = x;
          cpy1 = y;
        } else {
          vx = nextX - prevX;
          vy = nextY - prevY;
          var dx0 = x - prevX;
          var dx1 = nextX - x;
          var dy0 = y - prevY;
          var dy1 = nextY - y;
          var lenPrevSeg = void 0;
          var lenNextSeg = void 0;

          if (smoothMonotone === 'x') {
            lenPrevSeg = Math.abs(dx0);
            lenNextSeg = Math.abs(dx1);
            var dir_1 = vx > 0 ? 1 : -1;
            cpx1 = x - dir_1 * lenPrevSeg * smooth;
            cpy1 = y;
            nextCpx0 = x + dir_1 * lenNextSeg * smooth;
            nextCpy0 = y;
          } else if (smoothMonotone === 'y') {
            lenPrevSeg = Math.abs(dy0);
            lenNextSeg = Math.abs(dy1);
            var dir_2 = vy > 0 ? 1 : -1;
            cpx1 = x;
            cpy1 = y - dir_2 * lenPrevSeg * smooth;
            nextCpx0 = x;
            nextCpy0 = y + dir_2 * lenNextSeg * smooth;
          } else {
            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1); // Use ratio of seg length

            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
            cpx1 = x - vx * smooth * (1 - ratioNextSeg);
            cpy1 = y - vy * smooth * (1 - ratioNextSeg); // cp0 of next segment

            nextCpx0 = x + vx * smooth * ratioNextSeg;
            nextCpy0 = y + vy * smooth * ratioNextSeg; // Smooth constraint between point and next point.
            // Avoid exceeding extreme after smoothing.

            nextCpx0 = mathMin$2(nextCpx0, mathMax$2(nextX, x));
            nextCpy0 = mathMin$2(nextCpy0, mathMax$2(nextY, y));
            nextCpx0 = mathMax$2(nextCpx0, mathMin$2(nextX, x));
            nextCpy0 = mathMax$2(nextCpy0, mathMin$2(nextY, y)); // Reclaculate cp1 based on the adjusted cp0 of next seg.

            vx = nextCpx0 - x;
            vy = nextCpy0 - y;
            cpx1 = x - vx * lenPrevSeg / lenNextSeg;
            cpy1 = y - vy * lenPrevSeg / lenNextSeg; // Smooth constraint between point and prev point.
            // Avoid exceeding extreme after smoothing.

            cpx1 = mathMin$2(cpx1, mathMax$2(prevX, x));
            cpy1 = mathMin$2(cpy1, mathMax$2(prevY, y));
            cpx1 = mathMax$2(cpx1, mathMin$2(prevX, x));
            cpy1 = mathMax$2(cpy1, mathMin$2(prevY, y)); // Adjust next cp0 again.

            vx = x - cpx1;
            vy = y - cpy1;
            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;
            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;
          }
        }

        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);
        cpx0 = nextCpx0;
        cpy0 = nextCpy0;
      } else {
        ctx.lineTo(x, y);
      }
    }

    prevX = x;
    prevY = y;
    idx += dir;
  }

  return k;
}

var ECPolylineShape =
/** @class */
function () {
  function ECPolylineShape() {
    this.smooth = 0;
    this.smoothConstraint = true;
  }

  return ECPolylineShape;
}();

var ECPolyline =
/** @class */
function (_super) {
  __extends$1(ECPolyline, _super);

  function ECPolyline(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'ec-polyline';
    return _this;
  }

  ECPolyline.prototype.getDefaultStyle = function () {
    return {
      stroke: '#000',
      fill: null
    };
  };

  ECPolyline.prototype.getDefaultShape = function () {
    return new ECPolylineShape();
  };

  ECPolyline.prototype.buildPath = function (ctx, shape) {
    var points = shape.points;
    var i = 0;
    var len = points.length / 2; // const result = getBoundingBox(points, shape.smoothConstraint);

    if (shape.connectNulls) {
      // Must remove first and last null values avoid draw error in polygon
      for (; len > 0; len--) {
        if (!isPointNull$1(points[len * 2 - 2], points[len * 2 - 1])) {
          break;
        }
      }

      for (; i < len; i++) {
        if (!isPointNull$1(points[i * 2], points[i * 2 + 1])) {
          break;
        }
      }
    }

    while (i < len) {
      i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
    }
  };

  ECPolyline.prototype.getPointOn = function (xOrY, dim) {
    if (!this.path) {
      this.createPathProxy();
      this.buildPath(this.path, this.shape);
    }

    var path = this.path;
    var data = path.data;
    var CMD = PathProxy$1.CMD;
    var x0;
    var y0;
    var isDimX = dim === 'x';
    var roots = [];

    for (var i = 0; i < data.length;) {
      var cmd = data[i++];
      var x = void 0;
      var y = void 0;
      var x2 = void 0;
      var y2 = void 0;
      var x3 = void 0;
      var y3 = void 0;
      var t = void 0;

      switch (cmd) {
        case CMD.M:
          x0 = data[i++];
          y0 = data[i++];
          break;

        case CMD.L:
          x = data[i++];
          y = data[i++];
          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);

          if (t <= 1 && t >= 0) {
            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;
            return isDimX ? [xOrY, val] : [val, xOrY];
          }

          x0 = x;
          y0 = y;
          break;

        case CMD.C:
          x = data[i++];
          y = data[i++];
          x2 = data[i++];
          y2 = data[i++];
          x3 = data[i++];
          y3 = data[i++];
          var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots) : cubicRootAt(y0, y, y2, y3, xOrY, roots);

          if (nRoot > 0) {
            for (var i_1 = 0; i_1 < nRoot; i_1++) {
              var t_1 = roots[i_1];

              if (t_1 <= 1 && t_1 >= 0) {
                var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1);
                return isDimX ? [xOrY, val] : [val, xOrY];
              }
            }
          }

          x0 = x3;
          y0 = y3;
          break;
      }
    }
  };

  return ECPolyline;
}(Path$1);

var ECPolygonShape =
/** @class */
function (_super) {
  __extends$1(ECPolygonShape, _super);

  function ECPolygonShape() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return ECPolygonShape;
}(ECPolylineShape);

var ECPolygon =
/** @class */
function (_super) {
  __extends$1(ECPolygon, _super);

  function ECPolygon(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'ec-polygon';
    return _this;
  }

  ECPolygon.prototype.getDefaultShape = function () {
    return new ECPolygonShape();
  };

  ECPolygon.prototype.buildPath = function (ctx, shape) {
    var points = shape.points;
    var stackedOnPoints = shape.stackedOnPoints;
    var i = 0;
    var len = points.length / 2;
    var smoothMonotone = shape.smoothMonotone;

    if (shape.connectNulls) {
      // Must remove first and last null values avoid draw error in polygon
      for (; len > 0; len--) {
        if (!isPointNull$1(points[len * 2 - 2], points[len * 2 - 1])) {
          break;
        }
      }

      for (; i < len; i++) {
        if (!isPointNull$1(points[i * 2], points[i * 2 + 1])) {
          break;
        }
      }
    }

    while (i < len) {
      var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);
      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
      i += k + 1;
      ctx.closePath();
    }
  };

  return ECPolygon;
}(Path$1);

function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
  var rect = cartesian.getArea();
  var x = rect.x;
  var y = rect.y;
  var width = rect.width;
  var height = rect.height;
  var lineWidth = seriesModel.get(['lineStyle', 'width']) || 2; // Expand the clip path a bit to avoid the border is clipped and looks thinner

  x -= lineWidth / 2;
  y -= lineWidth / 2;
  width += lineWidth;
  height += lineWidth; // fix: https://github.com/apache/incubator-echarts/issues/11369

  x = Math.floor(x);
  width = Math.round(width);
  var clipPath = new Rect$1({
    shape: {
      x: x,
      y: y,
      width: width,
      height: height
    }
  });

  if (hasAnimation) {
    var baseAxis = cartesian.getBaseAxis();
    var isHorizontal = baseAxis.isHorizontal();
    var isAxisInversed = baseAxis.inverse;

    if (isHorizontal) {
      if (isAxisInversed) {
        clipPath.shape.x += width;
      }

      clipPath.shape.width = 0;
    } else {
      if (!isAxisInversed) {
        clipPath.shape.y += height;
      }

      clipPath.shape.height = 0;
    }

    var duringCb = isFunction(during) ? function (percent) {
      during(percent, clipPath);
    } : null;
    initProps(clipPath, {
      shape: {
        width: width,
        height: height,
        x: x,
        y: y
      }
    }, seriesModel, null, done, duringCb);
  }

  return clipPath;
}

function createPolarClipPath(polar, hasAnimation, seriesModel) {
  var sectorArea = polar.getArea(); // Avoid float number rounding error for symbol on the edge of axis extent.

  var r0 = round$1(sectorArea.r0, 1);
  var r = round$1(sectorArea.r, 1);
  var clipPath = new Sector$1({
    shape: {
      cx: round$1(polar.cx, 1),
      cy: round$1(polar.cy, 1),
      r0: r0,
      r: r,
      startAngle: sectorArea.startAngle,
      endAngle: sectorArea.endAngle,
      clockwise: sectorArea.clockwise
    }
  });

  if (hasAnimation) {
    var isRadial = polar.getBaseAxis().dim === 'angle';

    if (isRadial) {
      clipPath.shape.endAngle = sectorArea.startAngle;
    } else {
      clipPath.shape.r = r0;
    }

    initProps(clipPath, {
      shape: {
        endAngle: sectorArea.endAngle,
        r: r
      }
    }, seriesModel);
  }

  return clipPath;
}

function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
  if (!coordSys) {
    return null;
  } else if (coordSys.type === 'polar') {
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  } else if (coordSys.type === 'cartesian2d') {
    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
  }

  return null;
}

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function isCoordinateSystemType(coordSys, type) {
  return coordSys.type === type;
}

function isPointsSame(points1, points2) {
  if (points1.length !== points2.length) {
    return;
  }

  for (var i = 0; i < points1.length; i++) {
    if (points1[i] !== points2[i]) {
      return;
    }
  }

  return true;
}

function bboxFromPoints(points) {
  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;

  for (var i = 0; i < points.length;) {
    var x = points[i++];
    var y = points[i++];

    if (!isNaN(x)) {
      minX = Math.min(x, minX);
      maxX = Math.max(x, maxX);
    }

    if (!isNaN(y)) {
      minY = Math.min(y, minY);
      maxY = Math.max(y, maxY);
    }
  }

  return [[minX, minY], [maxX, maxY]];
}

function getBoundingDiff(points1, points2) {
  var _a = bboxFromPoints(points1),
      min1 = _a[0],
      max1 = _a[1];

  var _b = bboxFromPoints(points2),
      min2 = _b[0],
      max2 = _b[1]; // Get a max value from each corner of two boundings.


  return Math.max(Math.abs(min1[0] - min2[0]), Math.abs(min1[1] - min2[1]), Math.abs(max1[0] - max2[0]), Math.abs(max1[1] - max2[1]));
}

function getSmooth(smooth) {
  return isNumber(smooth) ? smooth : smooth ? 0.5 : 0;
}

function getStackedOnPoints(coordSys, data, dataCoordInfo) {
  if (!dataCoordInfo.valueDim) {
    return [];
  }

  var len = data.count();
  var points = createFloat32Array(len * 2);

  for (var idx = 0; idx < len; idx++) {
    var pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);
    points[idx * 2] = pt[0];
    points[idx * 2 + 1] = pt[1];
  }

  return points;
}

function turnPointsIntoStep(points, coordSys, stepTurnAt, connectNulls) {
  var baseAxis = coordSys.getBaseAxis();
  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;
  var stepPoints = [];
  var i = 0;
  var stepPt = [];
  var pt = [];
  var nextPt = [];
  var filteredPoints = [];

  if (connectNulls) {
    for (i = 0; i < points.length; i += 2) {
      if (!isNaN(points[i]) && !isNaN(points[i + 1])) {
        filteredPoints.push(points[i], points[i + 1]);
      }
    }

    points = filteredPoints;
  }

  for (i = 0; i < points.length - 2; i += 2) {
    nextPt[0] = points[i + 2];
    nextPt[1] = points[i + 3];
    pt[0] = points[i];
    pt[1] = points[i + 1];
    stepPoints.push(pt[0], pt[1]);

    switch (stepTurnAt) {
      case 'end':
        stepPt[baseIndex] = nextPt[baseIndex];
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        break;

      case 'middle':
        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
        var stepPt2 = [];
        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        stepPoints.push(stepPt2[0], stepPt2[1]);
        break;

      default:
        // default is start
        stepPt[baseIndex] = pt[baseIndex];
        stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
    }
  } // Last points


  stepPoints.push(points[i++], points[i++]);
  return stepPoints;
}
/**
 * Clip color stops to edge. Avoid creating too large gradients.
 * Which may lead to blurry when GPU acceleration is enabled. See #15680
 *
 * The stops has been sorted from small to large.
 */


function clipColorStops(colorStops, maxSize) {
  var newColorStops = [];
  var len = colorStops.length; // coord will always < 0 in prevOutOfRangeColorStop.

  var prevOutOfRangeColorStop;
  var prevInRangeColorStop;

  function lerpStop(stop0, stop1, clippedCoord) {
    var coord0 = stop0.coord;
    var p = (clippedCoord - coord0) / (stop1.coord - coord0);
    var color = lerp(p, [stop0.color, stop1.color]);
    return {
      coord: clippedCoord,
      color: color
    };
  }

  for (var i = 0; i < len; i++) {
    var stop_1 = colorStops[i];
    var coord = stop_1.coord;

    if (coord < 0) {
      prevOutOfRangeColorStop = stop_1;
    } else if (coord > maxSize) {
      if (prevInRangeColorStop) {
        newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize));
      } else if (prevOutOfRangeColorStop) {
        // If there are two stops and coord range is between these two stops
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize));
      } // All following stop will be out of range. So just ignore them.


      break;
    } else {
      if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0)); // Reset

        prevOutOfRangeColorStop = null;
      }

      newColorStops.push(stop_1);
      prevInRangeColorStop = stop_1;
    }
  }

  return newColorStops;
}

function getVisualGradient(data, coordSys, api) {
  var visualMetaList = data.getVisual('visualMeta');

  if (!visualMetaList || !visualMetaList.length || !data.count()) {
    // When data.count() is 0, gradient range can not be calculated.
    return;
  }

  if (coordSys.type !== 'cartesian2d') {
    if (process.env.NODE_ENV !== 'production') {
      console.warn('Visual map on line style is only supported on cartesian2d.');
    }

    return;
  }

  var coordDim;
  var visualMeta;

  for (var i = visualMetaList.length - 1; i >= 0; i--) {
    var dimInfo = data.getDimensionInfo(visualMetaList[i].dimension);
    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y

    if (coordDim === 'x' || coordDim === 'y') {
      visualMeta = visualMetaList[i];
      break;
    }
  }

  if (!visualMeta) {
    if (process.env.NODE_ENV !== 'production') {
      console.warn('Visual map on line style only support x or y dimension.');
    }

    return;
  } // If the area to be rendered is bigger than area defined by LinearGradient,
  // the canvas spec prescribes that the color of the first stop and the last
  // stop should be used. But if two stops are added at offset 0, in effect
  // browsers use the color of the second stop to render area outside
  // LinearGradient. So we can only infinitesimally extend area defined in
  // LinearGradient to render `outerColors`.


  var axis = coordSys.getAxis(coordDim); // dataToCoord mapping may not be linear, but must be monotonic.

  var colorStops = map$1(visualMeta.stops, function (stop) {
    // offset will be calculated later.
    return {
      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
      color: stop.color
    };
  });
  var stopLen = colorStops.length;
  var outerColors = visualMeta.outerColors.slice();

  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
    colorStops.reverse();
    outerColors.reverse();
  }

  var colorStopsInRange = clipColorStops(colorStops, coordDim === 'x' ? api.getWidth() : api.getHeight());
  var inRangeStopLen = colorStopsInRange.length;

  if (!inRangeStopLen && stopLen) {
    // All stops are out of range. All will be the same color.
    return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;
  }

  var tinyExtent = 10; // Arbitrary value: 10px

  var minCoord = colorStopsInRange[0].coord - tinyExtent;
  var maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;
  var coordSpan = maxCoord - minCoord;

  if (coordSpan < 1e-3) {
    return 'transparent';
  }

  each$9(colorStopsInRange, function (stop) {
    stop.offset = (stop.coord - minCoord) / coordSpan;
  });
  colorStopsInRange.push({
    // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
    offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,
    color: outerColors[1] || 'transparent'
  });
  colorStopsInRange.unshift({
    offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,
    color: outerColors[0] || 'transparent'
  });
  var gradient = new LinearGradient$1(0, 0, 0, 0, colorStopsInRange, true);
  gradient[coordDim] = minCoord;
  gradient[coordDim + '2'] = maxCoord;
  return gradient;
}

function getIsIgnoreFunc(seriesModel, data, coordSys) {
  var showAllSymbol = seriesModel.get('showAllSymbol');
  var isAuto = showAllSymbol === 'auto';

  if (showAllSymbol && !isAuto) {
    return;
  }

  var categoryAxis = coordSys.getAxesByScale('ordinal')[0];

  if (!categoryAxis) {
    return;
  } // Note that category label interval strategy might bring some weird effect
  // in some scenario: users may wonder why some of the symbols are not
  // displayed. So we show all symbols as possible as we can.


  if (isAuto // Simplify the logic, do not determine label overlap here.
  && canShowAllSymbolForCategory(categoryAxis, data)) {
    return;
  } // Otherwise follow the label interval strategy on category axis.


  var categoryDataDim = data.mapDimension(categoryAxis.dim);
  var labelMap = {};
  each$9(categoryAxis.getViewLabels(), function (labelItem) {
    var ordinalNumber = categoryAxis.scale.getRawOrdinalNumber(labelItem.tickValue);
    labelMap[ordinalNumber] = 1;
  });
  return function (dataIndex) {
    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
  };
}

function canShowAllSymbolForCategory(categoryAxis, data) {
  // In mose cases, line is monotonous on category axis, and the label size
  // is close with each other. So we check the symbol size and some of the
  // label size alone with the category axis to estimate whether all symbol
  // can be shown without overlap.
  var axisExtent = categoryAxis.getExtent();
  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();
  isNaN(availSize) && (availSize = 0); // 0/0 is NaN.
  // Sampling some points, max 5.

  var dataLen = data.count();
  var step = Math.max(1, Math.round(dataLen / 5));

  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
    if (SymbolClz.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.
    )[categoryAxis.isHorizontal() ? 1 : 0] // Empirical number
    * 1.5 > availSize) {
      return false;
    }
  }

  return true;
}

function isPointNull(x, y) {
  return isNaN(x) || isNaN(y);
}

function getLastIndexNotNull(points) {
  var len = points.length / 2;

  for (; len > 0; len--) {
    if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {
      break;
    }
  }

  return len - 1;
}

function getPointAtIndex(points, idx) {
  return [points[idx * 2], points[idx * 2 + 1]];
}

function getIndexRange(points, xOrY, dim) {
  var len = points.length / 2;
  var dimIdx = dim === 'x' ? 0 : 1;
  var a;
  var b;
  var prevIndex = 0;
  var nextIndex = -1;

  for (var i = 0; i < len; i++) {
    b = points[i * 2 + dimIdx];

    if (isNaN(b) || isNaN(points[i * 2 + 1 - dimIdx])) {
      continue;
    }

    if (i === 0) {
      a = b;
      continue;
    }

    if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {
      nextIndex = i;
      break;
    }

    prevIndex = i;
    a = b;
  }

  return {
    range: [prevIndex, nextIndex],
    t: (xOrY - a) / (b - a)
  };
}

function anyStateShowEndLabel(seriesModel) {
  if (seriesModel.get(['endLabel', 'show'])) {
    return true;
  }

  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    if (seriesModel.get([SPECIAL_STATES[i], 'endLabel', 'show'])) {
      return true;
    }
  }

  return false;
}

function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
  if (isCoordinateSystemType(coordSys, 'cartesian2d')) {
    var endLabelModel_1 = seriesModel.getModel('endLabel');
    var valueAnimation_1 = endLabelModel_1.get('valueAnimation');
    var data_1 = seriesModel.getData();
    var labelAnimationRecord_1 = {
      lastFrameIndex: 0
    };
    var during = anyStateShowEndLabel(seriesModel) ? function (percent, clipRect) {
      lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);
    } : null;
    var isHorizontal = coordSys.getBaseAxis().isHorizontal();
    var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, function () {
      var endLabel = lineView._endLabel;

      if (endLabel && hasAnimation) {
        if (labelAnimationRecord_1.originalX != null) {
          endLabel.attr({
            x: labelAnimationRecord_1.originalX,
            y: labelAnimationRecord_1.originalY
          });
        }
      }
    }, during); // Expand clip shape to avoid clipping when line value exceeds axis

    if (!seriesModel.get('clip', true)) {
      var rectShape = clipPath.shape;
      var expandSize = Math.max(rectShape.width, rectShape.height);

      if (isHorizontal) {
        rectShape.y -= expandSize;
        rectShape.height += expandSize * 2;
      } else {
        rectShape.x -= expandSize;
        rectShape.width += expandSize * 2;
      }
    } // Set to the final frame. To make sure label layout is right.


    if (during) {
      during(1, clipPath);
    }

    return clipPath;
  } else {
    if (process.env.NODE_ENV !== 'production') {
      if (seriesModel.get(['endLabel', 'show'])) {
        console.warn('endLabel is not supported for lines in polar systems.');
      }
    }

    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  }
}

function getEndLabelStateSpecified(endLabelModel, coordSys) {
  var baseAxis = coordSys.getBaseAxis();
  var isHorizontal = baseAxis.isHorizontal();
  var isBaseInversed = baseAxis.inverse;
  var align = isHorizontal ? isBaseInversed ? 'right' : 'left' : 'center';
  var verticalAlign = isHorizontal ? 'middle' : isBaseInversed ? 'top' : 'bottom';
  return {
    normal: {
      align: endLabelModel.get('align') || align,
      verticalAlign: endLabelModel.get('verticalAlign') || verticalAlign
    }
  };
}

var LineView =
/** @class */
function (_super) {
  __extends$1(LineView, _super);

  function LineView() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  LineView.prototype.init = function () {
    var lineGroup = new Group$3();
    var symbolDraw = new SymbolDraw$1();
    this.group.add(symbolDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineGroup = lineGroup;
  };

  LineView.prototype.render = function (seriesModel, ecModel, api) {
    var _this = this;

    var coordSys = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var lineStyleModel = seriesModel.getModel('lineStyle');
    var areaStyleModel = seriesModel.getModel('areaStyle');
    var points = data.getLayout('points') || [];
    var isCoordSysPolar = coordSys.type === 'polar';
    var prevCoordSys = this._coordSys;
    var symbolDraw = this._symbolDraw;
    var polyline = this._polyline;
    var polygon = this._polygon;
    var lineGroup = this._lineGroup;
    var hasAnimation = seriesModel.get('animation');
    var isAreaChart = !areaStyleModel.isEmpty();
    var valueOrigin = areaStyleModel.get('origin');
    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
    var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
    var showSymbol = seriesModel.get('showSymbol');
    var connectNulls = seriesModel.get('connectNulls');
    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys); // Remove temporary symbols

    var oldData = this._data;
    oldData && oldData.eachItemGraphicEl(function (el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    }); // Remove previous created symbols if showSymbol changed to false

    if (!showSymbol) {
      symbolDraw.remove();
    }

    group.add(lineGroup); // FIXME step not support polar

    var step = !isCoordSysPolar ? seriesModel.get('step') : false;
    var clipShapeForSymbol;

    if (coordSys && coordSys.getArea && seriesModel.get('clip', true)) {
      clipShapeForSymbol = coordSys.getArea(); // Avoid float number rounding error for symbol on the edge of axis extent.
      // See #7913 and `test/dataZoom-clip.html`.

      if (clipShapeForSymbol.width != null) {
        clipShapeForSymbol.x -= 0.1;
        clipShapeForSymbol.y -= 0.1;
        clipShapeForSymbol.width += 0.2;
        clipShapeForSymbol.height += 0.2;
      } else if (clipShapeForSymbol.r0) {
        clipShapeForSymbol.r0 -= 0.5;
        clipShapeForSymbol.r += 0.5;
      }
    }

    this._clipShapeForSymbol = clipShapeForSymbol;
    var visualColor = getVisualGradient(data, coordSys, api) || data.getVisual('style')[data.getVisual('drawType')]; // Initialization animation or coordinate system changed

    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function (idx) {
          return [points[idx * 2], points[idx * 2 + 1]];
        }
      });
      hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);

      if (step) {
        // TODO If stacked series is not step
        points = turnPointsIntoStep(points, coordSys, step, connectNulls);

        if (stackedOnPoints) {
          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);
        }
      }

      polyline = this._newPolyline(points);

      if (isAreaChart) {
        polygon = this._newPolygon(points, stackedOnPoints);
      } // If areaStyle is removed
      else if (polygon) {
          lineGroup.remove(polygon);
          polygon = this._polygon = null;
        } // NOTE: Must update _endLabel before setClipPath.


      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }

      lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
    } else {
      if (isAreaChart && !polygon) {
        // If areaStyle is added
        polygon = this._newPolygon(points, stackedOnPoints);
      } else if (polygon && !isAreaChart) {
        // If areaStyle is removed
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      } // NOTE: Must update _endLabel before setClipPath.


      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      } // Update clipPath


      var oldClipPath = lineGroup.getClipPath();

      if (oldClipPath) {
        var newClipPath = createLineClipPath(this, coordSys, false, seriesModel);
        initProps(oldClipPath, {
          shape: newClipPath.shape
        }, seriesModel);
      } else {
        lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
      } // Always update, or it is wrong in the case turning on legend
      // because points are not changed


      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function (idx) {
          return [points[idx * 2], points[idx * 2 + 1]];
        }
      }); // In the case data zoom triggerred refreshing frequently
      // Data may not change if line has a category axis. So it should animate nothing

      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
        if (hasAnimation) {
          this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls);
        } else {
          // Not do it in update with animation
          if (step) {
            // TODO If stacked series is not step
            points = turnPointsIntoStep(points, coordSys, step, connectNulls);

            if (stackedOnPoints) {
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);
            }
          }

          polyline.setShape({
            points: points
          });
          polygon && polygon.setShape({
            points: points,
            stackedOnPoints: stackedOnPoints
          });
        }
      }
    }

    var emphasisModel = seriesModel.getModel('emphasis');
    var focus = emphasisModel.get('focus');
    var blurScope = emphasisModel.get('blurScope');
    var emphasisDisabled = emphasisModel.get('disabled');
    polyline.useStyle(defaults( // Use color in lineStyle first
    lineStyleModel.getLineStyle(), {
      fill: 'none',
      stroke: visualColor,
      lineJoin: 'bevel'
    }));
    setStatesStylesFromModel(polyline, seriesModel, 'lineStyle');

    if (polyline.style.lineWidth > 0 && seriesModel.get(['emphasis', 'lineStyle', 'width']) === 'bolder') {
      var emphasisLineStyle = polyline.getState('emphasis').style;
      emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;
    } // Needs seriesIndex for focus


    getECData(polyline).seriesIndex = seriesModel.seriesIndex;
    toggleHoverEmphasis(polyline, focus, blurScope, emphasisDisabled);
    var smooth = getSmooth(seriesModel.get('smooth'));
    var smoothMonotone = seriesModel.get('smoothMonotone');
    polyline.setShape({
      smooth: smooth,
      smoothMonotone: smoothMonotone,
      connectNulls: connectNulls
    });

    if (polygon) {
      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');
      var stackedOnSmooth = 0;
      polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
        fill: visualColor,
        opacity: 0.7,
        lineJoin: 'bevel',
        decal: data.getVisual('style').decal
      }));

      if (stackedOnSeries) {
        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
      }

      polygon.setShape({
        smooth: smooth,
        stackedOnSmooth: stackedOnSmooth,
        smoothMonotone: smoothMonotone,
        connectNulls: connectNulls
      });
      setStatesStylesFromModel(polygon, seriesModel, 'areaStyle'); // Needs seriesIndex for focus

      getECData(polygon).seriesIndex = seriesModel.seriesIndex;
      toggleHoverEmphasis(polygon, focus, blurScope, emphasisDisabled);
    }

    var changePolyState = function (toState) {
      _this._changePolyState(toState);
    };

    data.eachItemGraphicEl(function (el) {
      // Switch polyline / polygon state if element changed its state.
      el && (el.onHoverStateChange = changePolyState);
    });
    this._polyline.onHoverStateChange = changePolyState;
    this._data = data; // Save the coordinate system for transition animation when data changed

    this._coordSys = coordSys;
    this._stackedOnPoints = stackedOnPoints;
    this._points = points;
    this._step = step;
    this._valueOrigin = valueOrigin;

    if (seriesModel.get('triggerLineEvent')) {
      this.packEventData(seriesModel, polyline);
      polygon && this.packEventData(seriesModel, polygon);
    }
  };

  LineView.prototype.packEventData = function (seriesModel, el) {
    getECData(el).eventData = {
      componentType: 'series',
      componentSubType: 'line',
      componentIndex: seriesModel.componentIndex,
      seriesIndex: seriesModel.seriesIndex,
      seriesName: seriesModel.name,
      seriesType: 'line'
    };
  };

  LineView.prototype.highlight = function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, payload);

    this._changePolyState('emphasis');

    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
      var points = data.getLayout('points');
      var symbol = data.getItemGraphicEl(dataIndex);

      if (!symbol) {
        // Create a temporary symbol if it is not exists
        var x = points[dataIndex * 2];
        var y = points[dataIndex * 2 + 1];

        if (isNaN(x) || isNaN(y)) {
          // Null data
          return;
        } // fix #11360: should't draw symbol outside clipShapeForSymbol


        if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) {
          return;
        }

        var zlevel = seriesModel.get('zlevel') || 0;
        var z = seriesModel.get('z') || 0;
        symbol = new SymbolClz(data, dataIndex);
        symbol.x = x;
        symbol.y = y;
        symbol.setZ(zlevel, z); // ensure label text of the temporary symbol is in front of line and area polygon

        var symbolLabel = symbol.getSymbolPath().getTextContent();

        if (symbolLabel) {
          symbolLabel.zlevel = zlevel;
          symbolLabel.z = z;
          symbolLabel.z2 = this._polyline.z2 + 1;
        }

        symbol.__temp = true;
        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation

        symbol.stopSymbolAnimation(true);
        this.group.add(symbol);
      }

      symbol.highlight();
    } else {
      // Highlight whole series
      ChartView$1.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
    }
  };

  LineView.prototype.downplay = function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, payload);

    this._changePolyState('normal');

    if (dataIndex != null && dataIndex >= 0) {
      var symbol = data.getItemGraphicEl(dataIndex);

      if (symbol) {
        if (symbol.__temp) {
          data.setItemGraphicEl(dataIndex, null);
          this.group.remove(symbol);
        } else {
          symbol.downplay();
        }
      }
    } else {
      // FIXME
      // can not downplay completely.
      // Downplay whole series
      ChartView$1.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
    }
  };

  LineView.prototype._changePolyState = function (toState) {
    var polygon = this._polygon;
    setStatesFlag(this._polyline, toState);
    polygon && setStatesFlag(polygon, toState);
  };

  LineView.prototype._newPolyline = function (points) {
    var polyline = this._polyline; // Remove previous created polyline

    if (polyline) {
      this._lineGroup.remove(polyline);
    }

    polyline = new ECPolyline({
      shape: {
        points: points
      },
      segmentIgnoreThreshold: 2,
      z2: 10
    });

    this._lineGroup.add(polyline);

    this._polyline = polyline;
    return polyline;
  };

  LineView.prototype._newPolygon = function (points, stackedOnPoints) {
    var polygon = this._polygon; // Remove previous created polygon

    if (polygon) {
      this._lineGroup.remove(polygon);
    }

    polygon = new ECPolygon({
      shape: {
        points: points,
        stackedOnPoints: stackedOnPoints
      },
      segmentIgnoreThreshold: 2
    });

    this._lineGroup.add(polygon);

    this._polygon = polygon;
    return polygon;
  };

  LineView.prototype._initSymbolLabelAnimation = function (data, coordSys, clipShape) {
    var isHorizontalOrRadial;
    var isCoordSysPolar;
    var baseAxis = coordSys.getBaseAxis();
    var isAxisInverse = baseAxis.inverse;

    if (coordSys.type === 'cartesian2d') {
      isHorizontalOrRadial = baseAxis.isHorizontal();
      isCoordSysPolar = false;
    } else if (coordSys.type === 'polar') {
      isHorizontalOrRadial = baseAxis.dim === 'angle';
      isCoordSysPolar = true;
    }

    var seriesModel = data.hostModel;
    var seriesDuration = seriesModel.get('animationDuration');

    if (isFunction(seriesDuration)) {
      seriesDuration = seriesDuration(null);
    }

    var seriesDalay = seriesModel.get('animationDelay') || 0;
    var seriesDalayValue = isFunction(seriesDalay) ? seriesDalay(null) : seriesDalay;
    data.eachItemGraphicEl(function (symbol, idx) {
      var el = symbol;

      if (el) {
        var point = [symbol.x, symbol.y];
        var start = void 0;
        var end = void 0;
        var current = void 0;

        if (clipShape) {
          if (isCoordSysPolar) {
            var polarClip = clipShape;
            var coord = coordSys.pointToCoord(point);

            if (isHorizontalOrRadial) {
              start = polarClip.startAngle;
              end = polarClip.endAngle;
              current = -coord[1] / 180 * Math.PI;
            } else {
              start = polarClip.r0;
              end = polarClip.r;
              current = coord[0];
            }
          } else {
            var gridClip = clipShape;

            if (isHorizontalOrRadial) {
              start = gridClip.x;
              end = gridClip.x + gridClip.width;
              current = symbol.x;
            } else {
              start = gridClip.y + gridClip.height;
              end = gridClip.y;
              current = symbol.y;
            }
          }
        }

        var ratio = end === start ? 0 : (current - start) / (end - start);

        if (isAxisInverse) {
          ratio = 1 - ratio;
        }

        var delay = isFunction(seriesDalay) ? seriesDalay(idx) : seriesDuration * ratio + seriesDalayValue;
        var symbolPath = el.getSymbolPath();
        var text = symbolPath.getTextContent();
        el.attr({
          scaleX: 0,
          scaleY: 0
        });
        el.animateTo({
          scaleX: 1,
          scaleY: 1
        }, {
          duration: 200,
          setToFinal: true,
          delay: delay
        });

        if (text) {
          text.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: delay
          });
        }

        symbolPath.disableLabelAnimation = true;
      }
    });
  };

  LineView.prototype._initOrUpdateEndLabel = function (seriesModel, coordSys, inheritColor) {
    var endLabelModel = seriesModel.getModel('endLabel');

    if (anyStateShowEndLabel(seriesModel)) {
      var data_2 = seriesModel.getData();
      var polyline = this._polyline; // series may be filtered.

      var points = data_2.getLayout('points');

      if (!points) {
        polyline.removeTextContent();
        this._endLabel = null;
        return;
      }

      var endLabel = this._endLabel;

      if (!endLabel) {
        endLabel = this._endLabel = new ZRText$1({
          z2: 200 // should be higher than item symbol

        });
        endLabel.ignoreClip = true;
        polyline.setTextContent(this._endLabel);
        polyline.disableLabelAnimation = true;
      } // Find last non-NaN data to display data


      var dataIndex = getLastIndexNotNull(points);

      if (dataIndex >= 0) {
        setLabelStyle(polyline, getLabelStatesModels(seriesModel, 'endLabel'), {
          inheritColor: inheritColor,
          labelFetcher: seriesModel,
          labelDataIndex: dataIndex,
          defaultText: function (dataIndex, opt, interpolatedValue) {
            return interpolatedValue != null ? getDefaultInterpolatedLabel(data_2, interpolatedValue) : getDefaultLabel(data_2, dataIndex);
          },
          enableTextSetter: true
        }, getEndLabelStateSpecified(endLabelModel, coordSys));
        polyline.textConfig.position = null;
      }
    } else if (this._endLabel) {
      this._polyline.removeTextContent();

      this._endLabel = null;
    }
  };

  LineView.prototype._endLabelOnDuring = function (percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
    var endLabel = this._endLabel;
    var polyline = this._polyline;

    if (endLabel) {
      // NOTE: Don't remove percent < 1. percent === 1 means the first frame during render.
      // The label is not prepared at this time.
      if (percent < 1 && animationRecord.originalX == null) {
        animationRecord.originalX = endLabel.x;
        animationRecord.originalY = endLabel.y;
      }

      var points = data.getLayout('points');
      var seriesModel = data.hostModel;
      var connectNulls = seriesModel.get('connectNulls');
      var precision = endLabelModel.get('precision');
      var distance = endLabelModel.get('distance') || 0;
      var baseAxis = coordSys.getBaseAxis();
      var isHorizontal = baseAxis.isHorizontal();
      var isBaseInversed = baseAxis.inverse;
      var clipShape = clipRect.shape;
      var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
      var distanceX = (isHorizontal ? distance : 0) * (isBaseInversed ? -1 : 1);
      var distanceY = (isHorizontal ? 0 : -distance) * (isBaseInversed ? -1 : 1);
      var dim = isHorizontal ? 'x' : 'y';
      var dataIndexRange = getIndexRange(points, xOrY, dim);
      var indices = dataIndexRange.range;
      var diff = indices[1] - indices[0];
      var value = void 0;

      if (diff >= 1) {
        // diff > 1 && connectNulls, which is on the null data.
        if (diff > 1 && !connectNulls) {
          var pt = getPointAtIndex(points, indices[0]);
          endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          valueAnimation && (value = seriesModel.getRawValue(indices[0]));
        } else {
          var pt = polyline.getPointOn(xOrY, dim);
          pt && endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          var startValue = seriesModel.getRawValue(indices[0]);
          var endValue = seriesModel.getRawValue(indices[1]);
          valueAnimation && (value = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
        }

        animationRecord.lastFrameIndex = indices[0];
      } else {
        // If diff <= 0, which is the range is not found(Include NaN)
        // Choose the first point or last point.
        var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
        var pt = getPointAtIndex(points, idx);
        valueAnimation && (value = seriesModel.getRawValue(idx));
        endLabel.attr({
          x: pt[0] + distanceX,
          y: pt[1] + distanceY
        });
      }

      if (valueAnimation) {
        labelInner(endLabel).setLabelText(value);
      }
    }
  };
  /**
   * @private
   */
  // FIXME Two value axis


  LineView.prototype._doUpdateAnimation = function (data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls) {
    var polyline = this._polyline;
    var polygon = this._polygon;
    var seriesModel = data.hostModel;
    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin);
    var current = diff.current;
    var stackedOnCurrent = diff.stackedOnCurrent;
    var next = diff.next;
    var stackedOnNext = diff.stackedOnNext;

    if (step) {
      // TODO If stacked series is not step
      current = turnPointsIntoStep(diff.current, coordSys, step, connectNulls);
      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step, connectNulls);
      next = turnPointsIntoStep(diff.next, coordSys, step, connectNulls);
      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step, connectNulls);
    } // Don't apply animation if diff is large.
    // For better result and avoid memory explosion problems like
    // https://github.com/apache/incubator-echarts/issues/12229


    if (getBoundingDiff(current, next) > 3000 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3000) {
      polyline.stopAnimation();
      polyline.setShape({
        points: next
      });

      if (polygon) {
        polygon.stopAnimation();
        polygon.setShape({
          points: next,
          stackedOnPoints: stackedOnNext
        });
      }

      return;
    }

    polyline.shape.__points = diff.current;
    polyline.shape.points = current;
    var target = {
      shape: {
        points: next
      }
    }; // Also animate the original points.
    // If points reference is changed when turning into step line.

    if (diff.current !== current) {
      target.shape.__points = diff.next;
    } // Stop previous animation.


    polyline.stopAnimation();
    updateProps$1(polyline, target, seriesModel);

    if (polygon) {
      polygon.setShape({
        // Reuse the points with polyline.
        points: current,
        stackedOnPoints: stackedOnCurrent
      });
      polygon.stopAnimation();
      updateProps$1(polygon, {
        shape: {
          stackedOnPoints: stackedOnNext
        }
      }, seriesModel); // If use attr directly in updateProps.

      if (polyline.shape.points !== polygon.shape.points) {
        polygon.shape.points = polyline.shape.points;
      }
    }

    var updatedDataInfo = [];
    var diffStatus = diff.status;

    for (var i = 0; i < diffStatus.length; i++) {
      var cmd = diffStatus[i].cmd;

      if (cmd === '=') {
        var el = data.getItemGraphicEl(diffStatus[i].idx1);

        if (el) {
          updatedDataInfo.push({
            el: el,
            ptIdx: i // Index of points

          });
        }
      }
    }

    if (polyline.animators && polyline.animators.length) {
      polyline.animators[0].during(function () {
        polygon && polygon.dirtyShape();
        var points = polyline.shape.__points;

        for (var i = 0; i < updatedDataInfo.length; i++) {
          var el = updatedDataInfo[i].el;
          var offset = updatedDataInfo[i].ptIdx * 2;
          el.x = points[offset];
          el.y = points[offset + 1];
          el.markRedraw();
        }
      });
    }
  };

  LineView.prototype.remove = function (ecModel) {
    var group = this.group;
    var oldData = this._data;

    this._lineGroup.removeAll();

    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting


    oldData && oldData.eachItemGraphicEl(function (el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
  };

  LineView.type = 'line';
  return LineView;
}(ChartView$1);

var LineView$1 = LineView;

function pointsLayout(seriesType, forceStoreInTypedArray) {
  return {
    seriesType: seriesType,
    plan: createRenderPlanner(),
    reset: function (seriesModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      var pipelineContext = seriesModel.pipelineContext;
      var useTypedArray = forceStoreInTypedArray || pipelineContext.large;

      if (!coordSys) {
        return;
      }

      var dims = map$1(coordSys.dimensions, function (dim) {
        return data.mapDimension(dim);
      }).slice(0, 2);
      var dimLen = dims.length;
      var stackResultDim = data.getCalculationInfo('stackResultDimension');

      if (isDimensionStacked(data, dims[0])) {
        dims[0] = stackResultDim;
      }

      if (isDimensionStacked(data, dims[1])) {
        dims[1] = stackResultDim;
      }

      var store = data.getStore();
      var dimIdx0 = data.getDimensionIndex(dims[0]);
      var dimIdx1 = data.getDimensionIndex(dims[1]);
      return dimLen && {
        progress: function (params, data) {
          var segCount = params.end - params.start;
          var points = useTypedArray && createFloat32Array(segCount * dimLen);
          var tmpIn = [];
          var tmpOut = [];

          for (var i = params.start, offset = 0; i < params.end; i++) {
            var point = void 0;

            if (dimLen === 1) {
              var x = store.get(dimIdx0, i); // NOTE: Make sure the second parameter is null to use default strategy.

              point = coordSys.dataToPoint(x, null, tmpOut);
            } else {
              tmpIn[0] = store.get(dimIdx0, i);
              tmpIn[1] = store.get(dimIdx1, i); // Let coordinate system to handle the NaN data.

              point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            }

            if (useTypedArray) {
              points[offset++] = point[0];
              points[offset++] = point[1];
            } else {
              data.setItemLayout(i, point.slice());
            }
          }

          useTypedArray && data.setLayout('points', points);
        }
      };
    }
  };
}

var samplers = {
  average: function (frame) {
    var sum = 0;
    var count = 0;

    for (var i = 0; i < frame.length; i++) {
      if (!isNaN(frame[i])) {
        sum += frame[i];
        count++;
      }
    } // Return NaN if count is 0


    return count === 0 ? NaN : sum / count;
  },
  sum: function (frame) {
    var sum = 0;

    for (var i = 0; i < frame.length; i++) {
      // Ignore NaN
      sum += frame[i] || 0;
    }

    return sum;
  },
  max: function (frame) {
    var max = -Infinity;

    for (var i = 0; i < frame.length; i++) {
      frame[i] > max && (max = frame[i]);
    } // NaN will cause illegal axis extent.


    return isFinite(max) ? max : NaN;
  },
  min: function (frame) {
    var min = Infinity;

    for (var i = 0; i < frame.length; i++) {
      frame[i] < min && (min = frame[i]);
    } // NaN will cause illegal axis extent.


    return isFinite(min) ? min : NaN;
  },
  // TODO
  // Median
  nearest: function (frame) {
    return frame[0];
  }
};

var indexSampler = function (frame) {
  return Math.round(frame.length / 2);
};

function dataSample(seriesType) {
  return {
    seriesType: seriesType,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function (seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var sampling = seriesModel.get('sampling');
      var coordSys = seriesModel.coordinateSystem;
      var count = data.count(); // Only cartesian2d support down sampling. Disable it when there is few data.

      if (count > 10 && coordSys.type === 'cartesian2d' && sampling) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis = coordSys.getOtherAxis(baseAxis);
        var extent = baseAxis.getExtent();
        var dpr = api.getDevicePixelRatio(); // Coordinste system has been resized

        var size = Math.abs(extent[1] - extent[0]) * (dpr || 1);
        var rate = Math.round(count / size);

        if (isFinite(rate) && rate > 1) {
          if (sampling === 'lttb') {
            seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis.dim), 1 / rate));
          }

          var sampler = void 0;

          if (isString(sampling)) {
            sampler = samplers[sampling];
          } else if (isFunction(sampling)) {
            sampler = sampling;
          }

          if (sampler) {
            // Only support sample the first dim mapped from value axis.
            seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));
          }
        }
      }
    }
  };
}

function install$i(registers) {
  registers.registerChartView(LineView$1);
  registers.registerSeriesModel(LineSeries);
  registers.registerLayout(pointsLayout('line', true));
  registers.registerVisual({
    seriesType: 'line',
    reset: function (seriesModel) {
      var data = seriesModel.getData(); // Visual coding for legend

      var lineStyle = seriesModel.getModel('lineStyle').getLineStyle();

      if (lineStyle && !lineStyle.stroke) {
        // Fill in visual should be palette color if
        // has color callback
        lineStyle.stroke = data.getVisual('style').fill;
      }

      data.setVisual('legendLineStyle', lineStyle);
    }
  }); // Down sample after filter

  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));
}

var BaseBarSeriesModel =
/** @class */
function (_super) {
  __extends$1(BaseBarSeriesModel, _super);

  function BaseBarSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = BaseBarSeriesModel.type;
    return _this;
  }

  BaseBarSeriesModel.prototype.getInitialData = function (option, ecModel) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };

  BaseBarSeriesModel.prototype.getMarkerPosition = function (value) {
    var coordSys = this.coordinateSystem;

    if (coordSys && coordSys.clampData) {
      // PENDING if clamp ?
      var pt = coordSys.dataToPoint(coordSys.clampData(value));
      var data = this.getData();
      var offset = data.getLayout('offset');
      var size = data.getLayout('size');
      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
      pt[offsetIndex] += offset + size / 2;
      return pt;
    }

    return [NaN, NaN];
  };

  BaseBarSeriesModel.type = 'series.__base_bar__';
  BaseBarSeriesModel.defaultOption = {
    // zlevel: 0,
    z: 2,
    coordinateSystem: 'cartesian2d',
    legendHoverLink: true,
    // stack: null
    // Cartesian coordinate system
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    barMinHeight: 0,
    barMinAngle: 0,
    // cursor: null,
    large: false,
    largeThreshold: 400,
    progressive: 3e3,
    progressiveChunkMode: 'mod'
  };
  return BaseBarSeriesModel;
}(SeriesModel$1);

SeriesModel$1.registerClass(BaseBarSeriesModel);
var BaseBarSeriesModel$1 = BaseBarSeriesModel;

var BarSeriesModel =
/** @class */
function (_super) {
  __extends$1(BarSeriesModel, _super);

  function BarSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = BarSeriesModel.type;
    return _this;
  }

  BarSeriesModel.prototype.getInitialData = function () {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true,
      createInvertedIndices: !!this.get('realtimeSort', true) || null
    });
  };
  /**
   * @override
   */


  BarSeriesModel.prototype.getProgressive = function () {
    // Do not support progressive in normal mode.
    return this.get('large') ? this.get('progressive') : false;
  };
  /**
   * @override
   */


  BarSeriesModel.prototype.getProgressiveThreshold = function () {
    // Do not support progressive in normal mode.
    var progressiveThreshold = this.get('progressiveThreshold');
    var largeThreshold = this.get('largeThreshold');

    if (largeThreshold > progressiveThreshold) {
      progressiveThreshold = largeThreshold;
    }

    return progressiveThreshold;
  };

  BarSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {
    return selectors.rect(data.getItemLayout(dataIndex));
  };

  BarSeriesModel.type = 'series.bar';
  BarSeriesModel.dependencies = ['grid', 'polar'];
  BarSeriesModel.defaultOption = inheritDefaultOption(BaseBarSeriesModel$1.defaultOption, {
    // If clipped
    // Only available on cartesian2d
    clip: true,
    roundCap: false,
    showBackground: false,
    backgroundStyle: {
      color: 'rgba(180, 180, 180, 0.2)',
      borderColor: null,
      borderWidth: 0,
      borderType: 'solid',
      borderRadius: 0,
      shadowBlur: 0,
      shadowColor: null,
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      opacity: 1
    },
    select: {
      itemStyle: {
        borderColor: '#212121'
      }
    },
    realtimeSort: false
  });
  return BarSeriesModel;
}(BaseBarSeriesModel$1);

var BarSeries = BarSeriesModel;

/**
 * Sausage: similar to sector, but have half circle on both sides
 */

var SausageShape =
/** @class */
function () {
  function SausageShape() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }

  return SausageShape;
}();

var SausagePath =
/** @class */
function (_super) {
  __extends$1(SausagePath, _super);

  function SausagePath(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'sausage';
    return _this;
  }

  SausagePath.prototype.getDefaultShape = function () {
    return new SausageShape();
  };

  SausagePath.prototype.buildPath = function (ctx, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var r0 = Math.max(shape.r0 || 0, 0);
    var r = Math.max(shape.r, 0);
    var dr = (r - r0) * 0.5;
    var rCenter = r0 + dr;
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var PI2 = Math.PI * 2;
    var lessThanCircle = clockwise ? endAngle - startAngle < PI2 : startAngle - endAngle < PI2;

    if (!lessThanCircle) {
      // Normalize angles
      startAngle = endAngle - (clockwise ? PI2 : -PI2);
    }

    var unitStartX = Math.cos(startAngle);
    var unitStartY = Math.sin(startAngle);
    var unitEndX = Math.cos(endAngle);
    var unitEndY = Math.sin(endAngle);

    if (lessThanCircle) {
      ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy);
      ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr, -Math.PI + startAngle, startAngle, !clockwise);
    } else {
      ctx.moveTo(unitStartX * r + cx, unitStartY * r + cy);
    }

    ctx.arc(cx, cy, r, startAngle, endAngle, !clockwise);
    ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);

    if (r0 !== 0) {
      ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise);
    } // ctx.closePath();

  };

  return SausagePath;
}(Path$1);

var Sausage = SausagePath;

function createSectorCalculateTextPosition(positionMapping, opts) {
  opts = opts || {};
  var isRoundCap = opts.isRoundCap;
  return function (out, opts, boundingRect) {
    var textPosition = opts.position;

    if (!textPosition || textPosition instanceof Array) {
      return calculateTextPosition(out, opts, boundingRect);
    }

    var mappedSectorPosition = positionMapping(textPosition);
    var distance = opts.distance != null ? opts.distance : 5;
    var sector = this.shape;
    var cx = sector.cx;
    var cy = sector.cy;
    var r = sector.r;
    var r0 = sector.r0;
    var middleR = (r + r0) / 2;
    var startAngle = sector.startAngle;
    var endAngle = sector.endAngle;
    var middleAngle = (startAngle + endAngle) / 2;
    var extraDist = isRoundCap ? Math.abs(r - r0) / 2 : 0;
    var mathCos = Math.cos;
    var mathSin = Math.sin; // base position: top-left

    var x = cx + r * mathCos(startAngle);
    var y = cy + r * mathSin(startAngle);
    var textAlign = 'left';
    var textVerticalAlign = 'top';

    switch (mappedSectorPosition) {
      case 'startArc':
        x = cx + (r0 - distance) * mathCos(middleAngle);
        y = cy + (r0 - distance) * mathSin(middleAngle);
        textAlign = 'center';
        textVerticalAlign = 'top';
        break;

      case 'insideStartArc':
        x = cx + (r0 + distance) * mathCos(middleAngle);
        y = cy + (r0 + distance) * mathSin(middleAngle);
        textAlign = 'center';
        textVerticalAlign = 'bottom';
        break;

      case 'startAngle':
        x = cx + middleR * mathCos(startAngle) + adjustAngleDistanceX(startAngle, distance + extraDist, false);
        y = cy + middleR * mathSin(startAngle) + adjustAngleDistanceY(startAngle, distance + extraDist, false);
        textAlign = 'right';
        textVerticalAlign = 'middle';
        break;

      case 'insideStartAngle':
        x = cx + middleR * mathCos(startAngle) + adjustAngleDistanceX(startAngle, -distance + extraDist, false);
        y = cy + middleR * mathSin(startAngle) + adjustAngleDistanceY(startAngle, -distance + extraDist, false);
        textAlign = 'left';
        textVerticalAlign = 'middle';
        break;

      case 'middle':
        x = cx + middleR * mathCos(middleAngle);
        y = cy + middleR * mathSin(middleAngle);
        textAlign = 'center';
        textVerticalAlign = 'middle';
        break;

      case 'endArc':
        x = cx + (r + distance) * mathCos(middleAngle);
        y = cy + (r + distance) * mathSin(middleAngle);
        textAlign = 'center';
        textVerticalAlign = 'bottom';
        break;

      case 'insideEndArc':
        x = cx + (r - distance) * mathCos(middleAngle);
        y = cy + (r - distance) * mathSin(middleAngle);
        textAlign = 'center';
        textVerticalAlign = 'top';
        break;

      case 'endAngle':
        x = cx + middleR * mathCos(endAngle) + adjustAngleDistanceX(endAngle, distance + extraDist, true);
        y = cy + middleR * mathSin(endAngle) + adjustAngleDistanceY(endAngle, distance + extraDist, true);
        textAlign = 'left';
        textVerticalAlign = 'middle';
        break;

      case 'insideEndAngle':
        x = cx + middleR * mathCos(endAngle) + adjustAngleDistanceX(endAngle, -distance + extraDist, true);
        y = cy + middleR * mathSin(endAngle) + adjustAngleDistanceY(endAngle, -distance + extraDist, true);
        textAlign = 'right';
        textVerticalAlign = 'middle';
        break;

      default:
        return calculateTextPosition(out, opts, boundingRect);
    }

    out = out || {};
    out.x = x;
    out.y = y;
    out.align = textAlign;
    out.verticalAlign = textVerticalAlign;
    return out;
  };
}
function setSectorTextRotation(sector, textPosition, positionMapping, rotateType) {
  if (isNumber(rotateType)) {
    // user-set rotation
    sector.setTextConfig({
      rotation: rotateType
    });
    return;
  } else if (isArray$1(textPosition)) {
    // user-set position, use 0 as auto rotation
    sector.setTextConfig({
      rotation: 0
    });
    return;
  }

  var shape = sector.shape;
  var startAngle = shape.clockwise ? shape.startAngle : shape.endAngle;
  var endAngle = shape.clockwise ? shape.endAngle : shape.startAngle;
  var middleAngle = (startAngle + endAngle) / 2;
  var anchorAngle;
  var mappedSectorPosition = positionMapping(textPosition);

  switch (mappedSectorPosition) {
    case 'startArc':
    case 'insideStartArc':
    case 'middle':
    case 'insideEndArc':
    case 'endArc':
      anchorAngle = middleAngle;
      break;

    case 'startAngle':
    case 'insideStartAngle':
      anchorAngle = startAngle;
      break;

    case 'endAngle':
    case 'insideEndAngle':
      anchorAngle = endAngle;
      break;

    default:
      sector.setTextConfig({
        rotation: 0
      });
      return;
  }

  var rotate = Math.PI * 1.5 - anchorAngle;
  /**
   * TODO: labels with rotate > Math.PI / 2 should be rotate another
   * half round flipped to increase readability. However, only middle
   * position supports this for now, because in other positions, the
   * anchor point is not at the center of the text, so the positions
   * after rotating is not as expected.
   */

  if (mappedSectorPosition === 'middle' && rotate > Math.PI / 2 && rotate < Math.PI * 1.5) {
    rotate -= Math.PI;
  }

  sector.setTextConfig({
    rotation: rotate
  });
}

function adjustAngleDistanceX(angle, distance, isEnd) {
  return distance * Math.sin(angle) * (isEnd ? -1 : 1);
}

function adjustAngleDistanceY(angle, distance, isEnd) {
  return distance * Math.cos(angle) * (isEnd ? 1 : -1);
}

var mathMax$1 = Math.max;
var mathMin$1 = Math.min;

function getClipArea(coord, data) {
  var coordSysClipArea = coord.getArea && coord.getArea();

  if (isCoordinateSystemType(coord, 'cartesian2d')) {
    var baseAxis = coord.getBaseAxis(); // When boundaryGap is false or using time axis. bar may exceed the grid.
    // We should not clip this part.
    // See test/bar2.html

    if (baseAxis.type !== 'category' || !baseAxis.onBand) {
      var expandWidth = data.getLayout('bandWidth');

      if (baseAxis.isHorizontal()) {
        coordSysClipArea.x -= expandWidth;
        coordSysClipArea.width += expandWidth * 2;
      } else {
        coordSysClipArea.y -= expandWidth;
        coordSysClipArea.height += expandWidth * 2;
      }
    }
  }

  return coordSysClipArea;
}

var BarView =
/** @class */
function (_super) {
  __extends$1(BarView, _super);

  function BarView() {
    var _this = _super.call(this) || this;

    _this.type = BarView.type;
    _this._isFirstFrame = true;
    return _this;
  }

  BarView.prototype.render = function (seriesModel, ecModel, api, payload) {
    this._model = seriesModel;

    this._removeOnRenderedListener(api);

    this._updateDrawMode(seriesModel);

    var coordinateSystemType = seriesModel.get('coordinateSystem');

    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {
      // Clear previously rendered progressive elements.
      this._progressiveEls = null;
      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);
    } else if (process.env.NODE_ENV !== 'production') {
      warn('Only cartesian2d and polar supported for bar.');
    }
  };

  BarView.prototype.incrementalPrepareRender = function (seriesModel) {
    this._clear();

    this._updateDrawMode(seriesModel); // incremental also need to clip, otherwise might be overlow.
    // But must not set clip in each frame, otherwise all of the children will be marked redraw.


    this._updateLargeClip(seriesModel);
  };

  BarView.prototype.incrementalRender = function (params, seriesModel) {
    // Reset
    this._progressiveEls = []; // Do not support progressive in normal mode.

    this._incrementalRenderLarge(params, seriesModel);
  };

  BarView.prototype.eachRendered = function (cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };

  BarView.prototype._updateDrawMode = function (seriesModel) {
    var isLargeDraw = seriesModel.pipelineContext.large;

    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;

      this._clear();
    }
  };

  BarView.prototype._renderNormal = function (seriesModel, ecModel, api, payload) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var coord = seriesModel.coordinateSystem;
    var baseAxis = coord.getBaseAxis();
    var isHorizontalOrRadial;

    if (coord.type === 'cartesian2d') {
      isHorizontalOrRadial = baseAxis.isHorizontal();
    } else if (coord.type === 'polar') {
      isHorizontalOrRadial = baseAxis.dim === 'angle';
    }

    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
    var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);

    if (realtimeSortCfg) {
      this._enableRealtimeSort(realtimeSortCfg, data, api);
    }

    var needsClip = seriesModel.get('clip', true) || realtimeSortCfg;
    var coordSysClipArea = getClipArea(coord, data); // If there is clipPath created in large mode. Remove it.

    group.removeClipPath(); // We don't use clipPath in normal mode because we needs a perfect animation
    // And don't want the label are clipped.

    var roundCap = seriesModel.get('roundCap', true);
    var drawBackground = seriesModel.get('showBackground', true);
    var backgroundModel = seriesModel.getModel('backgroundStyle');
    var barBorderRadius = backgroundModel.get('borderRadius') || 0;
    var bgEls = [];
    var oldBgEls = this._backgroundEls;
    var isInitSort = payload && payload.isInitSort;
    var isChangeOrder = payload && payload.type === 'changeAxisOrder';

    function createBackground(dataIndex) {
      var bgLayout = getLayout[coord.type](data, dataIndex);
      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
      bgEl.useStyle(backgroundModel.getItemStyle()); // Only cartesian2d support borderRadius.

      if (coord.type === 'cartesian2d') {
        bgEl.setShape('r', barBorderRadius);
      }

      bgEls[dataIndex] = bgEl;
      return bgEl;
    }
    data.diff(oldData).add(function (dataIndex) {
      var itemModel = data.getItemModel(dataIndex);
      var layout = getLayout[coord.type](data, dataIndex, itemModel);

      if (drawBackground) {
        createBackground(dataIndex);
      } // If dataZoom in filteMode: 'empty', the baseValue can be set as NaN in "axisProxy".


      if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout)) {
        return;
      }

      var isClipped = false;

      if (needsClip) {
        // Clip will modify the layout params.
        // And return a boolean to determine if the shape are fully clipped.
        isClipped = clip[coord.type](coordSysClipArea, layout);
      }

      var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);

      if (realtimeSortCfg) {
        /**
         * Force label animation because even if the element is
         * ignored because it's clipped, it may not be clipped after
         * changing order. Then, if not using forceLabelAnimation,
         * the label animation was never started, in which case,
         * the label will be the final value and doesn't have label
         * animation.
         */
        el.forceLabelAnimation = true;
      }

      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');

      if (isInitSort) {
        el.attr({
          shape: layout
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, dataIndex, isHorizontalOrRadial, false, false);
      } else {
        initProps(el, {
          shape: layout
        }, seriesModel, dataIndex);
      }

      data.setItemGraphicEl(dataIndex, el);
      group.add(el);
      el.ignore = isClipped;
    }).update(function (newIndex, oldIndex) {
      var itemModel = data.getItemModel(newIndex);
      var layout = getLayout[coord.type](data, newIndex, itemModel);

      if (drawBackground) {
        var bgEl = void 0;

        if (oldBgEls.length === 0) {
          bgEl = createBackground(oldIndex);
        } else {
          bgEl = oldBgEls[oldIndex];
          bgEl.useStyle(backgroundModel.getItemStyle()); // Only cartesian2d support borderRadius.

          if (coord.type === 'cartesian2d') {
            bgEl.setShape('r', barBorderRadius);
          }

          bgEls[newIndex] = bgEl;
        }

        var bgLayout = getLayout[coord.type](data, newIndex);
        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
        updateProps$1(bgEl, {
          shape: shape
        }, animationModel, newIndex);
      }

      var el = oldData.getItemGraphicEl(oldIndex);

      if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout)) {
        group.remove(el);
        return;
      }

      var isClipped = false;

      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout);

        if (isClipped) {
          group.remove(el);
        }
      }

      if (!el) {
        el = elementCreator[coord.type](seriesModel, data, newIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);
      } else {
        saveOldStyle(el);
      }

      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }

      if (isChangeOrder) {
        var textEl = el.getTextContent();

        if (textEl) {
          var labelInnerStore = labelInner(textEl);

          if (labelInnerStore.prevValue != null) {
            /**
             * Set preValue to be value so that no new label
             * should be started, otherwise, it will take a full
             * `animationDurationUpdate` time to finish the
             * animation, which is not expected.
             */
            labelInnerStore.prevValue = labelInnerStore.value;
          }
        }
      } // Not change anything if only order changed.
      // Especially not change label.
      else {
          updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
        }

      if (isInitSort) {
        el.attr({
          shape: layout
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, newIndex, isHorizontalOrRadial, true, isChangeOrder);
      } else {
        updateProps$1(el, {
          shape: layout
        }, seriesModel, newIndex, null);
      }

      data.setItemGraphicEl(newIndex, el);
      el.ignore = isClipped;
      group.add(el);
    }).remove(function (dataIndex) {
      var el = oldData.getItemGraphicEl(dataIndex);
      el && removeElementWithFadeOut(el, seriesModel, dataIndex);
    }).execute();
    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group$3());
    bgGroup.removeAll();

    for (var i = 0; i < bgEls.length; ++i) {
      bgGroup.add(bgEls[i]);
    }

    group.add(bgGroup);
    this._backgroundEls = bgEls;
    this._data = data;
  };

  BarView.prototype._renderLarge = function (seriesModel, ecModel, api) {
    this._clear();

    createLarge(seriesModel, this.group);

    this._updateLargeClip(seriesModel);
  };

  BarView.prototype._incrementalRenderLarge = function (params, seriesModel) {
    this._removeBackground();

    createLarge(seriesModel, this.group, this._progressiveEls, true);
  };

  BarView.prototype._updateLargeClip = function (seriesModel) {
    // Use clipPath in large mode.
    var clipPath = seriesModel.get('clip', true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
    var group = this.group;

    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
  };

  BarView.prototype._enableRealtimeSort = function (realtimeSortCfg, data, api) {
    var _this = this; // If no data in the first frame, wait for data to initSort


    if (!data.count()) {
      return;
    }

    var baseAxis = realtimeSortCfg.baseAxis;

    if (this._isFirstFrame) {
      this._dispatchInitSort(data, realtimeSortCfg, api);

      this._isFirstFrame = false;
    } else {
      var orderMapping_1 = function (idx) {
        var el = data.getItemGraphicEl(idx);
        var shape = el && el.shape;
        return shape && // The result should be consistent with the initial sort by data value.
        // Do not support the case that both positive and negative exist.
        Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width) // If data is NaN, shape.xxx may be NaN, so use || 0 here in case
        || 0;
      };

      this._onRendered = function () {
        _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);
      };

      api.getZr().on('rendered', this._onRendered);
    }
  };

  BarView.prototype._dataSort = function (data, baseAxis, orderMapping) {
    var info = [];
    data.each(data.mapDimension(baseAxis.dim), function (ordinalNumber, dataIdx) {
      var mappedValue = orderMapping(dataIdx);
      mappedValue = mappedValue == null ? NaN : mappedValue;
      info.push({
        dataIndex: dataIdx,
        mappedValue: mappedValue,
        ordinalNumber: ordinalNumber
      });
    });
    info.sort(function (a, b) {
      // If NaN, it will be treated as min val.
      return b.mappedValue - a.mappedValue;
    });
    return {
      ordinalNumbers: map$1(info, function (item) {
        return item.ordinalNumber;
      })
    };
  };

  BarView.prototype._isOrderChangedWithinSameData = function (data, orderMapping, baseAxis) {
    var scale = baseAxis.scale;
    var ordinalDataDim = data.mapDimension(baseAxis.dim);
    var lastValue = Number.MAX_VALUE;

    for (var tickNum = 0, len = scale.getOrdinalMeta().categories.length; tickNum < len; ++tickNum) {
      var rawIdx = data.rawIndexOf(ordinalDataDim, scale.getRawOrdinalNumber(tickNum));
      var value = rawIdx < 0 // If some tick have no bar, the tick will be treated as min.
      ? Number.MIN_VALUE // PENDING: if dataZoom on baseAxis exits, is it a performance issue?
      : orderMapping(data.indexOfRawIndex(rawIdx));

      if (value > lastValue) {
        return true;
      }

      lastValue = value;
    }

    return false;
  };
  /*
   * Consider the case when A and B changed order, whose representing
   * bars are both out of sight, we don't wish to trigger reorder action
   * as long as the order in the view doesn't change.
   */


  BarView.prototype._isOrderDifferentInView = function (orderInfo, baseAxis) {
    var scale = baseAxis.scale;
    var extent = scale.getExtent();
    var tickNum = Math.max(0, extent[0]);
    var tickMax = Math.min(extent[1], scale.getOrdinalMeta().categories.length - 1);

    for (; tickNum <= tickMax; ++tickNum) {
      if (orderInfo.ordinalNumbers[tickNum] !== scale.getRawOrdinalNumber(tickNum)) {
        return true;
      }
    }
  };

  BarView.prototype._updateSortWithinSameData = function (data, orderMapping, baseAxis, api) {
    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {
      return;
    }

    var sortInfo = this._dataSort(data, baseAxis, orderMapping);

    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
      this._removeOnRenderedListener(api);

      api.dispatchAction({
        type: 'changeAxisOrder',
        componentType: baseAxis.dim + 'Axis',
        axisId: baseAxis.index,
        sortInfo: sortInfo
      });
    }
  };

  BarView.prototype._dispatchInitSort = function (data, realtimeSortCfg, api) {
    var baseAxis = realtimeSortCfg.baseAxis;

    var sortResult = this._dataSort(data, baseAxis, function (dataIdx) {
      return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);
    });

    api.dispatchAction({
      type: 'changeAxisOrder',
      componentType: baseAxis.dim + 'Axis',
      isInitSort: true,
      axisId: baseAxis.index,
      sortInfo: sortResult
    });
  };

  BarView.prototype.remove = function (ecModel, api) {
    this._clear(this._model);

    this._removeOnRenderedListener(api);
  };

  BarView.prototype.dispose = function (ecModel, api) {
    this._removeOnRenderedListener(api);
  };

  BarView.prototype._removeOnRenderedListener = function (api) {
    if (this._onRendered) {
      api.getZr().off('rendered', this._onRendered);
      this._onRendered = null;
    }
  };

  BarView.prototype._clear = function (model) {
    var group = this.group;
    var data = this._data;

    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
      this._removeBackground();

      this._backgroundEls = [];
      data.eachItemGraphicEl(function (el) {
        removeElementWithFadeOut(el, model, getECData(el).dataIndex);
      });
    } else {
      group.removeAll();
    }

    this._data = null;
    this._isFirstFrame = true;
  };

  BarView.prototype._removeBackground = function () {
    this.group.remove(this._backgroundGroup);
    this._backgroundGroup = null;
  };

  BarView.type = 'bar';
  return BarView;
}(ChartView$1);

var clip = {
  cartesian2d: function (coordSysBoundingRect, layout) {
    var signWidth = layout.width < 0 ? -1 : 1;
    var signHeight = layout.height < 0 ? -1 : 1; // Needs positive width and height

    if (signWidth < 0) {
      layout.x += layout.width;
      layout.width = -layout.width;
    }

    if (signHeight < 0) {
      layout.y += layout.height;
      layout.height = -layout.height;
    }

    var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;
    var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;
    var x = mathMax$1(layout.x, coordSysBoundingRect.x);
    var x2 = mathMin$1(layout.x + layout.width, coordSysX2);
    var y = mathMax$1(layout.y, coordSysBoundingRect.y);
    var y2 = mathMin$1(layout.y + layout.height, coordSysY2);
    var xClipped = x2 < x;
    var yClipped = y2 < y; // When xClipped or yClipped, the element will be marked as `ignore`.
    // But we should also place the element at the edge of the coord sys bounding rect.
    // Beause if data changed and the bar show again, its transition animaiton
    // will begin at this place.

    layout.x = xClipped && x > coordSysX2 ? x2 : x;
    layout.y = yClipped && y > coordSysY2 ? y2 : y;
    layout.width = xClipped ? 0 : x2 - x;
    layout.height = yClipped ? 0 : y2 - y; // Reverse back

    if (signWidth < 0) {
      layout.x += layout.width;
      layout.width = -layout.width;
    }

    if (signHeight < 0) {
      layout.y += layout.height;
      layout.height = -layout.height;
    }

    return xClipped || yClipped;
  },
  polar: function (coordSysClipArea, layout) {
    var signR = layout.r0 <= layout.r ? 1 : -1; // Make sure r is larger than r0

    if (signR < 0) {
      var tmp = layout.r;
      layout.r = layout.r0;
      layout.r0 = tmp;
    }

    var r = mathMin$1(layout.r, coordSysClipArea.r);
    var r0 = mathMax$1(layout.r0, coordSysClipArea.r0);
    layout.r = r;
    layout.r0 = r0;
    var clipped = r - r0 < 0; // Reverse back

    if (signR < 0) {
      var tmp = layout.r;
      layout.r = layout.r0;
      layout.r0 = tmp;
    }

    return clipped;
  }
};
var elementCreator = {
  cartesian2d: function (seriesModel, data, newIndex, layout, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
    var rect = new Rect$1({
      shape: extend$2({}, layout),
      z2: 1
    });
    rect.__dataIndex = newIndex;
    rect.name = 'item';

    if (animationModel) {
      var rectShape = rect.shape;
      var animateProperty = isHorizontal ? 'height' : 'width';
      rectShape[animateProperty] = 0;
    }

    return rect;
  },
  polar: function (seriesModel, data, newIndex, layout, isRadial, animationModel, axisModel, isUpdate, roundCap) {
    var ShapeClass = !isRadial && roundCap ? Sausage : Sector$1;
    var sector = new ShapeClass({
      shape: layout,
      z2: 1
    });
    sector.name = 'item';
    var positionMap = createPolarPositionMapping(isRadial);
    sector.calculateTextPosition = createSectorCalculateTextPosition(positionMap, {
      isRoundCap: ShapeClass === Sausage
    }); // Animation

    if (animationModel) {
      var sectorShape = sector.shape;
      var animateProperty = isRadial ? 'r' : 'endAngle';
      var animateTarget = {};
      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;
      animateTarget[animateProperty] = layout[animateProperty];
      (isUpdate ? updateProps$1 : initProps)(sector, {
        shape: animateTarget // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue

      }, animationModel);
    }

    return sector;
  }
};

function shouldRealtimeSort(seriesModel, coordSys) {
  var realtimeSortOption = seriesModel.get('realtimeSort', true);
  var baseAxis = coordSys.getBaseAxis();

  if (process.env.NODE_ENV !== 'production') {
    if (realtimeSortOption) {
      if (baseAxis.type !== 'category') {
        warn('`realtimeSort` will not work because this bar series is not based on a category axis.');
      }

      if (coordSys.type !== 'cartesian2d') {
        warn('`realtimeSort` will not work because this bar series is not on cartesian2d.');
      }
    }
  }

  if (realtimeSortOption && baseAxis.type === 'category' && coordSys.type === 'cartesian2d') {
    return {
      baseAxis: baseAxis,
      otherAxis: coordSys.getOtherAxis(baseAxis)
    };
  }
}

function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout, newIndex, isHorizontal, isUpdate, isChangeOrder) {
  var seriesTarget;
  var axisTarget;

  if (isHorizontal) {
    axisTarget = {
      x: layout.x,
      width: layout.width
    };
    seriesTarget = {
      y: layout.y,
      height: layout.height
    };
  } else {
    axisTarget = {
      y: layout.y,
      height: layout.height
    };
    seriesTarget = {
      x: layout.x,
      width: layout.width
    };
  }

  if (!isChangeOrder) {
    // Keep the original growth animation if only axis order changed.
    // Not start a new animation.
    (isUpdate ? updateProps$1 : initProps)(el, {
      shape: seriesTarget
    }, seriesAnimationModel, newIndex, null);
  }

  var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
  (isUpdate ? updateProps$1 : initProps)(el, {
    shape: axisTarget
  }, axisAnimationModel, newIndex);
}

function checkPropertiesNotValid(obj, props) {
  for (var i = 0; i < props.length; i++) {
    if (!isFinite(obj[props[i]])) {
      return true;
    }
  }

  return false;
}

var rectPropties = ['x', 'y', 'width', 'height'];
var polarPropties = ['cx', 'cy', 'r', 'startAngle', 'endAngle'];
var isValidLayout = {
  cartesian2d: function (layout) {
    return !checkPropertiesNotValid(layout, rectPropties);
  },
  polar: function (layout) {
    return !checkPropertiesNotValid(layout, polarPropties);
  }
};
var getLayout = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function (data, dataIndex, itemModel) {
    var layout = data.getItemLayout(dataIndex);
    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0; // fix layout with lineWidth

    var signX = layout.width > 0 ? 1 : -1;
    var signY = layout.height > 0 ? 1 : -1;
    return {
      x: layout.x + signX * fixedLineWidth / 2,
      y: layout.y + signY * fixedLineWidth / 2,
      width: layout.width - signX * fixedLineWidth,
      height: layout.height - signY * fixedLineWidth
    };
  },
  polar: function (data, dataIndex, itemModel) {
    var layout = data.getItemLayout(dataIndex);
    return {
      cx: layout.cx,
      cy: layout.cy,
      r0: layout.r0,
      r: layout.r,
      startAngle: layout.startAngle,
      endAngle: layout.endAngle,
      clockwise: layout.clockwise
    };
  }
};

function isZeroOnPolar(layout) {
  return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;
}

function createPolarPositionMapping(isRadial) {
  return function (isRadial) {
    var arcOrAngle = isRadial ? 'Arc' : 'Angle';
    return function (position) {
      switch (position) {
        case 'start':
        case 'insideStart':
        case 'end':
        case 'insideEnd':
          return position + arcOrAngle;

        default:
          return position;
      }
    };
  }(isRadial);
}

function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, isPolar) {
  var style = data.getItemVisual(dataIndex, 'style');

  if (!isPolar) {
    el.setShape('r', itemModel.get(['itemStyle', 'borderRadius']) || 0);
  }

  el.useStyle(style);
  var cursorStyle = itemModel.getShallow('cursor');
  cursorStyle && el.attr('cursor', cursorStyle);
  var labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout.r >= layout.r0 ? 'endArc' : 'startArc' : layout.endAngle >= layout.startAngle ? 'endAngle' : 'startAngle' : isHorizontalOrRadial ? layout.height >= 0 ? 'bottom' : 'top' : layout.width >= 0 ? 'right' : 'left';
  var labelStatesModels = getLabelStatesModels(itemModel);
  setLabelStyle(el, labelStatesModels, {
    labelFetcher: seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
    inheritColor: style.fill,
    defaultOpacity: style.opacity,
    defaultOutsidePosition: labelPositionOutside
  });
  var label = el.getTextContent();

  if (isPolar && label) {
    var position = itemModel.get(['label', 'position']);
    el.textConfig.inside = position === 'middle' ? true : null;
    setSectorTextRotation(el, position === 'outside' ? labelPositionOutside : position, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(['label', 'rotate']));
  }

  setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function (value) {
    return getDefaultInterpolatedLabel(data, value);
  });
  var emphasisModel = itemModel.getModel(['emphasis']);
  toggleHoverEmphasis(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));
  setStatesStylesFromModel(el, itemModel);

  if (isZeroOnPolar(layout)) {
    el.style.fill = 'none';
    el.style.stroke = 'none';
    each$9(el.states, function (state) {
      if (state.style) {
        state.style.fill = state.style.stroke = 'none';
      }
    });
  }
} // In case width or height are too small.


function getLineWidth(itemModel, rawLayout) {
  // Has no border.
  var borderColor = itemModel.get(['itemStyle', 'borderColor']);

  if (!borderColor || borderColor === 'none') {
    return 0;
  }

  var lineWidth = itemModel.get(['itemStyle', 'borderWidth']) || 0; // width or height may be NaN for empty data

  var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
  var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
  return Math.min(lineWidth, width, height);
}

var LagePathShape =
/** @class */
function () {
  function LagePathShape() {}

  return LagePathShape;
}();

var LargePath =
/** @class */
function (_super) {
  __extends$1(LargePath, _super);

  function LargePath(opts) {
    var _this = _super.call(this, opts) || this;

    _this.type = 'largeBar';
    return _this;
  }

  LargePath.prototype.getDefaultShape = function () {
    return new LagePathShape();
  };

  LargePath.prototype.buildPath = function (ctx, shape) {
    // Drawing lines is more efficient than drawing
    // a whole line or drawing rects.
    var points = shape.points;
    var baseDimIdx = this.baseDimIdx;
    var valueDimIdx = 1 - this.baseDimIdx;
    var startPoint = [];
    var size = [];
    var barWidth = this.barWidth;

    for (var i = 0; i < points.length; i += 3) {
      size[baseDimIdx] = barWidth;
      size[valueDimIdx] = points[i + 2];
      startPoint[baseDimIdx] = points[i + baseDimIdx];
      startPoint[valueDimIdx] = points[i + valueDimIdx];
      ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);
    }
  };

  return LargePath;
}(Path$1);

function createLarge(seriesModel, group, progressiveEls, incremental) {
  // TODO support polar
  var data = seriesModel.getData();
  var baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;
  var largeDataIndices = data.getLayout('largeDataIndices');
  var barWidth = data.getLayout('size');
  var backgroundModel = seriesModel.getModel('backgroundStyle');
  var bgPoints = data.getLayout('largeBackgroundPoints');

  if (bgPoints) {
    var bgEl = new LargePath({
      shape: {
        points: bgPoints
      },
      incremental: !!incremental,
      silent: true,
      z2: 0
    });
    bgEl.baseDimIdx = baseDimIdx;
    bgEl.largeDataIndices = largeDataIndices;
    bgEl.barWidth = barWidth;
    bgEl.useStyle(backgroundModel.getItemStyle());
    group.add(bgEl);
    progressiveEls && progressiveEls.push(bgEl);
  }

  var el = new LargePath({
    shape: {
      points: data.getLayout('largePoints')
    },
    incremental: !!incremental,
    ignoreCoarsePointer: true,
    z2: 1
  });
  el.baseDimIdx = baseDimIdx;
  el.largeDataIndices = largeDataIndices;
  el.barWidth = barWidth;
  group.add(el);
  el.useStyle(data.getVisual('style')); // Enable tooltip and user mouse/touch event handlers.

  getECData(el).seriesIndex = seriesModel.seriesIndex;

  if (!seriesModel.get('silent')) {
    el.on('mousedown', largePathUpdateDataIndex);
    el.on('mousemove', largePathUpdateDataIndex);
  }

  progressiveEls && progressiveEls.push(el);
} // Use throttle to avoid frequently traverse to find dataIndex.


var largePathUpdateDataIndex = throttle(function (event) {
  var largePath = this;
  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
  getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
}, 30, false);

function largePathFindDataIndex(largePath, x, y) {
  var baseDimIdx = largePath.baseDimIdx;
  var valueDimIdx = 1 - baseDimIdx;
  var points = largePath.shape.points;
  var largeDataIndices = largePath.largeDataIndices;
  var startPoint = [];
  var size = [];
  var barWidth = largePath.barWidth;

  for (var i = 0, len = points.length / 3; i < len; i++) {
    var ii = i * 3;
    size[baseDimIdx] = barWidth;
    size[valueDimIdx] = points[ii + 2];
    startPoint[baseDimIdx] = points[ii + baseDimIdx];
    startPoint[valueDimIdx] = points[ii + valueDimIdx];

    if (size[valueDimIdx] < 0) {
      startPoint[valueDimIdx] += size[valueDimIdx];
      size[valueDimIdx] = -size[valueDimIdx];
    }

    if (x >= startPoint[0] && x <= startPoint[0] + size[0] && y >= startPoint[1] && y <= startPoint[1] + size[1]) {
      return largeDataIndices[i];
    }
  }

  return -1;
}

function createBackgroundShape(isHorizontalOrRadial, layout, coord) {
  if (isCoordinateSystemType(coord, 'cartesian2d')) {
    var rectShape = layout;
    var coordLayout = coord.getArea();
    return {
      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
    };
  } else {
    var coordLayout = coord.getArea();
    var sectorShape = layout;
    return {
      cx: coordLayout.cx,
      cy: coordLayout.cy,
      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
    };
  }
}

function createBackgroundEl(coord, isHorizontalOrRadial, layout) {
  var ElementClz = coord.type === 'polar' ? Sector$1 : Rect$1;
  return new ElementClz({
    shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),
    silent: true,
    z2: 0
  });
}

var BarView$1 = BarView;

function install$h(registers) {
  registers.registerChartView(BarView$1);
  registers.registerSeriesModel(BarSeries);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry$1(layout$1, 'bar')); // Do layout after other overall layout, which can preapre some informations.

  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout('bar')); // Down sample after filter

  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample('bar'));
  /**
   * @payload
   * @property {string} [componentType=series]
   * @property {number} [dx]
   * @property {number} [dy]
   * @property {number} [zoom]
   * @property {number} [originX]
   * @property {number} [originY]
   */

  registers.registerAction({
    type: 'changeAxisOrder',
    event: 'changeAxisOrder',
    update: 'update'
  }, function (payload, ecModel) {
    var componentType = payload.componentType || 'series';
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function (componentModel) {
      if (payload.sortInfo) {
        componentModel.axis.setCategorySortInfo(payload.sortInfo);
      }
    });
  });
}

var PI2 = Math.PI * 2;
var RADIAN$1 = Math.PI / 180;

function getViewRect(seriesModel, api) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}

function getBasicPieLayout(seriesModel, api) {
  var viewRect = getViewRect(seriesModel, api);
  var center = seriesModel.get('center');
  var radius = seriesModel.get('radius');

  if (!isArray$1(radius)) {
    radius = [0, radius];
  }

  if (!isArray$1(center)) {
    center = [center, center];
  }

  var width = parsePercent(viewRect.width, api.getWidth());
  var height = parsePercent(viewRect.height, api.getHeight());
  var size = Math.min(width, height);
  var r0 = parsePercent(radius[0], size / 2);
  var r = parsePercent(radius[1], size / 2);
  var cx;
  var cy;
  var coordSys = seriesModel.coordinateSystem;

  if (coordSys) {
    // percentage is not allowed when coordinate system is specified
    var point = coordSys.dataToPoint(center);
    cx = point[0] || 0;
    cy = point[1] || 0;
  } else {
    cx = parsePercent(center[0], width) + viewRect.x;
    cy = parsePercent(center[1], height) + viewRect.y;
  }

  return {
    cx: cx,
    cy: cy,
    r0: r0,
    r: r
  };
}
function pieLayout(seriesType, ecModel, api) {
  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
    var data = seriesModel.getData();
    var valueDim = data.mapDimension('value');
    var viewRect = getViewRect(seriesModel, api);

    var _a = getBasicPieLayout(seriesModel, api),
        cx = _a.cx,
        cy = _a.cy,
        r = _a.r,
        r0 = _a.r0;

    var startAngle = -seriesModel.get('startAngle') * RADIAN$1;
    var minAngle = seriesModel.get('minAngle') * RADIAN$1;
    var validDataCount = 0;
    data.each(valueDim, function (value) {
      !isNaN(value) && validDataCount++;
    });
    var sum = data.getSum(valueDim); // Sum may be 0

    var unitRadian = Math.PI / (sum || validDataCount) * 2;
    var clockwise = seriesModel.get('clockwise');
    var roseType = seriesModel.get('roseType');
    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]

    var extent = data.getDataExtent(valueDim);
    extent[0] = 0; // In the case some sector angle is smaller than minAngle

    var restAngle = PI2;
    var valueSumLargerThanMinAngle = 0;
    var currentAngle = startAngle;
    var dir = clockwise ? 1 : -1;
    data.setLayout({
      viewRect: viewRect,
      r: r
    });
    data.each(valueDim, function (value, idx) {
      var angle;

      if (isNaN(value)) {
        data.setItemLayout(idx, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: clockwise,
          cx: cx,
          cy: cy,
          r0: r0,
          r: roseType ? NaN : r
        });
        return;
      } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？


      if (roseType !== 'area') {
        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
      } else {
        angle = PI2 / validDataCount;
      }

      if (angle < minAngle) {
        angle = minAngle;
        restAngle -= minAngle;
      } else {
        valueSumLargerThanMinAngle += value;
      }

      var endAngle = currentAngle + dir * angle;
      data.setItemLayout(idx, {
        angle: angle,
        startAngle: currentAngle,
        endAngle: endAngle,
        clockwise: clockwise,
        cx: cx,
        cy: cy,
        r0: r0,
        r: roseType ? linearMap$2(value, extent, [r0, r]) : r
      });
      currentAngle = endAngle;
    }); // Some sector is constrained by minAngle
    // Rest sectors needs recalculate angle

    if (restAngle < PI2 && validDataCount) {
      // Average the angle if rest angle is not enough after all angles is
      // Constrained by minAngle
      if (restAngle <= 1e-3) {
        var angle_1 = PI2 / validDataCount;
        data.each(valueDim, function (value, idx) {
          if (!isNaN(value)) {
            var layout_1 = data.getItemLayout(idx);
            layout_1.angle = angle_1;
            layout_1.startAngle = startAngle + dir * idx * angle_1;
            layout_1.endAngle = startAngle + dir * (idx + 1) * angle_1;
          }
        });
      } else {
        unitRadian = restAngle / valueSumLargerThanMinAngle;
        currentAngle = startAngle;
        data.each(valueDim, function (value, idx) {
          if (!isNaN(value)) {
            var layout_2 = data.getItemLayout(idx);
            var angle = layout_2.angle === minAngle ? minAngle : value * unitRadian;
            layout_2.startAngle = currentAngle;
            layout_2.endAngle = currentAngle + dir * angle;
            currentAngle += dir * angle;
          }
        });
      }
    }
  });
}

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function dataFilter(seriesType) {
  return {
    seriesType: seriesType,
    reset: function (seriesModel, ecModel) {
      var legendModels = ecModel.findComponents({
        mainType: 'legend'
      });

      if (!legendModels || !legendModels.length) {
        return;
      }

      var data = seriesModel.getData();
      data.filterSelf(function (idx) {
        var name = data.getName(idx); // If in any legend component the status is not selected.

        for (var i = 0; i < legendModels.length; i++) {
          // @ts-ignore FIXME: LegendModel
          if (!legendModels[i].isSelected(name)) {
            return false;
          }
        }

        return true;
      });
    }
  };
}

var RADIAN = Math.PI / 180;

function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
  if (list.length < 2) {
    return;
  }

  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {
    var rB = semi.rB;
    var rB2 = rB * rB;

    for (var i = 0; i < semi.list.length; i++) {
      var item = semi.list[i];
      var dy = Math.abs(item.label.y - cy); // horizontal r is always same with original r because x is not changed.

      var rA = r + item.len;
      var rA2 = rA * rA; // Use ellipse implicit function to calculate x

      var dx = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);
      var newX = cx + (dx + item.len2) * dir;
      var deltaX = newX - item.label.x;
      var newTargetWidth = item.targetTextWidth - deltaX * dir; // text x is changed, so need to recalculate width.

      constrainTextWidth(item, newTargetWidth, true);
      item.label.x = newX;
    }
  } // Adjust X based on the shifted y. Make tight labels aligned on an ellipse curve.


  function recalculateX(items) {
    // Extremes of
    var topSemi = {
      list: [],
      maxY: 0
    };
    var bottomSemi = {
      list: [],
      maxY: 0
    };

    for (var i = 0; i < items.length; i++) {
      if (items[i].labelAlignTo !== 'none') {
        continue;
      }

      var item = items[i];
      var semi = item.label.y > cy ? bottomSemi : topSemi;
      var dy = Math.abs(item.label.y - cy);

      if (dy >= semi.maxY) {
        var dx = item.label.x - cx - item.len2 * dir; // horizontal r is always same with original r because x is not changed.

        var rA = r + item.len; // Canculate rB based on the topest / bottemest label.

        var rB = Math.abs(dx) < rA ? Math.sqrt(dy * dy / (1 - dx * dx / rA / rA)) : rA;
        semi.rB = rB;
        semi.maxY = dy;
      }

      semi.list.push(item);
    }

    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);
    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);
  }

  var len = list.length;

  for (var i = 0; i < len; i++) {
    if (list[i].position === 'outer' && list[i].labelAlignTo === 'labelLine') {
      var dx = list[i].label.x - farthestX;
      list[i].linePoints[1][0] += dx;
      list[i].label.x = farthestX;
    }
  }

  if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {
    recalculateX(list);
  }
}

function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
  var leftList = [];
  var rightList = [];
  var leftmostX = Number.MAX_VALUE;
  var rightmostX = -Number.MAX_VALUE;

  for (var i = 0; i < labelLayoutList.length; i++) {
    var label = labelLayoutList[i].label;

    if (isPositionCenter(labelLayoutList[i])) {
      continue;
    }

    if (label.x < cx) {
      leftmostX = Math.min(leftmostX, label.x);
      leftList.push(labelLayoutList[i]);
    } else {
      rightmostX = Math.max(rightmostX, label.x);
      rightList.push(labelLayoutList[i]);
    }
  }

  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout = labelLayoutList[i];

    if (!isPositionCenter(layout) && layout.linePoints) {
      if (layout.labelStyleWidth != null) {
        continue;
      }

      var label = layout.label;
      var linePoints = layout.linePoints;
      var targetTextWidth = void 0;

      if (layout.labelAlignTo === 'edge') {
        if (label.x < cx) {
          targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.edgeDistance;
        } else {
          targetTextWidth = viewLeft + viewWidth - layout.edgeDistance - linePoints[2][0] - layout.labelDistance;
        }
      } else if (layout.labelAlignTo === 'labelLine') {
        if (label.x < cx) {
          targetTextWidth = leftmostX - viewLeft - layout.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - rightmostX - layout.bleedMargin;
        }
      } else {
        if (label.x < cx) {
          targetTextWidth = label.x - viewLeft - layout.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - label.x - layout.bleedMargin;
        }
      }

      layout.targetTextWidth = targetTextWidth;
      constrainTextWidth(layout, targetTextWidth);
    }
  }

  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);

  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout = labelLayoutList[i];

    if (!isPositionCenter(layout) && layout.linePoints) {
      var label = layout.label;
      var linePoints = layout.linePoints;
      var isAlignToEdge = layout.labelAlignTo === 'edge';
      var padding = label.style.padding;
      var paddingH = padding ? padding[1] + padding[3] : 0; // textRect.width already contains paddingH if bgColor is set

      var extraPaddingH = label.style.backgroundColor ? 0 : paddingH;
      var realTextWidth = layout.rect.width + extraPaddingH;
      var dist = linePoints[1][0] - linePoints[2][0];

      if (isAlignToEdge) {
        if (label.x < cx) {
          linePoints[2][0] = viewLeft + layout.edgeDistance + realTextWidth + layout.labelDistance;
        } else {
          linePoints[2][0] = viewLeft + viewWidth - layout.edgeDistance - realTextWidth - layout.labelDistance;
        }
      } else {
        if (label.x < cx) {
          linePoints[2][0] = label.x + layout.labelDistance;
        } else {
          linePoints[2][0] = label.x - layout.labelDistance;
        }

        linePoints[1][0] = linePoints[2][0] + dist;
      }

      linePoints[1][1] = linePoints[2][1] = label.y;
    }
  }
}
/**
 * Set max width of each label, and then wrap each label to the max width.
 *
 * @param layout label layout
 * @param availableWidth max width for the label to display
 * @param forceRecalculate recaculate the text layout even if the current width
 * is smaller than `availableWidth`. This is useful when the text was previously
 * wrapped by calling `constrainTextWidth` but now `availableWidth` changed, in
 * which case, previous wrapping should be redo.
 */


function constrainTextWidth(layout, availableWidth, forceRecalculate) {
  if (forceRecalculate === void 0) {
    forceRecalculate = false;
  }

  if (layout.labelStyleWidth != null) {
    // User-defined style.width has the highest priority.
    return;
  }

  var label = layout.label;
  var style = label.style;
  var textRect = layout.rect;
  var bgColor = style.backgroundColor;
  var padding = style.padding;
  var paddingH = padding ? padding[1] + padding[3] : 0;
  var overflow = style.overflow; // textRect.width already contains paddingH if bgColor is set

  var oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);

  if (availableWidth < oldOuterWidth || forceRecalculate) {
    var oldHeight = textRect.height;

    if (overflow && overflow.match('break')) {
      // Temporarily set background to be null to calculate
      // the bounding box without backgroud.
      label.setStyle('backgroundColor', null); // Set constraining width

      label.setStyle('width', availableWidth - paddingH); // This is the real bounding box of the text without padding

      var innerRect = label.getBoundingRect();
      label.setStyle('width', Math.ceil(innerRect.width));
      label.setStyle('backgroundColor', bgColor);
    } else {
      var availableInnerWidth = availableWidth - paddingH;
      var newWidth = availableWidth < oldOuterWidth // Current text is too wide, use `availableWidth` as max width.
      ? availableInnerWidth : // Current available width is enough, but the text may have
      // already been wrapped with a smaller available width.
      forceRecalculate ? availableInnerWidth > layout.unconstrainedWidth // Current available is larger than text width,
      // so don't constrain width (otherwise it may have
      // empty space in the background).
      ? null // Current available is smaller than text width, so
      // use the current available width as constraining
      // width.
      : availableInnerWidth : // Current available width is enough, so no need to
      // constrain.
      null;
      label.setStyle('width', newWidth);
    }

    var newRect = label.getBoundingRect();
    textRect.width = newRect.width;
    var margin = (label.style.margin || 0) + 2.1;
    textRect.height = newRect.height + margin;
    textRect.y -= (textRect.height - oldHeight) / 2;
  }
}

function isPositionCenter(sectorShape) {
  // Not change x for center label
  return sectorShape.position === 'center';
}

function pieLabelLayout(seriesModel) {
  var data = seriesModel.getData();
  var labelLayoutList = [];
  var cx;
  var cy;
  var hasLabelRotate = false;
  var minShowLabelRadian = (seriesModel.get('minShowLabelAngle') || 0) * RADIAN;
  var viewRect = data.getLayout('viewRect');
  var r = data.getLayout('r');
  var viewWidth = viewRect.width;
  var viewLeft = viewRect.x;
  var viewTop = viewRect.y;
  var viewHeight = viewRect.height;

  function setNotShow(el) {
    el.ignore = true;
  }

  function isLabelShown(label) {
    if (!label.ignore) {
      return true;
    }

    for (var key in label.states) {
      if (label.states[key].ignore === false) {
        return true;
      }
    }

    return false;
  }

  data.each(function (idx) {
    var sector = data.getItemGraphicEl(idx);
    var sectorShape = sector.shape;
    var label = sector.getTextContent();
    var labelLine = sector.getTextGuideLine();
    var itemModel = data.getItemModel(idx);
    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis

    var labelPosition = labelModel.get('position') || itemModel.get(['emphasis', 'label', 'position']);
    var labelDistance = labelModel.get('distanceToLabelLine');
    var labelAlignTo = labelModel.get('alignTo');
    var edgeDistance = parsePercent(labelModel.get('edgeDistance'), viewWidth);
    var bleedMargin = labelModel.get('bleedMargin');
    var labelLineModel = itemModel.getModel('labelLine');
    var labelLineLen = labelLineModel.get('length');
    labelLineLen = parsePercent(labelLineLen, viewWidth);
    var labelLineLen2 = labelLineModel.get('length2');
    labelLineLen2 = parsePercent(labelLineLen2, viewWidth);

    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
      each$9(label.states, setNotShow);
      each$9(labelLine.states, setNotShow);
      label.ignore = labelLine.ignore = true;
      return;
    }

    if (!isLabelShown(label)) {
      return;
    }

    var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;
    var nx = Math.cos(midAngle);
    var ny = Math.sin(midAngle);
    var textX;
    var textY;
    var linePoints;
    var textAlign;
    cx = sectorShape.cx;
    cy = sectorShape.cy;
    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';

    if (labelPosition === 'center') {
      textX = sectorShape.cx;
      textY = sectorShape.cy;
      textAlign = 'center';
    } else {
      var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;
      var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;
      textX = x1 + nx * 3;
      textY = y1 + ny * 3;

      if (!isLabelInside) {
        // For roseType
        var x2 = x1 + nx * (labelLineLen + r - sectorShape.r);
        var y2 = y1 + ny * (labelLineLen + r - sectorShape.r);
        var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;
        var y3 = y2;

        if (labelAlignTo === 'edge') {
          // Adjust textX because text align of edge is opposite
          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;
        } else {
          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);
        }

        textY = y3;
        linePoints = [[x1, y1], [x2, y2], [x3, y3]];
      }

      textAlign = isLabelInside ? 'center' : labelAlignTo === 'edge' ? nx > 0 ? 'right' : 'left' : nx > 0 ? 'left' : 'right';
    }

    var PI = Math.PI;
    var labelRotate = 0;
    var rotate = labelModel.get('rotate');

    if (isNumber(rotate)) {
      labelRotate = rotate * (PI / 180);
    } else if (labelPosition === 'center') {
      labelRotate = 0;
    } else if (rotate === 'radial' || rotate === true) {
      var radialAngle = nx < 0 ? -midAngle + PI : -midAngle;
      labelRotate = radialAngle;
    } else if (rotate === 'tangential' && labelPosition !== 'outside' && labelPosition !== 'outer') {
      var rad = Math.atan2(nx, ny);

      if (rad < 0) {
        rad = PI * 2 + rad;
      }

      var isDown = ny > 0;

      if (isDown) {
        rad = PI + rad;
      }

      labelRotate = rad - PI;
    }

    hasLabelRotate = !!labelRotate;
    label.x = textX;
    label.y = textY;
    label.rotation = labelRotate;
    label.setStyle({
      verticalAlign: 'middle'
    }); // Not sectorShape the inside label

    if (!isLabelInside) {
      var textRect = label.getBoundingRect().clone();
      textRect.applyTransform(label.getComputedTransform()); // Text has a default 1px stroke. Exclude this.

      var margin = (label.style.margin || 0) + 2.1;
      textRect.y -= margin / 2;
      textRect.height += margin;
      labelLayoutList.push({
        label: label,
        labelLine: labelLine,
        position: labelPosition,
        len: labelLineLen,
        len2: labelLineLen2,
        minTurnAngle: labelLineModel.get('minTurnAngle'),
        maxSurfaceAngle: labelLineModel.get('maxSurfaceAngle'),
        surfaceNormal: new Point$1(nx, ny),
        linePoints: linePoints,
        textAlign: textAlign,
        labelDistance: labelDistance,
        labelAlignTo: labelAlignTo,
        edgeDistance: edgeDistance,
        bleedMargin: bleedMargin,
        rect: textRect,
        unconstrainedWidth: textRect.width,
        labelStyleWidth: label.style.width
      });
    } else {
      label.setStyle({
        align: textAlign
      });
      var selectState = label.states.select;

      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }

    sector.setTextConfig({
      inside: isLabelInside
    });
  });

  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {
    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
  }

  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout = labelLayoutList[i];
    var label = layout.label;
    var labelLine = layout.labelLine;
    var notShowLabel = isNaN(label.x) || isNaN(label.y);

    if (label) {
      label.setStyle({
        align: layout.textAlign
      });

      if (notShowLabel) {
        each$9(label.states, setNotShow);
        label.ignore = true;
      }

      var selectState = label.states.select;

      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }

    if (labelLine) {
      var linePoints = layout.linePoints;

      if (notShowLabel || !linePoints) {
        each$9(labelLine.states, setNotShow);
        labelLine.ignore = true;
      } else {
        limitTurnAngle(linePoints, layout.minTurnAngle);
        limitSurfaceAngle(linePoints, layout.surfaceNormal, layout.maxSurfaceAngle);
        labelLine.setShape({
          points: linePoints
        }); // Set the anchor to the midpoint of sector

        label.__hostTarget.textGuideLineConfig = {
          anchor: new Point$1(linePoints[0][0], linePoints[0][1])
        };
      }
    }
  }
}

function getSectorCornerRadius(model, shape, zeroIfNull) {
  var cornerRadius = model.get('borderRadius');

  if (cornerRadius == null) {
    return zeroIfNull ? {
      cornerRadius: 0
    } : null;
  }

  if (!isArray$1(cornerRadius)) {
    cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius];
  }

  var dr = Math.abs(shape.r || 0 - shape.r0 || 0);
  return {
    cornerRadius: map$1(cornerRadius, function (cr) {
      return parsePercent$1(cr, dr);
    })
  };
}

/**
 * Piece of pie including Sector, Label, LabelLine
 */

var PiePiece =
/** @class */
function (_super) {
  __extends$1(PiePiece, _super);

  function PiePiece(data, idx, startAngle) {
    var _this = _super.call(this) || this;

    _this.z2 = 2;
    var text = new ZRText$1();

    _this.setTextContent(text);

    _this.updateData(data, idx, startAngle, true);

    return _this;
  }

  PiePiece.prototype.updateData = function (data, idx, startAngle, firstCreate) {
    var sector = this;
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var emphasisModel = itemModel.getModel('emphasis');
    var layout = data.getItemLayout(idx); // cornerRadius & innerCornerRadius doesn't exist in the item layout. Use `0` if null value is specified.
    // see `setItemLayout` in `pieLayout.ts`.

    var sectorShape = extend$2(getSectorCornerRadius(itemModel.getModel('itemStyle'), layout, true), layout); // Ignore NaN data.

    if (isNaN(sectorShape.startAngle)) {
      // Use NaN shape to avoid drawing shape.
      sector.setShape(sectorShape);
      return;
    }

    if (firstCreate) {
      sector.setShape(sectorShape);
      var animationType = seriesModel.getShallow('animationType');

      if (seriesModel.ecModel.ssr) {
        // Use scale animation in SSR mode(opacity?)
        // Because CSS SVG animation doesn't support very customized shape animation.
        initProps(sector, {
          scaleX: 0,
          scaleY: 0
        }, seriesModel, {
          dataIndex: idx,
          isFrom: true
        });
        sector.originX = sectorShape.cx;
        sector.originY = sectorShape.cy;
      } else if (animationType === 'scale') {
        sector.shape.r = layout.r0;
        initProps(sector, {
          shape: {
            r: layout.r
          }
        }, seriesModel, idx);
      } // Expansion
      else {
          if (startAngle != null) {
            sector.setShape({
              startAngle: startAngle,
              endAngle: startAngle
            });
            initProps(sector, {
              shape: {
                startAngle: layout.startAngle,
                endAngle: layout.endAngle
              }
            }, seriesModel, idx);
          } else {
            sector.shape.endAngle = layout.startAngle;
            updateProps$1(sector, {
              shape: {
                endAngle: layout.endAngle
              }
            }, seriesModel, idx);
          }
        }
    } else {
      saveOldStyle(sector); // Transition animation from the old shape

      updateProps$1(sector, {
        shape: sectorShape
      }, seriesModel, idx);
    }

    sector.useStyle(data.getItemVisual(idx, 'style'));
    setStatesStylesFromModel(sector, itemModel);
    var midAngle = (layout.startAngle + layout.endAngle) / 2;
    var offset = seriesModel.get('selectedOffset');
    var dx = Math.cos(midAngle) * offset;
    var dy = Math.sin(midAngle) * offset;
    var cursorStyle = itemModel.getShallow('cursor');
    cursorStyle && sector.attr('cursor', cursorStyle);

    this._updateLabel(seriesModel, data, idx);

    sector.ensureState('emphasis').shape = extend$2({
      r: layout.r + (emphasisModel.get('scale') ? emphasisModel.get('scaleSize') || 0 : 0)
    }, getSectorCornerRadius(emphasisModel.getModel('itemStyle'), layout));
    extend$2(sector.ensureState('select'), {
      x: dx,
      y: dy,
      shape: getSectorCornerRadius(itemModel.getModel(['select', 'itemStyle']), layout)
    });
    extend$2(sector.ensureState('blur'), {
      shape: getSectorCornerRadius(itemModel.getModel(['blur', 'itemStyle']), layout)
    });
    var labelLine = sector.getTextGuideLine();
    var labelText = sector.getTextContent();
    labelLine && extend$2(labelLine.ensureState('select'), {
      x: dx,
      y: dy
    }); // TODO: needs dx, dy in zrender?

    extend$2(labelText.ensureState('select'), {
      x: dx,
      y: dy
    });
    toggleHoverEmphasis(this, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));
  };

  PiePiece.prototype._updateLabel = function (seriesModel, data, idx) {
    var sector = this;
    var itemModel = data.getItemModel(idx);
    var labelLineModel = itemModel.getModel('labelLine');
    var style = data.getItemVisual(idx, 'style');
    var visualColor = style && style.fill;
    var visualOpacity = style && style.opacity;
    setLabelStyle(sector, getLabelStatesModels(itemModel), {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      defaultText: seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx)
    });
    var labelText = sector.getTextContent(); // Set textConfig on sector.

    sector.setTextConfig({
      // reset position, rotation
      position: null,
      rotation: null
    }); // Make sure update style on labelText after setLabelStyle.
    // Because setLabelStyle will replace a new style on it.

    labelText.attr({
      z2: 10
    });
    var labelPosition = seriesModel.get(['label', 'position']);

    if (labelPosition !== 'outside' && labelPosition !== 'outer') {
      sector.removeTextGuideLine();
    } else {
      var polyline = this.getTextGuideLine();

      if (!polyline) {
        polyline = new Polyline$1();
        this.setTextGuideLine(polyline);
      } // Default use item visual color


      setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {
        stroke: visualColor,
        opacity: retrieve3(labelLineModel.get(['lineStyle', 'opacity']), visualOpacity, 1)
      });
    }
  };

  return PiePiece;
}(Sector$1); // Pie view


var PieView =
/** @class */
function (_super) {
  __extends$1(PieView, _super);

  function PieView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.ignoreLabelLineUpdate = true;
    return _this;
  }

  PieView.prototype.render = function (seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    var startAngle; // First render

    if (!oldData && data.count() > 0) {
      var shape = data.getItemLayout(0);

      for (var s = 1; isNaN(shape && shape.startAngle) && s < data.count(); ++s) {
        shape = data.getItemLayout(s);
      }

      if (shape) {
        startAngle = shape.startAngle;
      }
    } // remove empty-circle if it exists


    if (this._emptyCircleSector) {
      group.remove(this._emptyCircleSector);
    } // when all data are filtered, show lightgray empty circle


    if (data.count() === 0 && seriesModel.get('showEmptyCircle')) {
      var sector = new Sector$1({
        shape: getBasicPieLayout(seriesModel, api)
      });
      sector.useStyle(seriesModel.getModel('emptyCircleStyle').getItemStyle());
      this._emptyCircleSector = sector;
      group.add(sector);
    }

    data.diff(oldData).add(function (idx) {
      var piePiece = new PiePiece(data, idx, startAngle);
      data.setItemGraphicEl(idx, piePiece);
      group.add(piePiece);
    }).update(function (newIdx, oldIdx) {
      var piePiece = oldData.getItemGraphicEl(oldIdx);
      piePiece.updateData(data, newIdx, startAngle);
      piePiece.off('click');
      group.add(piePiece);
      data.setItemGraphicEl(newIdx, piePiece);
    }).remove(function (idx) {
      var piePiece = oldData.getItemGraphicEl(idx);
      removeElementWithFadeOut(piePiece, seriesModel, idx);
    }).execute();
    pieLabelLayout(seriesModel); // Always use initial animation.

    if (seriesModel.get('animationTypeUpdate') !== 'expansion') {
      this._data = data;
    }
  };

  PieView.prototype.dispose = function () {};

  PieView.prototype.containPoint = function (point, seriesModel) {
    var data = seriesModel.getData();
    var itemLayout = data.getItemLayout(0);

    if (itemLayout) {
      var dx = point[0] - itemLayout.cx;
      var dy = point[1] - itemLayout.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  };

  PieView.type = 'pie';
  return PieView;
}(ChartView$1);

var PieView$1 = PieView;

/**
 * [Usage]:
 * (1)
 * createListSimply(seriesModel, ['value']);
 * (2)
 * createListSimply(seriesModel, {
 *     coordDimensions: ['value'],
 *     dimensionsCount: 5
 * });
 */

function createSeriesDataSimply(seriesModel, opt, nameList) {
  opt = isArray$1(opt) && {
    coordDimensions: opt
  } || extend$2({
    encodeDefine: seriesModel.getEncode()
  }, opt);
  var source = seriesModel.getSource();
  var dimensions = prepareSeriesDataSchema(source, opt).dimensions;
  var list = new SeriesData$1(dimensions, seriesModel);
  list.initData(source, nameList);
  return list;
}

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * LegendVisualProvider is an bridge that pick encoded color from data and
 * provide to the legend component.
 */
var LegendVisualProvider =
/** @class */
function () {
  function LegendVisualProvider( // Function to get data after filtered. It stores all the encoding info
  getDataWithEncodedVisual, // Function to get raw data before filtered.
  getRawData) {
    this._getDataWithEncodedVisual = getDataWithEncodedVisual;
    this._getRawData = getRawData;
  }

  LegendVisualProvider.prototype.getAllNames = function () {
    var rawData = this._getRawData(); // We find the name from the raw data. In case it's filtered by the legend component.
    // Normally, the name can be found in rawData, but can't be found in filtered data will display as gray.


    return rawData.mapArray(rawData.getName);
  };

  LegendVisualProvider.prototype.containName = function (name) {
    var rawData = this._getRawData();

    return rawData.indexOfName(name) >= 0;
  };

  LegendVisualProvider.prototype.indexOfName = function (name) {
    // Only get data when necessary.
    // Because LegendVisualProvider constructor may be new in the stage that data is not prepared yet.
    // Invoking Series#getData immediately will throw an error.
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();

    return dataWithEncodedVisual.indexOfName(name);
  };

  LegendVisualProvider.prototype.getItemVisual = function (dataIndex, key) {
    // Get encoded visual properties from final filtered data.
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();

    return dataWithEncodedVisual.getItemVisual(dataIndex, key);
  };

  return LegendVisualProvider;
}();

var LegendVisualProvider$1 = LegendVisualProvider;

var PieSeriesModel =
/** @class */
function (_super) {
  __extends$1(PieSeriesModel, _super);

  function PieSeriesModel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @overwrite
   */


  PieSeriesModel.prototype.init = function (option) {
    _super.prototype.init.apply(this, arguments); // Enable legend selection for each data item
    // Use a function instead of direct access because data reference may changed


    this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));

    this._defaultLabelLine(option);
  };
  /**
   * @overwrite
   */


  PieSeriesModel.prototype.mergeOption = function () {
    _super.prototype.mergeOption.apply(this, arguments);
  };
  /**
   * @overwrite
   */


  PieSeriesModel.prototype.getInitialData = function () {
    var data = createSeriesDataSimply(this, {
      coordDimensions: ['value'],
      encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
    });
    var valueList = [];
    data.each(data.mapDimension('value'), function (value) {
      valueList.push(value);
    });
    this.seats = getPercentSeats(valueList, data.hostModel.get('percentPrecision'));
    return data;
  };
  /**
   * @overwrite
   */


  PieSeriesModel.prototype.getDataParams = function (dataIndex) {
    var params = _super.prototype.getDataParams.call(this, dataIndex);

    params.percent = this.seats[dataIndex];
    params.$vars.push('percent');
    return params;
  };

  PieSeriesModel.prototype._defaultLabelLine = function (option) {
    // Extend labelLine emphasis
    defaultEmphasis(option, 'labelLine', ['show']);
    var labelLineNormalOpt = option.labelLine;
    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`

    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  };

  PieSeriesModel.type = 'series.pie';
  PieSeriesModel.defaultOption = {
    // zlevel: 0,
    z: 2,
    legendHoverLink: true,
    colorBy: 'data',
    // 默认全局居中
    center: ['50%', '50%'],
    radius: [0, '75%'],
    // 默认顺时针
    clockwise: true,
    startAngle: 90,
    // 最小角度改为0
    minAngle: 0,
    // If the angle of a sector less than `minShowLabelAngle`,
    // the label will not be displayed.
    minShowLabelAngle: 0,
    // 选中时扇区偏移量
    selectedOffset: 10,
    // 选择模式，默认关闭，可选single，multiple
    // selectedMode: false,
    // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
    // roseType: null,
    percentPrecision: 2,
    // If still show when all data zero.
    stillShowZeroSum: true,
    // cursor: null,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    width: null,
    height: null,
    label: {
      // color: 'inherit',
      // If rotate around circle
      rotate: 0,
      show: true,
      overflow: 'truncate',
      // 'outer', 'inside', 'center'
      position: 'outer',
      // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
      alignTo: 'none',
      // Closest distance between label and chart edge.
      // Works only position is 'outer' and alignTo is 'edge'.
      edgeDistance: '25%',
      // Works only position is 'outer' and alignTo is not 'edge'.
      bleedMargin: 10,
      // Distance between text and label line.
      distanceToLabelLine: 5 // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      // 默认使用全局文本样式，详见TEXTSTYLE
      // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数

    },
    // Enabled when label.normal.position is 'outer'
    labelLine: {
      show: true,
      // 引导线两段中的第一段长度
      length: 15,
      // 引导线两段中的第二段长度
      length2: 15,
      smooth: false,
      minTurnAngle: 90,
      maxSurfaceAngle: 90,
      lineStyle: {
        // color: 各异,
        width: 1,
        type: 'solid'
      }
    },
    itemStyle: {
      borderWidth: 1,
      borderJoin: 'round'
    },
    showEmptyCircle: true,
    emptyCircleStyle: {
      color: 'lightgray',
      opacity: 1
    },
    labelLayout: {
      // Hide the overlapped label.
      hideOverlap: true
    },
    emphasis: {
      scale: true,
      scaleSize: 5
    },
    // If use strategy to avoid label overlapping
    avoidLabelOverlap: true,
    // Animation type. Valid values: expansion, scale
    animationType: 'expansion',
    animationDuration: 1000,
    // Animation type when update. Valid values: transition, expansion
    animationTypeUpdate: 'transition',
    animationEasingUpdate: 'cubicInOut',
    animationDurationUpdate: 500,
    animationEasing: 'cubicInOut'
  };
  return PieSeriesModel;
}(SeriesModel$1);

var PieSeriesModel$1 = PieSeriesModel;

function negativeDataFilter(seriesType) {
  return {
    seriesType: seriesType,
    reset: function (seriesModel, ecModel) {
      var data = seriesModel.getData();
      data.filterSelf(function (idx) {
        // handle negative value condition
        var valueDim = data.mapDimension('value');
        var curValue = data.get(valueDim, idx);

        if (isNumber(curValue) && !isNaN(curValue) && curValue < 0) {
          return false;
        }

        return true;
      });
    }
  };
}

function install$g(registers) {
  registers.registerChartView(PieView$1);
  registers.registerSeriesModel(PieSeriesModel$1);
  createLegacyDataSelectAction('pie', registers.registerAction);
  registers.registerLayout(curry$1(pieLayout, 'pie'));
  registers.registerProcessor(dataFilter('pie'));
  registers.registerProcessor(negativeDataFilter('pie'));
}

var GridModel =
/** @class */
function (_super) {
  __extends$1(GridModel, _super);

  function GridModel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  GridModel.type = 'grid';
  GridModel.dependencies = ['xAxis', 'yAxis'];
  GridModel.layoutMode = 'box';
  GridModel.defaultOption = {
    show: false,
    // zlevel: 0,
    z: 0,
    left: '10%',
    top: 60,
    right: '10%',
    bottom: 70,
    // If grid size contain label
    containLabel: false,
    // width: {totalWidth} - left - right,
    // height: {totalHeight} - top - bottom,
    backgroundColor: 'rgba(0,0,0,0)',
    borderWidth: 1,
    borderColor: '#ccc'
  };
  return GridModel;
}(ComponentModel$1);

var GridModel$1 = GridModel;

var CartesianAxisModel =
/** @class */
function (_super) {
  __extends$1(CartesianAxisModel, _super);

  function CartesianAxisModel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  CartesianAxisModel.prototype.getCoordSysModel = function () {
    return this.getReferringComponents('grid', SINGLE_REFERRING).models[0];
  };

  CartesianAxisModel.type = 'cartesian2dAxis';
  return CartesianAxisModel;
}(ComponentModel$1);
mixin(CartesianAxisModel, AxisModelCommonMixin);

var defaultOption$1 = {
  show: true,
  // zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: false,
  // Axis name displayed.
  name: '',
  // 'start' | 'middle' | 'end'
  nameLocation: 'end',
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: '...',
    placeholder: '.'
  },
  // Use global text style by default.
  nameTextStyle: {},
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: false,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: false,
  tooltip: {
    show: false
  },
  axisPointer: {},
  axisLine: {
    show: true,
    onZero: true,
    onZeroAxisIndex: null,
    lineStyle: {
      color: '#6E7079',
      width: 1,
      type: 'solid'
    },
    // The arrow at both ends the the axis.
    symbol: ['none', 'none'],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: true,
    // Whether axisTick is inside the grid or outside the grid.
    inside: false,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: true,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: false,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12
  },
  splitLine: {
    show: true,
    lineStyle: {
      color: ['#E0E6F1'],
      width: 1,
      type: 'solid'
    }
  },
  splitArea: {
    show: false,
    areaStyle: {
      color: ['rgba(250,250,250,0.2)', 'rgba(210,219,238,0.2)']
    }
  }
};
var categoryAxis = merge$1({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: true,
  // Set false to faster category collection.
  deduplication: null,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: false
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: false,
    interval: 'auto'
  },
  axisLabel: {
    interval: 'auto'
  }
}, defaultOption$1);
var valueAxis = merge$1({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: 'auto'
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: 'auto'
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: false,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Lenght of minor tick
    length: 3,
    // Line style
    lineStyle: {// Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: false,
    lineStyle: {
      color: '#F4F7FD',
      width: 1
    }
  }
}, defaultOption$1);
var timeAxis = merge$1({
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: false,
    showMaxLabel: false,
    rich: {
      primary: {
        fontWeight: 'bold'
      }
    }
  },
  splitLine: {
    show: false
  }
}, valueAxis);
var logAxis = defaults({
  logBase: 10
}, valueAxis);
var axisDefault = {
  category: categoryAxis,
  value: valueAxis,
  time: timeAxis,
  log: logAxis
};

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var AXIS_TYPES = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};

/**
 * Generate sub axis model class
 * @param axisName 'x' 'y' 'radius' 'angle' 'parallel' ...
 */

function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
  each$9(AXIS_TYPES, function (v, axisType) {
    var defaultOption = merge$1(merge$1({}, axisDefault[axisType], true), extraDefaultOption, true);

    var AxisModel =
    /** @class */
    function (_super) {
      __extends$1(AxisModel, _super);

      function AxisModel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.type = axisName + 'Axis.' + axisType;
        return _this;
      }

      AxisModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {
        var layoutMode = fetchLayoutMode(this);
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        merge$1(option, themeModel.get(axisType + 'Axis'));
        merge$1(option, this.getDefaultOption());
        option.type = getAxisType(option);

        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      };

      AxisModel.prototype.optionUpdated = function () {
        var thisOption = this.option;

        if (thisOption.type === 'category') {
          this.__ordinalMeta = OrdinalMeta$1.createByAxisModel(this);
        }
      };
      /**
       * Should not be called before all of 'getInitailData' finished.
       * Because categories are collected during initializing data.
       */


      AxisModel.prototype.getCategories = function (rawData) {
        var option = this.option; // FIXME
        // warning if called before all of 'getInitailData' finished.

        if (option.type === 'category') {
          if (rawData) {
            return option.data;
          }

          return this.__ordinalMeta.categories;
        }
      };

      AxisModel.prototype.getOrdinalMeta = function () {
        return this.__ordinalMeta;
      };

      AxisModel.type = axisName + 'Axis.' + axisType;
      AxisModel.defaultOption = defaultOption;
      return AxisModel;
    }(BaseAxisModelClass);

    registers.registerComponentModel(AxisModel);
  });
  registers.registerSubTypeDefaulter(axisName + 'Axis', getAxisType);
}

function getAxisType(option) {
  // Default axis with data is category axis
  return option.type || (option.data ? 'category' : 'value');
}

var Cartesian =
/** @class */
function () {
  function Cartesian(name) {
    this.type = 'cartesian';
    this._dimList = [];
    this._axes = {};
    this.name = name || '';
  }

  Cartesian.prototype.getAxis = function (dim) {
    return this._axes[dim];
  };

  Cartesian.prototype.getAxes = function () {
    return map$1(this._dimList, function (dim) {
      return this._axes[dim];
    }, this);
  };

  Cartesian.prototype.getAxesByScale = function (scaleType) {
    scaleType = scaleType.toLowerCase();
    return filter(this.getAxes(), function (axis) {
      return axis.scale.type === scaleType;
    });
  };

  Cartesian.prototype.addAxis = function (axis) {
    var dim = axis.dim;
    this._axes[dim] = axis;

    this._dimList.push(dim);
  };

  return Cartesian;
}();
var Cartesian$1 = Cartesian;

var cartesian2DDimensions = ['x', 'y'];

function canCalculateAffineTransform(scale) {
  return scale.type === 'interval' || scale.type === 'time';
}

var Cartesian2D =
/** @class */
function (_super) {
  __extends$1(Cartesian2D, _super);

  function Cartesian2D() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'cartesian2d';
    _this.dimensions = cartesian2DDimensions;
    return _this;
  }
  /**
   * Calculate an affine transform matrix if two axes are time or value.
   * It's mainly for accelartion on the large time series data.
   */


  Cartesian2D.prototype.calcAffineTransform = function () {
    this._transform = this._invTransform = null;
    var xAxisScale = this.getAxis('x').scale;
    var yAxisScale = this.getAxis('y').scale;

    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
      return;
    }

    var xScaleExtent = xAxisScale.getExtent();
    var yScaleExtent = yAxisScale.getExtent();
    var start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
    var end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];

    if (!xScaleSpan || !yScaleSpan) {
      return;
    } // Accelerate data to point calculation on the special large time series data.


    var scaleX = (end[0] - start[0]) / xScaleSpan;
    var scaleY = (end[1] - start[1]) / yScaleSpan;
    var translateX = start[0] - xScaleExtent[0] * scaleX;
    var translateY = start[1] - yScaleExtent[0] * scaleY;
    var m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
    this._invTransform = invert([], m);
  };
  /**
   * Base axis will be used on stacking.
   */


  Cartesian2D.prototype.getBaseAxis = function () {
    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
  };

  Cartesian2D.prototype.containPoint = function (point) {
    var axisX = this.getAxis('x');
    var axisY = this.getAxis('y');
    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
  };

  Cartesian2D.prototype.containData = function (data) {
    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);
  };

  Cartesian2D.prototype.containZone = function (data1, data2) {
    var zoneDiag1 = this.dataToPoint(data1);
    var zoneDiag2 = this.dataToPoint(data2);
    var area = this.getArea();
    var zone = new BoundingRect$1(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);
    return area.intersect(zone);
  };

  Cartesian2D.prototype.dataToPoint = function (data, clamp, out) {
    out = out || [];
    var xVal = data[0];
    var yVal = data[1]; // Fast path

    if (this._transform // It's supported that if data is like `[Inifity, 123]`, where only Y pixel calculated.
    && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
      return applyTransform$1(out, data, this._transform);
    }

    var xAxis = this.getAxis('x');
    var yAxis = this.getAxis('y');
    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp));
    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp));
    return out;
  };

  Cartesian2D.prototype.clampData = function (data, out) {
    var xScale = this.getAxis('x').scale;
    var yScale = this.getAxis('y').scale;
    var xAxisExtent = xScale.getExtent();
    var yAxisExtent = yScale.getExtent();
    var x = xScale.parse(data[0]);
    var y = yScale.parse(data[1]);
    out = out || [];
    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
    return out;
  };

  Cartesian2D.prototype.pointToData = function (point, clamp) {
    var out = [];

    if (this._invTransform) {
      return applyTransform$1(out, point, this._invTransform);
    }

    var xAxis = this.getAxis('x');
    var yAxis = this.getAxis('y');
    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp);
    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp);
    return out;
  };

  Cartesian2D.prototype.getOtherAxis = function (axis) {
    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
  };
  /**
   * Get rect area of cartesian.
   * Area will have a contain function to determine if a point is in the coordinate system.
   */


  Cartesian2D.prototype.getArea = function () {
    var xExtent = this.getAxis('x').getGlobalExtent();
    var yExtent = this.getAxis('y').getGlobalExtent();
    var x = Math.min(xExtent[0], xExtent[1]);
    var y = Math.min(yExtent[0], yExtent[1]);
    var width = Math.max(xExtent[0], xExtent[1]) - x;
    var height = Math.max(yExtent[0], yExtent[1]) - y;
    return new BoundingRect$1(x, y, width, height);
  };

  return Cartesian2D;
}(Cartesian$1);

var Axis2D =
/** @class */
function (_super) {
  __extends$1(Axis2D, _super);

  function Axis2D(dim, scale, coordExtent, axisType, position) {
    var _this = _super.call(this, dim, scale, coordExtent) || this;
    /**
     * Index of axis, can be used as key
     * Injected outside.
     */


    _this.index = 0;
    _this.type = axisType || 'value';
    _this.position = position || 'bottom';
    return _this;
  }

  Axis2D.prototype.isHorizontal = function () {
    var position = this.position;
    return position === 'top' || position === 'bottom';
  };
  /**
   * Each item cooresponds to this.getExtent(), which
   * means globalExtent[0] may greater than globalExtent[1],
   * unless `asc` is input.
   *
   * @param {boolean} [asc]
   * @return {Array.<number>}
   */


  Axis2D.prototype.getGlobalExtent = function (asc) {
    var ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc && ret[0] > ret[1] && ret.reverse();
    return ret;
  };

  Axis2D.prototype.pointToData = function (point, clamp) {
    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);
  };
  /**
   * Set ordinalSortInfo
   * @param info new OrdinalSortInfo
   */


  Axis2D.prototype.setCategorySortInfo = function (info) {
    if (this.type !== 'category') {
      return false;
    }

    this.model.option.categorySortInfo = info;
    this.scale.setSortInfo(info);
  };

  return Axis2D;
}(Axis$1);

var Axis2D$1 = Axis2D;

/**
 * Can only be called after coordinate system creation stage.
 * (Can be called before coordinate system update stage).
 */

function layout(gridModel, axisModel, opt) {
  opt = opt || {};
  var grid = gridModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout = {};
  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
  var rawAxisPosition = axis.position;
  var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;
  var axisDim = axis.dim;
  var rect = grid.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var idx = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  };
  var axisOffset = axisModel.get('offset') || 0;
  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];

  if (otherAxisOnZeroOf) {
    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
    posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
  } // Axis position


  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]]; // Axis rotation

  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim

  var dirMap = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
  layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;

  if (axisModel.get(['axisTick', 'inside'])) {
    layout.tickDirection = -layout.tickDirection;
  }

  if (retrieve(opt.labelInside, axisModel.get(['axisLabel', 'inside']))) {
    layout.labelDirection = -layout.labelDirection;
  } // Special label rotation


  var labelRotate = axisModel.get(['axisLabel', 'rotate']);
  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // Over splitLine and splitArea

  layout.z2 = 1;
  return layout;
}
function isCartesian2DSeries(seriesModel) {
  return seriesModel.get('coordinateSystem') === 'cartesian2d';
}
function findAxisModels(seriesModel) {
  var axisModelMap = {
    xAxisModel: null,
    yAxisModel: null
  };
  each$9(axisModelMap, function (v, key) {
    var axisType = key.replace(/Model$/, '');
    var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];

    if (process.env.NODE_ENV !== 'production') {
      if (!axisModel) {
        throw new Error(axisType + ' "' + retrieve3(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '" not found');
      }
    }

    axisModelMap[key] = axisModel;
  });
  return axisModelMap;
}

var mathLog = Math.log;
function alignScaleTicks(scale, axisModel, alignToScale) {
  var intervalScaleProto = IntervalScale$1.prototype; // NOTE: There is a precondition for log scale  here:
  // In log scale we store _interval and _extent of exponent value.
  // So if we use the method of InternalScale to set/get these data.
  // It process the exponent value, which is linear and what we want here.

  var alignToTicks = intervalScaleProto.getTicks.call(alignToScale);
  var alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, true);
  var alignToSplitNumber = alignToTicks.length - 1;
  var alignToInterval = intervalScaleProto.getInterval.call(alignToScale);
  var scaleExtent = getScaleExtent(scale, axisModel);
  var rawExtent = scaleExtent.extent;
  var isMinFixed = scaleExtent.fixMin;
  var isMaxFixed = scaleExtent.fixMax;

  if (scale.type === 'log') {
    var logBase = mathLog(scale.base);
    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];
  }

  scale.setExtent(rawExtent[0], rawExtent[1]);
  scale.calcNiceExtent({
    splitNumber: alignToSplitNumber,
    fixMin: isMinFixed,
    fixMax: isMaxFixed
  });
  var extent = intervalScaleProto.getExtent.call(scale); // Need to update the rawExtent.
  // Because value in rawExtent may be not parsed. e.g. 'dataMin', 'dataMax'

  if (isMinFixed) {
    rawExtent[0] = extent[0];
  }

  if (isMaxFixed) {
    rawExtent[1] = extent[1];
  }

  var interval = intervalScaleProto.getInterval.call(scale);
  var min = rawExtent[0];
  var max = rawExtent[1];

  if (isMinFixed && isMaxFixed) {
    // User set min, max, divide to get new interval
    interval = (max - min) / alignToSplitNumber;
  } else if (isMinFixed) {
    max = rawExtent[0] + interval * alignToSplitNumber; // User set min, expand extent on the other side

    while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1])) {
      interval = increaseInterval(interval);
      max = rawExtent[0] + interval * alignToSplitNumber;
    }
  } else if (isMaxFixed) {
    // User set max, expand extent on the other side
    min = rawExtent[1] - interval * alignToSplitNumber;

    while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0])) {
      interval = increaseInterval(interval);
      min = rawExtent[1] - interval * alignToSplitNumber;
    }
  } else {
    var nicedSplitNumber = scale.getTicks().length - 1;

    if (nicedSplitNumber > alignToSplitNumber) {
      interval = increaseInterval(interval);
    }

    var range = interval * alignToSplitNumber;
    max = Math.ceil(rawExtent[1] / interval) * interval;
    min = round$1(max - range); // Not change the result that crossing zero.

    if (min < 0 && rawExtent[0] >= 0) {
      min = 0;
      max = round$1(range);
    } else if (max > 0 && rawExtent[1] <= 0) {
      max = 0;
      min = -round$1(range);
    }
  } // Adjust min, max based on the extent of alignTo. When min or max is set in alignTo scale


  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval; // NOTE: Must in setExtent -> setInterval -> setNiceExtent order.

  intervalScaleProto.setExtent.call(scale, min + interval * t0, max + interval * t1);
  intervalScaleProto.setInterval.call(scale, interval);

  if (t0 || t1) {
    intervalScaleProto.setNiceExtent.call(scale, min + interval, max - interval);
  }

  if (process.env.NODE_ENV !== 'production') {
    var ticks = intervalScaleProto.getTicks.call(scale);

    if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {
      warn( // eslint-disable-next-line
      "The ticks may be not readable when set min: " + axisModel.get('min') + ", max: " + axisModel.get('max') + " and alignTicks: true");
    }
  }
}

var Grid =
/** @class */
function () {
  function Grid(gridModel, ecModel, api) {
    // FIXME:TS where used (different from registered type 'cartesian2d')?
    this.type = 'grid';
    this._coordsMap = {};
    this._coordsList = [];
    this._axesMap = {};
    this._axesList = [];
    this.axisPointerEnabled = true;
    this.dimensions = cartesian2DDimensions;

    this._initCartesian(gridModel, ecModel, api);

    this.model = gridModel;
  }

  Grid.prototype.getRect = function () {
    return this._rect;
  };

  Grid.prototype.update = function (ecModel, api) {
    var axesMap = this._axesMap;

    this._updateScale(ecModel, this.model);

    function updateAxisTicks(axes) {
      var alignTo; // Axis is added in order of axisIndex.

      var axesIndices = keys(axes);
      var len = axesIndices.length;

      if (!len) {
        return;
      }

      var axisNeedsAlign = []; // Process once and calculate the ticks for those don't use alignTicks.

      for (var i = len - 1; i >= 0; i--) {
        var idx = +axesIndices[i]; // Convert to number.

        var axis = axes[idx];
        var model = axis.model;
        var scale = axis.scale;

        if ( // Only value and log axis without interval support alignTicks.
        isIntervalOrLogScale(scale) && model.get('alignTicks') && model.get('interval') == null) {
          axisNeedsAlign.push(axis);
        } else {
          niceScaleExtent(scale, model);

          if (isIntervalOrLogScale(scale)) {
            // Can only align to interval or log axis.
            alignTo = axis;
          }
        }
      }
      // PENDING. Should we find the axis that both set interval, min, max and align to this one?

      if (axisNeedsAlign.length) {
        if (!alignTo) {
          alignTo = axisNeedsAlign.pop();
          niceScaleExtent(alignTo.scale, alignTo.model);
        }

        each$9(axisNeedsAlign, function (axis) {
          alignScaleTicks(axis.scale, axis.model, alignTo.scale);
        });
      }
    }

    updateAxisTicks(axesMap.x);
    updateAxisTicks(axesMap.y); // Key: axisDim_axisIndex, value: boolean, whether onZero target.

    var onZeroRecords = {};
    each$9(axesMap.x, function (xAxis) {
      fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);
    });
    each$9(axesMap.y, function (yAxis) {
      fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);
    }); // Resize again if containLabel is enabled
    // FIXME It may cause getting wrong grid size in data processing stage

    this.resize(this.model, api);
  };
  /**
   * Resize the grid
   */


  Grid.prototype.resize = function (gridModel, api, ignoreContainLabel) {
    var boxLayoutParams = gridModel.getBoxLayoutParams();
    var isContainLabel = !ignoreContainLabel && gridModel.get('containLabel');
    var gridRect = getLayoutRect(boxLayoutParams, {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._rect = gridRect;
    var axesList = this._axesList;
    adjustAxes(); // Minus label size

    if (isContainLabel) {
      each$9(axesList, function (axis) {
        if (!axis.model.get(['axisLabel', 'inside'])) {
          var labelUnionRect = estimateLabelUnionRect(axis);

          if (labelUnionRect) {
            var dim = axis.isHorizontal() ? 'height' : 'width';
            var margin = axis.model.get(['axisLabel', 'margin']);
            gridRect[dim] -= labelUnionRect[dim] + margin;

            if (axis.position === 'top') {
              gridRect.y += labelUnionRect.height + margin;
            } else if (axis.position === 'left') {
              gridRect.x += labelUnionRect.width + margin;
            }
          }
        }
      });
      adjustAxes();
    }

    each$9(this._coordsList, function (coord) {
      // Calculate affine matrix to accelerate the data to point transform.
      // If all the axes scales are time or value.
      coord.calcAffineTransform();
    });

    function adjustAxes() {
      each$9(axesList, function (axis) {
        var isHorizontal = axis.isHorizontal();
        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
        var idx = axis.inverse ? 1 : 0;
        axis.setExtent(extent[idx], extent[1 - idx]);
        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
      });
    }
  };

  Grid.prototype.getAxis = function (dim, axisIndex) {
    var axesMapOnDim = this._axesMap[dim];

    if (axesMapOnDim != null) {
      return axesMapOnDim[axisIndex || 0];
    }
  };

  Grid.prototype.getAxes = function () {
    return this._axesList.slice();
  };

  Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
      return this._coordsMap[key];
    }

    if (isObject$3(xAxisIndex)) {
      yAxisIndex = xAxisIndex.yAxisIndex;
      xAxisIndex = xAxisIndex.xAxisIndex;
    }

    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
      if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {
        return coordList[i];
      }
    }
  };

  Grid.prototype.getCartesians = function () {
    return this._coordsList.slice();
  };
  /**
   * @implements
   */


  Grid.prototype.convertToPixel = function (ecModel, finder, value) {
    var target = this._findConvertTarget(finder);

    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
  };
  /**
   * @implements
   */


  Grid.prototype.convertFromPixel = function (ecModel, finder, value) {
    var target = this._findConvertTarget(finder);

    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
  };

  Grid.prototype._findConvertTarget = function (finder) {
    var seriesModel = finder.seriesModel;
    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0];
    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0];
    var gridModel = finder.gridModel;
    var coordsList = this._coordsList;
    var cartesian;
    var axis;

    if (seriesModel) {
      cartesian = seriesModel.coordinateSystem;
      indexOf(coordsList, cartesian) < 0 && (cartesian = null);
    } else if (xAxisModel && yAxisModel) {
      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
      axis = this.getAxis('x', xAxisModel.componentIndex);
    } else if (yAxisModel) {
      axis = this.getAxis('y', yAxisModel.componentIndex);
    } // Lowest priority.
    else if (gridModel) {
        var grid = gridModel.coordinateSystem;

        if (grid === this) {
          cartesian = this._coordsList[0];
        }
      }

    return {
      cartesian: cartesian,
      axis: axis
    };
  };
  /**
   * @implements
   */


  Grid.prototype.containPoint = function (point) {
    var coord = this._coordsList[0];

    if (coord) {
      return coord.containPoint(point);
    }
  };
  /**
   * Initialize cartesian coordinate systems
   */


  Grid.prototype._initCartesian = function (gridModel, ecModel, api) {
    var _this = this;

    var grid = this;
    var axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    var axesMap = {
      x: {},
      y: {}
    };
    var axesCount = {
      x: 0,
      y: 0
    }; /// Create axis

    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);

    if (!axesCount.x || !axesCount.y) {
      // Roll back when there no either x or y axis
      this._axesMap = {};
      this._axesList = [];
      return;
    }

    this._axesMap = axesMap; /// Create cartesian2d

    each$9(axesMap.x, function (xAxis, xAxisIndex) {
      each$9(axesMap.y, function (yAxis, yAxisIndex) {
        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
        var cartesian = new Cartesian2D(key);
        cartesian.master = _this;
        cartesian.model = gridModel;
        _this._coordsMap[key] = cartesian;

        _this._coordsList.push(cartesian);

        cartesian.addAxis(xAxis);
        cartesian.addAxis(yAxis);
      });
    });

    function createAxisCreator(dimName) {
      return function (axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
          return;
        }

        var axisPosition = axisModel.get('position');

        if (dimName === 'x') {
          // Fix position
          if (axisPosition !== 'top' && axisPosition !== 'bottom') {
            // Default bottom of X
            axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';
          }
        } else {
          // Fix position
          if (axisPosition !== 'left' && axisPosition !== 'right') {
            // Default left of Y
            axisPosition = axisPositionUsed.left ? 'right' : 'left';
          }
        }

        axisPositionUsed[axisPosition] = true;
        var axis = new Axis2D$1(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);
        var isCategory = axis.type === 'category';
        axis.onBand = isCategory && axisModel.get('boundaryGap');
        axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel

        axisModel.axis = axis; // Inject axisModel into axis

        axis.model = axisModel; // Inject grid info axis

        axis.grid = grid; // Index of axis, can be used as key

        axis.index = idx;

        grid._axesList.push(axis);

        axesMap[dimName][idx] = axis;
        axesCount[dimName]++;
      };
    }
  };
  /**
   * Update cartesian properties from series.
   */


  Grid.prototype._updateScale = function (ecModel, gridModel) {
    // Reset scale
    each$9(this._axesList, function (axis) {
      axis.scale.setExtent(Infinity, -Infinity);

      if (axis.type === 'category') {
        var categorySortInfo = axis.model.get('categorySortInfo');
        axis.scale.setSortInfo(categorySortInfo);
      }
    });
    ecModel.eachSeries(function (seriesModel) {
      if (isCartesian2DSeries(seriesModel)) {
        var axesModelMap = findAxisModels(seriesModel);
        var xAxisModel = axesModelMap.xAxisModel;
        var yAxisModel = axesModelMap.yAxisModel;

        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
          return;
        }

        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        var data = seriesModel.getData();
        var xAxis = cartesian.getAxis('x');
        var yAxis = cartesian.getAxis('y');
        unionExtent(data, xAxis);
        unionExtent(data, yAxis);
      }
    }, this);

    function unionExtent(data, axis) {
      each$9(getDataDimensionsOnAxis(data, axis.dim), function (dim) {
        axis.scale.unionExtentFromData(data, dim);
      });
    }
  };
  /**
   * @param dim 'x' or 'y' or 'auto' or null/undefined
   */


  Grid.prototype.getTooltipAxes = function (dim) {
    var baseAxes = [];
    var otherAxes = [];
    each$9(this.getCartesians(), function (cartesian) {
      var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
      var otherAxis = cartesian.getOtherAxis(baseAxis);
      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });
    return {
      baseAxes: baseAxes,
      otherAxes: otherAxes
    };
  };

  Grid.create = function (ecModel, api) {
    var grids = [];
    ecModel.eachComponent('grid', function (gridModel, idx) {
      var grid = new Grid(gridModel, ecModel, api);
      grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize
      // should be performed in create stage.

      grid.resize(gridModel, api, true);
      gridModel.coordinateSystem = grid;
      grids.push(grid);
    }); // Inject the coordinateSystems into seriesModel

    ecModel.eachSeries(function (seriesModel) {
      if (!isCartesian2DSeries(seriesModel)) {
        return;
      }

      var axesModelMap = findAxisModels(seriesModel);
      var xAxisModel = axesModelMap.xAxisModel;
      var yAxisModel = axesModelMap.yAxisModel;
      var gridModel = xAxisModel.getCoordSysModel();

      if (process.env.NODE_ENV !== 'production') {
        if (!gridModel) {
          throw new Error('Grid "' + retrieve3(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '" not found');
        }

        if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {
          throw new Error('xAxis and yAxis must use the same grid');
        }
      }

      var grid = gridModel.coordinateSystem;
      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    });
    return grids;
  }; // For deciding which dimensions to use when creating list data


  Grid.dimensions = cartesian2DDimensions;
  return Grid;
}();
/**
 * Check if the axis is used in the specified grid.
 */


function isAxisUsedInTheGrid(axisModel, gridModel) {
  return axisModel.getCoordSysModel() === gridModel;
}

function fixAxisOnZero(axesMap, otherAxisDim, axis, // Key: see `getOnZeroRecordKey`
onZeroRecords) {
  axis.getAxesOnZeroOf = function () {
    // TODO: onZero of multiple axes.
    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
  }; // onZero can not be enabled in these two situations:
  // 1. When any other axis is a category axis.
  // 2. When no axis is cross 0 point.


  var otherAxes = axesMap[otherAxisDim];
  var otherAxisOnZeroOf;
  var axisModel = axis.model;
  var onZero = axisModel.get(['axisLine', 'onZero']);
  var onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex']);

  if (!onZero) {
    return;
  } // If target axis is specified.


  if (onZeroAxisIndex != null) {
    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
    }
  } else {
    // Find the first available other axis.
    for (var idx in otherAxes) {
      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) // Consider that two Y axes on one value axis,
      // if both onZero, the two Y axes overlap.
      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
        otherAxisOnZeroOf = otherAxes[idx];
        break;
      }
    }
  }

  if (otherAxisOnZeroOf) {
    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
  }

  function getOnZeroRecordKey(axis) {
    return axis.dim + '_' + axis.index;
  }
}

function canOnZeroToAxis(axis) {
  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);
}

function updateAxisTransform(axis, coordBase) {
  var axisExtent = axis.getExtent();
  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform

  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {
    return coord + coordBase;
  } : function (coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {
    return coord - coordBase;
  } : function (coord) {
    return axisExtentSum - coord + coordBase;
  };
}

var Grid$1 = Grid;

var PI = Math.PI;
/**
 * A final axis is translated and rotated from a "standard axis".
 * So opt.position and opt.rotation is required.
 *
 * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
 * for example: (0, 0) ------------> (0, 50)
 *
 * nameDirection or tickDirection or labelDirection is 1 means tick
 * or label is below the standard axis, whereas is -1 means above
 * the standard axis. labelOffset means offset between label and axis,
 * which is useful when 'onZero', where axisLabel is in the grid and
 * label in outside grid.
 *
 * Tips: like always,
 * positive rotation represents anticlockwise, and negative rotation
 * represents clockwise.
 * The direction of position coordinate is the same as the direction
 * of screen coordinate.
 *
 * Do not need to consider axis 'inverse', which is auto processed by
 * axis extent.
 */

var AxisBuilder =
/** @class */
function () {
  function AxisBuilder(axisModel, opt) {
    this.group = new Group$3();
    this.opt = opt;
    this.axisModel = axisModel; // Default value

    defaults(opt, {
      labelOffset: 0,
      nameDirection: 1,
      tickDirection: 1,
      labelDirection: 1,
      silent: true,
      handleAutoShown: function () {
        return true;
      }
    }); // FIXME Not use a seperate text group?

    var transformGroup = new Group$3({
      x: opt.position[0],
      y: opt.position[1],
      rotation: opt.rotation
    }); // this.group.add(transformGroup);
    // this._transformGroup = transformGroup;

    transformGroup.updateTransform();
    this._transformGroup = transformGroup;
  }

  AxisBuilder.prototype.hasBuilder = function (name) {
    return !!builders[name];
  };

  AxisBuilder.prototype.add = function (name) {
    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);
  };

  AxisBuilder.prototype.getGroup = function () {
    return this.group;
  };

  AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {
    var rotationDiff = remRadian(textRotation - axisRotation);
    var textAlign;
    var textVerticalAlign;

    if (isRadianAroundZero(rotationDiff)) {
      // Label is parallel with axis line.
      textVerticalAlign = direction > 0 ? 'top' : 'bottom';
      textAlign = 'center';
    } else if (isRadianAroundZero(rotationDiff - PI)) {
      // Label is inverse parallel with axis line.
      textVerticalAlign = direction > 0 ? 'bottom' : 'top';
      textAlign = 'center';
    } else {
      textVerticalAlign = 'middle';

      if (rotationDiff > 0 && rotationDiff < PI) {
        textAlign = direction > 0 ? 'right' : 'left';
      } else {
        textAlign = direction > 0 ? 'left' : 'right';
      }
    }

    return {
      rotation: rotationDiff,
      textAlign: textAlign,
      textVerticalAlign: textVerticalAlign
    };
  };

  AxisBuilder.makeAxisEventDataBase = function (axisModel) {
    var eventData = {
      componentType: axisModel.mainType,
      componentIndex: axisModel.componentIndex
    };
    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
    return eventData;
  };

  AxisBuilder.isLabelSilent = function (axisModel) {
    var tooltipOpt = axisModel.get('tooltip');
    return axisModel.get('silent') // Consider mouse cursor, add these restrictions.
    || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);
  };

  return AxisBuilder;
}();
var builders = {
  axisLine: function (opt, axisModel, group, transformGroup) {
    var shown = axisModel.get(['axisLine', 'show']);

    if (shown === 'auto' && opt.handleAutoShown) {
      shown = opt.handleAutoShown('axisLine');
    }

    if (!shown) {
      return;
    }

    var extent = axisModel.axis.getExtent();
    var matrix = transformGroup.transform;
    var pt1 = [extent[0], 0];
    var pt2 = [extent[1], 0];
    var inverse = pt1[0] > pt2[0];

    if (matrix) {
      applyTransform$1(pt1, pt1, matrix);
      applyTransform$1(pt2, pt2, matrix);
    }

    var lineStyle = extend$2({
      lineCap: 'round'
    }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle());
    var line = new Line$1({
      shape: {
        x1: pt1[0],
        y1: pt1[1],
        x2: pt2[0],
        y2: pt2[1]
      },
      style: lineStyle,
      strokeContainThreshold: opt.strokeContainThreshold || 5,
      silent: true,
      z2: 1
    });
    subPixelOptimizeLine(line.shape, line.style.lineWidth);
    line.anid = 'line';
    group.add(line);
    var arrows = axisModel.get(['axisLine', 'symbol']);

    if (arrows != null) {
      var arrowSize = axisModel.get(['axisLine', 'symbolSize']);

      if (isString(arrows)) {
        // Use the same arrow for start and end point
        arrows = [arrows, arrows];
      }

      if (isString(arrowSize) || isNumber(arrowSize)) {
        // Use the same size for width and height
        arrowSize = [arrowSize, arrowSize];
      }

      var arrowOffset = normalizeSymbolOffset(axisModel.get(['axisLine', 'symbolOffset']) || 0, arrowSize);
      var symbolWidth_1 = arrowSize[0];
      var symbolHeight_1 = arrowSize[1];
      each$9([{
        rotate: opt.rotation + Math.PI / 2,
        offset: arrowOffset[0],
        r: 0
      }, {
        rotate: opt.rotation - Math.PI / 2,
        offset: arrowOffset[1],
        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
      }], function (point, index) {
        if (arrows[index] !== 'none' && arrows[index] != null) {
          var symbol = createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true); // Calculate arrow position with offset

          var r = point.r + point.offset;
          var pt = inverse ? pt2 : pt1;
          symbol.attr({
            rotation: point.rotate,
            x: pt[0] + r * Math.cos(opt.rotation),
            y: pt[1] - r * Math.sin(opt.rotation),
            silent: true,
            z2: 11
          });
          group.add(symbol);
        }
      });
    }
  },
  axisTickLabel: function (opt, axisModel, group, transformGroup) {
    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);
    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);
    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection); // This bit fixes the label overlap issue for the time chart.
    // See https://github.com/apache/echarts/issues/14266 for more.

    if (axisModel.get(['axisLabel', 'hideOverlap'])) {
      var labelList = prepareLayoutList(map$1(labelEls, function (label) {
        return {
          label: label,
          priority: label.z2,
          defaultAttr: {
            ignore: label.ignore
          }
        };
      }));
      hideOverlap(labelList);
    }
  },
  axisName: function (opt, axisModel, group, transformGroup) {
    var name = retrieve(opt.axisName, axisModel.get('name'));

    if (!name) {
      return;
    }

    var nameLocation = axisModel.get('nameLocation');
    var nameDirection = opt.nameDirection;
    var textStyleModel = axisModel.getModel('nameTextStyle');
    var gap = axisModel.get('nameGap') || 0;
    var extent = axisModel.axis.getExtent();
    var gapSignal = extent[0] > extent[1] ? -1 : 1;
    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // Reuse labelOffset.
    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];
    var labelLayout;
    var nameRotation = axisModel.get('nameRotate');

    if (nameRotation != null) {
      nameRotation = nameRotation * PI / 180; // To radian.
    }

    var axisNameAvailableWidth;

    if (isNameLocationCenter(nameLocation)) {
      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.
      nameDirection);
    } else {
      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent);
      axisNameAvailableWidth = opt.axisNameAvailableWidth;

      if (axisNameAvailableWidth != null) {
        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
      }
    }

    var textFont = textStyleModel.getFont();
    var truncateOpt = axisModel.get('nameTruncate', true) || {};
    var ellipsis = truncateOpt.ellipsis;
    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
    var textEl = new ZRText$1({
      x: pos[0],
      y: pos[1],
      rotation: labelLayout.rotation,
      silent: AxisBuilder.isLabelSilent(axisModel),
      style: createTextStyle$1(textStyleModel, {
        text: name,
        font: textFont,
        overflow: 'truncate',
        width: maxWidth,
        ellipsis: ellipsis,
        fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),
        align: textStyleModel.get('align') || labelLayout.textAlign,
        verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign
      }),
      z2: 1
    });
    setTooltipConfig({
      el: textEl,
      componentModel: axisModel,
      itemName: name
    });
    textEl.__fullText = name; // Id for animation

    textEl.anid = 'name';

    if (axisModel.get('triggerEvent')) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = 'axisName';
      eventData.name = name;
      getECData(textEl).eventData = eventData;
    } // FIXME


    transformGroup.add(textEl);
    textEl.updateTransform();
    group.add(textEl);
    textEl.decomposeTransform();
  }
};

function endTextLayout(rotation, textPosition, textRotate, extent) {
  var rotationDiff = remRadian(textRotate - rotation);
  var textAlign;
  var textVerticalAlign;
  var inverse = extent[0] > extent[1];
  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;

  if (isRadianAroundZero(rotationDiff - PI / 2)) {
    textVerticalAlign = onLeft ? 'bottom' : 'top';
    textAlign = 'center';
  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
    textVerticalAlign = onLeft ? 'top' : 'bottom';
    textAlign = 'center';
  } else {
    textVerticalAlign = 'middle';

    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
      textAlign = onLeft ? 'left' : 'right';
    } else {
      textAlign = onLeft ? 'right' : 'left';
    }
  }

  return {
    rotation: rotationDiff,
    textAlign: textAlign,
    textVerticalAlign: textVerticalAlign
  };
}

function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
  if (shouldShowAllLabels(axisModel.axis)) {
    return;
  } // If min or max are user set, we need to check
  // If the tick on min(max) are overlap on their neighbour tick
  // If they are overlapped, we need to hide the min(max) tick label


  var showMinLabel = axisModel.get(['axisLabel', 'showMinLabel']);
  var showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']); // FIXME
  // Have not consider onBand yet, where tick els is more than label els.

  labelEls = labelEls || [];
  tickEls = tickEls || [];
  var firstLabel = labelEls[0];
  var nextLabel = labelEls[1];
  var lastLabel = labelEls[labelEls.length - 1];
  var prevLabel = labelEls[labelEls.length - 2];
  var firstTick = tickEls[0];
  var nextTick = tickEls[1];
  var lastTick = tickEls[tickEls.length - 1];
  var prevTick = tickEls[tickEls.length - 2];

  if (showMinLabel === false) {
    ignoreEl(firstLabel);
    ignoreEl(firstTick);
  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
    if (showMinLabel) {
      ignoreEl(nextLabel);
      ignoreEl(nextTick);
    } else {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    }
  }

  if (showMaxLabel === false) {
    ignoreEl(lastLabel);
    ignoreEl(lastTick);
  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
    if (showMaxLabel) {
      ignoreEl(prevLabel);
      ignoreEl(prevTick);
    } else {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    }
  }
}

function ignoreEl(el) {
  el && (el.ignore = true);
}

function isTwoLabelOverlapped(current, next) {
  // current and next has the same rotation.
  var firstRect = current && current.getBoundingRect().clone();
  var nextRect = next && next.getBoundingRect().clone();

  if (!firstRect || !nextRect) {
    return;
  } // When checking intersect of two rotated labels, we use mRotationBack
  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.


  var mRotationBack = identity([]);
  rotate(mRotationBack, mRotationBack, -current.rotation);
  firstRect.applyTransform(mul([], mRotationBack, current.getLocalTransform()));
  nextRect.applyTransform(mul([], mRotationBack, next.getLocalTransform()));
  return firstRect.intersect(nextRect);
}

function isNameLocationCenter(nameLocation) {
  return nameLocation === 'middle' || nameLocation === 'center';
}

function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
  var tickEls = [];
  var pt1 = [];
  var pt2 = [];

  for (var i = 0; i < ticksCoords.length; i++) {
    var tickCoord = ticksCoords[i].coord;
    pt1[0] = tickCoord;
    pt1[1] = 0;
    pt2[0] = tickCoord;
    pt2[1] = tickEndCoord;

    if (tickTransform) {
      applyTransform$1(pt1, pt1, tickTransform);
      applyTransform$1(pt2, pt2, tickTransform);
    } // Tick line, Not use group transform to have better line draw


    var tickEl = new Line$1({
      shape: {
        x1: pt1[0],
        y1: pt1[1],
        x2: pt2[0],
        y2: pt2[1]
      },
      style: tickLineStyle,
      z2: 2,
      autoBatch: true,
      silent: true
    });
    subPixelOptimizeLine(tickEl.shape, tickEl.style.lineWidth);
    tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue;
    tickEls.push(tickEl);
  }

  return tickEls;
}

function buildAxisMajorTicks(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var tickModel = axisModel.getModel('axisTick');
  var shown = tickModel.get('show');

  if (shown === 'auto' && opt.handleAutoShown) {
    shown = opt.handleAutoShown('axisTick');
  }

  if (!shown || axis.scale.isBlank()) {
    return;
  }

  var lineStyleModel = tickModel.getModel('lineStyle');
  var tickEndCoord = opt.tickDirection * tickModel.get('length');
  var ticksCoords = axis.getTicksCoords();
  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])
  }), 'ticks');

  for (var i = 0; i < ticksEls.length; i++) {
    group.add(ticksEls[i]);
  }

  return ticksEls;
}

function buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {
  var axis = axisModel.axis;
  var minorTickModel = axisModel.getModel('minorTick');

  if (!minorTickModel.get('show') || axis.scale.isBlank()) {
    return;
  }

  var minorTicksCoords = axis.getMinorTicksCoords();

  if (!minorTicksCoords.length) {
    return;
  }

  var lineStyleModel = minorTickModel.getModel('lineStyle');
  var tickEndCoord = tickDirection * minorTickModel.get('length');
  var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel('axisTick').getLineStyle(), {
    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])
  }));

  for (var i = 0; i < minorTicksCoords.length; i++) {
    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);

    for (var k = 0; k < minorTicksEls.length; k++) {
      group.add(minorTicksEls[k]);
    }
  }
}

function buildAxisLabel(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var show = retrieve(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']));

  if (!show || axis.scale.isBlank()) {
    return;
  }

  var labelModel = axisModel.getModel('axisLabel');
  var labelMargin = labelModel.get('margin');
  var labels = axis.getViewLabels(); // Special label rotate.

  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;
  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
  var labelEls = [];
  var silent = AxisBuilder.isLabelSilent(axisModel);
  var triggerEvent = axisModel.get('triggerEvent');
  each$9(labels, function (labelItem, index) {
    var tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
    var formattedLabel = labelItem.formattedLabel;
    var rawLabel = labelItem.rawLabel;
    var itemLabelModel = labelModel;

    if (rawCategoryData && rawCategoryData[tickValue]) {
      var rawCategoryItem = rawCategoryData[tickValue];

      if (isObject$3(rawCategoryItem) && rawCategoryItem.textStyle) {
        itemLabelModel = new Model$1(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
      }
    }

    var textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']);
    var tickCoord = axis.dataToCoord(tickValue);
    var textEl = new ZRText$1({
      x: tickCoord,
      y: opt.labelOffset + opt.labelDirection * labelMargin,
      rotation: labelLayout.rotation,
      silent: silent,
      z2: 10 + (labelItem.level || 0),
      style: createTextStyle$1(itemLabelModel, {
        text: formattedLabel,
        align: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,
        verticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,
        fill: isFunction(textColor) ? textColor( // (1) In category axis with data zoom, tick is not the original
        // index of axis.data. So tick should not be exposed to user
        // in category axis.
        // (2) Compatible with previous version, which always use formatted label as
        // input. But in interval scale the formatted label is like '223,445', which
        // maked user repalce ','. So we modify it to return original val but remain
        // it as 'string' to avoid error in replacing.
        axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor
      })
    });
    textEl.anid = 'label_' + tickValue; // Pack data for mouse event

    if (triggerEvent) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = 'axisLabel';
      eventData.value = rawLabel;
      eventData.tickIndex = index;

      if (axis.type === 'category') {
        eventData.dataIndex = tickValue;
      }

      getECData(textEl).eventData = eventData;
    } // FIXME


    transformGroup.add(textEl);
    textEl.updateTransform();
    labelEls.push(textEl);
    group.add(textEl);
    textEl.decomposeTransform();
  });
  return labelEls;
}

var AxisBuilder$1 = AxisBuilder;

// allAxesInfo should be updated when setOption performed.

function collect(ecModel, api) {
  var result = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: false,

    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart.

  result.seriesInvolved && collectSeriesInfo(result, ecModel);
  return result;
}

function collectAxesInfo(result, ecModel, api) {
  var globalTooltipModel = ecModel.getComponent('tooltip');
  var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global.

  var linksOption = globalAxisPointerModel.get('link', true) || [];
  var linkGroups = []; // Collect axes info.

  each$9(api.getCoordinateSystems(), function (coordSys) {
    // Some coordinate system do not support axes, like geo.
    if (!coordSys.axisPointerEnabled) {
      return;
    }

    var coordSysKey = makeKey(coordSys.model);
    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
    result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer
    // for user. So we enable seting tooltip on coordSys model.

    var coordSysModel = coordSys.model;
    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);
    each$9(coordSys.getAxes(), curry$1(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys.
    // Notice this case: coordSys is `grid` but not `cartesian2D` here.

    if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not
    // show but axisPointer will show as normal.
    && baseTooltipModel.get('show')) {
      // Compatible with previous logic. But series.tooltip.trigger: 'axis'
      // or series.data[n].tooltip.trigger: 'axis' are not support any more.
      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';
      var cross = baseTooltipModel.get(['axisPointer', 'type']) === 'cross';
      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(['axisPointer', 'axis']));

      if (triggerAxis || cross) {
        each$9(tooltipAxes.baseAxes, curry$1(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));
      }

      if (cross) {
        each$9(tooltipAxes.otherAxes, curry$1(saveTooltipAxisInfo, 'cross', false));
      }
    } // fromTooltip: true | false | 'cross'
    // triggerTooltip: true | false | null


    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);
      var axisPointerShow = axisPointerModel.get('show');

      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
        return;
      }

      if (triggerTooltip == null) {
        triggerTooltip = axisPointerModel.get('triggerTooltip');
      }

      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
      var snap = axisPointerModel.get('snap');
      var axisKey = makeKey(axis.model);
      var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority).

      var axisInfo = result.axesInfo[axisKey] = {
        key: axisKey,
        axis: axis,
        coordSys: coordSys,
        axisPointerModel: axisPointerModel,
        triggerTooltip: triggerTooltip,
        involveSeries: involveSeries,
        snap: snap,
        useHandle: isHandleTrigger(axisPointerModel),
        seriesModels: [],
        linkGroup: null
      };
      axesInfoInCoordSys[axisKey] = axisInfo;
      result.seriesInvolved = result.seriesInvolved || involveSeries;
      var groupIndex = getLinkGroupIndex(linksOption, axis);

      if (groupIndex != null) {
        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
          axesInfo: {}
        });
        linkGroup.axesInfo[axisKey] = axisInfo;
        linkGroup.mapper = linksOption[groupIndex].mapper;
        axisInfo.linkGroup = linkGroup;
      }
    }
  });
}

function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');
  var fields = ['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'];
  var volatileOption = {};
  each$9(fields, function (field) {
    volatileOption[field] = clone$3(tooltipAxisPointerModel.get(field));
  }); // category axis do not auto snap, otherwise some tick that do not
  // has value can not be hovered. value/time/log axis default snap if
  // triggered from tooltip and trigger tooltip.

  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default.
  // Only these properties can be overrided from tooltip to axisPointer.

  if (tooltipAxisPointerModel.get('type') === 'cross') {
    volatileOption.type = 'line';
  }

  var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default.

  labelOption.show == null && (labelOption.show = false);

  if (fromTooltip === 'cross') {
    // When 'cross', both axes show labels.
    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(['label', 'show']);
    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true; // If triggerTooltip, this is a base axis, which should better not use cross style
    // (cross style is dashed by default)

    if (!triggerTooltip) {
      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');
      crossStyle && defaults(labelOption, crossStyle.textStyle);
    }
  }

  return axis.model.getModel('axisPointer', new Model$1(volatileOption, globalAxisPointerModel, ecModel));
}

function collectSeriesInfo(result, ecModel) {
  // Prepare data for axis trigger
  ecModel.eachSeries(function (seriesModel) {
    // Notice this case: this coordSys is `cartesian2D` but not `grid`.
    var coordSys = seriesModel.coordinateSystem;
    var seriesTooltipTrigger = seriesModel.get(['tooltip', 'trigger'], true);
    var seriesTooltipShow = seriesModel.get(['tooltip', 'show'], true);

    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get(['axisPointer', 'show'], true) === false) {
      return;
    }

    each$9(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {
      var axis = axisInfo.axis;

      if (coordSys.getAxis(axis.dim) === axis) {
        axisInfo.seriesModels.push(seriesModel);
        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
        axisInfo.seriesDataCount += seriesModel.getData().count();
      }
    });
  });
}
/**
 * For example:
 * {
 *     axisPointer: {
 *         links: [{
 *             xAxisIndex: [2, 4],
 *             yAxisIndex: 'all'
 *         }, {
 *             xAxisId: ['a5', 'a7'],
 *             xAxisName: 'xxx'
 *         }]
 *     }
 * }
 */


function getLinkGroupIndex(linksOption, axis) {
  var axisModel = axis.model;
  var dim = axis.dim;

  for (var i = 0; i < linksOption.length; i++) {
    var linkOption = linksOption[i] || {};

    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {
      return i;
    }
  }
}

function checkPropInLink(linkPropValue, axisPropValue) {
  return linkPropValue === 'all' || isArray$1(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}

function fixValue(axisModel) {
  var axisInfo = getAxisInfo(axisModel);

  if (!axisInfo) {
    return;
  }

  var axisPointerModel = axisInfo.axisPointerModel;
  var scale = axisInfo.axis.scale;
  var option = axisPointerModel.option;
  var status = axisPointerModel.get('status');
  var value = axisPointerModel.get('value'); // Parse init value for category and time axis.

  if (value != null) {
    value = scale.parse(value);
  }

  var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value
  // and status should be initialized.

  if (status == null) {
    option.status = useHandle ? 'show' : 'hide';
  }

  var extent = scale.getExtent().slice();
  extent[0] > extent[1] && extent.reverse();

  if ( // Pick a value on axis when initializing.
  value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent,
  // where we should re-pick a value to keep `handle` displaying normally.
  || value > extent[1]) {
    // Make handle displayed on the end of the axis when init, which looks better.
    value = extent[1];
  }

  if (value < extent[0]) {
    value = extent[0];
  }

  option.value = value;

  if (useHandle) {
    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';
  }
}
function getAxisInfo(axisModel) {
  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;
  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}
function getAxisPointerModel(axisModel) {
  var axisInfo = getAxisInfo(axisModel);
  return axisInfo && axisInfo.axisPointerModel;
}

function isHandleTrigger(axisPointerModel) {
  return !!axisPointerModel.get(['handle', 'show']);
}
/**
 * @param {module:echarts/model/Model} model
 * @return {string} unique key
 */


function makeKey(model) {
  return model.type + '||' + model.id;
}

var axisPointerClazz = {};
/**
 * Base class of AxisView.
 */

var AxisView =
/** @class */
function (_super) {
  __extends$1(AxisView, _super);

  function AxisView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = AxisView.type;
    return _this;
  }
  /**
   * @override
   */


  AxisView.prototype.render = function (axisModel, ecModel, api, payload) {
    // FIXME
    // This process should proformed after coordinate systems updated
    // (axis scale updated), and should be performed each time update.
    // So put it here temporarily, although it is not appropriate to
    // put a model-writing procedure in `view`.
    this.axisPointerClass && fixValue(axisModel);

    _super.prototype.render.apply(this, arguments);

    this._doUpdateAxisPointerClass(axisModel, api, true);
  };
  /**
   * Action handler.
   */


  AxisView.prototype.updateAxisPointer = function (axisModel, ecModel, api, payload) {
    this._doUpdateAxisPointerClass(axisModel, api, false);
  };
  /**
   * @override
   */


  AxisView.prototype.remove = function (ecModel, api) {
    var axisPointer = this._axisPointer;
    axisPointer && axisPointer.remove(api);
  };
  /**
   * @override
   */


  AxisView.prototype.dispose = function (ecModel, api) {
    this._disposeAxisPointer(api);

    _super.prototype.dispose.apply(this, arguments);
  };

  AxisView.prototype._doUpdateAxisPointerClass = function (axisModel, api, forceRender) {
    var Clazz = AxisView.getAxisPointerClass(this.axisPointerClass);

    if (!Clazz) {
      return;
    }

    var axisPointerModel = getAxisPointerModel(axisModel);
    axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);
  };

  AxisView.prototype._disposeAxisPointer = function (api) {
    this._axisPointer && this._axisPointer.dispose(api);
    this._axisPointer = null;
  };

  AxisView.registerAxisPointerClass = function (type, clazz) {
    if (process.env.NODE_ENV !== 'production') {
      if (axisPointerClazz[type]) {
        throw new Error('axisPointer ' + type + ' exists');
      }
    }

    axisPointerClazz[type] = clazz;
  };

  AxisView.getAxisPointerClass = function (type) {
    return type && axisPointerClazz[type];
  };
  AxisView.type = 'axis';
  return AxisView;
}(ComponentView$1);

var AxisView$1 = AxisView;

var inner$3 = makeInner();
function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
  var axis = axisModel.axis;

  if (axis.scale.isBlank()) {
    return;
  } // TODO: TYPE


  var splitAreaModel = axisModel.getModel('splitArea');
  var areaStyleModel = splitAreaModel.getModel('areaStyle');
  var areaColors = areaStyleModel.get('color');
  var gridRect = gridModel.coordinateSystem.getRect();
  var ticksCoords = axis.getTicksCoords({
    tickModel: splitAreaModel,
    clamp: true
  });

  if (!ticksCoords.length) {
    return;
  } // For Making appropriate splitArea animation, the color and anid
  // should be corresponding to previous one if possible.


  var areaColorsLen = areaColors.length;
  var lastSplitAreaColors = inner$3(axisView).splitAreaColors;
  var newSplitAreaColors = createHashMap();
  var colorIndex = 0;

  if (lastSplitAreaColors) {
    for (var i = 0; i < ticksCoords.length; i++) {
      var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);

      if (cIndex != null) {
        colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
        break;
      }
    }
  }

  var prev = axis.toGlobalCoord(ticksCoords[0].coord);
  var areaStyle = areaStyleModel.getAreaStyle();
  areaColors = isArray$1(areaColors) ? areaColors : [areaColors];

  for (var i = 1; i < ticksCoords.length; i++) {
    var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
    var x = void 0;
    var y = void 0;
    var width = void 0;
    var height = void 0;

    if (axis.isHorizontal()) {
      x = prev;
      y = gridRect.y;
      width = tickCoord - x;
      height = gridRect.height;
      prev = x + width;
    } else {
      x = gridRect.x;
      y = prev;
      width = gridRect.width;
      height = tickCoord - y;
      prev = y + height;
    }

    var tickValue = ticksCoords[i - 1].tickValue;
    tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
    axisGroup.add(new Rect$1({
      anid: tickValue != null ? 'area_' + tickValue : null,
      shape: {
        x: x,
        y: y,
        width: width,
        height: height
      },
      style: defaults({
        fill: areaColors[colorIndex]
      }, areaStyle),
      autoBatch: true,
      silent: true
    }));
    colorIndex = (colorIndex + 1) % areaColorsLen;
  }

  inner$3(axisView).splitAreaColors = newSplitAreaColors;
}
function rectCoordAxisHandleRemove(axisView) {
  inner$3(axisView).splitAreaColors = null;
}

var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
var selfBuilderAttrs = ['splitArea', 'splitLine', 'minorSplitLine'];

var CartesianAxisView =
/** @class */
function (_super) {
  __extends$1(CartesianAxisView, _super);

  function CartesianAxisView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CartesianAxisView.type;
    _this.axisPointerClass = 'CartesianAxisPointer';
    return _this;
  }
  /**
   * @override
   */


  CartesianAxisView.prototype.render = function (axisModel, ecModel, api, payload) {
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group$3();
    this.group.add(this._axisGroup);

    if (!axisModel.get('show')) {
      return;
    }

    var gridModel = axisModel.getCoordSysModel();
    var layout$1 = layout(gridModel, axisModel);
    var axisBuilder = new AxisBuilder$1(axisModel, extend$2({
      handleAutoShown: function (elementType) {
        var cartesians = gridModel.coordinateSystem.getCartesians();

        for (var i = 0; i < cartesians.length; i++) {
          if (isIntervalOrLogScale(cartesians[i].getOtherAxis(axisModel.axis).scale)) {
            // Still show axis tick or axisLine if other axis is value / log
            return true;
          }
        } // Not show axisTick or axisLine if other axis is category / time


        return false;
      }
    }, layout$1));
    each$9(axisBuilderAttrs, axisBuilder.add, axisBuilder);

    this._axisGroup.add(axisBuilder.getGroup());

    each$9(selfBuilderAttrs, function (name) {
      if (axisModel.get([name, 'show'])) {
        axisElementBuilders[name](this, this._axisGroup, axisModel, gridModel);
      }
    }, this); // THIS is a special case for bar racing chart.
    // Update the axis label from the natural initial layout to
    // sorted layout should has no animation.

    var isInitialSortFromBarRacing = payload && payload.type === 'changeAxisOrder' && payload.isInitSort;

    if (!isInitialSortFromBarRacing) {
      groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    }

    _super.prototype.render.call(this, axisModel, ecModel, api, payload);
  };

  CartesianAxisView.prototype.remove = function () {
    rectCoordAxisHandleRemove(this);
  };

  CartesianAxisView.type = 'cartesianAxis';
  return CartesianAxisView;
}(AxisView$1);

var axisElementBuilders = {
  splitLine: function (axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;

    if (axis.scale.isBlank()) {
      return;
    }

    var splitLineModel = axisModel.getModel('splitLine');
    var lineStyleModel = splitLineModel.getModel('lineStyle');
    var lineColors = lineStyleModel.get('color');
    lineColors = isArray$1(lineColors) ? lineColors : [lineColors];
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    var p1 = [];
    var p2 = [];
    var lineStyle = lineStyleModel.getLineStyle();

    for (var i = 0; i < ticksCoords.length; i++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);

      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }

      var colorIndex = lineCount++ % lineColors.length;
      var tickValue = ticksCoords[i].tickValue;
      var line = new Line$1({
        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,
        autoBatch: true,
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        style: defaults({
          stroke: lineColors[colorIndex]
        }, lineStyle),
        silent: true
      });
      subPixelOptimizeLine(line.shape, lineStyle.lineWidth);
      axisGroup.add(line);
    }
  },
  minorSplitLine: function (axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    var minorSplitLineModel = axisModel.getModel('minorSplitLine');
    var lineStyleModel = minorSplitLineModel.getModel('lineStyle');
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var minorTicksCoords = axis.getMinorTicksCoords();

    if (!minorTicksCoords.length) {
      return;
    }

    var p1 = [];
    var p2 = [];
    var lineStyle = lineStyleModel.getLineStyle();

    for (var i = 0; i < minorTicksCoords.length; i++) {
      for (var k = 0; k < minorTicksCoords[i].length; k++) {
        var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);

        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }

        var line = new Line$1({
          anid: 'minor_line_' + minorTicksCoords[i][k].tickValue,
          autoBatch: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: lineStyle,
          silent: true
        });
        subPixelOptimizeLine(line.shape, lineStyle.lineWidth);
        axisGroup.add(line);
      }
    }
  },
  splitArea: function (axisView, axisGroup, axisModel, gridModel) {
    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
  }
};

var CartesianXAxisView =
/** @class */
function (_super) {
  __extends$1(CartesianXAxisView, _super);

  function CartesianXAxisView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CartesianXAxisView.type;
    return _this;
  }

  CartesianXAxisView.type = 'xAxis';
  return CartesianXAxisView;
}(CartesianAxisView);

var CartesianYAxisView =
/** @class */
function (_super) {
  __extends$1(CartesianYAxisView, _super);

  function CartesianYAxisView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CartesianXAxisView.type;
    return _this;
  }

  CartesianYAxisView.type = 'yAxis';
  return CartesianYAxisView;
}(CartesianAxisView);

var GridView =
/** @class */
function (_super) {
  __extends$1(GridView, _super);

  function GridView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'grid';
    return _this;
  }

  GridView.prototype.render = function (gridModel, ecModel) {
    this.group.removeAll();

    if (gridModel.get('show')) {
      this.group.add(new Rect$1({
        shape: gridModel.coordinateSystem.getRect(),
        style: defaults({
          fill: gridModel.get('backgroundColor')
        }, gridModel.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }
  };

  GridView.type = 'grid';
  return GridView;
}(ComponentView$1);

var extraOption = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function install$f(registers) {
  registers.registerComponentView(GridView);
  registers.registerComponentModel(GridModel$1);
  registers.registerCoordinateSystem('cartesian2d', Grid$1);
  axisModelCreator(registers, 'x', CartesianAxisModel, extraOption);
  axisModelCreator(registers, 'y', CartesianAxisModel, extraOption);
  registers.registerComponentView(CartesianXAxisView);
  registers.registerComponentView(CartesianYAxisView);
  registers.registerPreprocessor(function (option) {
    // Only create grid when need
    if (option.xAxis && option.yAxis && !option.grid) {
      option.grid = {};
    }
  });
}

var ATTR = '\0_ec_interaction_mutex';
function isTaken(zr, resourceKey) {
  return !!getStore(zr)[resourceKey];
}

function getStore(zr) {
  return zr[ATTR] || (zr[ATTR] = {});
}
/**
 * payload: {
 *     type: 'takeGlobalCursor',
 *     key: 'dataZoomSelect', or 'brush', or ...,
 *         If no userKey, release global cursor.
 * }
 */
// TODO: SELF REGISTERED.


registerAction({
  type: 'takeGlobalCursor',
  event: 'globalCursorTaken',
  update: 'update'
}, noop$1);

var RoamController =
/** @class */
function (_super) {
  __extends$1(RoamController, _super);

  function RoamController(zr) {
    var _this = _super.call(this) || this;

    _this._zr = zr; // Avoid two roamController bind the same handler

    var mousedownHandler = bind$1(_this._mousedownHandler, _this);
    var mousemoveHandler = bind$1(_this._mousemoveHandler, _this);
    var mouseupHandler = bind$1(_this._mouseupHandler, _this);
    var mousewheelHandler = bind$1(_this._mousewheelHandler, _this);
    var pinchHandler = bind$1(_this._pinchHandler, _this);
    /**
     * Notice: only enable needed types. For example, if 'zoom'
     * is not needed, 'zoom' should not be enabled, otherwise
     * default mousewheel behaviour (scroll page) will be disabled.
     */

    _this.enable = function (controlType, opt) {
      // Disable previous first
      this.disable();
      this._opt = defaults(clone$3(opt) || {}, {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        // By default, wheel do not trigger move.
        moveOnMouseWheel: false,
        preventDefaultMouseMove: true
      });

      if (controlType == null) {
        controlType = true;
      }

      if (controlType === true || controlType === 'move' || controlType === 'pan') {
        zr.on('mousedown', mousedownHandler);
        zr.on('mousemove', mousemoveHandler);
        zr.on('mouseup', mouseupHandler);
      }

      if (controlType === true || controlType === 'scale' || controlType === 'zoom') {
        zr.on('mousewheel', mousewheelHandler);
        zr.on('pinch', pinchHandler);
      }
    };

    _this.disable = function () {
      zr.off('mousedown', mousedownHandler);
      zr.off('mousemove', mousemoveHandler);
      zr.off('mouseup', mouseupHandler);
      zr.off('mousewheel', mousewheelHandler);
      zr.off('pinch', pinchHandler);
    };

    return _this;
  }

  RoamController.prototype.isDragging = function () {
    return this._dragging;
  };

  RoamController.prototype.isPinching = function () {
    return this._pinching;
  };

  RoamController.prototype.setPointerChecker = function (pointerChecker) {
    this.pointerChecker = pointerChecker;
  };

  RoamController.prototype.dispose = function () {
    this.disable();
  };

  RoamController.prototype._mousedownHandler = function (e) {
    if (isMiddleOrRightButtonOnMouseUpDown(e)) {
      return;
    }

    var el = e.target;

    while (el) {
      if (el.draggable) {
        return;
      } // check if host is draggable


      el = el.__hostTarget || el.parent;
    }

    var x = e.offsetX;
    var y = e.offsetY; // Only check on mosedown, but not mousemove.
    // Mouse can be out of target when mouse moving.

    if (this.pointerChecker && this.pointerChecker(e, x, y)) {
      this._x = x;
      this._y = y;
      this._dragging = true;
    }
  };

  RoamController.prototype._mousemoveHandler = function (e) {
    if (!this._dragging || !isAvailableBehavior('moveOnMouseMove', e, this._opt) || e.gestureEvent === 'pinch' || isTaken(this._zr, 'globalPan')) {
      return;
    }

    var x = e.offsetX;
    var y = e.offsetY;
    var oldX = this._x;
    var oldY = this._y;
    var dx = x - oldX;
    var dy = y - oldY;
    this._x = x;
    this._y = y;
    this._opt.preventDefaultMouseMove && stop(e.event);
    trigger(this, 'pan', 'moveOnMouseMove', e, {
      dx: dx,
      dy: dy,
      oldX: oldX,
      oldY: oldY,
      newX: x,
      newY: y,
      isAvailableBehavior: null
    });
  };

  RoamController.prototype._mouseupHandler = function (e) {
    if (!isMiddleOrRightButtonOnMouseUpDown(e)) {
      this._dragging = false;
    }
  };

  RoamController.prototype._mousewheelHandler = function (e) {
    var shouldZoom = isAvailableBehavior('zoomOnMouseWheel', e, this._opt);
    var shouldMove = isAvailableBehavior('moveOnMouseWheel', e, this._opt);
    var wheelDelta = e.wheelDelta;
    var absWheelDeltaDelta = Math.abs(wheelDelta);
    var originX = e.offsetX;
    var originY = e.offsetY; // wheelDelta maybe -0 in chrome mac.

    if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
      return;
    } // If both `shouldZoom` and `shouldMove` is true, trigger
    // their event both, and the final behavior is determined
    // by event listener themselves.


    if (shouldZoom) {
      // Convenience:
      // Mac and VM Windows on Mac: scroll up: zoom out.
      // Windows: scroll up: zoom in.
      // FIXME: Should do more test in different environment.
      // wheelDelta is too complicated in difference nvironment
      // (https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel),
      // although it has been normallized by zrender.
      // wheelDelta of mouse wheel is bigger than touch pad.
      var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
      var scale = wheelDelta > 0 ? factor : 1 / factor;
      checkPointerAndTrigger(this, 'zoom', 'zoomOnMouseWheel', e, {
        scale: scale,
        originX: originX,
        originY: originY,
        isAvailableBehavior: null
      });
    }

    if (shouldMove) {
      // FIXME: Should do more test in different environment.
      var absDelta = Math.abs(wheelDelta); // wheelDelta of mouse wheel is bigger than touch pad.

      var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
      checkPointerAndTrigger(this, 'scrollMove', 'moveOnMouseWheel', e, {
        scrollDelta: scrollDelta,
        originX: originX,
        originY: originY,
        isAvailableBehavior: null
      });
    }
  };

  RoamController.prototype._pinchHandler = function (e) {
    if (isTaken(this._zr, 'globalPan')) {
      return;
    }

    var scale = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
    checkPointerAndTrigger(this, 'zoom', null, e, {
      scale: scale,
      originX: e.pinchX,
      originY: e.pinchY,
      isAvailableBehavior: null
    });
  };

  return RoamController;
}(Eventful$1);

function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
  if (controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY)) {
    // When mouse is out of roamController rect,
    // default befavoius should not be be disabled, otherwise
    // page sliding is disabled, contrary to expectation.
    stop(e.event);
    trigger(controller, eventName, behaviorToCheck, e, contollerEvent);
  }
}

function trigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
  // Also provide behavior checker for event listener, for some case that
  // multiple components share one listener.
  contollerEvent.isAvailableBehavior = bind$1(isAvailableBehavior, null, behaviorToCheck, e); // TODO should not have type issue.

  controller.trigger(eventName, contollerEvent);
} // settings: {
//     zoomOnMouseWheel
//     moveOnMouseMove
//     moveOnMouseWheel
// }
// The value can be: true / false / 'shift' / 'ctrl' / 'alt'.


function isAvailableBehavior(behaviorToCheck, e, settings) {
  var setting = settings[behaviorToCheck];
  return !behaviorToCheck || setting && (!isString(setting) || e.event[setting + 'Key']);
}

var RoamController$1 = RoamController;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * For geo and graph.
 */
function updateViewOnPan(controllerHost, dx, dy) {
  var target = controllerHost.target;
  target.x += dx;
  target.y += dy;
  target.dirty();
}
/**
 * For geo and graph.
 */

function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
  var target = controllerHost.target;
  var zoomLimit = controllerHost.zoomLimit;
  var newZoom = controllerHost.zoom = controllerHost.zoom || 1;
  newZoom *= zoomDelta;

  if (zoomLimit) {
    var zoomMin = zoomLimit.min || 0;
    var zoomMax = zoomLimit.max || Infinity;
    newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
  }

  var zoomScale = newZoom / controllerHost.zoom;
  controllerHost.zoom = newZoom; // Keep the mouse center when scaling

  target.x -= (zoomX - target.x) * (zoomScale - 1);
  target.y -= (zoomY - target.y) * (zoomScale - 1);
  target.scaleX *= zoomScale;
  target.scaleY *= zoomScale;
  target.dirty();
}

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var IRRELEVANT_EXCLUDES = {
  'axisPointer': 1,
  'tooltip': 1,
  'brush': 1
};
/**
 * Avoid that: mouse click on a elements that is over geo or graph,
 * but roam is triggered.
 */

function onIrrelevantElement(e, api, targetCoordSysModel) {
  var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem.

  var coordSys = model && model.coordinateSystem;
  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES.hasOwnProperty(model.mainType) && coordSys && coordSys.model !== targetCoordSysModel;
}

function parseXML(svg) {
    if (isString(svg)) {
        var parser = new DOMParser();
        svg = parser.parseFromString(svg, 'text/xml');
    }
    var svgNode = svg;
    if (svgNode.nodeType === 9) {
        svgNode = svgNode.firstChild;
    }
    while (svgNode.nodeName.toLowerCase() !== 'svg' || svgNode.nodeType !== 1) {
        svgNode = svgNode.nextSibling;
    }
    return svgNode;
}

var nodeParsers;
var INHERITABLE_STYLE_ATTRIBUTES_MAP = {
    'fill': 'fill',
    'stroke': 'stroke',
    'stroke-width': 'lineWidth',
    'opacity': 'opacity',
    'fill-opacity': 'fillOpacity',
    'stroke-opacity': 'strokeOpacity',
    'stroke-dasharray': 'lineDash',
    'stroke-dashoffset': 'lineDashOffset',
    'stroke-linecap': 'lineCap',
    'stroke-linejoin': 'lineJoin',
    'stroke-miterlimit': 'miterLimit',
    'font-family': 'fontFamily',
    'font-size': 'fontSize',
    'font-style': 'fontStyle',
    'font-weight': 'fontWeight',
    'text-anchor': 'textAlign',
    'visibility': 'visibility',
    'display': 'display'
};
var INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys(INHERITABLE_STYLE_ATTRIBUTES_MAP);
var SELF_STYLE_ATTRIBUTES_MAP = {
    'alignment-baseline': 'textBaseline',
    'stop-color': 'stopColor'
};
var SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys(SELF_STYLE_ATTRIBUTES_MAP);
var SVGParser = (function () {
    function SVGParser() {
        this._defs = {};
        this._root = null;
    }
    SVGParser.prototype.parse = function (xml, opt) {
        opt = opt || {};
        var svg = parseXML(xml);
        if (process.env.NODE_ENV !== 'production') {
            if (!svg) {
                throw new Error('Illegal svg');
            }
        }
        this._defsUsePending = [];
        var root = new Group$3();
        this._root = root;
        var named = [];
        var viewBox = svg.getAttribute('viewBox') || '';
        var width = parseFloat((svg.getAttribute('width') || opt.width));
        var height = parseFloat((svg.getAttribute('height') || opt.height));
        isNaN(width) && (width = null);
        isNaN(height) && (height = null);
        parseAttributes(svg, root, null, true, false);
        var child = svg.firstChild;
        while (child) {
            this._parseNode(child, root, named, null, false, false);
            child = child.nextSibling;
        }
        applyDefs(this._defs, this._defsUsePending);
        this._defsUsePending = [];
        var viewBoxRect;
        var viewBoxTransform;
        if (viewBox) {
            var viewBoxArr = splitNumberSequence(viewBox);
            if (viewBoxArr.length >= 4) {
                viewBoxRect = {
                    x: parseFloat((viewBoxArr[0] || 0)),
                    y: parseFloat((viewBoxArr[1] || 0)),
                    width: parseFloat(viewBoxArr[2]),
                    height: parseFloat(viewBoxArr[3])
                };
            }
        }
        if (viewBoxRect && width != null && height != null) {
            viewBoxTransform = makeViewBoxTransform(viewBoxRect, { x: 0, y: 0, width: width, height: height });
            if (!opt.ignoreViewBox) {
                var elRoot = root;
                root = new Group$3();
                root.add(elRoot);
                elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;
                elRoot.x = viewBoxTransform.x;
                elRoot.y = viewBoxTransform.y;
            }
        }
        if (!opt.ignoreRootClip && width != null && height != null) {
            root.setClipPath(new Rect$1({
                shape: { x: 0, y: 0, width: width, height: height }
            }));
        }
        return {
            root: root,
            width: width,
            height: height,
            viewBoxRect: viewBoxRect,
            viewBoxTransform: viewBoxTransform,
            named: named
        };
    };
    SVGParser.prototype._parseNode = function (xmlNode, parentGroup, named, namedFrom, isInDefs, isInText) {
        var nodeName = xmlNode.nodeName.toLowerCase();
        var el;
        var namedFromForSub = namedFrom;
        if (nodeName === 'defs') {
            isInDefs = true;
        }
        if (nodeName === 'text') {
            isInText = true;
        }
        if (nodeName === 'defs' || nodeName === 'switch') {
            el = parentGroup;
        }
        else {
            if (!isInDefs) {
                var parser_1 = nodeParsers[nodeName];
                if (parser_1 && hasOwn(nodeParsers, nodeName)) {
                    el = parser_1.call(this, xmlNode, parentGroup);
                    var nameAttr = xmlNode.getAttribute('name');
                    if (nameAttr) {
                        var newNamed = {
                            name: nameAttr,
                            namedFrom: null,
                            svgNodeTagLower: nodeName,
                            el: el
                        };
                        named.push(newNamed);
                        if (nodeName === 'g') {
                            namedFromForSub = newNamed;
                        }
                    }
                    else if (namedFrom) {
                        named.push({
                            name: namedFrom.name,
                            namedFrom: namedFrom,
                            svgNodeTagLower: nodeName,
                            el: el
                        });
                    }
                    parentGroup.add(el);
                }
            }
            var parser = paintServerParsers[nodeName];
            if (parser && hasOwn(paintServerParsers, nodeName)) {
                var def = parser.call(this, xmlNode);
                var id = xmlNode.getAttribute('id');
                if (id) {
                    this._defs[id] = def;
                }
            }
        }
        if (el && el.isGroup) {
            var child = xmlNode.firstChild;
            while (child) {
                if (child.nodeType === 1) {
                    this._parseNode(child, el, named, namedFromForSub, isInDefs, isInText);
                }
                else if (child.nodeType === 3 && isInText) {
                    this._parseText(child, el);
                }
                child = child.nextSibling;
            }
        }
    };
    SVGParser.prototype._parseText = function (xmlNode, parentGroup) {
        var text = new TSpan$1({
            style: {
                text: xmlNode.textContent
            },
            silent: true,
            x: this._textX || 0,
            y: this._textY || 0
        });
        inheritStyle(parentGroup, text);
        parseAttributes(xmlNode, text, this._defsUsePending, false, false);
        applyTextAlignment(text, parentGroup);
        var textStyle = text.style;
        var fontSize = textStyle.fontSize;
        if (fontSize && fontSize < 9) {
            textStyle.fontSize = 9;
            text.scaleX *= fontSize / 9;
            text.scaleY *= fontSize / 9;
        }
        var font = (textStyle.fontSize || textStyle.fontFamily) && [
            textStyle.fontStyle,
            textStyle.fontWeight,
            (textStyle.fontSize || 12) + 'px',
            textStyle.fontFamily || 'sans-serif'
        ].join(' ');
        textStyle.font = font;
        var rect = text.getBoundingRect();
        this._textX += rect.width;
        parentGroup.add(text);
        return text;
    };
    SVGParser.internalField = (function () {
        nodeParsers = {
            'g': function (xmlNode, parentGroup) {
                var g = new Group$3();
                inheritStyle(parentGroup, g);
                parseAttributes(xmlNode, g, this._defsUsePending, false, false);
                return g;
            },
            'rect': function (xmlNode, parentGroup) {
                var rect = new Rect$1();
                inheritStyle(parentGroup, rect);
                parseAttributes(xmlNode, rect, this._defsUsePending, false, false);
                rect.setShape({
                    x: parseFloat(xmlNode.getAttribute('x') || '0'),
                    y: parseFloat(xmlNode.getAttribute('y') || '0'),
                    width: parseFloat(xmlNode.getAttribute('width') || '0'),
                    height: parseFloat(xmlNode.getAttribute('height') || '0')
                });
                rect.silent = true;
                return rect;
            },
            'circle': function (xmlNode, parentGroup) {
                var circle = new Circle$1();
                inheritStyle(parentGroup, circle);
                parseAttributes(xmlNode, circle, this._defsUsePending, false, false);
                circle.setShape({
                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),
                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),
                    r: parseFloat(xmlNode.getAttribute('r') || '0')
                });
                circle.silent = true;
                return circle;
            },
            'line': function (xmlNode, parentGroup) {
                var line = new Line$1();
                inheritStyle(parentGroup, line);
                parseAttributes(xmlNode, line, this._defsUsePending, false, false);
                line.setShape({
                    x1: parseFloat(xmlNode.getAttribute('x1') || '0'),
                    y1: parseFloat(xmlNode.getAttribute('y1') || '0'),
                    x2: parseFloat(xmlNode.getAttribute('x2') || '0'),
                    y2: parseFloat(xmlNode.getAttribute('y2') || '0')
                });
                line.silent = true;
                return line;
            },
            'ellipse': function (xmlNode, parentGroup) {
                var ellipse = new Ellipse$1();
                inheritStyle(parentGroup, ellipse);
                parseAttributes(xmlNode, ellipse, this._defsUsePending, false, false);
                ellipse.setShape({
                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),
                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),
                    rx: parseFloat(xmlNode.getAttribute('rx') || '0'),
                    ry: parseFloat(xmlNode.getAttribute('ry') || '0')
                });
                ellipse.silent = true;
                return ellipse;
            },
            'polygon': function (xmlNode, parentGroup) {
                var pointsStr = xmlNode.getAttribute('points');
                var pointsArr;
                if (pointsStr) {
                    pointsArr = parsePoints(pointsStr);
                }
                var polygon = new Polygon$1({
                    shape: {
                        points: pointsArr || []
                    },
                    silent: true
                });
                inheritStyle(parentGroup, polygon);
                parseAttributes(xmlNode, polygon, this._defsUsePending, false, false);
                return polygon;
            },
            'polyline': function (xmlNode, parentGroup) {
                var pointsStr = xmlNode.getAttribute('points');
                var pointsArr;
                if (pointsStr) {
                    pointsArr = parsePoints(pointsStr);
                }
                var polyline = new Polyline$1({
                    shape: {
                        points: pointsArr || []
                    },
                    silent: true
                });
                inheritStyle(parentGroup, polyline);
                parseAttributes(xmlNode, polyline, this._defsUsePending, false, false);
                return polyline;
            },
            'image': function (xmlNode, parentGroup) {
                var img = new ZRImage$1();
                inheritStyle(parentGroup, img);
                parseAttributes(xmlNode, img, this._defsUsePending, false, false);
                img.setStyle({
                    image: xmlNode.getAttribute('xlink:href') || xmlNode.getAttribute('href'),
                    x: +xmlNode.getAttribute('x'),
                    y: +xmlNode.getAttribute('y'),
                    width: +xmlNode.getAttribute('width'),
                    height: +xmlNode.getAttribute('height')
                });
                img.silent = true;
                return img;
            },
            'text': function (xmlNode, parentGroup) {
                var x = xmlNode.getAttribute('x') || '0';
                var y = xmlNode.getAttribute('y') || '0';
                var dx = xmlNode.getAttribute('dx') || '0';
                var dy = xmlNode.getAttribute('dy') || '0';
                this._textX = parseFloat(x) + parseFloat(dx);
                this._textY = parseFloat(y) + parseFloat(dy);
                var g = new Group$3();
                inheritStyle(parentGroup, g);
                parseAttributes(xmlNode, g, this._defsUsePending, false, true);
                return g;
            },
            'tspan': function (xmlNode, parentGroup) {
                var x = xmlNode.getAttribute('x');
                var y = xmlNode.getAttribute('y');
                if (x != null) {
                    this._textX = parseFloat(x);
                }
                if (y != null) {
                    this._textY = parseFloat(y);
                }
                var dx = xmlNode.getAttribute('dx') || '0';
                var dy = xmlNode.getAttribute('dy') || '0';
                var g = new Group$3();
                inheritStyle(parentGroup, g);
                parseAttributes(xmlNode, g, this._defsUsePending, false, true);
                this._textX += parseFloat(dx);
                this._textY += parseFloat(dy);
                return g;
            },
            'path': function (xmlNode, parentGroup) {
                var d = xmlNode.getAttribute('d') || '';
                var path = createFromString(d);
                inheritStyle(parentGroup, path);
                parseAttributes(xmlNode, path, this._defsUsePending, false, false);
                path.silent = true;
                return path;
            }
        };
    })();
    return SVGParser;
}());
var paintServerParsers = {
    'lineargradient': function (xmlNode) {
        var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);
        var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);
        var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);
        var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);
        var gradient = new LinearGradient$1(x1, y1, x2, y2);
        parsePaintServerUnit(xmlNode, gradient);
        parseGradientColorStops(xmlNode, gradient);
        return gradient;
    },
    'radialgradient': function (xmlNode) {
        var cx = parseInt(xmlNode.getAttribute('cx') || '0', 10);
        var cy = parseInt(xmlNode.getAttribute('cy') || '0', 10);
        var r = parseInt(xmlNode.getAttribute('r') || '0', 10);
        var gradient = new RadialGradient$1(cx, cy, r);
        parsePaintServerUnit(xmlNode, gradient);
        parseGradientColorStops(xmlNode, gradient);
        return gradient;
    }
};
function parsePaintServerUnit(xmlNode, gradient) {
    var gradientUnits = xmlNode.getAttribute('gradientUnits');
    if (gradientUnits === 'userSpaceOnUse') {
        gradient.global = true;
    }
}
function parseGradientColorStops(xmlNode, gradient) {
    var stop = xmlNode.firstChild;
    while (stop) {
        if (stop.nodeType === 1
            && stop.nodeName.toLocaleLowerCase() === 'stop') {
            var offsetStr = stop.getAttribute('offset');
            var offset = void 0;
            if (offsetStr && offsetStr.indexOf('%') > 0) {
                offset = parseInt(offsetStr, 10) / 100;
            }
            else if (offsetStr) {
                offset = parseFloat(offsetStr);
            }
            else {
                offset = 0;
            }
            var styleVals = {};
            parseInlineStyle(stop, styleVals, styleVals);
            var stopColor = styleVals.stopColor
                || stop.getAttribute('stop-color')
                || '#000000';
            gradient.colorStops.push({
                offset: offset,
                color: stopColor
            });
        }
        stop = stop.nextSibling;
    }
}
function inheritStyle(parent, child) {
    if (parent && parent.__inheritedStyle) {
        if (!child.__inheritedStyle) {
            child.__inheritedStyle = {};
        }
        defaults(child.__inheritedStyle, parent.__inheritedStyle);
    }
}
function parsePoints(pointsString) {
    var list = splitNumberSequence(pointsString);
    var points = [];
    for (var i = 0; i < list.length; i += 2) {
        var x = parseFloat(list[i]);
        var y = parseFloat(list[i + 1]);
        points.push([x, y]);
    }
    return points;
}
function parseAttributes(xmlNode, el, defsUsePending, onlyInlineStyle, isTextGroup) {
    var disp = el;
    var inheritedStyle = disp.__inheritedStyle = disp.__inheritedStyle || {};
    var selfStyle = {};
    if (xmlNode.nodeType === 1) {
        parseTransformAttribute(xmlNode, el);
        parseInlineStyle(xmlNode, inheritedStyle, selfStyle);
        if (!onlyInlineStyle) {
            parseAttributeStyle(xmlNode, inheritedStyle, selfStyle);
        }
    }
    disp.style = disp.style || {};
    if (inheritedStyle.fill != null) {
        disp.style.fill = getFillStrokeStyle(disp, 'fill', inheritedStyle.fill, defsUsePending);
    }
    if (inheritedStyle.stroke != null) {
        disp.style.stroke = getFillStrokeStyle(disp, 'stroke', inheritedStyle.stroke, defsUsePending);
    }
    each$9([
        'lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'
    ], function (propName) {
        if (inheritedStyle[propName] != null) {
            disp.style[propName] = parseFloat(inheritedStyle[propName]);
        }
    });
    each$9([
        'lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign'
    ], function (propName) {
        if (inheritedStyle[propName] != null) {
            disp.style[propName] = inheritedStyle[propName];
        }
    });
    if (isTextGroup) {
        disp.__selfStyle = selfStyle;
    }
    if (inheritedStyle.lineDash) {
        disp.style.lineDash = map$1(splitNumberSequence(inheritedStyle.lineDash), function (str) {
            return parseFloat(str);
        });
    }
    if (inheritedStyle.visibility === 'hidden' || inheritedStyle.visibility === 'collapse') {
        disp.invisible = true;
    }
    if (inheritedStyle.display === 'none') {
        disp.ignore = true;
    }
}
function applyTextAlignment(text, parentGroup) {
    var parentSelfStyle = parentGroup.__selfStyle;
    if (parentSelfStyle) {
        var textBaseline = parentSelfStyle.textBaseline;
        var zrTextBaseline = textBaseline;
        if (!textBaseline || textBaseline === 'auto') {
            zrTextBaseline = 'alphabetic';
        }
        else if (textBaseline === 'baseline') {
            zrTextBaseline = 'alphabetic';
        }
        else if (textBaseline === 'before-edge' || textBaseline === 'text-before-edge') {
            zrTextBaseline = 'top';
        }
        else if (textBaseline === 'after-edge' || textBaseline === 'text-after-edge') {
            zrTextBaseline = 'bottom';
        }
        else if (textBaseline === 'central' || textBaseline === 'mathematical') {
            zrTextBaseline = 'middle';
        }
        text.style.textBaseline = zrTextBaseline;
    }
    var parentInheritedStyle = parentGroup.__inheritedStyle;
    if (parentInheritedStyle) {
        var textAlign = parentInheritedStyle.textAlign;
        var zrTextAlign = textAlign;
        if (textAlign) {
            if (textAlign === 'middle') {
                zrTextAlign = 'center';
            }
            text.style.textAlign = zrTextAlign;
        }
    }
}
var urlRegex = /^url\(\s*#(.*?)\)/;
function getFillStrokeStyle(el, method, str, defsUsePending) {
    var urlMatch = str && str.match(urlRegex);
    if (urlMatch) {
        var url = trim(urlMatch[1]);
        defsUsePending.push([el, method, url]);
        return;
    }
    if (str === 'none') {
        str = null;
    }
    return str;
}
function applyDefs(defs, defsUsePending) {
    for (var i = 0; i < defsUsePending.length; i++) {
        var item = defsUsePending[i];
        item[0].style[item[1]] = defs[item[2]];
    }
}
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function splitNumberSequence(rawStr) {
    return rawStr.match(numberReg) || [];
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g;
var DEGREE_TO_ANGLE = Math.PI / 180;
function parseTransformAttribute(xmlNode, node) {
    var transform = xmlNode.getAttribute('transform');
    if (transform) {
        transform = transform.replace(/,/g, ' ');
        var transformOps_1 = [];
        var mt = null;
        transform.replace(transformRegex, function (str, type, value) {
            transformOps_1.push(type, value);
            return '';
        });
        for (var i = transformOps_1.length - 1; i > 0; i -= 2) {
            var value = transformOps_1[i];
            var type = transformOps_1[i - 1];
            var valueArr = splitNumberSequence(value);
            mt = mt || create();
            switch (type) {
                case 'translate':
                    translate(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);
                    break;
                case 'scale':
                    scale$1(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);
                    break;
                case 'rotate':
                    rotate(mt, mt, -parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
                    break;
                case 'skewX':
                    var sx = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
                    mul(mt, [1, 0, sx, 1, 0, 0], mt);
                    break;
                case 'skewY':
                    var sy = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
                    mul(mt, [1, sy, 0, 1, 0, 0], mt);
                    break;
                case 'matrix':
                    mt[0] = parseFloat(valueArr[0]);
                    mt[1] = parseFloat(valueArr[1]);
                    mt[2] = parseFloat(valueArr[2]);
                    mt[3] = parseFloat(valueArr[3]);
                    mt[4] = parseFloat(valueArr[4]);
                    mt[5] = parseFloat(valueArr[5]);
                    break;
            }
        }
        node.setLocalTransform(mt);
    }
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function parseInlineStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
    var style = xmlNode.getAttribute('style');
    if (!style) {
        return;
    }
    styleRegex.lastIndex = 0;
    var styleRegResult;
    while ((styleRegResult = styleRegex.exec(style)) != null) {
        var svgStlAttr = styleRegResult[1];
        var zrInheritableStlAttr = hasOwn(INHERITABLE_STYLE_ATTRIBUTES_MAP, svgStlAttr)
            ? INHERITABLE_STYLE_ATTRIBUTES_MAP[svgStlAttr]
            : null;
        if (zrInheritableStlAttr) {
            inheritableStyleResult[zrInheritableStlAttr] = styleRegResult[2];
        }
        var zrSelfStlAttr = hasOwn(SELF_STYLE_ATTRIBUTES_MAP, svgStlAttr)
            ? SELF_STYLE_ATTRIBUTES_MAP[svgStlAttr]
            : null;
        if (zrSelfStlAttr) {
            selfStyleResult[zrSelfStlAttr] = styleRegResult[2];
        }
    }
}
function parseAttributeStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
    for (var i = 0; i < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
        var svgAttrName = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[i];
        var attrValue = xmlNode.getAttribute(svgAttrName);
        if (attrValue != null) {
            inheritableStyleResult[INHERITABLE_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
        }
    }
    for (var i = 0; i < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
        var svgAttrName = SELF_STYLE_ATTRIBUTES_MAP_KEYS[i];
        var attrValue = xmlNode.getAttribute(svgAttrName);
        if (attrValue != null) {
            selfStyleResult[SELF_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
        }
    }
}
function makeViewBoxTransform(viewBoxRect, boundingRect) {
    var scaleX = boundingRect.width / viewBoxRect.width;
    var scaleY = boundingRect.height / viewBoxRect.height;
    var scale = Math.min(scaleX, scaleY);
    return {
        scale: scale,
        x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + (boundingRect.x + boundingRect.width / 2),
        y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + (boundingRect.y + boundingRect.height / 2)
    };
}
function parseSVG(xml, opt) {
    var parser = new SVGParser();
    return parser.parse(xml, opt);
}

/**
 * "region available" means that: enable users to set attribute `name="xxx"` on those tags
 * to make it be a region.
 * 1. region styles and its label styles can be defined in echarts opton:
 * ```js
 * geo: {
 *     regions: [{
 *         name: 'xxx',
 *         itemStyle: { ... },
 *         label: { ... }
 *     }, {
 *         ...
 *     },
 *     ...]
 * };
 * ```
 * 2. name can be duplicated in different SVG tag. All of the tags with the same name share
 * a region option. For exampel if there are two <path> representing two lung lobes. They have
 * no common parents but both of them need to display label "lung" inside.
 */

var REGION_AVAILABLE_SVG_TAG_MAP = createHashMap(['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path', // <text> <tspan> are also enabled becuase some SVG might paint text itself,
// but still need to trigger events or tooltip.
'text', 'tspan', // <g> is also enabled because this case: if multiple tags share one name
// and need label displayed, every tags will display the name, which is not
// expected. So we can put them into a <g name="xxx">. Thereby only one label
// displayed and located based on the bounding rect of the <g>.
'g']);

var GeoSVGResource =
/** @class */
function () {
  function GeoSVGResource(mapName, svg) {
    this.type = 'geoSVG'; // All used graphics. key: hostKey, value: root

    this._usedGraphicMap = createHashMap(); // All unused graphics.

    this._freedGraphics = [];
    this._mapName = mapName; // Only perform parse to XML object here, which might be time
    // consiming for large SVG.
    // Although convert XML to zrender element is also time consiming,
    // if we do it here, the clone of zrender elements has to be
    // required. So we do it once for each geo instance, util real
    // performance issues call for optimizing it.

    this._parsedXML = parseXML(svg);
  }

  GeoSVGResource.prototype.load = function ()
  /* nameMap: NameMap */
  {
    // In the "load" stage, graphic need to be built to
    // get boundingRect for geo coordinate system.
    var firstGraphic = this._firstGraphic; // Create the return data structure only when first graphic created.
    // Because they will be used in geo coordinate system update stage,
    // and `regions` will be mounted at `geo` coordinate system,
    // in which there is no "view" info, so that it should better not to
    // make references to graphic elements.

    if (!firstGraphic) {
      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);

      this._freedGraphics.push(firstGraphic);

      this._boundingRect = this._firstGraphic.boundingRect.clone(); // PENDING: `nameMap` will not be supported until some real requirement come.
      // if (nameMap) {
      //     named = applyNameMap(named, nameMap);
      // }

      var _a = createRegions(firstGraphic.named),
          regions = _a.regions,
          regionsMap = _a.regionsMap;

      this._regions = regions;
      this._regionsMap = regionsMap;
    }

    return {
      boundingRect: this._boundingRect,
      regions: this._regions,
      regionsMap: this._regionsMap
    };
  };

  GeoSVGResource.prototype._buildGraphic = function (svgXML) {
    var result;
    var rootFromParse;

    try {
      result = svgXML && parseSVG(svgXML, {
        ignoreViewBox: true,
        ignoreRootClip: true
      }) || {};
      rootFromParse = result.root;
      assert(rootFromParse != null);
    } catch (e) {
      throw new Error('Invalid svg format\n' + e.message);
    } // Note: we keep the covenant that the root has no transform. So always add an extra root.


    var root = new Group$3();
    root.add(rootFromParse);
    root.isGeoSVGGraphicRoot = true; // [THE_RULE_OF_VIEWPORT_AND_VIEWBOX]
    //
    // Consider: `<svg width="..." height="..." viewBox="...">`
    // - the `width/height` we call it `svgWidth/svgHeight` for short.
    // - `(0, 0, svgWidth, svgHeight)` defines the viewport of the SVG, or say,
    //   "viewport boundingRect", or `boundingRect` for short.
    // - `viewBox` defines the transform from the real content ot the viewport.
    //   `viewBox` has the same unit as the content of SVG.
    //   If `viewBox` exists, a transform is defined, so the unit of `svgWidth/svgHeight` become
    //   different from the content of SVG. Otherwise, they are the same.
    //
    // If both `svgWidth/svgHeight/viewBox` are specified in a SVG file, the transform rule will be:
    // 0. `boundingRect` is `(0, 0, svgWidth, svgHeight)`. Set it to Geo['_rect'] (View['_rect']).
    // 1. Make a transform from `viewBox` to `boundingRect`.
    //    Note: only suport `preserveAspectRatio 'xMidYMid'` here. That is, this transform will preserve
    //    the aspect ratio.
    // 2. Make a transform from boundingRect to Geo['_viewRect'] (View['_viewRect'])
    //    (`Geo`/`View` will do this job).
    //    Note: this transform might not preserve aspect radio, which depending on how users specify
    //    viewRect in echarts option (e.g., `geo.left/top/width/height` will not preserve aspect ratio,
    //    but `geo.layoutCenter/layoutSize` will preserve aspect ratio).
    //
    // If `svgWidth/svgHeight` not specified, we use `viewBox` as the `boundingRect` to make the SVG
    // layout look good.
    //
    // If neither `svgWidth/svgHeight` nor `viewBox` are not specified, we calculate the boundingRect
    // of the SVG content and use them to make SVG layout look good.

    var svgWidth = result.width;
    var svgHeight = result.height;
    var viewBoxRect = result.viewBoxRect;
    var boundingRect = this._boundingRect;

    if (!boundingRect) {
      var bRectX = void 0;
      var bRectY = void 0;
      var bRectWidth = void 0;
      var bRectHeight = void 0;

      if (svgWidth != null) {
        bRectX = 0;
        bRectWidth = svgWidth;
      } else if (viewBoxRect) {
        bRectX = viewBoxRect.x;
        bRectWidth = viewBoxRect.width;
      }

      if (svgHeight != null) {
        bRectY = 0;
        bRectHeight = svgHeight;
      } else if (viewBoxRect) {
        bRectY = viewBoxRect.y;
        bRectHeight = viewBoxRect.height;
      } // If both viewBox and svgWidth/svgHeight not specified,
      // we have to determine how to layout those element to make them look good.


      if (bRectX == null || bRectY == null) {
        var calculatedBoundingRect = rootFromParse.getBoundingRect();

        if (bRectX == null) {
          bRectX = calculatedBoundingRect.x;
          bRectWidth = calculatedBoundingRect.width;
        }

        if (bRectY == null) {
          bRectY = calculatedBoundingRect.y;
          bRectHeight = calculatedBoundingRect.height;
        }
      }

      boundingRect = this._boundingRect = new BoundingRect$1(bRectX, bRectY, bRectWidth, bRectHeight);
    }

    if (viewBoxRect) {
      var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect); // Only support `preserveAspectRatio 'xMidYMid'`

      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;
      rootFromParse.x = viewBoxTransform.x;
      rootFromParse.y = viewBoxTransform.y;
    } // SVG needs to clip based on `viewBox`. And some SVG files really rely on this feature.
    // They do not strictly confine all of the content inside a display rect, but deliberately
    // use a `viewBox` to define a displayable rect.
    // PENDING:
    // The drawback of the `setClipPath` here is: the region label (genereted by echarts) near the
    // edge might also be clipped, because region labels are put as `textContent` of the SVG path.


    root.setClipPath(new Rect$1({
      shape: boundingRect.plain()
    }));
    var named = [];
    each$9(result.named, function (namedItem) {
      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {
        named.push(namedItem);
        setSilent(namedItem.el);
      }
    });
    return {
      root: root,
      boundingRect: boundingRect,
      named: named
    };
  };
  /**
   * Consider:
   * (1) One graphic element can not be shared by different `geoView` running simultaneously.
   *     Notice, also need to consider multiple echarts instances share a `mapRecord`.
   * (2) Converting SVG to graphic elements is time consuming.
   * (3) In the current architecture, `load` should be called frequently to get boundingRect,
   *     and it is called without view info.
   * So we maintain graphic elements in this module, and enables `view` to use/return these
   * graphics from/to the pool with it's uid.
   */


  GeoSVGResource.prototype.useGraphic = function (hostKey
  /*, nameMap: NameMap */
  ) {
    var usedRootMap = this._usedGraphicMap;
    var svgGraphic = usedRootMap.get(hostKey);

    if (svgGraphic) {
      return svgGraphic;
    }

    svgGraphic = this._freedGraphics.pop() // use the first boundingRect to avoid duplicated boundingRect calculation.
    || this._buildGraphic(this._parsedXML);
    usedRootMap.set(hostKey, svgGraphic); // PENDING: `nameMap` will not be supported until some real requirement come.
    // `nameMap` can only be obtained from echarts option.
    // The original `named` must not be modified.
    // if (nameMap) {
    //     svgGraphic = extend({}, svgGraphic);
    //     svgGraphic.named = applyNameMap(svgGraphic.named, nameMap);
    // }

    return svgGraphic;
  };

  GeoSVGResource.prototype.freeGraphic = function (hostKey) {
    var usedRootMap = this._usedGraphicMap;
    var svgGraphic = usedRootMap.get(hostKey);

    if (svgGraphic) {
      usedRootMap.removeKey(hostKey);

      this._freedGraphics.push(svgGraphic);
    }
  };

  return GeoSVGResource;
}();

function setSilent(el) {
  // Only named element has silent: false, other elements should
  // act as background and has no user interaction.
  el.silent = false; // text|tspan will be converted to group.

  if (el.isGroup) {
    el.traverse(function (child) {
      child.silent = false;
    });
  }
}

function createRegions(named) {
  var regions = [];
  var regionsMap = createHashMap(); // Create resions only for the first graphic.

  each$9(named, function (namedItem) {
    // Region has feature to calculate center for tooltip or other features.
    // If there is a <g name="xxx">, the center should be the center of the
    // bounding rect of the g.
    if (namedItem.namedFrom != null) {
      return;
    }

    var region = new GeoSVGRegion(namedItem.name, namedItem.el); // PENDING: if `nameMap` supported, this region can not be mounted on
    // `this`, but can only be created each time `load()` called.

    regions.push(region); // PENDING: if multiple tag named with the same name, only one will be
    // found by `_regionsMap`. `_regionsMap` is used to find a coordinate
    // by name. We use `region.getCenter()` as the coordinate.

    regionsMap.set(namedItem.name, region);
  });
  return {
    regions: regions,
    regionsMap: regionsMap
  };
} // PENDING: `nameMap` will not be supported until some real requirement come.
// /**
//  * Use the alias in geoNameMap.
//  * The input `named` must not be modified.
//  */
// function applyNameMap(
//     named: GeoSVGGraphicRecord['named'],
//     nameMap: NameMap
// ): GeoSVGGraphicRecord['named'] {
//     const result = [] as GeoSVGGraphicRecord['named'];
//     for (let i = 0; i < named.length; i++) {
//         let regionGraphic = named[i];
//         const name = regionGraphic.name;
//         if (nameMap && nameMap.hasOwnProperty(name)) {
//             regionGraphic = extend({}, regionGraphic);
//             regionGraphic.name = name;
//         }
//         result.push(regionGraphic);
//     }
//     return result;
// }

var geoCoord = [126, 25];
var nanhaiName = '南海诸岛';
var points$1 = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];

for (var i = 0; i < points$1.length; i++) {
  for (var k = 0; k < points$1[i].length; k++) {
    points$1[i][k][0] /= 10.5;
    points$1[i][k][1] /= -10.5 / 0.75;
    points$1[i][k][0] += geoCoord[0];
    points$1[i][k][1] += geoCoord[1];
  }
}

function fixNanhai(mapType, regions) {
  if (mapType === 'china') {
    for (var i = 0; i < regions.length; i++) {
      // Already exists.
      if (regions[i].name === nanhaiName) {
        return;
      }
    }

    regions.push(new GeoJSONRegion(nanhaiName, map$1(points$1, function (exterior) {
      return {
        type: 'polygon',
        exterior: exterior
      };
    }), geoCoord));
  }
}

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var coordsOffsetMap = {
  '南海诸岛': [32, 80],
  // 全国
  '广东': [0, -10],
  '香港': [10, 5],
  '澳门': [-10, 10],
  //'北京': [-10, 0],
  '天津': [5, 5]
};
function fixTextCoords(mapType, region) {
  if (mapType === 'china') {
    var coordFix = coordsOffsetMap[region.name];

    if (coordFix) {
      var cp = region.getCenter();
      cp[0] += coordFix[0] / 10.5;
      cp[1] += -coordFix[1] / (10.5 / 0.75);
      region.setCenter(cp);
    }
  }
}

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Fix for 钓鱼岛
// let Region = require('../Region');
// let zrUtil = require('zrender/lib/core/util');
// let geoCoord = [126, 25];
var points = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function fixDiaoyuIsland(mapType, region) {
  if (mapType === 'china' && region.name === '台湾') {
    region.geometries.push({
      type: 'polygon',
      exterior: points[0]
    });
  }
}

var DEFAULT_NAME_PROPERTY = 'name';

var GeoJSONResource =
/** @class */
function () {
  function GeoJSONResource(mapName, geoJSON, specialAreas) {
    this.type = 'geoJSON';
    this._parsedMap = createHashMap();
    this._mapName = mapName;
    this._specialAreas = specialAreas; // PENDING: delay the parse to the first usage to rapid up the FMP?

    this._geoJSON = parseInput(geoJSON);
  }
  /**
   * @param nameMap can be null/undefined
   * @param nameProperty can be null/undefined
   */


  GeoJSONResource.prototype.load = function (nameMap, nameProperty) {
    nameProperty = nameProperty || DEFAULT_NAME_PROPERTY;

    var parsed = this._parsedMap.get(nameProperty);

    if (!parsed) {
      var rawRegions = this._parseToRegions(nameProperty);

      parsed = this._parsedMap.set(nameProperty, {
        regions: rawRegions,
        boundingRect: calculateBoundingRect(rawRegions)
      });
    }

    var regionsMap = createHashMap();
    var finalRegions = [];
    each$9(parsed.regions, function (region) {
      var regionName = region.name; // Try use the alias in geoNameMap

      if (nameMap && hasOwn(nameMap, regionName)) {
        region = region.cloneShallow(regionName = nameMap[regionName]);
      }

      finalRegions.push(region);
      regionsMap.set(regionName, region);
    });
    return {
      regions: finalRegions,
      boundingRect: parsed.boundingRect || new BoundingRect$1(0, 0, 0, 0),
      regionsMap: regionsMap
    };
  };

  GeoJSONResource.prototype._parseToRegions = function (nameProperty) {
    var mapName = this._mapName;
    var geoJSON = this._geoJSON;
    var rawRegions; // https://jsperf.com/try-catch-performance-overhead

    try {
      rawRegions = geoJSON ? parseGeoJSON(geoJSON, nameProperty) : [];
    } catch (e) {
      throw new Error('Invalid geoJson format\n' + e.message);
    }

    fixNanhai(mapName, rawRegions);
    each$9(rawRegions, function (region) {
      var regionName = region.name;
      fixTextCoords(mapName, region);
      fixDiaoyuIsland(mapName, region); // Some area like Alaska in USA map needs to be tansformed
      // to look better

      var specialArea = this._specialAreas && this._specialAreas[regionName];

      if (specialArea) {
        region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
      }
    }, this);
    return rawRegions;
  };
  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */


  GeoJSONResource.prototype.getMapForUser = function () {
    return {
      // For backward compatibility, use geoJson
      // PENDING: it has been returning them without clone.
      // do we need to avoid outsite modification?
      geoJson: this._geoJSON,
      geoJSON: this._geoJSON,
      specialAreas: this._specialAreas
    };
  };

  return GeoJSONResource;
}();

function calculateBoundingRect(regions) {
  var rect;

  for (var i = 0; i < regions.length; i++) {
    var regionRect = regions[i].getBoundingRect();
    rect = rect || regionRect.clone();
    rect.union(regionRect);
  }

  return rect;
}

function parseInput(source) {
  return !isString(source) ? source : typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(source) : new Function('return (' + source + ');')();
}

var storage = createHashMap();
var geoSourceManager = {
  /**
   * Compatible with previous `echarts.registerMap`.
   *
   * @usage
   * ```js
   *
   * echarts.registerMap('USA', geoJson, specialAreas);
   *
   * echarts.registerMap('USA', {
   *     geoJson: geoJson,
   *     specialAreas: {...}
   * });
   * echarts.registerMap('USA', {
   *     geoJSON: geoJson,
   *     specialAreas: {...}
   * });
   *
   * echarts.registerMap('airport', {
   *     svg: svg
   * }
   * ```
   *
   * Note:
   * Do not support that register multiple geoJSON or SVG
   * one map name. Because different geoJSON and SVG have
   * different unit. It's not easy to make sure how those
   * units are mapping/normalize.
   * If intending to use multiple geoJSON or SVG, we can
   * use multiple geo coordinate system.
   */
  registerMap: function (mapName, rawDef, rawSpecialAreas) {
    if (rawDef.svg) {
      var resource = new GeoSVGResource(mapName, rawDef.svg);
      storage.set(mapName, resource);
    } else {
      // Recommend:
      //     echarts.registerMap('eu', { geoJSON: xxx, specialAreas: xxx });
      // Backward compatibility:
      //     echarts.registerMap('eu', geoJSON, specialAreas);
      //     echarts.registerMap('eu', { geoJson: xxx, specialAreas: xxx });
      var geoJSON = rawDef.geoJson || rawDef.geoJSON;

      if (geoJSON && !rawDef.features) {
        rawSpecialAreas = rawDef.specialAreas;
      } else {
        geoJSON = rawDef;
      }

      var resource = new GeoJSONResource(mapName, geoJSON, rawSpecialAreas);
      storage.set(mapName, resource);
    }
  },
  getGeoResource: function (mapName) {
    return storage.get(mapName);
  },

  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */
  getMapForUser: function (mapName) {
    var resource = storage.get(mapName); // Do not support return SVG until some real requirement come.

    return resource && resource.type === 'geoJSON' && resource.getMapForUser();
  },
  load: function (mapName, nameMap, nameProperty) {
    var resource = storage.get(mapName);

    if (!resource) {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Map ' + mapName + ' not exists. The GeoJSON of the map must be provided.');
      }

      return;
    }

    return resource.load(nameMap, nameProperty);
  }
};

/**
 * Only these tags enable use `itemStyle` if they are named in SVG.
 * Other tags like <text> <tspan> <image> might not suitable for `itemStyle`.
 * They will not be considered to be styled until some requirements come.
 */

var OPTION_STYLE_ENABLED_TAGS = ['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path'];
var OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS);
var STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(['g']));
var LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(['g']));
var mapLabelRaw = makeInner();

function getFixedItemStyle(model) {
  var itemStyle = model.getItemStyle();
  var areaColor = model.get('areaColor'); // If user want the color not to be changed when hover,
  // they should both set areaColor and color to be null.

  if (areaColor != null) {
    itemStyle.fill = areaColor;
  }

  return itemStyle;
} // Only stroke can be used for line.
// Using fill in style if stroke not exits.
// TODO Not sure yet. Perhaps a separate `lineStyle`?


function fixLineStyle(styleHost) {
  var style = styleHost.style;

  if (style) {
    style.stroke = style.stroke || style.fill;
    style.fill = null;
  }
}

var MapDraw =
/** @class */
function () {
  function MapDraw(api) {
    var group = new Group$3();
    this.uid = getUID('ec_map_draw');
    this._controller = new RoamController$1(api.getZr());
    this._controllerHost = {
      target: group
    };
    this.group = group;
    group.add(this._regionsGroup = new Group$3());
    group.add(this._svgGroup = new Group$3());
  }

  MapDraw.prototype.draw = function (mapOrGeoModel, ecModel, api, fromView, payload) {
    var isGeo = mapOrGeoModel.mainType === 'geo'; // Map series has data. GEO model that controlled by map series
    // will be assigned with map data. Other GEO model has no data.

    var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
    isGeo && ecModel.eachComponent({
      mainType: 'series',
      subType: 'map'
    }, function (mapSeries) {
      if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
        data = mapSeries.getData();
      }
    });
    var geo = mapOrGeoModel.coordinateSystem;
    var regionsGroup = this._regionsGroup;
    var group = this.group;
    var transformInfo = geo.getTransformInfo();
    var transformInfoRaw = transformInfo.raw;
    var transformInfoRoam = transformInfo.roam; // No animation when first draw or in action

    var isFirstDraw = !regionsGroup.childAt(0) || payload;

    if (isFirstDraw) {
      group.x = transformInfoRoam.x;
      group.y = transformInfoRoam.y;
      group.scaleX = transformInfoRoam.scaleX;
      group.scaleY = transformInfoRoam.scaleY;
      group.dirty();
    } else {
      updateProps$1(group, transformInfoRoam, mapOrGeoModel);
    }

    var isVisualEncodedByVisualMap = data && data.getVisual('visualMeta') && data.getVisual('visualMeta').length > 0;
    var viewBuildCtx = {
      api: api,
      geo: geo,
      mapOrGeoModel: mapOrGeoModel,
      data: data,
      isVisualEncodedByVisualMap: isVisualEncodedByVisualMap,
      isGeo: isGeo,
      transformInfoRaw: transformInfoRaw
    };

    if (geo.resourceType === 'geoJSON') {
      this._buildGeoJSON(viewBuildCtx);
    } else if (geo.resourceType === 'geoSVG') {
      this._buildSVG(viewBuildCtx);
    }

    this._updateController(mapOrGeoModel, ecModel, api);

    this._updateMapSelectHandler(mapOrGeoModel, regionsGroup, api, fromView);
  };

  MapDraw.prototype._buildGeoJSON = function (viewBuildCtx) {
    var regionsGroupByName = this._regionsGroupByName = createHashMap();
    var regionsInfoByName = createHashMap();
    var regionsGroup = this._regionsGroup;
    var transformInfoRaw = viewBuildCtx.transformInfoRaw;
    var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
    var data = viewBuildCtx.data;
    var projection = viewBuildCtx.geo.projection;
    var projectionStream = projection && projection.stream;

    function transformPoint(point, project) {
      if (project) {
        // projection may return null point.
        point = project(point);
      }

      return point && [point[0] * transformInfoRaw.scaleX + transformInfoRaw.x, point[1] * transformInfoRaw.scaleY + transformInfoRaw.y];
    }

    function transformPolygonPoints(inPoints) {
      var outPoints = []; // If projectionStream is provided. Use it instead of single point project.

      var project = !projectionStream && projection && projection.project;

      for (var i = 0; i < inPoints.length; ++i) {
        var newPt = transformPoint(inPoints[i], project);
        newPt && outPoints.push(newPt);
      }

      return outPoints;
    }

    function getPolyShape(points) {
      return {
        shape: {
          points: transformPolygonPoints(points)
        }
      };
    }

    regionsGroup.removeAll(); // Only when the resource is GeoJSON, there is `geo.regions`.

    each$9(viewBuildCtx.geo.regions, function (region) {
      var regionName = region.name; // Consider in GeoJson properties.name may be duplicated, for example,
      // there is multiple region named "United Kindom" or "France" (so many
      // colonies). And it is not appropriate to merge them in geo, which
      // will make them share the same label and bring trouble in label
      // location calculation.

      var regionGroup = regionsGroupByName.get(regionName);

      var _a = regionsInfoByName.get(regionName) || {},
          dataIdx = _a.dataIdx,
          regionModel = _a.regionModel;

      if (!regionGroup) {
        regionGroup = regionsGroupByName.set(regionName, new Group$3());
        regionsGroup.add(regionGroup);
        dataIdx = data ? data.indexOfName(regionName) : null;
        regionModel = viewBuildCtx.isGeo ? mapOrGeoModel.getRegionModel(regionName) : data ? data.getItemModel(dataIdx) : null;
        regionsInfoByName.set(regionName, {
          dataIdx: dataIdx,
          regionModel: regionModel
        });
      }

      var polygonSubpaths = [];
      var polylineSubpaths = [];
      each$9(region.geometries, function (geometry) {
        // Polygon and MultiPolygon
        if (geometry.type === 'polygon') {
          var polys = [geometry.exterior].concat(geometry.interiors || []);

          if (projectionStream) {
            polys = projectPolys(polys, projectionStream);
          }

          each$9(polys, function (poly) {
            polygonSubpaths.push(new Polygon$1(getPolyShape(poly)));
          });
        } // LineString and MultiLineString
        else {
            var points = geometry.points;

            if (projectionStream) {
              points = projectPolys(points, projectionStream, true);
            }

            each$9(points, function (points) {
              polylineSubpaths.push(new Polyline$1(getPolyShape(points)));
            });
          }
      });
      var centerPt = transformPoint(region.getCenter(), projection && projection.project);

      function createCompoundPath(subpaths, isLine) {
        if (!subpaths.length) {
          return;
        }

        var compoundPath = new CompoundPath$1({
          culling: true,
          segmentIgnoreThreshold: 1,
          shape: {
            paths: subpaths
          }
        });
        regionGroup.add(compoundPath);
        applyOptionStyleForRegion(viewBuildCtx, compoundPath, dataIdx, regionModel);
        resetLabelForRegion(viewBuildCtx, compoundPath, regionName, regionModel, mapOrGeoModel, dataIdx, centerPt);

        if (isLine) {
          fixLineStyle(compoundPath);
          each$9(compoundPath.states, fixLineStyle);
        }
      }

      createCompoundPath(polygonSubpaths);
      createCompoundPath(polylineSubpaths, true);
    }); // Ensure children have been added to `regionGroup` before calling them.

    regionsGroupByName.each(function (regionGroup, regionName) {
      var _a = regionsInfoByName.get(regionName),
          dataIdx = _a.dataIdx,
          regionModel = _a.regionModel;

      resetEventTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel, dataIdx);
      resetTooltipForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
      resetStateTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
    }, this);
  };

  MapDraw.prototype._buildSVG = function (viewBuildCtx) {
    var mapName = viewBuildCtx.geo.map;
    var transformInfoRaw = viewBuildCtx.transformInfoRaw;
    this._svgGroup.x = transformInfoRaw.x;
    this._svgGroup.y = transformInfoRaw.y;
    this._svgGroup.scaleX = transformInfoRaw.scaleX;
    this._svgGroup.scaleY = transformInfoRaw.scaleY;

    if (this._svgResourceChanged(mapName)) {
      this._freeSVG();

      this._useSVG(mapName);
    }

    var svgDispatcherMap = this._svgDispatcherMap = createHashMap();
    var focusSelf = false;
    each$9(this._svgGraphicRecord.named, function (namedItem) {
      // Note that we also allow different elements have the same name.
      // For example, a glyph of a city and the label of the city have
      // the same name and their tooltip info can be defined in a single
      // region option.
      var regionName = namedItem.name;
      var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
      var data = viewBuildCtx.data;
      var svgNodeTagLower = namedItem.svgNodeTagLower;
      var el = namedItem.el;
      var dataIdx = data ? data.indexOfName(regionName) : null;
      var regionModel = mapOrGeoModel.getRegionModel(regionName);

      if (OPTION_STYLE_ENABLED_TAG_MAP.get(svgNodeTagLower) != null && el instanceof Displayable$1) {
        applyOptionStyleForRegion(viewBuildCtx, el, dataIdx, regionModel);
      }

      if (el instanceof Displayable$1) {
        el.culling = true;
      } // We do not know how the SVG like so we'd better not to change z2.
      // Otherwise it might bring some unexpected result. For example,
      // an area hovered that make some inner city can not be clicked.


      el.z2EmphasisLift = 0; // If self named:

      if (!namedItem.namedFrom) {
        // label should batter to be displayed based on the center of <g>
        // if it is named rather than displayed on each child.
        if (LABEL_HOST_MAP.get(svgNodeTagLower) != null) {
          resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, null);
        }

        resetEventTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx);
        resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);

        if (STATE_TRIGGER_TAG_MAP.get(svgNodeTagLower) != null) {
          var focus_1 = resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);

          if (focus_1 === 'self') {
            focusSelf = true;
          }

          var els = svgDispatcherMap.get(regionName) || svgDispatcherMap.set(regionName, []);
          els.push(el);
        }
      }
    }, this);

    this._enableBlurEntireSVG(focusSelf, viewBuildCtx);
  };

  MapDraw.prototype._enableBlurEntireSVG = function (focusSelf, viewBuildCtx) {
    // It's a little complicated to support blurring the entire geoSVG in series-map.
    // So do not suport it until some requirements come.
    // At present, in series-map, only regions can be blurred.
    if (focusSelf && viewBuildCtx.isGeo) {
      var blurStyle = viewBuildCtx.mapOrGeoModel.getModel(['blur', 'itemStyle']).getItemStyle(); // Only suport `opacity` here. Because not sure that other props are suitable for
      // all of the elements generated by SVG (especially for Text/TSpan/Image/... ).

      var opacity_1 = blurStyle.opacity;

      this._svgGraphicRecord.root.traverse(function (el) {
        if (!el.isGroup) {
          // PENDING: clear those settings to SVG elements when `_freeSVG`.
          // (Currently it happen not to be needed.)
          setDefaultStateProxy(el);
          var style = el.ensureState('blur').style || {}; // Do not overwrite the region style that already set from region option.

          if (style.opacity == null && opacity_1 != null) {
            style.opacity = opacity_1;
          } // If `ensureState('blur').style = {}`, there will be default opacity.
          // Enable `stateTransition` (animation).


          el.ensureState('emphasis');
        }
      });
    }
  };

  MapDraw.prototype.remove = function () {
    this._regionsGroup.removeAll();

    this._regionsGroupByName = null;

    this._svgGroup.removeAll();

    this._freeSVG();

    this._controller.dispose();

    this._controllerHost = null;
  };

  MapDraw.prototype.findHighDownDispatchers = function (name, geoModel) {
    if (name == null) {
      return [];
    }

    var geo = geoModel.coordinateSystem;

    if (geo.resourceType === 'geoJSON') {
      var regionsGroupByName = this._regionsGroupByName;

      if (regionsGroupByName) {
        var regionGroup = regionsGroupByName.get(name);
        return regionGroup ? [regionGroup] : [];
      }
    } else if (geo.resourceType === 'geoSVG') {
      return this._svgDispatcherMap && this._svgDispatcherMap.get(name) || [];
    }
  };

  MapDraw.prototype._svgResourceChanged = function (mapName) {
    return this._svgMapName !== mapName;
  };

  MapDraw.prototype._useSVG = function (mapName) {
    var resource = geoSourceManager.getGeoResource(mapName);

    if (resource && resource.type === 'geoSVG') {
      var svgGraphic = resource.useGraphic(this.uid);

      this._svgGroup.add(svgGraphic.root);

      this._svgGraphicRecord = svgGraphic;
      this._svgMapName = mapName;
    }
  };

  MapDraw.prototype._freeSVG = function () {
    var mapName = this._svgMapName;

    if (mapName == null) {
      return;
    }

    var resource = geoSourceManager.getGeoResource(mapName);

    if (resource && resource.type === 'geoSVG') {
      resource.freeGraphic(this.uid);
    }

    this._svgGraphicRecord = null;
    this._svgDispatcherMap = null;

    this._svgGroup.removeAll();

    this._svgMapName = null;
  };

  MapDraw.prototype._updateController = function (mapOrGeoModel, ecModel, api) {
    var geo = mapOrGeoModel.coordinateSystem;
    var controller = this._controller;
    var controllerHost = this._controllerHost; // @ts-ignore FIXME:TS

    controllerHost.zoomLimit = mapOrGeoModel.get('scaleLimit');
    controllerHost.zoom = geo.getZoom(); // roamType is will be set default true if it is null
    // @ts-ignore FIXME:TS

    controller.enable(mapOrGeoModel.get('roam') || false);
    var mainType = mapOrGeoModel.mainType;

    function makeActionBase() {
      var action = {
        type: 'geoRoam',
        componentType: mainType
      };
      action[mainType + 'Id'] = mapOrGeoModel.id;
      return action;
    }

    controller.off('pan').on('pan', function (e) {
      this._mouseDownFlag = false;
      updateViewOnPan(controllerHost, e.dx, e.dy);
      api.dispatchAction(extend$2(makeActionBase(), {
        dx: e.dx,
        dy: e.dy,
        animation: {
          duration: 0
        }
      }));
    }, this);
    controller.off('zoom').on('zoom', function (e) {
      this._mouseDownFlag = false;
      updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
      api.dispatchAction(extend$2(makeActionBase(), {
        zoom: e.scale,
        originX: e.originX,
        originY: e.originY,
        animation: {
          duration: 0
        }
      }));
    }, this);
    controller.setPointerChecker(function (e, x, y) {
      return geo.containPoint([x, y]) && !onIrrelevantElement(e, api, mapOrGeoModel);
    });
  };
  /**
   * FIXME: this is a temporarily workaround.
   * When `geoRoam` the elements need to be reset in `MapView['render']`, because the props like
   * `ignore` might have been modified by `LabelManager`, and `LabelManager#addLabelsOfSeries`
   * will subsequently cache `defaultAttr` like `ignore`. If do not do this reset, the modified
   * props will have no chance to be restored.
   * Note: this reset should be after `clearStates` in `renderSeries` becuase `useStates` in
   * `renderSeries` will cache the modified `ignore` to `el._normalState`.
   * TODO:
   * Use clone/immutable in `LabelManager`?
   */


  MapDraw.prototype.resetForLabelLayout = function () {
    this.group.traverse(function (el) {
      var label = el.getTextContent();

      if (label) {
        label.ignore = mapLabelRaw(label).ignore;
      }
    });
  };

  MapDraw.prototype._updateMapSelectHandler = function (mapOrGeoModel, regionsGroup, api, fromView) {
    var mapDraw = this;
    regionsGroup.off('mousedown');
    regionsGroup.off('click'); // @ts-ignore FIXME:TS resolve type conflict

    if (mapOrGeoModel.get('selectedMode')) {
      regionsGroup.on('mousedown', function () {
        mapDraw._mouseDownFlag = true;
      });
      regionsGroup.on('click', function (e) {
        if (!mapDraw._mouseDownFlag) {
          return;
        }

        mapDraw._mouseDownFlag = false;
      });
    }
  };

  return MapDraw;
}();

function applyOptionStyleForRegion(viewBuildCtx, el, dataIndex, regionModel) {
  // All of the path are using `itemStyle`, becuase
  // (1) Some SVG also use fill on polyline (The different between
  // polyline and polygon is "open" or "close" but not fill or not).
  // (2) For the common props like opacity, if some use itemStyle
  // and some use `lineStyle`, it might confuse users.
  // (3) Most SVG use <path>, where can not detect wether draw a "line"
  // or a filled shape, so use `itemStyle` for <path>.
  var normalStyleModel = regionModel.getModel('itemStyle');
  var emphasisStyleModel = regionModel.getModel(['emphasis', 'itemStyle']);
  var blurStyleModel = regionModel.getModel(['blur', 'itemStyle']);
  var selectStyleModel = regionModel.getModel(['select', 'itemStyle']); // NOTE: DONT use 'style' in visual when drawing map.
  // This component is used for drawing underlying map for both geo component and map series.

  var normalStyle = getFixedItemStyle(normalStyleModel);
  var emphasisStyle = getFixedItemStyle(emphasisStyleModel);
  var selectStyle = getFixedItemStyle(selectStyleModel);
  var blurStyle = getFixedItemStyle(blurStyleModel); // Update the itemStyle if has data visual

  var data = viewBuildCtx.data;

  if (data) {
    // Only visual color of each item will be used. It can be encoded by visualMap
    // But visual color of series is used in symbol drawing
    // Visual color for each series is for the symbol draw
    var style = data.getItemVisual(dataIndex, 'style');
    var decal = data.getItemVisual(dataIndex, 'decal');

    if (viewBuildCtx.isVisualEncodedByVisualMap && style.fill) {
      normalStyle.fill = style.fill;
    }

    if (decal) {
      normalStyle.decal = createOrUpdatePatternFromDecal(decal, viewBuildCtx.api);
    }
  } // SVG text, tspan and image can be named but not supporeted
  // to be styled by region option yet.


  el.setStyle(normalStyle);
  el.style.strokeNoScale = true;
  el.ensureState('emphasis').style = emphasisStyle;
  el.ensureState('select').style = selectStyle;
  el.ensureState('blur').style = blurStyle; // Enable blur

  setDefaultStateProxy(el);
}

function resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, // Exist only if `viewBuildCtx.data` exists.
dataIdx, // If labelXY not provided, use `textConfig.position: 'inside'`
labelXY) {
  var data = viewBuildCtx.data;
  var isGeo = viewBuildCtx.isGeo;
  var isDataNaN = data && isNaN(data.get(data.mapDimension('value'), dataIdx));
  var itemLayout = data && data.getItemLayout(dataIdx); // In the following cases label will be drawn
  // 1. In map series and data value is NaN
  // 2. In geo component
  // 3. Region has no series legendIcon, which will be add a showLabel flag in mapSymbolLayout

  if (isGeo || isDataNaN || itemLayout && itemLayout.showLabel) {
    var query = !isGeo ? dataIdx : regionName;
    var labelFetcher = void 0; // Consider dataIdx not found.

    if (!data || dataIdx >= 0) {
      labelFetcher = mapOrGeoModel;
    }

    var specifiedTextOpt = labelXY ? {
      normal: {
        align: 'center',
        verticalAlign: 'middle'
      }
    } : null; // Caveat: must be called after `setDefaultStateProxy(el);` called.
    // because textContent will be assign with `el.stateProxy` inside.

    setLabelStyle(el, getLabelStatesModels(regionModel), {
      labelFetcher: labelFetcher,
      labelDataIndex: query,
      defaultText: regionName
    }, specifiedTextOpt);
    var textEl = el.getTextContent();

    if (textEl) {
      mapLabelRaw(textEl).ignore = textEl.ignore;

      if (el.textConfig && labelXY) {
        // Compute a relative offset based on the el bounding rect.
        var rect = el.getBoundingRect().clone(); // Need to make sure the percent position base on the same rect in normal and
        // emphasis state. Otherwise if using boundingRect of el, but the emphasis state
        // has borderWidth (even 0.5px), the text position will be changed obviously
        // if the position is very big like ['1234%', '1345%'].

        el.textConfig.layoutRect = rect;
        el.textConfig.position = [(labelXY[0] - rect.x) / rect.width * 100 + '%', (labelXY[1] - rect.y) / rect.height * 100 + '%'];
      }
    } // PENDING:
    // If labelLayout is enabled (test/label-layout.html), el.dataIndex should be specified.
    // But el.dataIndex is also used to determine whether user event should be triggered,
    // where el.seriesIndex or el.dataModel must be specified. At present for a single el
    // there is not case that "only label layout enabled but user event disabled", so here
    // we depends `resetEventTriggerForRegion` to do the job of setting `el.dataIndex`.


    el.disableLabelAnimation = true;
  } else {
    el.removeTextContent();
    el.removeTextConfig();
    el.disableLabelAnimation = null;
  }
}

function resetEventTriggerForRegion(viewBuildCtx, eventTrigger, regionName, regionModel, mapOrGeoModel, // Exist only if `viewBuildCtx.data` exists.
dataIdx) {
  // setItemGraphicEl, setHoverStyle after all polygons and labels
  // are added to the regionGroup
  if (viewBuildCtx.data) {
    // FIXME: when series-map use a SVG map, and there are duplicated name specified
    // on different SVG elements, after `data.setItemGraphicEl(...)`:
    // (1) all of them will be mounted with `dataIndex`, `seriesIndex`, so that tooltip
    // can be triggered only mouse hover. That's correct.
    // (2) only the last element will be kept in `data`, so that if trigger tooltip
    // by `dispatchAction`, only the last one can be found and triggered. That might be
    // not correct. We will fix it in future if anyone demanding that.
    viewBuildCtx.data.setItemGraphicEl(dataIdx, eventTrigger);
  } // series-map will not trigger "geoselectchange" no matter it is
  // based on a declared geo component. Because series-map will
  // trigger "selectchange". If it trigger both the two events,
  // If users call `chart.dispatchAction({type: 'toggleSelect'})`,
  // it not easy to also fire event "geoselectchanged".
  else {
      // Package custom mouse event for geo component
      getECData(eventTrigger).eventData = {
        componentType: 'geo',
        componentIndex: mapOrGeoModel.componentIndex,
        geoIndex: mapOrGeoModel.componentIndex,
        name: regionName,
        region: regionModel && regionModel.option || {}
      };
    }
}

function resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
  if (!viewBuildCtx.data) {
    setTooltipConfig({
      el: el,
      componentModel: mapOrGeoModel,
      itemName: regionName,
      // @ts-ignore FIXME:TS fix the "compatible with each other"?
      itemTooltipOption: regionModel.get('tooltip')
    });
  }
}

function resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
  // @ts-ignore FIXME:TS fix the "compatible with each other"?
  el.highDownSilentOnTouch = !!mapOrGeoModel.get('selectedMode'); // @ts-ignore FIXME:TS fix the "compatible with each other"?

  var emphasisModel = regionModel.getModel('emphasis');
  var focus = emphasisModel.get('focus');
  toggleHoverEmphasis(el, focus, emphasisModel.get('blurScope'), emphasisModel.get('disabled'));

  if (viewBuildCtx.isGeo) {
    enableComponentHighDownFeatures(el, mapOrGeoModel, regionName);
  }

  return focus;
}

function projectPolys(rings, // Polygons include exterior and interiors. Or polylines.
createStream, isLine) {
  var polygons = [];
  var curPoly;

  function startPolygon() {
    curPoly = [];
  }

  function endPolygon() {
    if (curPoly.length) {
      polygons.push(curPoly);
      curPoly = [];
    }
  }

  var stream = createStream({
    polygonStart: startPolygon,
    polygonEnd: endPolygon,
    lineStart: startPolygon,
    lineEnd: endPolygon,
    point: function (x, y) {
      // May have NaN values from stream.
      if (isFinite(x) && isFinite(y)) {
        curPoly.push([x, y]);
      }
    },
    sphere: function () {}
  });
  !isLine && stream.polygonStart();
  each$9(rings, function (ring) {
    stream.lineStart();

    for (var i = 0; i < ring.length; i++) {
      stream.point(ring[i][0], ring[i][1]);
    }

    stream.lineEnd();
  });
  !isLine && stream.polygonEnd();
  return polygons;
}

var MapDraw$1 = MapDraw; // @ts-ignore FIXME:TS fix the "compatible with each other"?

var MapView =
/** @class */
function (_super) {
  __extends$1(MapView, _super);

  function MapView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MapView.type;
    return _this;
  }

  MapView.prototype.render = function (mapModel, ecModel, api, payload) {
    // Not render if it is an toggleSelect action from self
    if (payload && payload.type === 'mapToggleSelect' && payload.from === this.uid) {
      return;
    }

    var group = this.group;
    group.removeAll();

    if (mapModel.getHostGeoModel()) {
      return;
    }

    if (this._mapDraw && payload && payload.type === 'geoRoam') {
      this._mapDraw.resetForLabelLayout();
    } // Not update map if it is an roam action from self


    if (!(payload && payload.type === 'geoRoam' && payload.componentType === 'series' && payload.seriesId === mapModel.id)) {
      if (mapModel.needsDrawMap) {
        var mapDraw = this._mapDraw || new MapDraw$1(api);
        group.add(mapDraw.group);
        mapDraw.draw(mapModel, ecModel, api, this, payload);
        this._mapDraw = mapDraw;
      } else {
        // Remove drawed map
        this._mapDraw && this._mapDraw.remove();
        this._mapDraw = null;
      }
    } else {
      var mapDraw = this._mapDraw;
      mapDraw && group.add(mapDraw.group);
    }

    mapModel.get('showLegendSymbol') && ecModel.getComponent('legend') && this._renderSymbols(mapModel, ecModel, api);
  };

  MapView.prototype.remove = function () {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
    this.group.removeAll();
  };

  MapView.prototype.dispose = function () {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
  };

  MapView.prototype._renderSymbols = function (mapModel, ecModel, api) {
    var originalData = mapModel.originalData;
    var group = this.group;
    originalData.each(originalData.mapDimension('value'), function (value, originalDataIndex) {
      if (isNaN(value)) {
        return;
      }

      var layout = originalData.getItemLayout(originalDataIndex);

      if (!layout || !layout.point) {
        // Not exists in map
        return;
      }

      var point = layout.point;
      var offset = layout.offset;
      var circle = new Circle$1({
        style: {
          // Because the special of map draw.
          // Which needs statistic of multiple series and draw on one map.
          // And each series also need a symbol with legend color
          //
          // Layout and visual are put one the different data
          // TODO
          fill: mapModel.getData().getVisual('style').fill
        },
        shape: {
          cx: point[0] + offset * 9,
          cy: point[1],
          r: 3
        },
        silent: true,
        // Do not overlap the first series, on which labels are displayed.
        z2: 8 + (!offset ? Z2_EMPHASIS_LIFT + 1 : 0)
      }); // Only the series that has the first value on the same region is in charge of rendering the label.
      // But consider the case:
      // series: [
      //     {id: 'X', type: 'map', map: 'm', {data: [{name: 'A', value: 11}, {name: 'B', {value: 22}]},
      //     {id: 'Y', type: 'map', map: 'm', {data: [{name: 'A', value: 21}, {name: 'C', {value: 33}]}
      // ]
      // The offset `0` of item `A` is at series `X`, but of item `C` is at series `Y`.
      // For backward compatibility, we follow the rule that render label `A` by the
      // settings on series `X` but render label `C` by the settings on series `Y`.

      if (!offset) {
        var fullData = mapModel.mainSeries.getData();
        var name_1 = originalData.getName(originalDataIndex);
        var fullIndex_1 = fullData.indexOfName(name_1);
        var itemModel = originalData.getItemModel(originalDataIndex);
        var labelModel = itemModel.getModel('label');
        var regionGroup = fullData.getItemGraphicEl(fullIndex_1); // `getFormattedLabel` needs to use `getData` inside. Here
        // `mapModel.getData()` is shallow cloned from `mainSeries.getData()`.
        // FIXME
        // If this is not the `mainSeries`, the item model (like label formatter)
        // set on original data item will never get. But it has been working
        // like that from the begining, and this scenario is rarely encountered.
        // So it won't be fixed until have to.

        setLabelStyle(circle, getLabelStatesModels(itemModel), {
          labelFetcher: {
            getFormattedLabel: function (idx, state) {
              return mapModel.getFormattedLabel(fullIndex_1, state);
            }
          },
          defaultText: name_1
        });
        circle.disableLabelAnimation = true;

        if (!labelModel.get('position')) {
          circle.setTextConfig({
            position: 'bottom'
          });
        }

        regionGroup.onHoverStateChange = function (toState) {
          setStatesFlag(circle, toState);
        };
      }

      group.add(circle);
    });
  };

  MapView.type = 'map';
  return MapView;
}(ChartView$1);

var MapView$1 = MapView;

var MapSeries =
/** @class */
function (_super) {
  __extends$1(MapSeries, _super);

  function MapSeries() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = MapSeries.type; // Only first map series of same mapType will drawMap.

    _this.needsDrawMap = false; // Group of all map series with same mapType

    _this.seriesGroup = [];

    _this.getTooltipPosition = function (dataIndex) {
      if (dataIndex != null) {
        var name_1 = this.getData().getName(dataIndex);
        var geo = this.coordinateSystem;
        var region = geo.getRegion(name_1);
        return region && geo.dataToPoint(region.getCenter());
      }
    };

    return _this;
  }

  MapSeries.prototype.getInitialData = function (option) {
    var data = createSeriesDataSimply(this, {
      coordDimensions: ['value'],
      encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
    });
    var dataNameMap = createHashMap();
    var toAppendNames = [];

    for (var i = 0, len = data.count(); i < len; i++) {
      var name_2 = data.getName(i);
      dataNameMap.set(name_2, true);
    }

    var geoSource = geoSourceManager.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
    each$9(geoSource.regions, function (region) {
      var name = region.name;

      if (!dataNameMap.get(name)) {
        toAppendNames.push(name);
      }
    }); // Complete data with missing regions. The consequent processes (like visual
    // map and render) can not be performed without a "full data". For example,
    // find `dataIndex` by name.

    data.appendValues([], toAppendNames);
    return data;
  };
  /**
   * If no host geo model, return null, which means using a
   * inner exclusive geo model.
   */


  MapSeries.prototype.getHostGeoModel = function () {
    var geoIndex = this.option.geoIndex;
    return geoIndex != null ? this.ecModel.getComponent('geo', geoIndex) : null;
  };

  MapSeries.prototype.getMapType = function () {
    return (this.getHostGeoModel() || this).option.map;
  }; // _fillOption(option, mapName) {
  // Shallow clone
  // option = zrUtil.extend({}, option);
  // option.data = geoCreator.getFilledRegions(option.data, mapName, option.nameMap);
  // return option;
  // }


  MapSeries.prototype.getRawValue = function (dataIndex) {
    // Use value stored in data instead because it is calculated from multiple series
    // FIXME Provide all value of multiple series ?
    var data = this.getData();
    return data.get(data.mapDimension('value'), dataIndex);
  };
  /**
   * Get model of region
   */


  MapSeries.prototype.getRegionModel = function (regionName) {
    var data = this.getData();
    return data.getItemModel(data.indexOfName(regionName));
  };
  /**
   * Map tooltip formatter
   */


  MapSeries.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
    // FIXME orignalData and data is a bit confusing
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var name = data.getName(dataIndex);
    var seriesGroup = this.seriesGroup;
    var seriesNames = [];

    for (var i = 0; i < seriesGroup.length; i++) {
      var otherIndex = seriesGroup[i].originalData.indexOfName(name);
      var valueDim = data.mapDimension('value');

      if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
        seriesNames.push(seriesGroup[i].name);
      }
    }

    return createTooltipMarkup('section', {
      header: seriesNames.join(', '),
      noHeader: !seriesNames.length,
      blocks: [createTooltipMarkup('nameValue', {
        name: name,
        value: value
      })]
    });
  };

  MapSeries.prototype.setZoom = function (zoom) {
    this.option.zoom = zoom;
  };

  MapSeries.prototype.setCenter = function (center) {
    this.option.center = center;
  };

  MapSeries.prototype.getLegendIcon = function (opt) {
    var iconType = opt.icon || 'roundRect';
    var icon = createSymbol(iconType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill);
    icon.setStyle(opt.itemStyle); // Map do not use itemStyle.borderWidth as border width

    icon.style.stroke = 'none'; // No rotation because no series visual symbol for map

    if (iconType.indexOf('empty') > -1) {
      icon.style.stroke = icon.style.fill;
      icon.style.fill = '#fff';
      icon.style.lineWidth = 2;
    }

    return icon;
  };

  MapSeries.type = 'series.map';
  MapSeries.dependencies = ['geo'];
  MapSeries.layoutMode = 'box';
  MapSeries.defaultOption = {
    // 一级层叠
    // zlevel: 0,
    // 二级层叠
    z: 2,
    coordinateSystem: 'geo',
    // map should be explicitly specified since ec3.
    map: '',
    // If `geoIndex` is not specified, a exclusive geo will be
    // created. Otherwise use the specified geo component, and
    // `map` and `mapType` are ignored.
    // geoIndex: 0,
    // 'center' | 'left' | 'right' | 'x%' | {number}
    left: 'center',
    // 'center' | 'top' | 'bottom' | 'x%' | {number}
    top: 'center',
    // right
    // bottom
    // width:
    // height
    // Aspect is width / height. Inited to be geoJson bbox aspect
    // This parameter is used for scale this aspect
    // Default value:
    // for geoSVG source: 1,
    // for geoJSON source: 0.75.
    aspectScale: null,
    ///// Layout with center and size
    // If you wan't to put map in a fixed size box with right aspect ratio
    // This two properties may more conveninet
    // layoutCenter: [50%, 50%]
    // layoutSize: 100
    showLegendSymbol: true,
    // Define left-top, right-bottom coords to control view
    // For example, [ [180, 90], [-180, -90] ],
    // higher priority than center and zoom
    boundingCoords: null,
    // Default on center of map
    center: null,
    zoom: 1,
    scaleLimit: null,
    selectedMode: true,
    label: {
      show: false,
      color: '#000'
    },
    // scaleLimit: null,
    itemStyle: {
      borderWidth: 0.5,
      borderColor: '#444',
      areaColor: '#eee'
    },
    emphasis: {
      label: {
        show: true,
        color: 'rgb(100,0,0)'
      },
      itemStyle: {
        areaColor: 'rgba(255,215,0,0.8)'
      }
    },
    select: {
      label: {
        show: true,
        color: 'rgb(100,0,0)'
      },
      itemStyle: {
        color: 'rgba(255,215,0,0.8)'
      }
    },
    nameProperty: 'name'
  };
  return MapSeries;
}(SeriesModel$1);

var MapSeries$1 = MapSeries;

function dataStatistics(datas, statisticType) {
  var dataNameMap = {};
  each$9(datas, function (data) {
    data.each(data.mapDimension('value'), function (value, idx) {
      // Add prefix to avoid conflict with Object.prototype.
      var mapKey = 'ec-' + data.getName(idx);
      dataNameMap[mapKey] = dataNameMap[mapKey] || [];

      if (!isNaN(value)) {
        dataNameMap[mapKey].push(value);
      }
    });
  });
  return datas[0].map(datas[0].mapDimension('value'), function (value, idx) {
    var mapKey = 'ec-' + datas[0].getName(idx);
    var sum = 0;
    var min = Infinity;
    var max = -Infinity;
    var len = dataNameMap[mapKey].length;

    for (var i = 0; i < len; i++) {
      min = Math.min(min, dataNameMap[mapKey][i]);
      max = Math.max(max, dataNameMap[mapKey][i]);
      sum += dataNameMap[mapKey][i];
    }

    var result;

    if (statisticType === 'min') {
      result = min;
    } else if (statisticType === 'max') {
      result = max;
    } else if (statisticType === 'average') {
      result = sum / len;
    } else {
      result = sum;
    }

    return len === 0 ? NaN : result;
  });
}

function mapDataStatistic(ecModel) {
  var seriesGroups = {};
  ecModel.eachSeriesByType('map', function (seriesModel) {
    var hostGeoModel = seriesModel.getHostGeoModel();
    var key = hostGeoModel ? 'o' + hostGeoModel.id : 'i' + seriesModel.getMapType();
    (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);
  });
  each$9(seriesGroups, function (seriesList, key) {
    var data = dataStatistics(map$1(seriesList, function (seriesModel) {
      return seriesModel.getData();
    }), seriesList[0].get('mapValueCalculation'));

    for (var i = 0; i < seriesList.length; i++) {
      seriesList[i].originalData = seriesList[i].getData();
    } // FIXME Put where?


    for (var i = 0; i < seriesList.length; i++) {
      seriesList[i].seriesGroup = seriesList;
      seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();
      seriesList[i].setData(data.cloneShallow());
      seriesList[i].mainSeries = seriesList[0];
    }
  });
}

function mapSymbolLayout(ecModel) {
  var processedMapType = {};
  ecModel.eachSeriesByType('map', function (mapSeries) {
    var mapType = mapSeries.getMapType();

    if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
      return;
    }

    var mapSymbolOffsets = {};
    each$9(mapSeries.seriesGroup, function (subMapSeries) {
      var geo = subMapSeries.coordinateSystem;
      var data = subMapSeries.originalData;

      if (subMapSeries.get('showLegendSymbol') && ecModel.getComponent('legend')) {
        data.each(data.mapDimension('value'), function (value, idx) {
          var name = data.getName(idx);
          var region = geo.getRegion(name); // If input series.data is [11, 22, '-'/null/undefined, 44],
          // it will be filled with NaN: [11, 22, NaN, 44] and NaN will
          // not be drawn. So here must validate if value is NaN.

          if (!region || isNaN(value)) {
            return;
          }

          var offset = mapSymbolOffsets[name] || 0;
          var point = geo.dataToPoint(region.getCenter());
          mapSymbolOffsets[name] = offset + 1;
          data.setItemLayout(idx, {
            point: point,
            offset: offset
          });
        });
      }
    }); // Show label of those region not has legendIcon (which is offset 0)

    var data = mapSeries.getData();
    data.each(function (idx) {
      var name = data.getName(idx);
      var layout = data.getItemLayout(idx) || {};
      layout.showLabel = !mapSymbolOffsets[name];
      data.setItemLayout(idx, layout);
    });
    processedMapType[mapType] = true;
  });
}

var v2ApplyTransform = applyTransform$1;

var View =
/** @class */
function (_super) {
  __extends$1(View, _super);

  function View(name) {
    var _this = _super.call(this) || this;

    _this.type = 'view';
    _this.dimensions = ['x', 'y'];
    /**
     * Represents the transform brought by roam/zoom.
     * If `View['_viewRect']` applies roam transform,
     * we can get the final displayed rect.
     */

    _this._roamTransformable = new Transformable$1();
    /**
     * Represents the transform from `View['_rect']` to `View['_viewRect']`.
     */

    _this._rawTransformable = new Transformable$1();
    _this.name = name;
    return _this;
  }

  View.prototype.setBoundingRect = function (x, y, width, height) {
    this._rect = new BoundingRect$1(x, y, width, height);
    return this._rect;
  };
  /**
   * @return {module:zrender/core/BoundingRect}
   */


  View.prototype.getBoundingRect = function () {
    return this._rect;
  };

  View.prototype.setViewRect = function (x, y, width, height) {
    this._transformTo(x, y, width, height);

    this._viewRect = new BoundingRect$1(x, y, width, height);
  };
  /**
   * Transformed to particular position and size
   */


  View.prototype._transformTo = function (x, y, width, height) {
    var rect = this.getBoundingRect();
    var rawTransform = this._rawTransformable;
    rawTransform.transform = rect.calculateTransform(new BoundingRect$1(x, y, width, height));
    var rawParent = rawTransform.parent;
    rawTransform.parent = null;
    rawTransform.decomposeTransform();
    rawTransform.parent = rawParent;

    this._updateTransform();
  };
  /**
   * Set center of view
   */


  View.prototype.setCenter = function (centerCoord, api) {
    if (!centerCoord) {
      return;
    }

    this._center = [parsePercent(centerCoord[0], api.getWidth()), parsePercent(centerCoord[1], api.getHeight())];

    this._updateCenterAndZoom();
  };

  View.prototype.setZoom = function (zoom) {
    zoom = zoom || 1;
    var zoomLimit = this.zoomLimit;

    if (zoomLimit) {
      if (zoomLimit.max != null) {
        zoom = Math.min(zoomLimit.max, zoom);
      }

      if (zoomLimit.min != null) {
        zoom = Math.max(zoomLimit.min, zoom);
      }
    }

    this._zoom = zoom;

    this._updateCenterAndZoom();
  };
  /**
   * Get default center without roam
   */


  View.prototype.getDefaultCenter = function () {
    // Rect before any transform
    var rawRect = this.getBoundingRect();
    var cx = rawRect.x + rawRect.width / 2;
    var cy = rawRect.y + rawRect.height / 2;
    return [cx, cy];
  };

  View.prototype.getCenter = function () {
    return this._center || this.getDefaultCenter();
  };

  View.prototype.getZoom = function () {
    return this._zoom || 1;
  };

  View.prototype.getRoamTransform = function () {
    return this._roamTransformable.getLocalTransform();
  };
  /**
   * Remove roam
   */


  View.prototype._updateCenterAndZoom = function () {
    // Must update after view transform updated
    var rawTransformMatrix = this._rawTransformable.getLocalTransform();

    var roamTransform = this._roamTransformable;
    var defaultCenter = this.getDefaultCenter();
    var center = this.getCenter();
    var zoom = this.getZoom();
    center = applyTransform$1([], center, rawTransformMatrix);
    defaultCenter = applyTransform$1([], defaultCenter, rawTransformMatrix);
    roamTransform.originX = center[0];
    roamTransform.originY = center[1];
    roamTransform.x = defaultCenter[0] - center[0];
    roamTransform.y = defaultCenter[1] - center[1];
    roamTransform.scaleX = roamTransform.scaleY = zoom;

    this._updateTransform();
  };
  /**
   * Update transform props on `this` based on the current
   * `this._roamTransformable` and `this._rawTransformable`.
   */


  View.prototype._updateTransform = function () {
    var roamTransformable = this._roamTransformable;
    var rawTransformable = this._rawTransformable;
    rawTransformable.parent = roamTransformable;
    roamTransformable.updateTransform();
    rawTransformable.updateTransform();
    copy(this.transform || (this.transform = []), rawTransformable.transform || create());
    this._rawTransform = rawTransformable.getLocalTransform();
    this.invTransform = this.invTransform || [];
    invert(this.invTransform, this.transform);
    this.decomposeTransform();
  };

  View.prototype.getTransformInfo = function () {
    var rawTransformable = this._rawTransformable;
    var roamTransformable = this._roamTransformable; // Becuase roamTransformabel has `originX/originY` modified,
    // but the caller of `getTransformInfo` can not handle `originX/originY`,
    // so need to recalcualte them.

    var dummyTransformable = new Transformable$1();
    dummyTransformable.transform = roamTransformable.transform;
    dummyTransformable.decomposeTransform();
    return {
      roam: {
        x: dummyTransformable.x,
        y: dummyTransformable.y,
        scaleX: dummyTransformable.scaleX,
        scaleY: dummyTransformable.scaleY
      },
      raw: {
        x: rawTransformable.x,
        y: rawTransformable.y,
        scaleX: rawTransformable.scaleX,
        scaleY: rawTransformable.scaleY
      }
    };
  };

  View.prototype.getViewRect = function () {
    return this._viewRect;
  };
  /**
   * Get view rect after roam transform
   */


  View.prototype.getViewRectAfterRoam = function () {
    var rect = this.getBoundingRect().clone();
    rect.applyTransform(this.transform);
    return rect;
  };
  /**
   * Convert a single (lon, lat) data item to (x, y) point.
   */


  View.prototype.dataToPoint = function (data, noRoam, out) {
    var transform = noRoam ? this._rawTransform : this.transform;
    out = out || [];
    return transform ? v2ApplyTransform(out, data, transform) : copy$1(out, data);
  };
  /**
   * Convert a (x, y) point to (lon, lat) data
   */


  View.prototype.pointToData = function (point) {
    var invTransform = this.invTransform;
    return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]];
  };

  View.prototype.convertToPixel = function (ecModel, finder, value) {
    var coordSys = getCoordSys$1(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };

  View.prototype.convertFromPixel = function (ecModel, finder, pixel) {
    var coordSys = getCoordSys$1(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };
  /**
   * @implements
   */


  View.prototype.containPoint = function (point) {
    return this.getViewRectAfterRoam().contain(point[0], point[1]);
  };

  View.dimensions = ['x', 'y'];
  return View;
}(Transformable$1);

function getCoordSys$1(finder) {
  var seriesModel = finder.seriesModel;
  return seriesModel ? seriesModel.coordinateSystem : null; // e.g., graph.
}

var View$1 = View;

var GEO_DEFAULT_PARAMS = {
  'geoJSON': {
    aspectScale: 0.75,
    invertLongitute: true
  },
  'geoSVG': {
    aspectScale: 1,
    invertLongitute: false
  }
};
var geo2DDimensions = ['lng', 'lat'];

var Geo =
/** @class */
function (_super) {
  __extends$1(Geo, _super);

  function Geo(name, map, opt) {
    var _this = _super.call(this, name) || this;

    _this.dimensions = geo2DDimensions;
    _this.type = 'geo'; // Only store specified name coord via `addGeoCoord`.

    _this._nameCoordMap = createHashMap();
    _this.map = map;
    var projection = opt.projection;
    var source = geoSourceManager.load(map, opt.nameMap, opt.nameProperty);
    var resource = geoSourceManager.getGeoResource(map);
    var resourceType = _this.resourceType = resource ? resource.type : null;
    var regions = _this.regions = source.regions;
    var defaultParams = GEO_DEFAULT_PARAMS[resource.type];
    _this._regionsMap = source.regionsMap;
    _this.regions = source.regions;

    if (process.env.NODE_ENV !== 'production' && projection) {
      // Do some check
      if (resourceType === 'geoSVG') {
        if (process.env.NODE_ENV !== 'production') {
          warn("Map " + map + " with SVG source can't use projection. Only GeoJSON source supports projection.");
        }

        projection = null;
      }

      if (!(projection.project && projection.unproject)) {
        if (process.env.NODE_ENV !== 'production') {
          warn('project and unproject must be both provided in the projeciton.');
        }

        projection = null;
      }
    }

    _this.projection = projection;
    var boundingRect;

    if (projection) {
      // Can't reuse the raw bounding rect
      for (var i = 0; i < regions.length; i++) {
        var regionRect = regions[i].getBoundingRect(projection);
        boundingRect = boundingRect || regionRect.clone();
        boundingRect.union(regionRect);
      }
    } else {
      boundingRect = source.boundingRect;
    }

    _this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height); // aspectScale and invertLongitute actually is the parameters default raw projection.
    // So we ignore them if projection is given.
    // Ignore default aspect scale if projection exits.


    _this.aspectScale = projection ? 1 : retrieve2(opt.aspectScale, defaultParams.aspectScale); // Not invert longitute if projection exits.

    _this._invertLongitute = projection ? false : defaultParams.invertLongitute;
    return _this;
  }

  Geo.prototype._transformTo = function (x, y, width, height) {
    var rect = this.getBoundingRect();
    var invertLongitute = this._invertLongitute;
    rect = rect.clone();

    if (invertLongitute) {
      // Longitute is inverted
      rect.y = -rect.y - rect.height;
    }

    var rawTransformable = this._rawTransformable;
    rawTransformable.transform = rect.calculateTransform(new BoundingRect$1(x, y, width, height));
    var rawParent = rawTransformable.parent;
    rawTransformable.parent = null;
    rawTransformable.decomposeTransform();
    rawTransformable.parent = rawParent;

    if (invertLongitute) {
      rawTransformable.scaleY = -rawTransformable.scaleY;
    }

    this._updateTransform();
  };

  Geo.prototype.getRegion = function (name) {
    return this._regionsMap.get(name);
  };

  Geo.prototype.getRegionByCoord = function (coord) {
    var regions = this.regions;

    for (var i = 0; i < regions.length; i++) {
      var region = regions[i];

      if (region.type === 'geoJSON' && region.contain(coord)) {
        return regions[i];
      }
    }
  };
  /**
   * Add geoCoord for indexing by name
   */


  Geo.prototype.addGeoCoord = function (name, geoCoord) {
    this._nameCoordMap.set(name, geoCoord);
  };
  /**
   * Get geoCoord by name
   */


  Geo.prototype.getGeoCoord = function (name) {
    var region = this._regionsMap.get(name); // calcualte center only on demand.


    return this._nameCoordMap.get(name) || region && region.getCenter();
  };

  Geo.prototype.dataToPoint = function (data, noRoam, out) {
    if (isString(data)) {
      // Map area name to geoCoord
      data = this.getGeoCoord(data);
    }

    if (data) {
      var projection = this.projection;

      if (projection) {
        // projection may return null point.
        data = projection.project(data);
      }

      return data && this.projectedToPoint(data, noRoam, out);
    }
  };

  Geo.prototype.pointToData = function (point) {
    var projection = this.projection;

    if (projection) {
      // projection may return null point.
      point = projection.unproject(point);
    }

    return point && this.pointToProjected(point);
  };
  /**
   * Point to projected data. Same with pointToData when projection is used.
   */


  Geo.prototype.pointToProjected = function (point) {
    return _super.prototype.pointToData.call(this, point);
  };

  Geo.prototype.projectedToPoint = function (projected, noRoam, out) {
    return _super.prototype.dataToPoint.call(this, projected, noRoam, out);
  };

  Geo.prototype.convertToPixel = function (ecModel, finder, value) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };

  Geo.prototype.convertFromPixel = function (ecModel, finder, pixel) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };

  return Geo;
}(View$1);
mixin(Geo, View$1);

function getCoordSys(finder) {
  var geoModel = finder.geoModel;
  var seriesModel = finder.seriesModel;
  return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem // For map series.
  || (seriesModel.getReferringComponents('geo', SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;
}

var Geo$1 = Geo;

/**
 * Resize method bound to the geo
 */

function resizeGeo(geoModel, api) {
  var boundingCoords = geoModel.get('boundingCoords');

  if (boundingCoords != null) {
    var leftTop_1 = boundingCoords[0];
    var rightBottom_1 = boundingCoords[1];

    if (!(isFinite(leftTop_1[0]) && isFinite(leftTop_1[1]) && isFinite(rightBottom_1[0]) && isFinite(rightBottom_1[1]))) {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Invalid boundingCoords');
      }
    } else {
      // Sample around the lng/lat rect and use projection to calculate actual bounding rect.
      var projection_1 = this.projection;

      if (projection_1) {
        var xMin = leftTop_1[0];
        var yMin = leftTop_1[1];
        var xMax = rightBottom_1[0];
        var yMax = rightBottom_1[1];
        leftTop_1 = [Infinity, Infinity];
        rightBottom_1 = [-Infinity, -Infinity]; // TODO better way?

        var sampleLine = function (x0, y0, x1, y1) {
          var dx = x1 - x0;
          var dy = y1 - y0;

          for (var i = 0; i <= 100; i++) {
            var p = i / 100;
            var pt = projection_1.project([x0 + dx * p, y0 + dy * p]);
            min$1(leftTop_1, leftTop_1, pt);
            max$1(rightBottom_1, rightBottom_1, pt);
          }
        }; // Top


        sampleLine(xMin, yMin, xMax, yMin); // Right

        sampleLine(xMax, yMin, xMax, yMax); // Bottom

        sampleLine(xMax, yMax, xMin, yMax); // Left

        sampleLine(xMin, yMax, xMax, yMin);
      }

      this.setBoundingRect(leftTop_1[0], leftTop_1[1], rightBottom_1[0] - leftTop_1[0], rightBottom_1[1] - leftTop_1[1]);
    }
  }

  var rect = this.getBoundingRect();
  var centerOption = geoModel.get('layoutCenter');
  var sizeOption = geoModel.get('layoutSize');
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  var aspect = rect.width / rect.height * this.aspectScale;
  var useCenterAndSize = false;
  var center;
  var size;

  if (centerOption && sizeOption) {
    center = [parsePercent(centerOption[0], viewWidth), parsePercent(centerOption[1], viewHeight)];
    size = parsePercent(sizeOption, Math.min(viewWidth, viewHeight));

    if (!isNaN(center[0]) && !isNaN(center[1]) && !isNaN(size)) {
      useCenterAndSize = true;
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.warn('Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.');
      }
    }
  }

  var viewRect;

  if (useCenterAndSize) {
    viewRect = {};

    if (aspect > 1) {
      // Width is same with size
      viewRect.width = size;
      viewRect.height = size / aspect;
    } else {
      viewRect.height = size;
      viewRect.width = size * aspect;
    }

    viewRect.y = center[1] - viewRect.height / 2;
    viewRect.x = center[0] - viewRect.width / 2;
  } else {
    // Use left/top/width/height
    var boxLayoutOption = geoModel.getBoxLayoutParams();
    boxLayoutOption.aspect = aspect;
    viewRect = getLayoutRect(boxLayoutOption, {
      width: viewWidth,
      height: viewHeight
    });
  }

  this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
  this.setCenter(geoModel.get('center'), api);
  this.setZoom(geoModel.get('zoom'));
} // Back compat for ECharts2, where the coord map is set on map series:
// {type: 'map', geoCoord: {'cityA': [116.46,39.92], 'cityA': [119.12,24.61]}},


function setGeoCoords(geo, model) {
  each$9(model.get('geoCoord'), function (geoCoord, name) {
    geo.addGeoCoord(name, geoCoord);
  });
}

var GeoCreator =
/** @class */
function () {
  function GeoCreator() {
    // For deciding which dimensions to use when creating list data
    this.dimensions = geo2DDimensions;
  }

  GeoCreator.prototype.create = function (ecModel, api) {
    var geoList = [];

    function getCommonGeoProperties(model) {
      return {
        nameProperty: model.get('nameProperty'),
        aspectScale: model.get('aspectScale'),
        projection: model.get('projection')
      };
    } // FIXME Create each time may be slow


    ecModel.eachComponent('geo', function (geoModel, idx) {
      var mapName = geoModel.get('map');
      var geo = new Geo$1(mapName + idx, mapName, extend$2({
        nameMap: geoModel.get('nameMap')
      }, getCommonGeoProperties(geoModel)));
      geo.zoomLimit = geoModel.get('scaleLimit');
      geoList.push(geo); // setGeoCoords(geo, geoModel);

      geoModel.coordinateSystem = geo;
      geo.model = geoModel; // Inject resize method

      geo.resize = resizeGeo;
      geo.resize(geoModel, api);
    });
    ecModel.eachSeries(function (seriesModel) {
      var coordSys = seriesModel.get('coordinateSystem');

      if (coordSys === 'geo') {
        var geoIndex = seriesModel.get('geoIndex') || 0;
        seriesModel.coordinateSystem = geoList[geoIndex];
      }
    }); // If has map series

    var mapModelGroupBySeries = {};
    ecModel.eachSeriesByType('map', function (seriesModel) {
      if (!seriesModel.getHostGeoModel()) {
        var mapType = seriesModel.getMapType();
        mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
        mapModelGroupBySeries[mapType].push(seriesModel);
      }
    });
    each$9(mapModelGroupBySeries, function (mapSeries, mapType) {
      var nameMapList = map$1(mapSeries, function (singleMapSeries) {
        return singleMapSeries.get('nameMap');
      });
      var geo = new Geo$1(mapType, mapType, extend$2({
        nameMap: mergeAll(nameMapList)
      }, getCommonGeoProperties(mapSeries[0])));
      geo.zoomLimit = retrieve.apply(null, map$1(mapSeries, function (singleMapSeries) {
        return singleMapSeries.get('scaleLimit');
      }));
      geoList.push(geo); // Inject resize method

      geo.resize = resizeGeo;
      geo.resize(mapSeries[0], api);
      each$9(mapSeries, function (singleMapSeries) {
        singleMapSeries.coordinateSystem = geo;
        setGeoCoords(geo, singleMapSeries);
      });
    });
    return geoList;
  };
  /**
   * Fill given regions array
   */


  GeoCreator.prototype.getFilledRegions = function (originRegionArr, mapName, nameMap, nameProperty) {
    // Not use the original
    var regionsArr = (originRegionArr || []).slice();
    var dataNameMap = createHashMap();

    for (var i = 0; i < regionsArr.length; i++) {
      dataNameMap.set(regionsArr[i].name, regionsArr[i]);
    }

    var source = geoSourceManager.load(mapName, nameMap, nameProperty);
    each$9(source.regions, function (region) {
      var name = region.name;
      !dataNameMap.get(name) && regionsArr.push({
        name: name
      });
    });
    return regionsArr;
  };

  return GeoCreator;
}();

var geoCreator = new GeoCreator();
var geoCreator$1 = geoCreator;

var GeoModel =
/** @class */
function (_super) {
  __extends$1(GeoModel, _super);

  function GeoModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = GeoModel.type;
    return _this;
  }

  GeoModel.prototype.init = function (option, parentModel, ecModel) {
    var source = geoSourceManager.getGeoResource(option.map);

    if (source && source.type === 'geoJSON') {
      var itemStyle = option.itemStyle = option.itemStyle || {};

      if (!('color' in itemStyle)) {
        itemStyle.color = '#eee';
      }
    }

    this.mergeDefaultAndTheme(option, ecModel); // Default label emphasis `show`

    defaultEmphasis(option, 'label', ['show']);
  };

  GeoModel.prototype.optionUpdated = function () {
    var _this = this;

    var option = this.option;
    option.regions = geoCreator$1.getFilledRegions(option.regions, option.map, option.nameMap, option.nameProperty);
    var selectedMap = {};
    this._optionModelMap = reduce(option.regions || [], function (optionModelMap, regionOpt) {
      var regionName = regionOpt.name;

      if (regionName) {
        optionModelMap.set(regionName, new Model$1(regionOpt, _this, _this.ecModel));

        if (regionOpt.selected) {
          selectedMap[regionName] = true;
        }
      }

      return optionModelMap;
    }, createHashMap());

    if (!option.selectedMap) {
      option.selectedMap = selectedMap;
    }
  };
  /**
   * Get model of region.
   */


  GeoModel.prototype.getRegionModel = function (name) {
    return this._optionModelMap.get(name) || new Model$1(null, this, this.ecModel);
  };
  /**
   * Format label
   * @param name Region name
   */


  GeoModel.prototype.getFormattedLabel = function (name, status) {
    var regionModel = this.getRegionModel(name);
    var formatter = status === 'normal' ? regionModel.get(['label', 'formatter']) : regionModel.get(['emphasis', 'label', 'formatter']);
    var params = {
      name: name
    };

    if (isFunction(formatter)) {
      params.status = status;
      return formatter(params);
    } else if (isString(formatter)) {
      return formatter.replace('{a}', name != null ? name : '');
    }
  };

  GeoModel.prototype.setZoom = function (zoom) {
    this.option.zoom = zoom;
  };

  GeoModel.prototype.setCenter = function (center) {
    this.option.center = center;
  }; // PENGING If selectedMode is null ?


  GeoModel.prototype.select = function (name) {
    var option = this.option;
    var selectedMode = option.selectedMode;

    if (!selectedMode) {
      return;
    }

    if (selectedMode !== 'multiple') {
      option.selectedMap = null;
    }

    var selectedMap = option.selectedMap || (option.selectedMap = {});
    selectedMap[name] = true;
  };

  GeoModel.prototype.unSelect = function (name) {
    var selectedMap = this.option.selectedMap;

    if (selectedMap) {
      selectedMap[name] = false;
    }
  };

  GeoModel.prototype.toggleSelected = function (name) {
    this[this.isSelected(name) ? 'unSelect' : 'select'](name);
  };

  GeoModel.prototype.isSelected = function (name) {
    var selectedMap = this.option.selectedMap;
    return !!(selectedMap && selectedMap[name]);
  };

  GeoModel.type = 'geo';
  GeoModel.layoutMode = 'box';
  GeoModel.defaultOption = {
    // zlevel: 0,
    z: 0,
    show: true,
    left: 'center',
    top: 'center',
    // Default value:
    // for geoSVG source: 1,
    // for geoJSON source: 0.75.
    aspectScale: null,
    ///// Layout with center and size
    // If you wan't to put map in a fixed size box with right aspect ratio
    // This two properties may more conveninet
    // layoutCenter: [50%, 50%]
    // layoutSize: 100
    silent: false,
    // Map type
    map: '',
    // Define left-top, right-bottom coords to control view
    // For example, [ [180, 90], [-180, -90] ]
    boundingCoords: null,
    // Default on center of map
    center: null,
    zoom: 1,
    scaleLimit: null,
    // selectedMode: false
    label: {
      show: false,
      color: '#000'
    },
    itemStyle: {
      borderWidth: 0.5,
      borderColor: '#444' // Default color:
      // + geoJSON: #eee
      // + geoSVG: null (use SVG original `fill`)
      // color: '#eee'

    },
    emphasis: {
      label: {
        show: true,
        color: 'rgb(100,0,0)'
      },
      itemStyle: {
        color: 'rgba(255,215,0,0.8)'
      }
    },
    select: {
      label: {
        show: true,
        color: 'rgb(100,0,0)'
      },
      itemStyle: {
        color: 'rgba(255,215,0,0.8)'
      }
    },
    regions: [] // tooltip: {
    //     show: false
    // }

  };
  return GeoModel;
}(ComponentModel$1);

var GeoModel$1 = GeoModel;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function getCenterCoord(view, point) {
  // Use projected coord as center because it's linear.
  return view.pointToProjected ? view.pointToProjected(point) : view.pointToData(point);
}

function updateCenterAndZoom(view, payload, zoomLimit, api) {
  var previousZoom = view.getZoom();
  var center = view.getCenter();
  var zoom = payload.zoom;
  var point = view.projectedToPoint ? view.projectedToPoint(center) : view.dataToPoint(center);

  if (payload.dx != null && payload.dy != null) {
    point[0] -= payload.dx;
    point[1] -= payload.dy;
    view.setCenter(getCenterCoord(view, point), api);
  }

  if (zoom != null) {
    if (zoomLimit) {
      var zoomMin = zoomLimit.min || 0;
      var zoomMax = zoomLimit.max || Infinity;
      zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
    } // Zoom on given point(originX, originY)


    view.scaleX *= zoom;
    view.scaleY *= zoom;
    var fixX = (payload.originX - view.x) * (zoom - 1);
    var fixY = (payload.originY - view.y) * (zoom - 1);
    view.x -= fixX;
    view.y -= fixY;
    view.updateTransform(); // Get the new center

    view.setCenter(getCenterCoord(view, point), api);
    view.setZoom(zoom * previousZoom);
  }

  return {
    center: view.getCenter(),
    zoom: view.getZoom()
  };
}

var GeoView =
/** @class */
function (_super) {
  __extends$1(GeoView, _super);

  function GeoView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = GeoView.type;
    _this.focusBlurEnabled = true;
    return _this;
  }

  GeoView.prototype.init = function (ecModel, api) {
    this._api = api;
  };

  GeoView.prototype.render = function (geoModel, ecModel, api, payload) {
    this._model = geoModel;

    if (!geoModel.get('show')) {
      this._mapDraw && this._mapDraw.remove();
      this._mapDraw = null;
      return;
    }

    if (!this._mapDraw) {
      this._mapDraw = new MapDraw$1(api);
    }

    var mapDraw = this._mapDraw;
    mapDraw.draw(geoModel, ecModel, api, this, payload);
    mapDraw.group.on('click', this._handleRegionClick, this);
    mapDraw.group.silent = geoModel.get('silent');
    this.group.add(mapDraw.group);
    this.updateSelectStatus(geoModel, ecModel, api);
  };

  GeoView.prototype._handleRegionClick = function (e) {
    var eventData;
    findEventDispatcher(e.target, function (current) {
      return (eventData = getECData(current).eventData) != null;
    }, true);

    if (eventData) {
      this._api.dispatchAction({
        type: 'geoToggleSelect',
        geoId: this._model.id,
        name: eventData.name
      });
    }
  };

  GeoView.prototype.updateSelectStatus = function (model, ecModel, api) {
    var _this = this;

    this._mapDraw.group.traverse(function (node) {
      var eventData = getECData(node).eventData;

      if (eventData) {
        _this._model.isSelected(eventData.name) ? api.enterSelect(node) : api.leaveSelect(node); // No need to traverse children.

        return true;
      }
    });
  };

  GeoView.prototype.findHighDownDispatchers = function (name) {
    return this._mapDraw && this._mapDraw.findHighDownDispatchers(name, this._model);
  };

  GeoView.prototype.dispose = function () {
    this._mapDraw && this._mapDraw.remove();
  };

  GeoView.type = 'geo';
  return GeoView;
}(ComponentView$1);

var GeoView$1 = GeoView;

function registerMap(mapName, geoJson, specialAreas) {
  geoSourceManager.registerMap(mapName, geoJson, specialAreas);
}

function install$e(registers) {
  registers.registerCoordinateSystem('geo', geoCreator$1);
  registers.registerComponentModel(GeoModel$1);
  registers.registerComponentView(GeoView$1);
  registers.registerImpl('registerMap', registerMap);
  registers.registerImpl('getMap', function (mapName) {
    return geoSourceManager.getMapForUser(mapName);
  });

  function makeAction(method, actionInfo) {
    actionInfo.update = 'geo:updateSelectStatus';
    registers.registerAction(actionInfo, function (payload, ecModel) {
      var selected = {};
      var allSelected = [];
      ecModel.eachComponent({
        mainType: 'geo',
        query: payload
      }, function (geoModel) {
        geoModel[method](payload.name);
        var geo = geoModel.coordinateSystem;
        each$9(geo.regions, function (region) {
          selected[region.name] = geoModel.isSelected(region.name) || false;
        }); // Notice: there might be duplicated name in different regions.

        var names = [];
        each$9(selected, function (v, name) {
          selected[name] && names.push(name);
        });
        allSelected.push({
          geoIndex: geoModel.componentIndex,
          // Use singular, the same naming convention as the event `selectchanged`.
          name: names
        });
      });
      return {
        selected: selected,
        allSelected: allSelected,
        name: payload.name
      };
    });
  }

  makeAction('toggleSelected', {
    type: 'geoToggleSelect',
    event: 'geoselectchanged'
  });
  makeAction('select', {
    type: 'geoSelect',
    event: 'geoselected'
  });
  makeAction('unSelect', {
    type: 'geoUnSelect',
    event: 'geounselected'
  });
  /**
   * @payload
   * @property {string} [componentType=series]
   * @property {number} [dx]
   * @property {number} [dy]
   * @property {number} [zoom]
   * @property {number} [originX]
   * @property {number} [originY]
   */

  registers.registerAction({
    type: 'geoRoam',
    event: 'geoRoam',
    update: 'updateTransform'
  }, function (payload, ecModel, api) {
    var componentType = payload.componentType || 'series';
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function (componentModel) {
      var geo = componentModel.coordinateSystem;

      if (geo.type !== 'geo') {
        return;
      }

      var res = updateCenterAndZoom(geo, payload, componentModel.get('scaleLimit'), api);
      componentModel.setCenter && componentModel.setCenter(res.center);
      componentModel.setZoom && componentModel.setZoom(res.zoom); // All map series with same `map` use the same geo coordinate system
      // So the center and zoom must be in sync. Include the series not selected by legend

      if (componentType === 'series') {
        each$9(componentModel.seriesGroup, function (seriesModel) {
          seriesModel.setCenter(res.center);
          seriesModel.setZoom(res.zoom);
        });
      }
    });
  });
}

function install$d(registers) {
  use(install$e);
  registers.registerChartView(MapView$1);
  registers.registerSeriesModel(MapSeries$1);
  registers.registerLayout(mapSymbolLayout);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);
  createLegacyDataSelectAction('map', registers.registerAction);
}

var each$6 = each$9;
var isObject = isObject$3;
var CATEGORY_DEFAULT_VISUAL_INDEX = -1;

var VisualMapping =
/** @class */
function () {
  function VisualMapping(option) {
    var mappingMethod = option.mappingMethod;
    var visualType = option.type;
    var thisOption = this.option = clone$3(option);
    this.type = visualType;
    this.mappingMethod = mappingMethod;
    this._normalizeData = normalizers[mappingMethod];
    var visualHandler = VisualMapping.visualHandlers[visualType];
    this.applyVisual = visualHandler.applyVisual;
    this.getColorMapper = visualHandler.getColorMapper;
    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];

    if (mappingMethod === 'piecewise') {
      normalizeVisualRange(thisOption);
      preprocessForPiecewise(thisOption);
    } else if (mappingMethod === 'category') {
      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,
      // which need no more preprocess except normalize visual.
      : normalizeVisualRange(thisOption, true);
    } else {
      // mappingMethod === 'linear' or 'fixed'
      assert(mappingMethod !== 'linear' || thisOption.dataExtent);
      normalizeVisualRange(thisOption);
    }
  }

  VisualMapping.prototype.mapValueToVisual = function (value) {
    var normalized = this._normalizeData(value);

    return this._normalizedToVisual(normalized, value);
  };

  VisualMapping.prototype.getNormalizer = function () {
    return bind$1(this._normalizeData, this);
  };
  /**
   * List available visual types.
   *
   * @public
   * @return {Array.<string>}
   */


  VisualMapping.listVisualTypes = function () {
    return keys(VisualMapping.visualHandlers);
  }; // /**
  //  * @public
  //  */
  // static addVisualHandler(name, handler) {
  //     visualHandlers[name] = handler;
  // }

  /**
   * @public
   */


  VisualMapping.isValidType = function (visualType) {
    return VisualMapping.visualHandlers.hasOwnProperty(visualType);
  };
  /**
   * Convinent method.
   * Visual can be Object or Array or primary type.
   */


  VisualMapping.eachVisual = function (visual, callback, context) {
    if (isObject$3(visual)) {
      each$9(visual, callback, context);
    } else {
      callback.call(context, visual);
    }
  };

  VisualMapping.mapVisual = function (visual, callback, context) {
    var isPrimary;
    var newVisual = isArray$1(visual) ? [] : isObject$3(visual) ? {} : (isPrimary = true, null);
    VisualMapping.eachVisual(visual, function (v, key) {
      var newVal = callback.call(context, v, key);
      isPrimary ? newVisual = newVal : newVisual[key] = newVal;
    });
    return newVisual;
  };
  /**
   * Retrieve visual properties from given object.
   */


  VisualMapping.retrieveVisuals = function (obj) {
    var ret = {};
    var hasVisual;
    obj && each$6(VisualMapping.visualHandlers, function (h, visualType) {
      if (obj.hasOwnProperty(visualType)) {
        ret[visualType] = obj[visualType];
        hasVisual = true;
      }
    });
    return hasVisual ? ret : null;
  };
  /**
   * Give order to visual types, considering colorSaturation, colorAlpha depends on color.
   *
   * @public
   * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}
   *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']
   * @return {Array.<string>} Sorted visual types.
   */


  VisualMapping.prepareVisualTypes = function (visualTypes) {
    if (isArray$1(visualTypes)) {
      visualTypes = visualTypes.slice();
    } else if (isObject(visualTypes)) {
      var types_1 = [];
      each$6(visualTypes, function (item, type) {
        types_1.push(type);
      });
      visualTypes = types_1;
    } else {
      return [];
    }

    visualTypes.sort(function (type1, type2) {
      // color should be front of colorSaturation, colorAlpha, ...
      // symbol and symbolSize do not matter.
      return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;
    });
    return visualTypes;
  };
  /**
   * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.
   * Other visuals are only depends on themself.
   */


  VisualMapping.dependsOn = function (visualType1, visualType2) {
    return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
  };
  /**
   * @param value
   * @param pieceList [{value: ..., interval: [min, max]}, ...]
   *                         Always from small to big.
   * @param findClosestWhenOutside Default to be false
   * @return index
   */


  VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {
    var possibleI;
    var abs = Infinity; // value has the higher priority.

    for (var i = 0, len = pieceList.length; i < len; i++) {
      var pieceValue = pieceList[i].value;

      if (pieceValue != null) {
        if (pieceValue === value // FIXME
        // It is supposed to compare value according to value type of dimension,
        // but currently value type can exactly be string or number.
        // Compromise for numeric-like string (like '12'), especially
        // in the case that visualMap.categories is ['22', '33'].
        || isString(pieceValue) && pieceValue === value + '') {
          return i;
        }

        findClosestWhenOutside && updatePossible(pieceValue, i);
      }
    }

    for (var i = 0, len = pieceList.length; i < len; i++) {
      var piece = pieceList[i];
      var interval = piece.interval;
      var close_1 = piece.close;

      if (interval) {
        if (interval[0] === -Infinity) {
          if (littleThan(close_1[1], value, interval[1])) {
            return i;
          }
        } else if (interval[1] === Infinity) {
          if (littleThan(close_1[0], interval[0], value)) {
            return i;
          }
        } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {
          return i;
        }

        findClosestWhenOutside && updatePossible(interval[0], i);
        findClosestWhenOutside && updatePossible(interval[1], i);
      }
    }

    if (findClosestWhenOutside) {
      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
    }

    function updatePossible(val, index) {
      var newAbs = Math.abs(val - value);

      if (newAbs < abs) {
        abs = newAbs;
        possibleI = index;
      }
    }
  };

  VisualMapping.visualHandlers = {
    color: {
      applyVisual: makeApplyVisual('color'),
      getColorMapper: function () {
        var thisOption = this.option;
        return bind$1(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {
          !isNormalized && (value = this._normalizeData(value));
          return doMapCategory.call(this, value);
        } : function (value, isNormalized, out) {
          // If output rgb array
          // which will be much faster and useful in pixel manipulation
          var returnRGBArray = !!out;
          !isNormalized && (value = this._normalizeData(value));
          out = fastLerp(value, thisOption.parsedVisual, out);
          return returnRGBArray ? out : stringify(out, 'rgba');
        }, this);
      },
      _normalizedToVisual: {
        linear: function (normalized) {
          return stringify(fastLerp(normalized, this.option.parsedVisual), 'rgba');
        },
        category: doMapCategory,
        piecewise: function (normalized, value) {
          var result = getSpecifiedVisual.call(this, value);

          if (result == null) {
            result = stringify(fastLerp(normalized, this.option.parsedVisual), 'rgba');
          }

          return result;
        },
        fixed: doMapFixed
      }
    },
    colorHue: makePartialColorVisualHandler(function (color$1, value) {
      return modifyHSL(color$1, value);
    }),
    colorSaturation: makePartialColorVisualHandler(function (color$1, value) {
      return modifyHSL(color$1, null, value);
    }),
    colorLightness: makePartialColorVisualHandler(function (color$1, value) {
      return modifyHSL(color$1, null, null, value);
    }),
    colorAlpha: makePartialColorVisualHandler(function (color$1, value) {
      return modifyAlpha(color$1, value);
    }),
    decal: {
      applyVisual: makeApplyVisual('decal'),
      _normalizedToVisual: {
        linear: null,
        category: doMapCategory,
        piecewise: null,
        fixed: null
      }
    },
    opacity: {
      applyVisual: makeApplyVisual('opacity'),
      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
    },
    liftZ: {
      applyVisual: makeApplyVisual('liftZ'),
      _normalizedToVisual: {
        linear: doMapFixed,
        category: doMapFixed,
        piecewise: doMapFixed,
        fixed: doMapFixed
      }
    },
    symbol: {
      applyVisual: function (value, getter, setter) {
        var symbolCfg = this.mapValueToVisual(value);
        setter('symbol', symbolCfg);
      },
      _normalizedToVisual: {
        linear: doMapToArray,
        category: doMapCategory,
        piecewise: function (normalized, value) {
          var result = getSpecifiedVisual.call(this, value);

          if (result == null) {
            result = doMapToArray.call(this, normalized);
          }

          return result;
        },
        fixed: doMapFixed
      }
    },
    symbolSize: {
      applyVisual: makeApplyVisual('symbolSize'),
      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
    }
  };
  return VisualMapping;
}();

function preprocessForPiecewise(thisOption) {
  var pieceList = thisOption.pieceList;
  thisOption.hasSpecialVisual = false;
  each$9(pieceList, function (piece, index) {
    piece.originIndex = index; // piece.visual is "result visual value" but not
    // a visual range, so it does not need to be normalized.

    if (piece.visual != null) {
      thisOption.hasSpecialVisual = true;
    }
  });
}

function preprocessForSpecifiedCategory(thisOption) {
  // Hash categories.
  var categories = thisOption.categories;
  var categoryMap = thisOption.categoryMap = {};
  var visual = thisOption.visual;
  each$6(categories, function (cate, index) {
    categoryMap[cate] = index;
  }); // Process visual map input.

  if (!isArray$1(visual)) {
    var visualArr_1 = [];

    if (isObject$3(visual)) {
      each$6(visual, function (v, cate) {
        var index = categoryMap[cate];
        visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
      });
    } else {
      // Is primary type, represents default visual.
      visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
    }

    visual = setVisualToOption(thisOption, visualArr_1);
  } // Remove categories that has no visual,
  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.


  for (var i = categories.length - 1; i >= 0; i--) {
    if (visual[i] == null) {
      delete categoryMap[categories[i]];
      categories.pop();
    }
  }
}

function normalizeVisualRange(thisOption, isCategory) {
  var visual = thisOption.visual;
  var visualArr = [];

  if (isObject$3(visual)) {
    each$6(visual, function (v) {
      visualArr.push(v);
    });
  } else if (visual != null) {
    visualArr.push(visual);
  }

  var doNotNeedPair = {
    color: 1,
    symbol: 1
  };

  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
    // Do not care visualArr.length === 0, which is illegal.
    visualArr[1] = visualArr[0];
  }

  setVisualToOption(thisOption, visualArr);
}

function makePartialColorVisualHandler(applyValue) {
  return {
    applyVisual: function (value, getter, setter) {
      // Only used in HSL
      var colorChannel = this.mapValueToVisual(value); // Must not be array value

      setter('color', applyValue(getter('color'), colorChannel));
    },
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  };
}

function doMapToArray(normalized) {
  var visual = this.option.visual;
  return visual[Math.round(linearMap$2(normalized, [0, 1], [0, visual.length - 1], true))] || {}; // TODO {}?
}

function makeApplyVisual(visualType) {
  return function (value, getter, setter) {
    setter(visualType, this.mapValueToVisual(value));
  };
}

function doMapCategory(normalized) {
  var visual = this.option.visual;
  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
}

function doMapFixed() {
  // visual will be convert to array.
  return this.option.visual[0];
}
/**
 * Create mapped to numeric visual
 */


function createNormalizedToNumericVisual(sourceExtent) {
  return {
    linear: function (normalized) {
      return linearMap$2(normalized, sourceExtent, this.option.visual, true);
    },
    category: doMapCategory,
    piecewise: function (normalized, value) {
      var result = getSpecifiedVisual.call(this, value);

      if (result == null) {
        result = linearMap$2(normalized, sourceExtent, this.option.visual, true);
      }

      return result;
    },
    fixed: doMapFixed
  };
}

function getSpecifiedVisual(value) {
  var thisOption = this.option;
  var pieceList = thisOption.pieceList;

  if (thisOption.hasSpecialVisual) {
    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
    var piece = pieceList[pieceIndex];

    if (piece && piece.visual) {
      return piece.visual[this.type];
    }
  }
}

function setVisualToOption(thisOption, visualArr) {
  thisOption.visual = visualArr;

  if (thisOption.type === 'color') {
    thisOption.parsedVisual = map$1(visualArr, function (item) {
      var color$1 = parse(item);

      if (!color$1 && process.env.NODE_ENV !== 'production') {
        warn("'" + item + "' is an illegal color, fallback to '#000000'", true);
      }

      return color$1 || [0, 0, 0, 1];
    });
  }

  return visualArr;
}
/**
 * Normalizers by mapping methods.
 */


var normalizers = {
  linear: function (value) {
    return linearMap$2(value, this.option.dataExtent, [0, 1], true);
  },
  piecewise: function (value) {
    var pieceList = this.option.pieceList;
    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);

    if (pieceIndex != null) {
      return linearMap$2(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
    }
  },
  category: function (value) {
    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal value

    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
  },
  fixed: noop$1
};

function littleThan(close, a, b) {
  return close ? a <= b : a < b;
}

var VisualMapping$1 = VisualMapping;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

/**
 * Calculate slider move result.
 * Usage:
 * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as
 * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.
 * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.
 *
 * @param delta Move length.
 * @param handleEnds handleEnds[0] can be bigger then handleEnds[1].
 *              handleEnds will be modified in this method.
 * @param extent handleEnds is restricted by extent.
 *              extent[0] should less or equals than extent[1].
 * @param handleIndex Can be 'all', means that both move the two handleEnds.
 * @param minSpan The range of dataZoom can not be smaller than that.
 *              If not set, handle0 and cross handle1. If set as a non-negative
 *              number (including `0`), handles will push each other when reaching
 *              the minSpan.
 * @param maxSpan The range of dataZoom can not be larger than that.
 * @return The input handleEnds.
 */
function sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
  delta = delta || 0;
  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.

  if (minSpan != null) {
    minSpan = restrict(minSpan, [0, extentSpan]);
  }

  if (maxSpan != null) {
    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
  }

  if (handleIndex === 'all') {
    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
    handleSpan = restrict(handleSpan, [0, extentSpan]);
    minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);
    handleIndex = 0;
  }

  handleEnds[0] = restrict(handleEnds[0], extent);
  handleEnds[1] = restrict(handleEnds[1], extent);
  var originalDistSign = getSpanSign(handleEnds, handleIndex);
  handleEnds[handleIndex] += delta; // Restrict in extent.

  var extentMinSpan = minSpan || 0;
  var realExtent = extent.slice();
  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.

  var currDistSign;
  currDistSign = getSpanSign(handleEnds, handleIndex);

  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
    // If minSpan exists, 'cross' is forbidden.
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
  } // Shrink span.


  currDistSign = getSpanSign(handleEnds, handleIndex);

  if (maxSpan != null && currDistSign.span > maxSpan) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
  }

  return handleEnds;
}

function getSpanSign(handleEnds, handleIndex) {
  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]
  // is at left of handleEnds[1] for non-cross case.

  return {
    span: Math.abs(dist),
    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1
  };
}

function restrict(value, extend) {
  return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));
}

var GRADIENT_LEVELS = 256;

var HeatmapLayer =
/** @class */
function () {
  function HeatmapLayer() {
    this.blurSize = 30;
    this.pointSize = 20;
    this.maxOpacity = 1;
    this.minOpacity = 0;
    this._gradientPixels = {
      inRange: null,
      outOfRange: null
    };
    var canvas = platformApi.createCanvas();
    this.canvas = canvas;
  }
  /**
   * Renders Heatmap and returns the rendered canvas
   * @param data array of data, each has x, y, value
   * @param width canvas width
   * @param height canvas height
   */


  HeatmapLayer.prototype.update = function (data, width, height, normalize, colorFunc, isInRange) {
    var brush = this._getBrush();

    var gradientInRange = this._getGradient(colorFunc, 'inRange');

    var gradientOutOfRange = this._getGradient(colorFunc, 'outOfRange');

    var r = this.pointSize + this.blurSize;
    var canvas = this.canvas;
    var ctx = canvas.getContext('2d');
    var len = data.length;
    canvas.width = width;
    canvas.height = height;

    for (var i = 0; i < len; ++i) {
      var p = data[i];
      var x = p[0];
      var y = p[1];
      var value = p[2]; // calculate alpha using value

      var alpha = normalize(value); // draw with the circle brush with alpha

      ctx.globalAlpha = alpha;
      ctx.drawImage(brush, x - r, y - r);
    }

    if (!canvas.width || !canvas.height) {
      // Avoid "Uncaught DOMException: Failed to execute 'getImageData' on
      // 'CanvasRenderingContext2D': The source height is 0."
      return canvas;
    } // colorize the canvas using alpha value and set with gradient


    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    var pixels = imageData.data;
    var offset = 0;
    var pixelLen = pixels.length;
    var minOpacity = this.minOpacity;
    var maxOpacity = this.maxOpacity;
    var diffOpacity = maxOpacity - minOpacity;

    while (offset < pixelLen) {
      var alpha = pixels[offset + 3] / 256;
      var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4; // Simple optimize to ignore the empty data

      if (alpha > 0) {
        var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange; // Any alpha > 0 will be mapped to [minOpacity, maxOpacity]

        alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
        pixels[offset++] = gradient[gradientOffset];
        pixels[offset++] = gradient[gradientOffset + 1];
        pixels[offset++] = gradient[gradientOffset + 2];
        pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
      } else {
        offset += 4;
      }
    }

    ctx.putImageData(imageData, 0, 0);
    return canvas;
  };
  /**
   * get canvas of a black circle brush used for canvas to draw later
   */


  HeatmapLayer.prototype._getBrush = function () {
    var brushCanvas = this._brushCanvas || (this._brushCanvas = platformApi.createCanvas()); // set brush size

    var r = this.pointSize + this.blurSize;
    var d = r * 2;
    brushCanvas.width = d;
    brushCanvas.height = d;
    var ctx = brushCanvas.getContext('2d');
    ctx.clearRect(0, 0, d, d); // in order to render shadow without the distinct circle,
    // draw the distinct circle in an invisible place,
    // and use shadowOffset to draw shadow in the center of the canvas

    ctx.shadowOffsetX = d;
    ctx.shadowBlur = this.blurSize; // draw the shadow in black, and use alpha and shadow blur to generate
    // color in color map

    ctx.shadowColor = '#000'; // draw circle in the left to the canvas

    ctx.beginPath();
    ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
    return brushCanvas;
  };
  /**
   * get gradient color map
   * @private
   */


  HeatmapLayer.prototype._getGradient = function (colorFunc, state) {
    var gradientPixels = this._gradientPixels;
    var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
    var color = [0, 0, 0, 0];
    var off = 0;

    for (var i = 0; i < 256; i++) {
      colorFunc[state](i / 255, true, color);
      pixelsSingleState[off++] = color[0];
      pixelsSingleState[off++] = color[1];
      pixelsSingleState[off++] = color[2];
      pixelsSingleState[off++] = color[3];
    }

    return pixelsSingleState;
  };

  return HeatmapLayer;
}();

var HeatmapLayer$1 = HeatmapLayer;

function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
  var dataSpan = dataExtent[1] - dataExtent[0];
  pieceList = map$1(pieceList, function (piece) {
    return {
      interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]
    };
  });
  var len = pieceList.length;
  var lastIndex = 0;
  return function (val) {
    var i; // Try to find in the location of the last found

    for (i = lastIndex; i < len; i++) {
      var interval = pieceList[i].interval;

      if (interval[0] <= val && val <= interval[1]) {
        lastIndex = i;
        break;
      }
    }

    if (i === len) {
      // Not found, back interation
      for (i = lastIndex - 1; i >= 0; i--) {
        var interval = pieceList[i].interval;

        if (interval[0] <= val && val <= interval[1]) {
          lastIndex = i;
          break;
        }
      }
    }

    return i >= 0 && i < len && selected[i];
  };
}

function getIsInContinuousRange(dataExtent, range) {
  var dataSpan = dataExtent[1] - dataExtent[0];
  range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];
  return function (val) {
    return val >= range[0] && val <= range[1];
  };
}

function isGeoCoordSys(coordSys) {
  var dimensions = coordSys.dimensions; // Not use coorSys.type === 'geo' because coordSys maybe extended

  return dimensions[0] === 'lng' && dimensions[1] === 'lat';
}

var HeatmapView =
/** @class */
function (_super) {
  __extends$1(HeatmapView, _super);

  function HeatmapView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = HeatmapView.type;
    return _this;
  }

  HeatmapView.prototype.render = function (seriesModel, ecModel, api) {
    var visualMapOfThisSeries;
    ecModel.eachComponent('visualMap', function (visualMap) {
      visualMap.eachTargetSeries(function (targetSeries) {
        if (targetSeries === seriesModel) {
          visualMapOfThisSeries = visualMap;
        }
      });
    });

    if (process.env.NODE_ENV !== 'production') {
      if (!visualMapOfThisSeries) {
        throw new Error('Heatmap must use with visualMap');
      }
    } // Clear previously rendered progressive elements.


    this._progressiveEls = null;
    this.group.removeAll();
    var coordSys = seriesModel.coordinateSystem;

    if (coordSys.type === 'cartesian2d' || coordSys.type === 'calendar') {
      this._renderOnCartesianAndCalendar(seriesModel, api, 0, seriesModel.getData().count());
    } else if (isGeoCoordSys(coordSys)) {
      this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);
    }
  };

  HeatmapView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {
    this.group.removeAll();
  };

  HeatmapView.prototype.incrementalRender = function (params, seriesModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;

    if (coordSys) {
      // geo does not support incremental rendering?
      if (isGeoCoordSys(coordSys)) {
        this.render(seriesModel, ecModel, api);
      } else {
        this._progressiveEls = [];

        this._renderOnCartesianAndCalendar(seriesModel, api, params.start, params.end, true);
      }
    }
  };

  HeatmapView.prototype.eachRendered = function (cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };

  HeatmapView.prototype._renderOnCartesianAndCalendar = function (seriesModel, api, start, end, incremental) {
    var coordSys = seriesModel.coordinateSystem;
    var isCartesian2d = isCoordinateSystemType(coordSys, 'cartesian2d');
    var width;
    var height;
    var xAxisExtent;
    var yAxisExtent;

    if (isCartesian2d) {
      var xAxis = coordSys.getAxis('x');
      var yAxis = coordSys.getAxis('y');

      if (process.env.NODE_ENV !== 'production') {
        if (!(xAxis.type === 'category' && yAxis.type === 'category')) {
          throw new Error('Heatmap on cartesian must have two category axes');
        }

        if (!(xAxis.onBand && yAxis.onBand)) {
          throw new Error('Heatmap on cartesian must have two axes with boundaryGap true');
        }
      } // add 0.5px to avoid the gaps


      width = xAxis.getBandWidth() + .5;
      height = yAxis.getBandWidth() + .5;
      xAxisExtent = xAxis.scale.getExtent();
      yAxisExtent = yAxis.scale.getExtent();
    }

    var group = this.group;
    var data = seriesModel.getData();
    var emphasisStyle = seriesModel.getModel(['emphasis', 'itemStyle']).getItemStyle();
    var blurStyle = seriesModel.getModel(['blur', 'itemStyle']).getItemStyle();
    var selectStyle = seriesModel.getModel(['select', 'itemStyle']).getItemStyle();
    var borderRadius = seriesModel.get(['itemStyle', 'borderRadius']);
    var labelStatesModels = getLabelStatesModels(seriesModel);
    var emphasisModel = seriesModel.getModel('emphasis');
    var focus = emphasisModel.get('focus');
    var blurScope = emphasisModel.get('blurScope');
    var emphasisDisabled = emphasisModel.get('disabled');
    var dataDims = isCartesian2d ? [data.mapDimension('x'), data.mapDimension('y'), data.mapDimension('value')] : [data.mapDimension('time'), data.mapDimension('value')];

    for (var idx = start; idx < end; idx++) {
      var rect = void 0;
      var style = data.getItemVisual(idx, 'style');

      if (isCartesian2d) {
        var dataDimX = data.get(dataDims[0], idx);
        var dataDimY = data.get(dataDims[1], idx); // Ignore empty data and out of extent data

        if (isNaN(data.get(dataDims[2], idx)) || dataDimX < xAxisExtent[0] || dataDimX > xAxisExtent[1] || dataDimY < yAxisExtent[0] || dataDimY > yAxisExtent[1]) {
          continue;
        }

        var point = coordSys.dataToPoint([dataDimX, dataDimY]);
        rect = new Rect$1({
          shape: {
            x: point[0] - width / 2,
            y: point[1] - height / 2,
            width: width,
            height: height
          },
          style: style
        });
      } else {
        // Ignore empty data
        if (isNaN(data.get(dataDims[1], idx))) {
          continue;
        }

        rect = new Rect$1({
          z2: 1,
          shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,
          style: style
        });
      } // Optimization for large datset


      if (data.hasItemOption) {
        var itemModel = data.getItemModel(idx);
        var emphasisModel_1 = itemModel.getModel('emphasis');
        emphasisStyle = emphasisModel_1.getModel('itemStyle').getItemStyle();
        blurStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();
        selectStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle(); // Each item value struct in the data would be firstly
        // {
        //     itemStyle: { borderRadius: [30, 30] },
        //     value: [2022, 02, 22]
        // }

        borderRadius = itemModel.get(['itemStyle', 'borderRadius']);
        focus = emphasisModel_1.get('focus');
        blurScope = emphasisModel_1.get('blurScope');
        emphasisDisabled = emphasisModel_1.get('disabled');
        labelStatesModels = getLabelStatesModels(itemModel);
      }

      rect.shape.r = borderRadius;
      var rawValue = seriesModel.getRawValue(idx);
      var defaultText = '-';

      if (rawValue && rawValue[2] != null) {
        defaultText = rawValue[2] + '';
      }

      setLabelStyle(rect, labelStatesModels, {
        labelFetcher: seriesModel,
        labelDataIndex: idx,
        defaultOpacity: style.opacity,
        defaultText: defaultText
      });
      rect.ensureState('emphasis').style = emphasisStyle;
      rect.ensureState('blur').style = blurStyle;
      rect.ensureState('select').style = selectStyle;
      toggleHoverEmphasis(rect, focus, blurScope, emphasisDisabled);
      rect.incremental = incremental; // PENDING

      if (incremental) {
        // Rect must use hover layer if it's incremental.
        rect.states.emphasis.hoverLayer = true;
      }

      group.add(rect);
      data.setItemGraphicEl(idx, rect);

      if (this._progressiveEls) {
        this._progressiveEls.push(rect);
      }
    }
  };

  HeatmapView.prototype._renderOnGeo = function (geo, seriesModel, visualMapModel, api) {
    var inRangeVisuals = visualMapModel.targetVisuals.inRange;
    var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange; // if (!visualMapping) {
    //     throw new Error('Data range must have color visuals');
    // }

    var data = seriesModel.getData();
    var hmLayer = this._hmLayer || this._hmLayer || new HeatmapLayer$1();
    hmLayer.blurSize = seriesModel.get('blurSize');
    hmLayer.pointSize = seriesModel.get('pointSize');
    hmLayer.minOpacity = seriesModel.get('minOpacity');
    hmLayer.maxOpacity = seriesModel.get('maxOpacity');
    var rect = geo.getViewRect().clone();
    var roamTransform = geo.getRoamTransform();
    rect.applyTransform(roamTransform); // Clamp on viewport

    var x = Math.max(rect.x, 0);
    var y = Math.max(rect.y, 0);
    var x2 = Math.min(rect.width + rect.x, api.getWidth());
    var y2 = Math.min(rect.height + rect.y, api.getHeight());
    var width = x2 - x;
    var height = y2 - y;
    var dims = [data.mapDimension('lng'), data.mapDimension('lat'), data.mapDimension('value')];
    var points = data.mapArray(dims, function (lng, lat, value) {
      var pt = geo.dataToPoint([lng, lat]);
      pt[0] -= x;
      pt[1] -= y;
      pt.push(value);
      return pt;
    });
    var dataExtent = visualMapModel.getExtent();
    var isInRange = visualMapModel.type === 'visualMap.continuous' ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
    hmLayer.update(points, width, height, inRangeVisuals.color.getNormalizer(), {
      inRange: inRangeVisuals.color.getColorMapper(),
      outOfRange: outOfRangeVisuals.color.getColorMapper()
    }, isInRange);
    var img = new ZRImage$1({
      style: {
        width: width,
        height: height,
        x: x,
        y: y,
        image: hmLayer.canvas
      },
      silent: true
    });
    this.group.add(img);
  };

  HeatmapView.type = 'heatmap';
  return HeatmapView;
}(ChartView$1);

var HeatmapView$1 = HeatmapView;

var HeatmapSeriesModel =
/** @class */
function (_super) {
  __extends$1(HeatmapSeriesModel, _super);

  function HeatmapSeriesModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = HeatmapSeriesModel.type;
    return _this;
  }

  HeatmapSeriesModel.prototype.getInitialData = function (option, ecModel) {
    return createSeriesData(null, this, {
      generateCoord: 'value'
    });
  };

  HeatmapSeriesModel.prototype.preventIncremental = function () {
    var coordSysCreator = CoordinateSystem.get(this.get('coordinateSystem'));

    if (coordSysCreator && coordSysCreator.dimensions) {
      return coordSysCreator.dimensions[0] === 'lng' && coordSysCreator.dimensions[1] === 'lat';
    }
  };

  HeatmapSeriesModel.type = 'series.heatmap';
  HeatmapSeriesModel.dependencies = ['grid', 'geo', 'calendar'];
  HeatmapSeriesModel.defaultOption = {
    coordinateSystem: 'cartesian2d',
    // zlevel: 0,
    z: 2,
    // Cartesian coordinate system
    // xAxisIndex: 0,
    // yAxisIndex: 0,
    // Geo coordinate system
    geoIndex: 0,
    blurSize: 30,
    pointSize: 20,
    maxOpacity: 1,
    minOpacity: 0,
    select: {
      itemStyle: {
        borderColor: '#212121'
      }
    }
  };
  return HeatmapSeriesModel;
}(SeriesModel$1);

var HeatmapSeriesModel$1 = HeatmapSeriesModel;

function install$c(registers) {
  registers.registerChartView(HeatmapView$1);
  registers.registerSeriesModel(HeatmapSeriesModel$1);
}

var inner$2 = makeInner();
var clone = clone$3;
var bind = bind$1;
/**
 * Base axis pointer class in 2D.
 */

var BaseAxisPointer =
/** @class */
function () {
  function BaseAxisPointer() {
    this._dragging = false;
    /**
     * In px, arbitrary value. Do not set too small,
     * no animation is ok for most cases.
     */

    this.animationThreshold = 15;
  }
  /**
   * @implement
   */


  BaseAxisPointer.prototype.render = function (axisModel, axisPointerModel, api, forceRender) {
    var value = axisPointerModel.get('value');
    var status = axisPointerModel.get('status'); // Bind them to `this`, not in closure, otherwise they will not
    // be replaced when user calling setOption in not merge mode.

    this._axisModel = axisModel;
    this._axisPointerModel = axisPointerModel;
    this._api = api; // Optimize: `render` will be called repeatly during mouse move.
    // So it is power consuming if performing `render` each time,
    // especially on mobile device.

    if (!forceRender && this._lastValue === value && this._lastStatus === status) {
      return;
    }

    this._lastValue = value;
    this._lastStatus = status;
    var group = this._group;
    var handle = this._handle;

    if (!status || status === 'hide') {
      // Do not clear here, for animation better.
      group && group.hide();
      handle && handle.hide();
      return;
    }

    group && group.show();
    handle && handle.show(); // Otherwise status is 'show'

    var elOption = {};
    this.makeElOption(elOption, value, axisModel, axisPointerModel, api); // Enable change axis pointer type.

    var graphicKey = elOption.graphicKey;

    if (graphicKey !== this._lastGraphicKey) {
      this.clear(api);
    }

    this._lastGraphicKey = graphicKey;
    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);

    if (!group) {
      group = this._group = new Group$3();
      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
      api.getZr().add(group);
    } else {
      var doUpdateProps = curry$1(updateProps, axisPointerModel, moveAnimation);
      this.updatePointerEl(group, elOption, doUpdateProps);
      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
    }

    updateMandatoryProps(group, axisPointerModel, true);

    this._renderHandle(value);
  };
  /**
   * @implement
   */


  BaseAxisPointer.prototype.remove = function (api) {
    this.clear(api);
  };
  /**
   * @implement
   */


  BaseAxisPointer.prototype.dispose = function (api) {
    this.clear(api);
  };
  /**
   * @protected
   */


  BaseAxisPointer.prototype.determineAnimation = function (axisModel, axisPointerModel) {
    var animation = axisPointerModel.get('animation');
    var axis = axisModel.axis;
    var isCategoryAxis = axis.type === 'category';
    var useSnap = axisPointerModel.get('snap'); // Value axis without snap always do not snap.

    if (!useSnap && !isCategoryAxis) {
      return false;
    }

    if (animation === 'auto' || animation == null) {
      var animationThreshold = this.animationThreshold;

      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
        return true;
      } // It is important to auto animation when snap used. Consider if there is
      // a dataZoom, animation will be disabled when too many points exist, while
      // it will be enabled for better visual effect when little points exist.


      if (useSnap) {
        var seriesDataCount = getAxisInfo(axisModel).seriesDataCount;
        var axisExtent = axis.getExtent(); // Approximate band width

        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
      }

      return false;
    }

    return animation === true;
  };
  /**
   * add {pointer, label, graphicKey} to elOption
   * @protected
   */


  BaseAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {// Shoule be implemenented by sub-class.
  };
  /**
   * @protected
   */


  BaseAxisPointer.prototype.createPointerEl = function (group, elOption, axisModel, axisPointerModel) {
    var pointerOption = elOption.pointer;

    if (pointerOption) {
      var pointerEl = inner$2(group).pointerEl = new graphic$1[pointerOption.type](clone(elOption.pointer));
      group.add(pointerEl);
    }
  };
  /**
   * @protected
   */


  BaseAxisPointer.prototype.createLabelEl = function (group, elOption, axisModel, axisPointerModel) {
    if (elOption.label) {
      var labelEl = inner$2(group).labelEl = new ZRText$1(clone(elOption.label));
      group.add(labelEl);
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  /**
   * @protected
   */


  BaseAxisPointer.prototype.updatePointerEl = function (group, elOption, updateProps) {
    var pointerEl = inner$2(group).pointerEl;

    if (pointerEl && elOption.pointer) {
      pointerEl.setStyle(elOption.pointer.style);
      updateProps(pointerEl, {
        shape: elOption.pointer.shape
      });
    }
  };
  /**
   * @protected
   */


  BaseAxisPointer.prototype.updateLabelEl = function (group, elOption, updateProps, axisPointerModel) {
    var labelEl = inner$2(group).labelEl;

    if (labelEl) {
      labelEl.setStyle(elOption.label.style);
      updateProps(labelEl, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: elOption.label.x,
        y: elOption.label.y
      });
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  /**
   * @private
   */


  BaseAxisPointer.prototype._renderHandle = function (value) {
    if (this._dragging || !this.updateHandleTransform) {
      return;
    }

    var axisPointerModel = this._axisPointerModel;

    var zr = this._api.getZr();

    var handle = this._handle;
    var handleModel = axisPointerModel.getModel('handle');
    var status = axisPointerModel.get('status');

    if (!handleModel.get('show') || !status || status === 'hide') {
      handle && zr.remove(handle);
      this._handle = null;
      return;
    }

    var isInit;

    if (!this._handle) {
      isInit = true;
      handle = this._handle = createIcon(handleModel.get('icon'), {
        cursor: 'move',
        draggable: true,
        onmousemove: function (e) {
          // Fot mobile devicem, prevent screen slider on the button.
          stop(e.event);
        },
        onmousedown: bind(this._onHandleDragMove, this, 0, 0),
        drift: bind(this._onHandleDragMove, this),
        ondragend: bind(this._onHandleDragEnd, this)
      });
      zr.add(handle);
    }

    updateMandatoryProps(handle, axisPointerModel, false); // update style

    handle.setStyle(handleModel.getItemStyle(null, ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'])); // update position

    var handleSize = handleModel.get('size');

    if (!isArray$1(handleSize)) {
      handleSize = [handleSize, handleSize];
    }

    handle.scaleX = handleSize[0] / 2;
    handle.scaleY = handleSize[1] / 2;
    createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');

    this._moveHandleToValue(value, isInit);
  };

  BaseAxisPointer.prototype._moveHandleToValue = function (value, isInit) {
    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
  };

  BaseAxisPointer.prototype._onHandleDragMove = function (dx, dy) {
    var handle = this._handle;

    if (!handle) {
      return;
    }

    this._dragging = true; // Persistent for throttle.

    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
    this._payloadInfo = trans;
    handle.stopAnimation();
    handle.attr(getHandleTransProps(trans));
    inner$2(handle).lastProp = null;

    this._doDispatchAxisPointer();
  };
  /**
   * Throttled method.
   */


  BaseAxisPointer.prototype._doDispatchAxisPointer = function () {
    var handle = this._handle;

    if (!handle) {
      return;
    }

    var payloadInfo = this._payloadInfo;
    var axisModel = this._axisModel;

    this._api.dispatchAction({
      type: 'updateAxisPointer',
      x: payloadInfo.cursorPoint[0],
      y: payloadInfo.cursorPoint[1],
      tooltipOption: payloadInfo.tooltipOption,
      axesInfo: [{
        axisDim: axisModel.axis.dim,
        axisIndex: axisModel.componentIndex
      }]
    });
  };

  BaseAxisPointer.prototype._onHandleDragEnd = function () {
    this._dragging = false;
    var handle = this._handle;

    if (!handle) {
      return;
    }

    var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with
    // axisPointer. So move handle to align the exact value position when
    // drag ended.


    this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle
    // button, and will be hidden after finger left handle button.


    this._api.dispatchAction({
      type: 'hideTip'
    });
  };
  /**
   * @private
   */


  BaseAxisPointer.prototype.clear = function (api) {
    this._lastValue = null;
    this._lastStatus = null;
    var zr = api.getZr();
    var group = this._group;
    var handle = this._handle;

    if (zr && group) {
      this._lastGraphicKey = null;
      group && zr.remove(group);
      handle && zr.remove(handle);
      this._group = null;
      this._handle = null;
      this._payloadInfo = null;
    }

    clear(this, '_doDispatchAxisPointer');
  };
  /**
   * @protected
   */


  BaseAxisPointer.prototype.doClear = function () {// Implemented by sub-class if necessary.
  };

  BaseAxisPointer.prototype.buildLabel = function (xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  };

  return BaseAxisPointer;
}();

function updateProps(animationModel, moveAnimation, el, props) {
  // Animation optimize.
  if (!propsEqual(inner$2(el).lastProp, props)) {
    inner$2(el).lastProp = props;
    moveAnimation ? updateProps$1(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
  }
}

function propsEqual(lastProps, newProps) {
  if (isObject$3(lastProps) && isObject$3(newProps)) {
    var equals_1 = true;
    each$9(newProps, function (item, key) {
      equals_1 = equals_1 && propsEqual(lastProps[key], item);
    });
    return !!equals_1;
  } else {
    return lastProps === newProps;
  }
}

function updateLabelShowHide(labelEl, axisPointerModel) {
  labelEl[axisPointerModel.get(['label', 'show']) ? 'show' : 'hide']();
}

function getHandleTransProps(trans) {
  return {
    x: trans.x || 0,
    y: trans.y || 0,
    rotation: trans.rotation || 0
  };
}

function updateMandatoryProps(group, axisPointerModel, silent) {
  var z = axisPointerModel.get('z');
  var zlevel = axisPointerModel.get('zlevel');
  group && group.traverse(function (el) {
    if (el.type !== 'group') {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
      el.silent = silent;
    }
  });
}

var BaseAxisPointer$1 = BaseAxisPointer;

function buildElStyle(axisPointerModel) {
  var axisPointerType = axisPointerModel.get('type');
  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');
  var style;

  if (axisPointerType === 'line') {
    style = styleModel.getLineStyle();
    style.fill = null;
  } else if (axisPointerType === 'shadow') {
    style = styleModel.getAreaStyle();
    style.stroke = null;
  }

  return style;
}
/**
 * @param {Function} labelPos {align, verticalAlign, position}
 */

function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
  var value = axisPointerModel.get('value');
  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {
    precision: axisPointerModel.get(['label', 'precision']),
    formatter: axisPointerModel.get(['label', 'formatter'])
  });
  var labelModel = axisPointerModel.getModel('label');
  var paddings = normalizeCssArray(labelModel.get('padding') || 0);
  var font = labelModel.getFont();
  var textRect = getBoundingRect(text, font);
  var position = labelPos.position;
  var width = textRect.width + paddings[1] + paddings[3];
  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.

  var align = labelPos.align;
  align === 'right' && (position[0] -= width);
  align === 'center' && (position[0] -= width / 2);
  var verticalAlign = labelPos.verticalAlign;
  verticalAlign === 'bottom' && (position[1] -= height);
  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container

  confineInContainer(position, width, height, api);
  var bgColor = labelModel.get('backgroundColor');

  if (!bgColor || bgColor === 'auto') {
    bgColor = axisModel.get(['axisLine', 'lineStyle', 'color']);
  }

  elOption.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: position[0],
    y: position[1],
    style: createTextStyle$1(labelModel, {
      text: text,
      font: font,
      fill: labelModel.getTextColor(),
      padding: paddings,
      backgroundColor: bgColor
    }),
    // Lable should be over axisPointer.
    z2: 10
  };
} // Do not overflow ec container

function confineInContainer(position, width, height, api) {
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  position[0] = Math.min(position[0] + width, viewWidth) - width;
  position[1] = Math.min(position[1] + height, viewHeight) - height;
  position[0] = Math.max(position[0], 0);
  position[1] = Math.max(position[1], 0);
}

function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
  value = axis.scale.parse(value);
  var text = axis.scale.getLabel({
    value: value
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: opt.precision
  });
  var formatter = opt.formatter;

  if (formatter) {
    var params_1 = {
      value: getAxisRawValue(axis, {
        value: value
      }),
      axisDimension: axis.dim,
      axisIndex: axis.index,
      seriesData: []
    };
    each$9(seriesDataIndices, function (idxItem) {
      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
      var dataIndex = idxItem.dataIndexInside;
      var dataParams = series && series.getDataParams(dataIndex);
      dataParams && params_1.seriesData.push(dataParams);
    });

    if (isString(formatter)) {
      text = formatter.replace('{value}', text);
    } else if (isFunction(formatter)) {
      text = formatter(params_1);
    }
  }

  return text;
}
function getTransformedPosition(axis, value, layoutInfo) {
  var transform = create();
  rotate(transform, transform, layoutInfo.rotation);
  translate(transform, transform, layoutInfo.position);
  return applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
}
function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
  // @ts-ignore
  var textLayout = AxisBuilder$1.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
  layoutInfo.labelMargin = axisPointerModel.get(['label', 'margin']);
  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
    position: getTransformedPosition(axisModel.axis, value, layoutInfo),
    align: textLayout.textAlign,
    verticalAlign: textLayout.textVerticalAlign
  });
}
function makeLineShape(p1, p2, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x1: p1[xDimIndex],
    y1: p1[1 - xDimIndex],
    x2: p2[xDimIndex],
    y2: p2[1 - xDimIndex]
  };
}
function makeRectShape(xy, wh, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x: xy[xDimIndex],
    y: xy[1 - xDimIndex],
    width: wh[xDimIndex],
    height: wh[1 - xDimIndex]
  };
}

var CartesianAxisPointer =
/** @class */
function (_super) {
  __extends$1(CartesianAxisPointer, _super);

  function CartesianAxisPointer() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @override
   */


  CartesianAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisPointerType = axisPointerModel.get('type');
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));

    if (axisPointerType && axisPointerType !== 'none') {
      var elStyle = buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }

    var layoutInfo = layout(grid.model, axisModel);
    buildCartesianSingleLabelElOption( // @ts-ignore
    value, elOption, layoutInfo, axisModel, axisPointerModel, api);
  };
  /**
   * @override
   */


  CartesianAxisPointer.prototype.getHandleTransform = function (value, axisModel, axisPointerModel) {
    var layoutInfo = layout(axisModel.axis.grid.model, axisModel, {
      labelInside: false
    }); // @ts-ignore

    layoutInfo.labelMargin = axisPointerModel.get(['handle', 'margin']);
    var pos = getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: pos[0],
      y: pos[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  };
  /**
   * @override
   */


  CartesianAxisPointer.prototype.updateHandleTransform = function (transform, delta, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisExtent = axis.getGlobalExtent(true);
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var dimIndex = axis.dim === 'x' ? 0 : 1;
    var currPosition = [transform.x, transform.y];
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex]; // Make tooltip do not overlap axisPointer and in the middle of the grid.

    var tooltipOptions = [{
      verticalAlign: 'middle'
    }, {
      align: 'center'
    }];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform.rotation,
      cursorPoint: cursorPoint,
      tooltipOption: tooltipOptions[dimIndex]
    };
  };

  return CartesianAxisPointer;
}(BaseAxisPointer$1);

function getCartesian(grid, axis) {
  var opt = {};
  opt[axis.dim + 'AxisIndex'] = axis.index;
  return grid.getCartesian(opt);
}

var pointerShapeBuilder = {
  line: function (axis, pixelValue, otherExtent) {
    var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
    return {
      type: 'Line',
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function (axis, pixelValue, otherExtent) {
    var bandWidth = Math.max(1, axis.getBandWidth());
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: 'Rect',
      shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
    };
  }
};

function getAxisDimIndex(axis) {
  return axis.dim === 'x' ? 0 : 1;
}

var CartesianAxisPointer$1 = CartesianAxisPointer;

var AxisPointerModel =
/** @class */
function (_super) {
  __extends$1(AxisPointerModel, _super);

  function AxisPointerModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = AxisPointerModel.type;
    return _this;
  }

  AxisPointerModel.type = 'axisPointer';
  AxisPointerModel.defaultOption = {
    // 'auto' means that show when triggered by tooltip or handle.
    show: 'auto',
    // zlevel: 0,
    z: 50,
    type: 'line',
    // axispointer triggered by tootip determine snap automatically,
    // see `modelHelper`.
    snap: false,
    triggerTooltip: true,
    value: null,
    status: null,
    link: [],
    // Do not set 'auto' here, otherwise global animation: false
    // will not effect at this axispointer.
    animation: null,
    animationDurationUpdate: 200,
    lineStyle: {
      color: '#B9BEC9',
      width: 1,
      type: 'dashed'
    },
    shadowStyle: {
      color: 'rgba(210,219,238,0.2)'
    },
    label: {
      show: true,
      formatter: null,
      precision: 'auto',
      margin: 3,
      color: '#fff',
      padding: [5, 7, 5, 7],
      backgroundColor: 'auto',
      borderColor: null,
      borderWidth: 0,
      borderRadius: 3
    },
    handle: {
      show: false,
      // eslint-disable-next-line
      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
      size: 45,
      // handle margin is from symbol center to axis, which is stable when circular move.
      margin: 50,
      // color: '#1b8bbd'
      // color: '#2f4554'
      color: '#333',
      shadowBlur: 3,
      shadowColor: '#aaa',
      shadowOffsetX: 0,
      shadowOffsetY: 2,
      // For mobile performance
      throttle: 40
    }
  };
  return AxisPointerModel;
}(ComponentModel$1);

var AxisPointerModel$1 = AxisPointerModel;

var inner$1 = makeInner();
var each$5 = each$9;
/**
 * @param {string} key
 * @param {module:echarts/ExtensionAPI} api
 * @param {Function} handler
 *      param: {string} currTrigger
 *      param: {Array.<number>} point
 */

function register(key, api, handler) {
  if (env$1.node) {
    return;
  }

  var zr = api.getZr();
  inner$1(zr).records || (inner$1(zr).records = {});
  initGlobalListeners(zr, api);
  var record = inner$1(zr).records[key] || (inner$1(zr).records[key] = {});
  record.handler = handler;
}

function initGlobalListeners(zr, api) {
  if (inner$1(zr).initialized) {
    return;
  }

  inner$1(zr).initialized = true;
  useHandler('click', curry$1(doEnter, 'click'));
  useHandler('mousemove', curry$1(doEnter, 'mousemove')); // useHandler('mouseout', onLeave);

  useHandler('globalout', onLeave);

  function useHandler(eventType, cb) {
    zr.on(eventType, function (e) {
      var dis = makeDispatchAction$1(api);
      each$5(inner$1(zr).records, function (record) {
        record && cb(record, e, dis.dispatchAction);
      });
      dispatchTooltipFinally(dis.pendings, api);
    });
  }
}

function dispatchTooltipFinally(pendings, api) {
  var showLen = pendings.showTip.length;
  var hideLen = pendings.hideTip.length;
  var actuallyPayload;

  if (showLen) {
    actuallyPayload = pendings.showTip[showLen - 1];
  } else if (hideLen) {
    actuallyPayload = pendings.hideTip[hideLen - 1];
  }

  if (actuallyPayload) {
    actuallyPayload.dispatchAction = null;
    api.dispatchAction(actuallyPayload);
  }
}

function onLeave(record, e, dispatchAction) {
  record.handler('leave', null, dispatchAction);
}

function doEnter(currTrigger, record, e, dispatchAction) {
  record.handler(currTrigger, e, dispatchAction);
}

function makeDispatchAction$1(api) {
  var pendings = {
    showTip: [],
    hideTip: []
  }; // FIXME
  // better approach?
  // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
  // which may be conflict, (axisPointer call showTip but tooltip call hideTip);
  // So we have to add "final stage" to merge those dispatched actions.

  var dispatchAction = function (payload) {
    var pendingList = pendings[payload.type];

    if (pendingList) {
      pendingList.push(payload);
    } else {
      payload.dispatchAction = dispatchAction;
      api.dispatchAction(payload);
    }
  };

  return {
    dispatchAction: dispatchAction,
    pendings: pendings
  };
}

function unregister(key, api) {
  if (env$1.node) {
    return;
  }

  var zr = api.getZr();
  var record = (inner$1(zr).records || {})[key];

  if (record) {
    inner$1(zr).records[key] = null;
  }
}

var AxisPointerView =
/** @class */
function (_super) {
  __extends$1(AxisPointerView, _super);

  function AxisPointerView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = AxisPointerView.type;
    return _this;
  }

  AxisPointerView.prototype.render = function (globalAxisPointerModel, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent('tooltip');
    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click'; // Register global listener in AxisPointerView to enable
    // AxisPointerView to be independent to Tooltip.

    register('axisPointer', api, function (currTrigger, e, dispatchAction) {
      // If 'none', it is not controlled by mouse totally.
      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {
        dispatchAction({
          type: 'updateAxisPointer',
          currTrigger: currTrigger,
          x: e && e.offsetX,
          y: e && e.offsetY
        });
      }
    });
  };

  AxisPointerView.prototype.remove = function (ecModel, api) {
    unregister('axisPointer', api);
  };

  AxisPointerView.prototype.dispose = function (ecModel, api) {
    unregister('axisPointer', api);
  };

  AxisPointerView.type = 'axisPointer';
  return AxisPointerView;
}(ComponentView$1);

var AxisPointerView$1 = AxisPointerView;

/**
 * @param finder contains {seriesIndex, dataIndex, dataIndexInside}
 * @param ecModel
 * @return  {point: [x, y], el: ...} point Will not be null.
 */

function findPointFromSeries(finder, ecModel) {
  var point = [];
  var seriesIndex = finder.seriesIndex;
  var seriesModel;

  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
    return {
      point: []
    };
  }

  var data = seriesModel.getData();
  var dataIndex = queryDataIndex(data, finder);

  if (dataIndex == null || dataIndex < 0 || isArray$1(dataIndex)) {
    return {
      point: []
    };
  }

  var el = data.getItemGraphicEl(dataIndex);
  var coordSys = seriesModel.coordinateSystem;

  if (seriesModel.getTooltipPosition) {
    point = seriesModel.getTooltipPosition(dataIndex) || [];
  } else if (coordSys && coordSys.dataToPoint) {
    if (finder.isStacked) {
      var baseAxis = coordSys.getBaseAxis();
      var valueAxis = coordSys.getOtherAxis(baseAxis);
      var valueAxisDim = valueAxis.dim;
      var baseAxisDim = baseAxis.dim;
      var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;
      var baseDim = data.mapDimension(baseAxisDim);
      var stackedData = [];
      stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
      stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo('stackResultDimension'), dataIndex);
      point = coordSys.dataToPoint(stackedData) || [];
    } else {
      point = coordSys.dataToPoint(data.getValues(map$1(coordSys.dimensions, function (dim) {
        return data.mapDimension(dim);
      }), dataIndex)) || [];
    }
  } else if (el) {
    // Use graphic bounding rect
    var rect = el.getBoundingRect().clone();
    rect.applyTransform(el.transform);
    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }

  return {
    point: point,
    el: el
  };
}

var inner = makeInner();
/**
 * Basic logic: check all axis, if they do not demand show/highlight,
 * then hide/downplay them.
 *
 * @return content of event obj for echarts.connect.
 */

function axisTrigger(payload, ecModel, api) {
  var currTrigger = payload.currTrigger;
  var point = [payload.x, payload.y];
  var finder = payload;
  var dispatchAction = payload.dispatchAction || bind$1(api.dispatchAction, api);
  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; // Pending
  // See #6121. But we are not able to reproduce it yet.

  if (!coordSysAxesInfo) {
    return;
  }

  if (illegalPoint(point)) {
    // Used in the default behavior of `connection`: use the sample seriesIndex
    // and dataIndex. And also used in the tooltipView trigger.
    point = findPointFromSeries({
      seriesIndex: finder.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: finder.dataIndex
    }, ecModel).point;
  }

  var isIllegalPoint = illegalPoint(point); // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).
  // Notice: In this case, it is difficult to get the `point` (which is necessary to show
  // tooltip, so if point is not given, we just use the point found by sample seriesIndex
  // and dataIndex.

  var inputAxesInfo = finder.axesInfo;
  var axesInfo = coordSysAxesInfo.axesInfo;
  var shouldHide = currTrigger === 'leave' || illegalPoint(point);
  var outputPayload = {};
  var showValueMap = {};
  var dataByCoordSys = {
    list: [],
    map: {}
  };
  var updaters = {
    showPointer: curry$1(showPointer, showValueMap),
    showTooltip: curry$1(showTooltip, dataByCoordSys)
  }; // Process for triggered axes.

  each$9(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {
    // If a point given, it must be contained by the coordinate system.
    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
    each$9(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {
      var axis = axisInfo.axis;
      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo); // If no inputAxesInfo, no axis is restricted.

      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
        var val = inputAxisInfo && inputAxisInfo.value;

        if (val == null && !isIllegalPoint) {
          val = axis.pointToData(point);
        }

        val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
      }
    });
  }); // Process for linked axes.

  var linkTriggers = {};
  each$9(axesInfo, function (tarAxisInfo, tarKey) {
    var linkGroup = tarAxisInfo.linkGroup; // If axis has been triggered in the previous stage, it should not be triggered by link.

    if (linkGroup && !showValueMap[tarKey]) {
      each$9(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {
        var srcValItem = showValueMap[srcKey]; // If srcValItem exist, source axis is triggered, so link to target axis.

        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
          var val = srcValItem.value;
          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
          linkTriggers[tarAxisInfo.key] = val;
        }
      });
    }
  });
  each$9(linkTriggers, function (val, tarKey) {
    processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
  });
  updateModelActually(showValueMap, axesInfo, outputPayload);
  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
  dispatchHighDownActually(axesInfo, dispatchAction, api);
  return outputPayload;
}

function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
  var axis = axisInfo.axis;

  if (axis.scale.isBlank() || !axis.containData(newValue)) {
    return;
  }

  if (!axisInfo.involveSeries) {
    updaters.showPointer(axisInfo, newValue);
    return;
  } // Heavy calculation. So put it after axis.containData checking.


  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
  var payloadBatch = payloadInfo.payloadBatch;
  var snapToValue = payloadInfo.snapToValue; // Fill content of event obj for echarts.connect.
  // By default use the first involved series data as a sample to connect.

  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
    extend$2(outputFinder, payloadBatch[0]);
  } // If no linkSource input, this process is for collecting link
  // target, where snap should not be accepted.


  if (!noSnap && axisInfo.snap) {
    if (axis.containData(snapToValue) && snapToValue != null) {
      newValue = snapToValue;
    }
  }

  updaters.showPointer(axisInfo, newValue, payloadBatch); // Tooltip should always be snapToValue, otherwise there will be
  // incorrect "axis value ~ series value" mapping displayed in tooltip.

  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}

function buildPayloadsBySeries(value, axisInfo) {
  var axis = axisInfo.axis;
  var dim = axis.dim;
  var snapToValue = value;
  var payloadBatch = [];
  var minDist = Number.MAX_VALUE;
  var minDiff = -1;
  each$9(axisInfo.seriesModels, function (series, idx) {
    var dataDim = series.getData().mapDimensionsAll(dim);
    var seriesNestestValue;
    var dataIndices;

    if (series.getAxisTooltipData) {
      var result = series.getAxisTooltipData(dataDim, value, axis);
      dataIndices = result.dataIndices;
      seriesNestestValue = result.nestestValue;
    } else {
      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex
      // when data length is not same.
      // false,
      axis.type === 'category' ? 0.5 : null);

      if (!dataIndices.length) {
        return;
      }

      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
    }

    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
      return;
    }

    var diff = value - seriesNestestValue;
    var dist = Math.abs(diff); // Consider category case

    if (dist <= minDist) {
      if (dist < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist;
        minDiff = diff;
        snapToValue = seriesNestestValue;
        payloadBatch.length = 0;
      }

      each$9(dataIndices, function (dataIndex) {
        payloadBatch.push({
          seriesIndex: series.seriesIndex,
          dataIndexInside: dataIndex,
          dataIndex: series.getData().getRawIndex(dataIndex)
        });
      });
    }
  });
  return {
    payloadBatch: payloadBatch,
    snapToValue: snapToValue
  };
}

function showPointer(showValueMap, axisInfo, value, payloadBatch) {
  showValueMap[axisInfo.key] = {
    value: value,
    payloadBatch: payloadBatch
  };
}

function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
  var payloadBatch = payloadInfo.payloadBatch;
  var axis = axisInfo.axis;
  var axisModel = axis.model;
  var axisPointerModel = axisInfo.axisPointerModel; // If no data, do not create anything in dataByCoordSys,
  // whose length will be used to judge whether dispatch action.

  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
    return;
  }

  var coordSysModel = axisInfo.coordSys.model;
  var coordSysKey = makeKey(coordSysModel);
  var coordSysItem = dataByCoordSys.map[coordSysKey];

  if (!coordSysItem) {
    coordSysItem = dataByCoordSys.map[coordSysKey] = {
      coordSysId: coordSysModel.id,
      coordSysIndex: coordSysModel.componentIndex,
      coordSysType: coordSysModel.type,
      coordSysMainType: coordSysModel.mainType,
      dataByAxis: []
    };
    dataByCoordSys.list.push(coordSysItem);
  }

  coordSysItem.dataByAxis.push({
    axisDim: axis.dim,
    axisIndex: axisModel.componentIndex,
    axisType: axisModel.type,
    axisId: axisModel.id,
    value: value,
    // Caustion: viewHelper.getValueLabel is actually on "view stage", which
    // depends that all models have been updated. So it should not be performed
    // here. Considering axisPointerModel used here is volatile, which is hard
    // to be retrieve in TooltipView, we prepare parameters here.
    valueLabelOpt: {
      precision: axisPointerModel.get(['label', 'precision']),
      formatter: axisPointerModel.get(['label', 'formatter'])
    },
    seriesDataIndices: payloadBatch.slice()
  });
}

function updateModelActually(showValueMap, axesInfo, outputPayload) {
  var outputAxesInfo = outputPayload.axesInfo = []; // Basic logic: If no 'show' required, 'hide' this axisPointer.

  each$9(axesInfo, function (axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    var valItem = showValueMap[key];

    if (valItem) {
      !axisInfo.useHandle && (option.status = 'show');
      option.value = valItem.value; // For label formatter param and highlight.

      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
    } // When always show (e.g., handle used), remain
    // original value and status.
    else {
        // If hide, value still need to be set, consider
        // click legend to toggle axis blank.
        !axisInfo.useHandle && (option.status = 'hide');
      } // If status is 'hide', should be no info in payload.


    option.status === 'show' && outputAxesInfo.push({
      axisDim: axisInfo.axis.dim,
      axisIndex: axisInfo.axis.model.componentIndex,
      value: option.value
    });
  });
}

function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
  // Basic logic: If no showTip required, hideTip will be dispatched.
  if (illegalPoint(point) || !dataByCoordSys.list.length) {
    dispatchAction({
      type: 'hideTip'
    });
    return;
  } // In most case only one axis (or event one series is used). It is
  // convinient to fetch payload.seriesIndex and payload.dataIndex
  // dirtectly. So put the first seriesIndex and dataIndex of the first
  // axis on the payload.


  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  dispatchAction({
    type: 'showTip',
    escapeConnect: true,
    x: point[0],
    y: point[1],
    tooltipOption: payload.tooltipOption,
    position: payload.position,
    dataIndexInside: sampleItem.dataIndexInside,
    dataIndex: sampleItem.dataIndex,
    seriesIndex: sampleItem.seriesIndex,
    dataByCoordSys: dataByCoordSys.list
  });
}

function dispatchHighDownActually(axesInfo, dispatchAction, api) {
  // FIXME
  // highlight status modification shoule be a stage of main process?
  // (Consider confilct (e.g., legend and axisPointer) and setOption)
  var zr = api.getZr();
  var highDownKey = 'axisPointerLastHighlights';
  var lastHighlights = inner(zr)[highDownKey] || {};
  var newHighlights = inner(zr)[highDownKey] = {}; // Update highlight/downplay status according to axisPointer model.
  // Build hash map and remove duplicate incidentally.

  each$9(axesInfo, function (axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    option.status === 'show' && each$9(option.seriesDataIndices, function (batchItem) {
      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;
      newHighlights[key] = batchItem;
    });
  }); // Diff.

  var toHighlight = [];
  var toDownplay = [];
  each$9(lastHighlights, function (batchItem, key) {
    !newHighlights[key] && toDownplay.push(batchItem);
  });
  each$9(newHighlights, function (batchItem, key) {
    !lastHighlights[key] && toHighlight.push(batchItem);
  });
  toDownplay.length && api.dispatchAction({
    type: 'downplay',
    escapeConnect: true,
    // Not blur others when highlight in axisPointer.
    notBlur: true,
    batch: toDownplay
  });
  toHighlight.length && api.dispatchAction({
    type: 'highlight',
    escapeConnect: true,
    // Not blur others when highlight in axisPointer.
    notBlur: true,
    batch: toHighlight
  });
}

function findInputAxisInfo(inputAxesInfo, axisInfo) {
  for (var i = 0; i < (inputAxesInfo || []).length; i++) {
    var inputAxisInfo = inputAxesInfo[i];

    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
      return inputAxisInfo;
    }
  }
}

function makeMapperParam(axisInfo) {
  var axisModel = axisInfo.axis.model;
  var item = {};
  var dim = item.axisDim = axisInfo.axis.dim;
  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;
  item.axisName = item[dim + 'AxisName'] = axisModel.name;
  item.axisId = item[dim + 'AxisId'] = axisModel.id;
  return item;
}

function illegalPoint(point) {
  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}

function install$b(registers) {
  // CartesianAxisPointer is not supposed to be required here. But consider
  // echarts.simple.js and online build tooltip, which only require gridSimple,
  // CartesianAxisPointer should be able to required somewhere.
  AxisView$1.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer$1);
  registers.registerComponentModel(AxisPointerModel$1);
  registers.registerComponentView(AxisPointerView$1);
  registers.registerPreprocessor(function (option) {
    // Always has a global axisPointerModel for default setting.
    if (option) {
      (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
      var link = option.axisPointer.link; // Normalize to array to avoid object mergin. But if link
      // is not set, remain null/undefined, otherwise it will
      // override existent link setting.

      if (link && !isArray$1(link)) {
        option.axisPointer.link = [link];
      }
    }
  }); // This process should proformed after coordinate systems created
  // and series data processed. So put it on statistic processing stage.

  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {
    // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
    // allAxesInfo should be updated when setOption performed.
    ecModel.getComponent('axisPointer').coordSysAxesInfo = collect(ecModel, api);
  }); // Broadcast to all views.

  registers.registerAction({
    type: 'updateAxisPointer',
    event: 'updateAxisPointer',
    update: ':updateAxisPointer'
  }, axisTrigger);
}

function install$a(registers) {
  use(install$f);
  use(install$b);
}

function makeBackground(rect, componentModel) {
  var padding = normalizeCssArray(componentModel.get('padding'));
  var style = componentModel.getItemStyle(['color', 'opacity']);
  style.fill = componentModel.get('backgroundColor');
  rect = new Rect$1({
    shape: {
      x: rect.x - padding[3],
      y: rect.y - padding[0],
      width: rect.width + padding[1] + padding[3],
      height: rect.height + padding[0] + padding[2],
      r: componentModel.get('borderRadius')
    },
    style: style,
    silent: true,
    z2: -1
  }); // FIXME
  // `subPixelOptimizeRect` may bring some gap between edge of viewpart
  // and background rect when setting like `left: 0`, `top: 0`.
  // graphic.subPixelOptimizeRect(rect);

  return rect;
}

var TooltipModel =
/** @class */
function (_super) {
  __extends$1(TooltipModel, _super);

  function TooltipModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TooltipModel.type;
    return _this;
  }

  TooltipModel.type = 'tooltip';
  TooltipModel.dependencies = ['axisPointer'];
  TooltipModel.defaultOption = {
    // zlevel: 0,
    z: 60,
    show: true,
    // tooltip main content
    showContent: true,
    // 'trigger' only works on coordinate system.
    // 'item' | 'axis' | 'none'
    trigger: 'item',
    // 'click' | 'mousemove' | 'none'
    triggerOn: 'mousemove|click',
    alwaysShowContent: false,
    displayMode: 'single',
    renderMode: 'auto',
    // whether restraint content inside viewRect.
    // If renderMode: 'richText', default true.
    // If renderMode: 'html', defaut false (for backward compat).
    confine: null,
    showDelay: 0,
    hideDelay: 100,
    // Animation transition time, unit is second
    transitionDuration: 0.4,
    enterable: false,
    backgroundColor: '#fff',
    // box shadow
    shadowBlur: 10,
    shadowColor: 'rgba(0, 0, 0, .2)',
    shadowOffsetX: 1,
    shadowOffsetY: 2,
    // tooltip border radius, unit is px, default is 4
    borderRadius: 4,
    // tooltip border width, unit is px, default is 0 (no border)
    borderWidth: 1,
    // Tooltip inside padding, default is 5 for all direction
    // Array is allowed to set up, right, bottom, left, same with css
    // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
    padding: null,
    // Extra css text
    extraCssText: '',
    // axis indicator, trigger by axis
    axisPointer: {
      // default is line
      // legal values: 'line' | 'shadow' | 'cross'
      type: 'line',
      // Valid when type is line, appoint tooltip line locate on which line. Optional
      // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
      // default is 'auto', chose the axis which type is category.
      // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
      axis: 'auto',
      animation: 'auto',
      animationDurationUpdate: 200,
      animationEasingUpdate: 'exponentialOut',
      crossStyle: {
        color: '#999',
        width: 1,
        type: 'dashed',
        // TODO formatter
        textStyle: {}
      } // lineStyle and shadowStyle should not be specified here,
      // otherwise it will always override those styles on option.axisPointer.

    },
    textStyle: {
      color: '#666',
      fontSize: 14
    }
  };
  return TooltipModel;
}(ComponentModel$1);

var TooltipModel$1 = TooltipModel;

/* global document */

function shouldTooltipConfine(tooltipModel) {
  var confineOption = tooltipModel.get('confine');
  return confineOption != null ? !!confineOption // In richText mode, the outside part can not be visible.
  : tooltipModel.get('renderMode') === 'richText';
}

function testStyle(styleProps) {
  if (!env$1.domSupported) {
    return;
  }

  var style = document.documentElement.style;

  for (var i = 0, len = styleProps.length; i < len; i++) {
    if (styleProps[i] in style) {
      return styleProps[i];
    }
  }
}

var TRANSFORM_VENDOR = testStyle(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);
var TRANSITION_VENDOR = testStyle(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);
function toCSSVendorPrefix(styleVendor, styleProp) {
  if (!styleVendor) {
    return styleProp;
  }

  styleProp = toCamelCase(styleProp, true);
  var idx = styleVendor.indexOf(styleProp);
  styleVendor = idx === -1 ? styleProp : "-" + styleVendor.slice(0, idx) + "-" + styleProp;
  return styleVendor.toLowerCase();
}
function getComputedStyle$1(el, style) {
  var stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el);
  return stl ? style ? stl[style] : stl : null;
}

/* global document, window */

var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, 'transition');
var CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, 'transform'); // eslint-disable-next-line

var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env$1.transform3dSupported ? 'will-change:transform;' : '');

function mirrorPos(pos) {
  pos = pos === 'left' ? 'right' : pos === 'right' ? 'left' : pos === 'top' ? 'bottom' : 'top';
  return pos;
}

function assembleArrow(tooltipModel, borderColor, arrowPosition) {
  if (!isString(arrowPosition) || arrowPosition === 'inside') {
    return '';
  }

  var backgroundColor = tooltipModel.get('backgroundColor');
  var borderWidth = tooltipModel.get('borderWidth');
  borderColor = convertToColorString(borderColor);
  var arrowPos = mirrorPos(arrowPosition);
  var arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);
  var positionStyle = '';
  var transformStyle = CSS_TRANSFORM_VENDOR + ':';
  var rotateDeg;

  if (indexOf(['left', 'right'], arrowPos) > -1) {
    positionStyle += 'top:50%';
    transformStyle += "translateY(-50%) rotate(" + (rotateDeg = arrowPos === 'left' ? -225 : -45) + "deg)";
  } else {
    positionStyle += 'left:50%';
    transformStyle += "translateX(-50%) rotate(" + (rotateDeg = arrowPos === 'top' ? 225 : 45) + "deg)";
  }

  var rotateRadian = rotateDeg * Math.PI / 180;
  var arrowWH = arrowSize + borderWidth;
  var rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));
  var arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;
  positionStyle += ";" + arrowPos + ":-" + arrowOffset + "px";
  var borderStyle = borderColor + " solid " + borderWidth + "px;";
  var styleCss = ["position:absolute;width:" + arrowSize + "px;height:" + arrowSize + "px;", positionStyle + ";" + transformStyle + ";", "border-bottom:" + borderStyle, "border-right:" + borderStyle, "background-color:" + backgroundColor + ";"];
  return "<div style=\"" + styleCss.join('') + "\"></div>";
}

function assembleTransition(duration, onlyFade) {
  var transitionCurve = 'cubic-bezier(0.23,1,0.32,1)';
  var transitionOption = " " + duration / 2 + "s " + transitionCurve;
  var transitionText = "opacity" + transitionOption + ",visibility" + transitionOption;

  if (!onlyFade) {
    transitionOption = " " + duration + "s " + transitionCurve;
    transitionText += env$1.transformSupported ? "," + CSS_TRANSFORM_VENDOR + transitionOption : ",left" + transitionOption + ",top" + transitionOption;
  }

  return CSS_TRANSITION_VENDOR + ':' + transitionText;
}

function assembleTransform(x, y, toString) {
  // If using float on style, the final width of the dom might
  // keep changing slightly while mouse move. So `toFixed(0)` them.
  var x0 = x.toFixed(0) + 'px';
  var y0 = y.toFixed(0) + 'px'; // not support transform, use `left` and `top` instead.

  if (!env$1.transformSupported) {
    return toString ? "top:" + y0 + ";left:" + x0 + ";" : [['top', y0], ['left', x0]];
  } // support transform


  var is3d = env$1.transform3dSupported;
  var translate = "translate" + (is3d ? '3d' : '') + "(" + x0 + "," + y0 + (is3d ? ',0' : '') + ")";
  return toString ? 'top:0;left:0;' + CSS_TRANSFORM_VENDOR + ':' + translate + ';' : [['top', 0], ['left', 0], [TRANSFORM_VENDOR, translate]];
}
/**
 * @param {Object} textStyle
 * @return {string}
 * @inner
 */


function assembleFont(textStyleModel) {
  var cssText = [];
  var fontSize = textStyleModel.get('fontSize');
  var color = textStyleModel.getTextColor();
  color && cssText.push('color:' + color);
  cssText.push('font:' + textStyleModel.getFont());
  fontSize // @ts-ignore, leave it to the tooltip refactor.
  && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
  var shadowColor = textStyleModel.get('textShadowColor');
  var shadowBlur = textStyleModel.get('textShadowBlur') || 0;
  var shadowOffsetX = textStyleModel.get('textShadowOffsetX') || 0;
  var shadowOffsetY = textStyleModel.get('textShadowOffsetY') || 0;
  shadowColor && shadowBlur && cssText.push('text-shadow:' + shadowOffsetX + 'px ' + shadowOffsetY + 'px ' + shadowBlur + 'px ' + shadowColor);
  each$9(['decoration', 'align'], function (name) {
    var val = textStyleModel.get(name);
    val && cssText.push('text-' + name + ':' + val);
  });
  return cssText.join(';');
}

function assembleCssText(tooltipModel, enableTransition, onlyFade) {
  var cssText = [];
  var transitionDuration = tooltipModel.get('transitionDuration');
  var backgroundColor = tooltipModel.get('backgroundColor');
  var shadowBlur = tooltipModel.get('shadowBlur');
  var shadowColor = tooltipModel.get('shadowColor');
  var shadowOffsetX = tooltipModel.get('shadowOffsetX');
  var shadowOffsetY = tooltipModel.get('shadowOffsetY');
  var textStyleModel = tooltipModel.getModel('textStyle');
  var padding = getPaddingFromTooltipModel(tooltipModel, 'html');
  var boxShadow = shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor;
  cssText.push('box-shadow:' + boxShadow); // Animation transition. Do not animate when transitionDuration is 0.

  enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));

  if (backgroundColor) {
    cssText.push('background-color:' + backgroundColor);
  } // Border style


  each$9(['width', 'color', 'radius'], function (name) {
    var borderName = 'border-' + name;
    var camelCase = toCamelCase(borderName);
    var val = tooltipModel.get(camelCase);
    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
  }); // Text style

  cssText.push(assembleFont(textStyleModel)); // Padding

  if (padding != null) {
    cssText.push('padding:' + normalizeCssArray(padding).join('px ') + 'px');
  }

  return cssText.join(';') + ';';
} // If not able to make, do not modify the input `out`.


function makeStyleCoord$1(out, zr, appendToBody, zrX, zrY) {
  var zrPainter = zr && zr.painter;

  if (appendToBody) {
    var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();

    if (zrViewportRoot) {
      // Some APPs might use scale on body, so we support CSS transform here.
      transformLocalCoord(out, zrViewportRoot, document.body, zrX, zrY);
    }
  } else {
    out[0] = zrX;
    out[1] = zrY; // xy should be based on canvas root. But tooltipContent is
    // the sibling of canvas root. So padding of ec container
    // should be considered here.

    var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();

    if (viewportRootOffset) {
      out[0] += viewportRootOffset.offsetLeft;
      out[1] += viewportRootOffset.offsetTop;
    }
  }

  out[2] = out[0] / zr.getWidth();
  out[3] = out[1] / zr.getHeight();
}

var TooltipHTMLContent =
/** @class */
function () {
  function TooltipHTMLContent(container, api, opt) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._firstShow = true;
    this._longHide = true;

    if (env$1.wxa) {
      return null;
    }

    var el = document.createElement('div'); // TODO: TYPE

    el.domBelongToZr = true;
    this.el = el;
    var zr = this._zr = api.getZr();
    var appendToBody = this._appendToBody = opt && opt.appendToBody;
    makeStyleCoord$1(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);

    if (appendToBody) {
      document.body.appendChild(el);
    } else {
      container.appendChild(el);
    }

    this._container = container; // FIXME
    // Is it needed to trigger zr event manually if
    // the browser do not support `pointer-events: none`.

    var self = this;

    el.onmouseenter = function () {
      // clear the timeout in hideLater and keep showing tooltip
      if (self._enterable) {
        clearTimeout(self._hideTimeout);
        self._show = true;
      }

      self._inContent = true;
    };

    el.onmousemove = function (e) {
      e = e || window.event;

      if (!self._enterable) {
        // `pointer-events: none` is set to tooltip content div
        // if `enterable` is set as `false`, and `el.onmousemove`
        // can not be triggered. But in browser that do not
        // support `pointer-events`, we need to do this:
        // Try trigger zrender event to avoid mouse
        // in and out shape too frequently
        var handler = zr.handler;
        var zrViewportRoot = zr.painter.getViewportRoot();
        normalizeEvent(zrViewportRoot, e, true);
        handler.dispatch('mousemove', e);
      }
    };

    el.onmouseleave = function () {
      // set `_inContent` to `false` before `hideLater`
      self._inContent = false;

      if (self._enterable) {
        if (self._show) {
          self.hideLater(self._hideDelay);
        }
      }
    };
  }
  /**
   * Update when tooltip is rendered
   */


  TooltipHTMLContent.prototype.update = function (tooltipModel) {
    // FIXME
    // Move this logic to ec main?
    var container = this._container;
    var position = getComputedStyle$1(container, 'position');
    var domStyle = container.style;

    if (domStyle.position !== 'absolute' && position !== 'absolute') {
      domStyle.position = 'relative';
    } // move tooltip if chart resized


    var alwaysShowContent = tooltipModel.get('alwaysShowContent');
    alwaysShowContent && this._moveIfResized(); // update className

    this.el.className = tooltipModel.get('className') || ''; // Hide the tooltip
    // PENDING
    // this.hide();
  };

  TooltipHTMLContent.prototype.show = function (tooltipModel, nearPointColor) {
    clearTimeout(this._hideTimeout);
    clearTimeout(this._longHideTimeout);
    var el = this.el;
    var style = el.style;
    var styleCoord = this._styleCoord;

    if (!el.innerHTML) {
      style.display = 'none';
    } else {
      style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) // initial transform
      + assembleTransform(styleCoord[0], styleCoord[1], true) + ("border-color:" + convertToColorString(nearPointColor) + ";") + (tooltipModel.get('extraCssText') || '') // If mouse occasionally move over the tooltip, a mouseout event will be
      // triggered by canvas, and cause some unexpectable result like dragging
      // stop, "unfocusAdjacency". Here `pointer-events: none` is used to solve
      // it. Although it is not supported by IE8~IE10, fortunately it is a rare
      // scenario.
      + (";pointer-events:" + (this._enterable ? 'auto' : 'none'));
    }

    this._show = true;
    this._firstShow = false;
    this._longHide = false;
  };

  TooltipHTMLContent.prototype.setContent = function (content, markers, tooltipModel, borderColor, arrowPosition) {
    var el = this.el;

    if (content == null) {
      el.innerHTML = '';
      return;
    }

    var arrow = '';

    if (isString(arrowPosition) && tooltipModel.get('trigger') === 'item' && !shouldTooltipConfine(tooltipModel)) {
      arrow = assembleArrow(tooltipModel, borderColor, arrowPosition);
    }

    if (isString(content)) {
      el.innerHTML = content + arrow;
    } else if (content) {
      // Clear previous
      el.innerHTML = '';

      if (!isArray$1(content)) {
        content = [content];
      }

      for (var i = 0; i < content.length; i++) {
        if (isDom(content[i]) && content[i].parentNode !== el) {
          el.appendChild(content[i]);
        }
      } // no arrow if empty


      if (arrow && el.childNodes.length) {
        // no need to create a new parent element, but it's not supported by IE 10 and older.
        // const arrowEl = document.createRange().createContextualFragment(arrow);
        var arrowEl = document.createElement('div');
        arrowEl.innerHTML = arrow;
        el.appendChild(arrowEl);
      }
    }
  };

  TooltipHTMLContent.prototype.setEnterable = function (enterable) {
    this._enterable = enterable;
  };

  TooltipHTMLContent.prototype.getSize = function () {
    var el = this.el;
    return [el.offsetWidth, el.offsetHeight];
  };

  TooltipHTMLContent.prototype.moveTo = function (zrX, zrY) {
    var styleCoord = this._styleCoord;
    makeStyleCoord$1(styleCoord, this._zr, this._appendToBody, zrX, zrY);

    if (styleCoord[0] != null && styleCoord[1] != null) {
      var style_1 = this.el.style;
      var transforms = assembleTransform(styleCoord[0], styleCoord[1]);
      each$9(transforms, function (transform) {
        style_1[transform[0]] = transform[1];
      });
    }
  };
  /**
   * when `alwaysShowContent` is true,
   * move the tooltip after chart resized
   */


  TooltipHTMLContent.prototype._moveIfResized = function () {
    // The ratio of left to width
    var ratioX = this._styleCoord[2]; // The ratio of top to height

    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };

  TooltipHTMLContent.prototype.hide = function () {
    var _this = this;

    var style = this.el.style;
    style.visibility = 'hidden';
    style.opacity = '0';
    env$1.transform3dSupported && (style.willChange = '');
    this._show = false;
    this._longHideTimeout = setTimeout(function () {
      return _this._longHide = true;
    }, 500);
  };

  TooltipHTMLContent.prototype.hideLater = function (time) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time) {
        this._hideDelay = time; // Set show false to avoid invoke hideLater multiple times

        this._show = false;
        this._hideTimeout = setTimeout(bind$1(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  };

  TooltipHTMLContent.prototype.isShow = function () {
    return this._show;
  };

  TooltipHTMLContent.prototype.dispose = function () {
    this.el.parentNode.removeChild(this.el);
  };

  return TooltipHTMLContent;
}();

var TooltipHTMLContent$1 = TooltipHTMLContent;

var TooltipRichContent =
/** @class */
function () {
  function TooltipRichContent(api) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._zr = api.getZr();
    makeStyleCoord(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);
  }
  /**
   * Update when tooltip is rendered
   */


  TooltipRichContent.prototype.update = function (tooltipModel) {
    var alwaysShowContent = tooltipModel.get('alwaysShowContent');
    alwaysShowContent && this._moveIfResized();
  };

  TooltipRichContent.prototype.show = function () {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }

    this.el.show();
    this._show = true;
  };
  /**
   * Set tooltip content
   */


  TooltipRichContent.prototype.setContent = function (content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
    var _this = this;

    if (isObject$3(content)) {
      throwError(process.env.NODE_ENV !== 'production' ? 'Passing DOM nodes as content is not supported in richText tooltip!' : '');
    }

    if (this.el) {
      this._zr.remove(this.el);
    }

    var textStyleModel = tooltipModel.getModel('textStyle');
    this.el = new ZRText$1({
      style: {
        rich: markupStyleCreator.richTextStyles,
        text: content,
        lineHeight: 22,
        borderWidth: 1,
        borderColor: borderColor,
        textShadowColor: textStyleModel.get('textShadowColor'),
        fill: tooltipModel.get(['textStyle', 'color']),
        padding: getPaddingFromTooltipModel(tooltipModel, 'richText'),
        verticalAlign: 'top',
        align: 'left'
      },
      z: tooltipModel.get('z')
    });
    each$9(['backgroundColor', 'borderRadius', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'], function (propName) {
      _this.el.style[propName] = tooltipModel.get(propName);
    });
    each$9(['textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY'], function (propName) {
      _this.el.style[propName] = textStyleModel.get(propName) || 0;
    });

    this._zr.add(this.el);

    var self = this;
    this.el.on('mouseover', function () {
      // clear the timeout in hideLater and keep showing tooltip
      if (self._enterable) {
        clearTimeout(self._hideTimeout);
        self._show = true;
      }

      self._inContent = true;
    });
    this.el.on('mouseout', function () {
      if (self._enterable) {
        if (self._show) {
          self.hideLater(self._hideDelay);
        }
      }

      self._inContent = false;
    });
  };

  TooltipRichContent.prototype.setEnterable = function (enterable) {
    this._enterable = enterable;
  };

  TooltipRichContent.prototype.getSize = function () {
    var el = this.el;
    var bounding = this.el.getBoundingRect(); // bounding rect does not include shadow. For renderMode richText,
    // if overflow, it will be cut. So calculate them accurately.

    var shadowOuterSize = calcShadowOuterSize(el.style);
    return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];
  };

  TooltipRichContent.prototype.moveTo = function (x, y) {
    var el = this.el;

    if (el) {
      var styleCoord = this._styleCoord;
      makeStyleCoord(styleCoord, this._zr, x, y);
      x = styleCoord[0];
      y = styleCoord[1];
      var style = el.style;
      var borderWidth = mathMaxWith0(style.borderWidth || 0);
      var shadowOuterSize = calcShadowOuterSize(style); // rich text x, y do not include border.

      el.x = x + borderWidth + shadowOuterSize.left;
      el.y = y + borderWidth + shadowOuterSize.top;
      el.markRedraw();
    }
  };
  /**
   * when `alwaysShowContent` is true,
   * move the tooltip after chart resized
   */


  TooltipRichContent.prototype._moveIfResized = function () {
    // The ratio of left to width
    var ratioX = this._styleCoord[2]; // The ratio of top to height

    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };

  TooltipRichContent.prototype.hide = function () {
    if (this.el) {
      this.el.hide();
    }

    this._show = false;
  };

  TooltipRichContent.prototype.hideLater = function (time) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time) {
        this._hideDelay = time; // Set show false to avoid invoke hideLater multiple times

        this._show = false;
        this._hideTimeout = setTimeout(bind$1(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  };

  TooltipRichContent.prototype.isShow = function () {
    return this._show;
  };

  TooltipRichContent.prototype.dispose = function () {
    this._zr.remove(this.el);
  };

  return TooltipRichContent;
}();

function mathMaxWith0(val) {
  return Math.max(0, val);
}

function calcShadowOuterSize(style) {
  var shadowBlur = mathMaxWith0(style.shadowBlur || 0);
  var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
  var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
  return {
    left: mathMaxWith0(shadowBlur - shadowOffsetX),
    right: mathMaxWith0(shadowBlur + shadowOffsetX),
    top: mathMaxWith0(shadowBlur - shadowOffsetY),
    bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
  };
}

function makeStyleCoord(out, zr, zrX, zrY) {
  out[0] = zrX;
  out[1] = zrY;
  out[2] = out[0] / zr.getWidth();
  out[3] = out[1] / zr.getHeight();
}

var TooltipRichContent$1 = TooltipRichContent;

var proxyRect = new Rect$1({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
});

var TooltipView =
/** @class */
function (_super) {
  __extends$1(TooltipView, _super);

  function TooltipView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TooltipView.type;
    return _this;
  }

  TooltipView.prototype.init = function (ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }

    var tooltipModel = ecModel.getComponent('tooltip');
    var renderMode = this._renderMode = getTooltipRenderMode(tooltipModel.get('renderMode'));
    this._tooltipContent = renderMode === 'richText' ? new TooltipRichContent$1(api) : new TooltipHTMLContent$1(api.getDom(), api, {
      appendToBody: tooltipModel.get('appendToBody', true)
    });
  };

  TooltipView.prototype.render = function (tooltipModel, ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    } // Reset


    this.group.removeAll();
    this._tooltipModel = tooltipModel;
    this._ecModel = ecModel;
    this._api = api;
    /**
     * @private
     * @type {boolean}
     */

    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
    var tooltipContent = this._tooltipContent;
    tooltipContent.update(tooltipModel);
    tooltipContent.setEnterable(tooltipModel.get('enterable'));

    this._initGlobalListener();

    this._keepShow(); // PENDING
    // `mousemove` event will be triggered very frequently when the mouse moves fast,
    // which causes that the `updatePosition` function was also called frequently.
    // In Chrome with devtools open and Firefox, tooltip looks laggy and shakes. See #14695 #16101
    // To avoid frequent triggering,
    // consider throttling it in 50ms when transition is enabled


    if (this._renderMode !== 'richText' && tooltipModel.get('transitionDuration')) {
      createOrUpdate(this, '_updatePosition', 50, 'fixRate');
    } else {
      clear(this, '_updatePosition');
    }
  };

  TooltipView.prototype._initGlobalListener = function () {
    var tooltipModel = this._tooltipModel;
    var triggerOn = tooltipModel.get('triggerOn');
    register('itemTooltip', this._api, bind$1(function (currTrigger, e, dispatchAction) {
      // If 'none', it is not controlled by mouse totally.
      if (triggerOn !== 'none') {
        if (triggerOn.indexOf(currTrigger) >= 0) {
          this._tryShow(e, dispatchAction);
        } else if (currTrigger === 'leave') {
          this._hide(dispatchAction);
        }
      }
    }, this));
  };

  TooltipView.prototype._keepShow = function () {
    var tooltipModel = this._tooltipModel;
    var ecModel = this._ecModel;
    var api = this._api;
    var triggerOn = tooltipModel.get('triggerOn'); // Try to keep the tooltip show when refreshing

    if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API,
    // self.manuallyShowTip({x, y}) might cause tooltip hide,
    // which is not expected.
    && triggerOn !== 'none' && triggerOn !== 'click') {
      var self_1 = this;
      clearTimeout(this._refreshUpdateTimeout);
      this._refreshUpdateTimeout = setTimeout(function () {
        // Show tip next tick after other charts are rendered
        // In case highlight action has wrong result
        // FIXME
        !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {
          x: self_1._lastX,
          y: self_1._lastY,
          dataByCoordSys: self_1._lastDataByCoordSys
        });
      });
    }
  };
  /**
   * Show tip manually by
   * dispatchAction({
   *     type: 'showTip',
   *     x: 10,
   *     y: 10
   * });
   * Or
   * dispatchAction({
   *      type: 'showTip',
   *      seriesIndex: 0,
   *      dataIndex or dataIndexInside or name
   * });
   *
   *  TODO Batch
   */


  TooltipView.prototype.manuallyShowTip = function (tooltipModel, ecModel, api, payload) {
    if (payload.from === this.uid || env$1.node || !api.getDom()) {
      return;
    }

    var dispatchAction = makeDispatchAction(payload, api); // Reset ticket

    this._ticket = ''; // When triggered from axisPointer.

    var dataByCoordSys = payload.dataByCoordSys;
    var cmptRef = findComponentReference(payload, ecModel, api);

    if (cmptRef) {
      var rect = cmptRef.el.getBoundingRect().clone();
      rect.applyTransform(cmptRef.el.transform);

      this._tryShow({
        offsetX: rect.x + rect.width / 2,
        offsetY: rect.y + rect.height / 2,
        target: cmptRef.el,
        position: payload.position,
        // When manully trigger, the mouse is not on the el, so we'd better to
        // position tooltip on the bottom of the el and display arrow is possible.
        positionDefault: 'bottom'
      }, dispatchAction);
    } else if (payload.tooltip && payload.x != null && payload.y != null) {
      var el = proxyRect;
      el.x = payload.x;
      el.y = payload.y;
      el.update();
      getECData(el).tooltipConfig = {
        name: null,
        option: payload.tooltip
      }; // Manually show tooltip while view is not using zrender elements.

      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        target: el
      }, dispatchAction);
    } else if (dataByCoordSys) {
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        dataByCoordSys: dataByCoordSys,
        tooltipOption: payload.tooltipOption
      }, dispatchAction);
    } else if (payload.seriesIndex != null) {
      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
        return;
      }

      var pointInfo = findPointFromSeries(payload, ecModel);
      var cx = pointInfo.point[0];
      var cy = pointInfo.point[1];

      if (cx != null && cy != null) {
        this._tryShow({
          offsetX: cx,
          offsetY: cy,
          target: pointInfo.el,
          position: payload.position,
          // When manully trigger, the mouse is not on the el, so we'd better to
          // position tooltip on the bottom of the el and display arrow is possible.
          positionDefault: 'bottom'
        }, dispatchAction);
      }
    } else if (payload.x != null && payload.y != null) {
      // FIXME
      // should wrap dispatchAction like `axisPointer/globalListener` ?
      api.dispatchAction({
        type: 'updateAxisPointer',
        x: payload.x,
        y: payload.y
      });

      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        target: api.getZr().findHover(payload.x, payload.y).target
      }, dispatchAction);
    }
  };

  TooltipView.prototype.manuallyHideTip = function (tooltipModel, ecModel, api, payload) {
    var tooltipContent = this._tooltipContent;

    if (!this._alwaysShowContent && this._tooltipModel) {
      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
    }

    this._lastX = this._lastY = this._lastDataByCoordSys = null;

    if (payload.from !== this.uid) {
      this._hide(makeDispatchAction(payload, api));
    }
  }; // Be compatible with previous design, that is, when tooltip.type is 'axis' and
  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
  // and tooltip.


  TooltipView.prototype._manuallyAxisShowTip = function (tooltipModel, ecModel, api, payload) {
    var seriesIndex = payload.seriesIndex;
    var dataIndex = payload.dataIndex; // @ts-ignore

    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;

    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
      return;
    }

    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);

    if (!seriesModel) {
      return;
    }

    var data = seriesModel.getData();
    var tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model], this._tooltipModel);

    if (tooltipCascadedModel.get('trigger') !== 'axis') {
      return;
    }

    api.dispatchAction({
      type: 'updateAxisPointer',
      seriesIndex: seriesIndex,
      dataIndex: dataIndex,
      position: payload.position
    });
    return true;
  };

  TooltipView.prototype._tryShow = function (e, dispatchAction) {
    var el = e.target;
    var tooltipModel = this._tooltipModel;

    if (!tooltipModel) {
      return;
    } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed


    this._lastX = e.offsetX;
    this._lastY = e.offsetY;
    var dataByCoordSys = e.dataByCoordSys;

    if (dataByCoordSys && dataByCoordSys.length) {
      this._showAxisTooltip(dataByCoordSys, e);
    } else if (el) {
      this._lastDataByCoordSys = null;
      var seriesDispatcher_1;
      var cmptDispatcher_1;
      findEventDispatcher(el, function (target) {
        // Always show item tooltip if mouse is on the element with dataIndex
        if (getECData(target).dataIndex != null) {
          seriesDispatcher_1 = target;
          return true;
        } // Tooltip provided directly. Like legend.


        if (getECData(target).tooltipConfig != null) {
          cmptDispatcher_1 = target;
          return true;
        }
      }, true);

      if (seriesDispatcher_1) {
        this._showSeriesItemTooltip(e, seriesDispatcher_1, dispatchAction);
      } else if (cmptDispatcher_1) {
        this._showComponentItemTooltip(e, cmptDispatcher_1, dispatchAction);
      } else {
        this._hide(dispatchAction);
      }
    } else {
      this._lastDataByCoordSys = null;

      this._hide(dispatchAction);
    }
  };

  TooltipView.prototype._showOrMove = function (tooltipModel, cb) {
    // showDelay is used in this case: tooltip.enterable is set
    // as true. User intent to move mouse into tooltip and click
    // something. `showDelay` makes it easier to enter the content
    // but tooltip do not move immediately.
    var delay = tooltipModel.get('showDelay');
    cb = bind$1(cb, this);
    clearTimeout(this._showTimout);
    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
  };

  TooltipView.prototype._showAxisTooltip = function (dataByCoordSys, e) {
    var ecModel = this._ecModel;
    var globalTooltipModel = this._tooltipModel;
    var point = [e.offsetX, e.offsetY];
    var singleTooltipModel = buildTooltipModel([e.tooltipOption], globalTooltipModel);
    var renderMode = this._renderMode;
    var cbParamsList = [];
    var articleMarkup = createTooltipMarkup('section', {
      blocks: [],
      noHeader: true
    }); // Only for legacy: `Serise['formatTooltip']` returns a string.

    var markupTextArrLegacy = [];
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    each$9(dataByCoordSys, function (itemCoordSys) {
      each$9(itemCoordSys.dataByAxis, function (axisItem) {
        var axisModel = ecModel.getComponent(axisItem.axisDim + 'Axis', axisItem.axisIndex);
        var axisValue = axisItem.value;

        if (!axisModel || axisValue == null) {
          return;
        }

        var axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
        var axisSectionMarkup = createTooltipMarkup('section', {
          header: axisValueLabel,
          noHeader: !trim(axisValueLabel),
          sortBlocks: true,
          blocks: []
        });
        articleMarkup.blocks.push(axisSectionMarkup);
        each$9(axisItem.seriesDataIndices, function (idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var cbParams = series.getDataParams(dataIndex); // Can't find data.

          if (cbParams.dataIndex < 0) {
            return;
          }

          cbParams.axisDim = axisItem.axisDim;
          cbParams.axisIndex = axisItem.axisIndex;
          cbParams.axisType = axisItem.axisType;
          cbParams.axisId = axisItem.axisId;
          cbParams.axisValue = getAxisRawValue(axisModel.axis, {
            value: axisValue
          });
          cbParams.axisValueLabel = axisValueLabel; // Pre-create marker style for makers. Users can assemble richText
          // text in `formatter` callback and use those markers style.

          cbParams.marker = markupStyleCreator.makeTooltipMarker('item', convertToColorString(cbParams.color), renderMode);
          var seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
          var frag = seriesTooltipResult.frag;

          if (frag) {
            var valueFormatter = buildTooltipModel([series], globalTooltipModel).get('valueFormatter');
            axisSectionMarkup.blocks.push(valueFormatter ? extend$2({
              valueFormatter: valueFormatter
            }, frag) : frag);
          }

          if (seriesTooltipResult.text) {
            markupTextArrLegacy.push(seriesTooltipResult.text);
          }

          cbParamsList.push(cbParams);
        });
      });
    }); // In most cases, the second axis is displays upper on the first one.
    // So we reverse it to look better.

    articleMarkup.blocks.reverse();
    markupTextArrLegacy.reverse();
    var positionExpr = e.position;
    var orderMode = singleTooltipModel.get('order');
    var builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get('useUTC'), singleTooltipModel.get('textStyle'));
    builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
    var blockBreak = renderMode === 'richText' ? '\n\n' : '<br/>';
    var allMarkupText = markupTextArrLegacy.join(blockBreak);

    this._showOrMove(singleTooltipModel, function () {
      if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {
        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
      } else {
        this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + '', point[0], point[1], positionExpr, null, markupStyleCreator);
      }
    }); // Do not trigger events here, because this branch only be entered
    // from dispatchAction.

  };

  TooltipView.prototype._showSeriesItemTooltip = function (e, dispatcher, dispatchAction) {
    var ecModel = this._ecModel;
    var ecData = getECData(dispatcher); // Use dataModel in element if possible
    // Used when mouseover on a element like markPoint or edge
    // In which case, the data is not main data in series.

    var seriesIndex = ecData.seriesIndex;
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link.

    var dataModel = ecData.dataModel || seriesModel;
    var dataIndex = ecData.dataIndex;
    var dataType = ecData.dataType;
    var data = dataModel.getData(dataType);
    var renderMode = this._renderMode;
    var positionDefault = e.positionDefault;
    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model], this._tooltipModel, positionDefault ? {
      position: positionDefault
    } : null);
    var tooltipTrigger = tooltipModel.get('trigger');

    if (tooltipTrigger != null && tooltipTrigger !== 'item') {
      return;
    }

    var params = dataModel.getDataParams(dataIndex, dataType);
    var markupStyleCreator = new TooltipMarkupStyleCreator(); // Pre-create marker style for makers. Users can assemble richText
    // text in `formatter` callback and use those markers style.

    params.marker = markupStyleCreator.makeTooltipMarker('item', convertToColorString(params.color), renderMode);
    var seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
    var orderMode = tooltipModel.get('order');
    var valueFormatter = tooltipModel.get('valueFormatter');
    var frag = seriesTooltipResult.frag;
    var markupText = frag ? buildTooltipMarkup(valueFormatter ? extend$2({
      valueFormatter: valueFormatter
    }, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get('useUTC'), tooltipModel.get('textStyle')) : seriesTooltipResult.text;
    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;

    this._showOrMove(tooltipModel, function () {
      this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target, markupStyleCreator);
    }); // FIXME
    // duplicated showtip if manuallyShowTip is called from dispatchAction.


    dispatchAction({
      type: 'showTip',
      dataIndexInside: dataIndex,
      dataIndex: data.getRawIndex(dataIndex),
      seriesIndex: seriesIndex,
      from: this.uid
    });
  };

  TooltipView.prototype._showComponentItemTooltip = function (e, el, dispatchAction) {
    var ecData = getECData(el);
    var tooltipConfig = ecData.tooltipConfig;
    var tooltipOpt = tooltipConfig.option || {};

    if (isString(tooltipOpt)) {
      var content = tooltipOpt;
      tooltipOpt = {
        content: content,
        // Fixed formatter
        formatter: content
      };
    }

    var tooltipModelCascade = [tooltipOpt];

    var cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);

    if (cmpt) {
      tooltipModelCascade.push(cmpt);
    } // In most cases, component tooltip formatter has different params with series tooltip formatter,
    // so that they can not share the same formatter. Since the global tooltip formatter is used for series
    // by convension, we do not use it as the default formatter for component.


    tooltipModelCascade.push({
      formatter: tooltipOpt.content
    });
    var positionDefault = e.positionDefault;
    var subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? {
      position: positionDefault
    } : null);
    var defaultHtml = subTooltipModel.get('content');
    var asyncTicket = Math.random() + ''; // PENDING: this case do not support richText style yet.

    var markupStyleCreator = new TooltipMarkupStyleCreator(); // Do not check whether `trigger` is 'none' here, because `trigger`
    // only works on coordinate system. In fact, we have not found case
    // that requires setting `trigger` nothing on component yet.

    this._showOrMove(subTooltipModel, function () {
      // Use formatterParams from element defined in component
      // Avoid users modify it.
      var formatterParams = clone$3(subTooltipModel.get('formatterParams') || {});

      this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e.offsetX, e.offsetY, e.position, el, markupStyleCreator);
    }); // If not dispatch showTip, tip may be hide triggered by axis.


    dispatchAction({
      type: 'showTip',
      from: this.uid
    });
  };

  TooltipView.prototype._showTooltipContent = function ( // Use Model<TooltipOption> insteadof TooltipModel because this model may be from series or other options.
  // Instead of top level tooltip.
  tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markupStyleCreator) {
    // Reset ticket
    this._ticket = '';

    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
      return;
    }

    var tooltipContent = this._tooltipContent;
    tooltipContent.setEnterable(tooltipModel.get('enterable'));
    var formatter = tooltipModel.get('formatter');
    positionExpr = positionExpr || tooltipModel.get('position');
    var html = defaultHtml;

    var nearPoint = this._getNearestPoint([x, y], params, tooltipModel.get('trigger'), tooltipModel.get('borderColor'));

    var nearPointColor = nearPoint.color;

    if (formatter) {
      if (isString(formatter)) {
        var useUTC = tooltipModel.ecModel.get('useUTC');
        var params0 = isArray$1(params) ? params[0] : params;
        var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf('time') >= 0;
        html = formatter;

        if (isTimeAxis) {
          html = format$1(params0.axisValue, html, useUTC);
        }

        html = formatTpl(html, params, true);
      } else if (isFunction(formatter)) {
        var callback = bind$1(function (cbTicket, html) {
          if (cbTicket === this._ticket) {
            tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);

            this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
          }
        }, this);
        this._ticket = asyncTicket;
        html = formatter(params, asyncTicket, callback);
      } else {
        html = formatter;
      }
    }

    tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
    tooltipContent.show(tooltipModel, nearPointColor);

    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
  };

  TooltipView.prototype._getNearestPoint = function (point, tooltipDataParams, trigger, borderColor) {
    if (trigger === 'axis' || isArray$1(tooltipDataParams)) {
      return {
        color: borderColor || (this._renderMode === 'html' ? '#fff' : 'none')
      };
    }

    if (!isArray$1(tooltipDataParams)) {
      return {
        color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
      };
    }
  };

  TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x, // Mouse x
  y, // Mouse y
  content, params, el) {
    var viewWidth = this._api.getWidth();

    var viewHeight = this._api.getHeight();

    positionExpr = positionExpr || tooltipModel.get('position');
    var contentSize = content.getSize();
    var align = tooltipModel.get('align');
    var vAlign = tooltipModel.get('verticalAlign');
    var rect = el && el.getBoundingRect().clone();
    el && rect.applyTransform(el.transform);

    if (isFunction(positionExpr)) {
      // Callback of position can be an array or a string specify the position
      positionExpr = positionExpr([x, y], params, content.el, rect, {
        viewSize: [viewWidth, viewHeight],
        contentSize: contentSize.slice()
      });
    }

    if (isArray$1(positionExpr)) {
      x = parsePercent(positionExpr[0], viewWidth);
      y = parsePercent(positionExpr[1], viewHeight);
    } else if (isObject$3(positionExpr)) {
      var boxLayoutPosition = positionExpr;
      boxLayoutPosition.width = contentSize[0];
      boxLayoutPosition.height = contentSize[1];
      var layoutRect = getLayoutRect(boxLayoutPosition, {
        width: viewWidth,
        height: viewHeight
      });
      x = layoutRect.x;
      y = layoutRect.y;
      align = null; // When positionExpr is left/top/right/bottom,
      // align and verticalAlign will not work.

      vAlign = null;
    } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
    else if (isString(positionExpr) && el) {
        var pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get('borderWidth'));
        x = pos[0];
        y = pos[1];
      } else {
        var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
        x = pos[0];
        y = pos[1];
      }

    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);

    if (shouldTooltipConfine(tooltipModel)) {
      var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
      x = pos[0];
      y = pos[1];
    }

    content.moveTo(x, y);
  }; // FIXME
  // Should we remove this but leave this to user?


  TooltipView.prototype._updateContentNotChangedOnAxis = function (dataByCoordSys, cbParamsList) {
    var lastCoordSys = this._lastDataByCoordSys;
    var lastCbParamsList = this._cbParamsList;
    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
    contentNotChanged && each$9(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {
      var lastDataByAxis = lastItemCoordSys.dataByAxis || [];
      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
      contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
      contentNotChanged && each$9(lastDataByAxis, function (lastItem, indexAxis) {
        var thisItem = thisDataByAxis[indexAxis] || {};
        var lastIndices = lastItem.seriesDataIndices || [];
        var newIndices = thisItem.seriesDataIndices || [];
        contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
        contentNotChanged && each$9(lastIndices, function (lastIdxItem, j) {
          var newIdxItem = newIndices[j];
          contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
        }); // check is cbParams data value changed

        lastCbParamsList && each$9(lastItem.seriesDataIndices, function (idxItem) {
          var seriesIdx = idxItem.seriesIndex;
          var cbParams = cbParamsList[seriesIdx];
          var lastCbParams = lastCbParamsList[seriesIdx];

          if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {
            contentNotChanged = false;
          }
        });
      });
    });
    this._lastDataByCoordSys = dataByCoordSys;
    this._cbParamsList = cbParamsList;
    return !!contentNotChanged;
  };

  TooltipView.prototype._hide = function (dispatchAction) {
    // Do not directly hideLater here, because this behavior may be prevented
    // in dispatchAction when showTip is dispatched.
    // FIXME
    // duplicated hideTip if manuallyHideTip is called from dispatchAction.
    this._lastDataByCoordSys = null;
    dispatchAction({
      type: 'hideTip',
      from: this.uid
    });
  };

  TooltipView.prototype.dispose = function (ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }

    clear(this, '_updatePosition');

    this._tooltipContent.dispose();

    unregister('itemTooltip', api);
  };

  TooltipView.type = 'tooltip';
  return TooltipView;
}(ComponentView$1);
/**
 * From top to bottom. (the last one should be globalTooltipModel);
 */


function buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {
  // Last is always tooltip model.
  var ecModel = globalTooltipModel.ecModel;
  var resultModel;

  if (defaultTooltipOption) {
    resultModel = new Model$1(defaultTooltipOption, ecModel, ecModel);
    resultModel = new Model$1(globalTooltipModel.option, resultModel, ecModel);
  } else {
    resultModel = globalTooltipModel;
  }

  for (var i = modelCascade.length - 1; i >= 0; i--) {
    var tooltipOpt = modelCascade[i];

    if (tooltipOpt) {
      if (tooltipOpt instanceof Model$1) {
        tooltipOpt = tooltipOpt.get('tooltip', true);
      } // In each data item tooltip can be simply write:
      // {
      //  value: 10,
      //  tooltip: 'Something you need to know'
      // }


      if (isString(tooltipOpt)) {
        tooltipOpt = {
          formatter: tooltipOpt
        };
      }

      if (tooltipOpt) {
        resultModel = new Model$1(tooltipOpt, resultModel, ecModel);
      }
    }
  }

  return resultModel;
}

function makeDispatchAction(payload, api) {
  return payload.dispatchAction || bind$1(api.dispatchAction, api);
}

function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
  var size = content.getSize();
  var width = size[0];
  var height = size[1];

  if (gapH != null) {
    // Add extra 2 pixels for this case:
    // At present the "values" in defaut tooltip are using CSS `float: right`.
    // When the right edge of the tooltip box is on the right side of the
    // viewport, the `float` layout might push the "values" to the second line.
    if (x + width + gapH + 2 > viewWidth) {
      x -= width + gapH;
    } else {
      x += gapH;
    }
  }

  if (gapV != null) {
    if (y + height + gapV > viewHeight) {
      y -= height + gapV;
    } else {
      y += gapV;
    }
  }

  return [x, y];
}

function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
  var size = content.getSize();
  var width = size[0];
  var height = size[1];
  x = Math.min(x + width, viewWidth) - width;
  y = Math.min(y + height, viewHeight) - height;
  x = Math.max(x, 0);
  y = Math.max(y, 0);
  return [x, y];
}

function calcTooltipPosition(position, rect, contentSize, borderWidth) {
  var domWidth = contentSize[0];
  var domHeight = contentSize[1];
  var offset = Math.ceil(Math.SQRT2 * borderWidth) + 8;
  var x = 0;
  var y = 0;
  var rectWidth = rect.width;
  var rectHeight = rect.height;

  switch (position) {
    case 'inside':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;

    case 'top':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y - domHeight - offset;
      break;

    case 'bottom':
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight + offset;
      break;

    case 'left':
      x = rect.x - domWidth - offset;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;

    case 'right':
      x = rect.x + rectWidth + offset;
      y = rect.y + rectHeight / 2 - domHeight / 2;
  }

  return [x, y];
}

function isCenterAlign(align) {
  return align === 'center' || align === 'middle';
}
/**
 * Find target component by payload like:
 * ```js
 * { legendId: 'some_id', name: 'xxx' }
 * { toolboxIndex: 1, name: 'xxx' }
 * { geoName: 'some_name', name: 'xxx' }
 * ```
 * PENDING: at present only
 *
 * If not found, return null/undefined.
 */


function findComponentReference(payload, ecModel, api) {
  var queryOptionMap = preParseFinder(payload).queryOptionMap;
  var componentMainType = queryOptionMap.keys()[0];

  if (!componentMainType || componentMainType === 'series') {
    return;
  }

  var queryResult = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {
    useDefault: false,
    enableAll: false,
    enableNone: false
  });
  var model = queryResult.models[0];

  if (!model) {
    return;
  }

  var view = api.getViewOfComponentModel(model);
  var el;
  view.group.traverse(function (subEl) {
    var tooltipConfig = getECData(subEl).tooltipConfig;

    if (tooltipConfig && tooltipConfig.name === payload.name) {
      el = subEl;
      return true; // stop
    }
  });

  if (el) {
    return {
      componentMainType: componentMainType,
      componentIndex: model.componentIndex,
      el: el
    };
  }
}

var TooltipView$1 = TooltipView;

function install$9(registers) {
  use(install$b);
  registers.registerComponentModel(TooltipModel$1);
  registers.registerComponentView(TooltipView$1);
  /**
   * @action
   * @property {string} type
   * @property {number} seriesIndex
   * @property {number} dataIndex
   * @property {number} [x]
   * @property {number} [y]
   */

  registers.registerAction({
    type: 'showTip',
    event: 'showTip',
    update: 'tooltip:manuallyShowTip'
  }, noop$1);
  registers.registerAction({
    type: 'hideTip',
    event: 'hideTip',
    update: 'tooltip:manuallyHideTip'
  }, noop$1);
}

var each$4 = each$9;

function hasKeys(obj) {
  if (obj) {
    for (var name_1 in obj) {
      if (obj.hasOwnProperty(name_1)) {
        return true;
      }
    }
  }
}

function createVisualMappings(option, stateList, supplementVisualOption) {
  var visualMappings = {};
  each$4(stateList, function (state) {
    var mappings = visualMappings[state] = createMappings();
    each$4(option[state], function (visualData, visualType) {
      if (!VisualMapping$1.isValidType(visualType)) {
        return;
      }

      var mappingOption = {
        type: visualType,
        visual: visualData
      };
      supplementVisualOption && supplementVisualOption(mappingOption, state);
      mappings[visualType] = new VisualMapping$1(mappingOption); // Prepare a alpha for opacity, for some case that opacity
      // is not supported, such as rendering using gradient color.

      if (visualType === 'opacity') {
        mappingOption = clone$3(mappingOption);
        mappingOption.type = 'colorAlpha';
        mappings.__hidden.__alphaForOpacity = new VisualMapping$1(mappingOption);
      }
    });
  });
  return visualMappings;

  function createMappings() {
    var Creater = function () {}; // Make sure hidden fields will not be visited by
    // object iteration (with hasOwnProperty checking).


    Creater.prototype.__hidden = Creater.prototype;
    var obj = new Creater();
    return obj;
  }
}
function replaceVisualOption(thisOption, newOption, keys) {
  // Visual attributes merge is not supported, otherwise it
  // brings overcomplicated merge logic. See #2853. So if
  // newOption has anyone of these keys, all of these keys
  // will be reset. Otherwise, all keys remain.
  var has;
  each$9(keys, function (key) {
    if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
      has = true;
    }
  });
  has && each$9(keys, function (key) {
    if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
      thisOption[key] = clone$3(newOption[key]);
    } else {
      delete thisOption[key];
    }
  });
}
/**
 * @param data
 * @param stateList
 * @param visualMappings <state, Object.<visualType, module:echarts/visual/VisualMapping>>
 * @param getValueState param: valueOrIndex, return: state.
 * @param dim dimension or dimension index.
 */

function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
  var visualTypesMap = {};
  each$9(stateList, function (state) {
    var visualTypes = VisualMapping$1.prepareVisualTypes(visualMappings[state]);
    visualTypesMap[state] = visualTypes;
  });
  return {
    progress: function progress(params, data) {
      var dimIndex;

      if (dim != null) {
        dimIndex = data.getDimensionIndex(dim);
      }

      function getVisual(key) {
        return getItemVisualFromData(data, dataIndex, key);
      }

      function setVisual(key, value) {
        setItemVisualFromData(data, dataIndex, key, value);
      }

      var dataIndex;
      var store = data.getStore();

      while ((dataIndex = params.next()) != null) {
        var rawDataItem = data.getRawDataItem(dataIndex); // Consider performance
        // @ts-ignore

        if (rawDataItem && rawDataItem.visualMap === false) {
          continue;
        }

        var value = dim != null ? store.get(dimIndex, dataIndex) : dataIndex;
        var valueState = getValueState(value);
        var mappings = visualMappings[valueState];
        var visualTypes = visualTypesMap[valueState];

        for (var i = 0, len = visualTypes.length; i < len; i++) {
          var type = visualTypes[i];
          mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
        }
      }
    }
  };
}

var TitleModel =
/** @class */
function (_super) {
  __extends$1(TitleModel, _super);

  function TitleModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TitleModel.type;
    _this.layoutMode = {
      type: 'box',
      ignoreSize: true
    };
    return _this;
  }

  TitleModel.type = 'title';
  TitleModel.defaultOption = {
    // zlevel: 0,
    z: 6,
    show: true,
    text: '',
    target: 'blank',
    subtext: '',
    subtarget: 'blank',
    left: 0,
    top: 0,
    backgroundColor: 'rgba(0,0,0,0)',
    borderColor: '#ccc',
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    textStyle: {
      fontSize: 18,
      fontWeight: 'bold',
      color: '#464646'
    },
    subtextStyle: {
      fontSize: 12,
      color: '#6E7079'
    }
  };
  return TitleModel;
}(ComponentModel$1); // View


var TitleView =
/** @class */
function (_super) {
  __extends$1(TitleView, _super);

  function TitleView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = TitleView.type;
    return _this;
  }

  TitleView.prototype.render = function (titleModel, ecModel, api) {
    this.group.removeAll();

    if (!titleModel.get('show')) {
      return;
    }

    var group = this.group;
    var textStyleModel = titleModel.getModel('textStyle');
    var subtextStyleModel = titleModel.getModel('subtextStyle');
    var textAlign = titleModel.get('textAlign');
    var textVerticalAlign = retrieve2(titleModel.get('textBaseline'), titleModel.get('textVerticalAlign'));
    var textEl = new ZRText$1({
      style: createTextStyle$1(textStyleModel, {
        text: titleModel.get('text'),
        fill: textStyleModel.getTextColor()
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var textRect = textEl.getBoundingRect();
    var subText = titleModel.get('subtext');
    var subTextEl = new ZRText$1({
      style: createTextStyle$1(subtextStyleModel, {
        text: subText,
        fill: subtextStyleModel.getTextColor(),
        y: textRect.height + titleModel.get('itemGap'),
        verticalAlign: 'top'
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var link = titleModel.get('link');
    var sublink = titleModel.get('sublink');
    var triggerEvent = titleModel.get('triggerEvent', true);
    textEl.silent = !link && !triggerEvent;
    subTextEl.silent = !sublink && !triggerEvent;

    if (link) {
      textEl.on('click', function () {
        windowOpen(link, '_' + titleModel.get('target'));
      });
    }

    if (sublink) {
      subTextEl.on('click', function () {
        windowOpen(sublink, '_' + titleModel.get('subtarget'));
      });
    }

    getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent ? {
      componentType: 'title',
      componentIndex: titleModel.componentIndex
    } : null;
    group.add(textEl);
    subText && group.add(subTextEl); // If no subText, but add subTextEl, there will be an empty line.

    var groupRect = group.getBoundingRect();
    var layoutOption = titleModel.getBoxLayoutParams();
    layoutOption.width = groupRect.width;
    layoutOption.height = groupRect.height;
    var layoutRect = getLayoutRect(layoutOption, {
      width: api.getWidth(),
      height: api.getHeight()
    }, titleModel.get('padding')); // Adjust text align based on position

    if (!textAlign) {
      // Align left if title is on the left. center and right is same
      textAlign = titleModel.get('left') || titleModel.get('right'); // @ts-ignore

      if (textAlign === 'middle') {
        textAlign = 'center';
      } // Adjust layout by text align


      if (textAlign === 'right') {
        layoutRect.x += layoutRect.width;
      } else if (textAlign === 'center') {
        layoutRect.x += layoutRect.width / 2;
      }
    }

    if (!textVerticalAlign) {
      textVerticalAlign = titleModel.get('top') || titleModel.get('bottom'); // @ts-ignore

      if (textVerticalAlign === 'center') {
        textVerticalAlign = 'middle';
      }

      if (textVerticalAlign === 'bottom') {
        layoutRect.y += layoutRect.height;
      } else if (textVerticalAlign === 'middle') {
        layoutRect.y += layoutRect.height / 2;
      }

      textVerticalAlign = textVerticalAlign || 'top';
    }

    group.x = layoutRect.x;
    group.y = layoutRect.y;
    group.markRedraw();
    var alignStyle = {
      align: textAlign,
      verticalAlign: textVerticalAlign
    };
    textEl.setStyle(alignStyle);
    subTextEl.setStyle(alignStyle); // Render background
    // Get groupRect again because textAlign has been changed

    groupRect = group.getBoundingRect();
    var padding = layoutRect.margin;
    var style = titleModel.getItemStyle(['color', 'opacity']);
    style.fill = titleModel.get('backgroundColor');
    var rect = new Rect$1({
      shape: {
        x: groupRect.x - padding[3],
        y: groupRect.y - padding[0],
        width: groupRect.width + padding[1] + padding[3],
        height: groupRect.height + padding[0] + padding[2],
        r: titleModel.get('borderRadius')
      },
      style: style,
      subPixelOptimize: true,
      silent: true
    });
    group.add(rect);
  };

  TitleView.type = 'title';
  return TitleView;
}(ComponentView$1);

function install$8(registers) {
  registers.registerComponentModel(TitleModel);
  registers.registerComponentView(TitleView);
}

var getDefaultSelectorOptions = function (ecModel, type) {
  if (type === 'all') {
    return {
      type: 'all',
      title: ecModel.getLocaleModel().get(['legend', 'selector', 'all'])
    };
  } else if (type === 'inverse') {
    return {
      type: 'inverse',
      title: ecModel.getLocaleModel().get(['legend', 'selector', 'inverse'])
    };
  }
};

var LegendModel =
/** @class */
function (_super) {
  __extends$1(LegendModel, _super);

  function LegendModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = LegendModel.type;
    _this.layoutMode = {
      type: 'box',
      // legend.width/height are maxWidth/maxHeight actually,
      // whereas realy width/height is calculated by its content.
      // (Setting {left: 10, right: 10} does not make sense).
      // So consider the case:
      // `setOption({legend: {left: 10});`
      // then `setOption({legend: {right: 10});`
      // The previous `left` should be cleared by setting `ignoreSize`.
      ignoreSize: true
    };
    return _this;
  }

  LegendModel.prototype.init = function (option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    option.selected = option.selected || {};

    this._updateSelector(option);
  };

  LegendModel.prototype.mergeOption = function (option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);

    this._updateSelector(option);
  };

  LegendModel.prototype._updateSelector = function (option) {
    var selector = option.selector;
    var ecModel = this.ecModel;

    if (selector === true) {
      selector = option.selector = ['all', 'inverse'];
    }

    if (isArray$1(selector)) {
      each$9(selector, function (item, index) {
        isString(item) && (item = {
          type: item
        });
        selector[index] = merge$1(item, getDefaultSelectorOptions(ecModel, item.type));
      });
    }
  };

  LegendModel.prototype.optionUpdated = function () {
    this._updateData(this.ecModel);

    var legendData = this._data; // If selectedMode is single, try to select one

    if (legendData[0] && this.get('selectedMode') === 'single') {
      var hasSelected = false; // If has any selected in option.selected

      for (var i = 0; i < legendData.length; i++) {
        var name_1 = legendData[i].get('name');

        if (this.isSelected(name_1)) {
          // Force to unselect others
          this.select(name_1);
          hasSelected = true;
          break;
        }
      } // Try select the first if selectedMode is single


      !hasSelected && this.select(legendData[0].get('name'));
    }
  };

  LegendModel.prototype._updateData = function (ecModel) {
    var potentialData = [];
    var availableNames = [];
    ecModel.eachRawSeries(function (seriesModel) {
      var seriesName = seriesModel.name;
      availableNames.push(seriesName);
      var isPotential;

      if (seriesModel.legendVisualProvider) {
        var provider = seriesModel.legendVisualProvider;
        var names = provider.getAllNames();

        if (!ecModel.isSeriesFiltered(seriesModel)) {
          availableNames = availableNames.concat(names);
        }

        if (names.length) {
          potentialData = potentialData.concat(names);
        } else {
          isPotential = true;
        }
      } else {
        isPotential = true;
      }

      if (isPotential && isNameSpecified(seriesModel)) {
        potentialData.push(seriesModel.name);
      }
    });
    /**
     * @type {Array.<string>}
     * @private
     */

    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,
    // which is convinient for user preparing option.

    var rawData = this.get('data') || potentialData;
    var legendData = map$1(rawData, function (dataItem) {
      // Can be string or number
      if (isString(dataItem) || isNumber(dataItem)) {
        dataItem = {
          name: dataItem
        };
      }

      return new Model$1(dataItem, this, this.ecModel);
    }, this);
    /**
     * @type {Array.<module:echarts/model/Model>}
     * @private
     */

    this._data = legendData;
  };

  LegendModel.prototype.getData = function () {
    return this._data;
  };

  LegendModel.prototype.select = function (name) {
    var selected = this.option.selected;
    var selectedMode = this.get('selectedMode');

    if (selectedMode === 'single') {
      var data = this._data;
      each$9(data, function (dataItem) {
        selected[dataItem.get('name')] = false;
      });
    }

    selected[name] = true;
  };

  LegendModel.prototype.unSelect = function (name) {
    if (this.get('selectedMode') !== 'single') {
      this.option.selected[name] = false;
    }
  };

  LegendModel.prototype.toggleSelected = function (name) {
    var selected = this.option.selected; // Default is true

    if (!selected.hasOwnProperty(name)) {
      selected[name] = true;
    }

    this[selected[name] ? 'unSelect' : 'select'](name);
  };

  LegendModel.prototype.allSelect = function () {
    var data = this._data;
    var selected = this.option.selected;
    each$9(data, function (dataItem) {
      selected[dataItem.get('name', true)] = true;
    });
  };

  LegendModel.prototype.inverseSelect = function () {
    var data = this._data;
    var selected = this.option.selected;
    each$9(data, function (dataItem) {
      var name = dataItem.get('name', true); // Initially, default value is true

      if (!selected.hasOwnProperty(name)) {
        selected[name] = true;
      }

      selected[name] = !selected[name];
    });
  };

  LegendModel.prototype.isSelected = function (name) {
    var selected = this.option.selected;
    return !(selected.hasOwnProperty(name) && !selected[name]) && indexOf(this._availableNames, name) >= 0;
  };

  LegendModel.prototype.getOrient = function () {
    return this.get('orient') === 'vertical' ? {
      index: 1,
      name: 'vertical'
    } : {
      index: 0,
      name: 'horizontal'
    };
  };

  LegendModel.type = 'legend.plain';
  LegendModel.dependencies = ['series'];
  LegendModel.defaultOption = {
    // zlevel: 0,
    z: 4,
    show: true,
    orient: 'horizontal',
    left: 'center',
    // right: 'center',
    top: 0,
    // bottom: null,
    align: 'auto',
    backgroundColor: 'rgba(0,0,0,0)',
    borderColor: '#ccc',
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    itemWidth: 25,
    itemHeight: 14,
    symbolRotate: 'inherit',
    symbolKeepAspect: true,
    inactiveColor: '#ccc',
    inactiveBorderColor: '#ccc',
    inactiveBorderWidth: 'auto',
    itemStyle: {
      color: 'inherit',
      opacity: 'inherit',
      borderColor: 'inherit',
      borderWidth: 'auto',
      borderCap: 'inherit',
      borderJoin: 'inherit',
      borderDashOffset: 'inherit',
      borderMiterLimit: 'inherit'
    },
    lineStyle: {
      width: 'auto',
      color: 'inherit',
      inactiveColor: '#ccc',
      inactiveWidth: 2,
      opacity: 'inherit',
      type: 'inherit',
      cap: 'inherit',
      join: 'inherit',
      dashOffset: 'inherit',
      miterLimit: 'inherit'
    },
    textStyle: {
      color: '#333'
    },
    selectedMode: true,
    selector: false,
    selectorLabel: {
      show: true,
      borderRadius: 10,
      padding: [3, 5, 3, 5],
      fontSize: 12,
      fontFamily: 'sans-serif',
      color: '#666',
      borderWidth: 1,
      borderColor: '#666'
    },
    emphasis: {
      selectorLabel: {
        show: true,
        color: '#eee',
        backgroundColor: '#666'
      }
    },
    selectorPosition: 'auto',
    selectorItemGap: 7,
    selectorButtonGap: 10,
    tooltip: {
      show: false
    }
  };
  return LegendModel;
}(ComponentModel$1);

var LegendModel$1 = LegendModel;

var curry = curry$1;
var each$3 = each$9;
var Group$1 = Group$3;

var LegendView =
/** @class */
function (_super) {
  __extends$1(LegendView, _super);

  function LegendView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = LegendView.type;
    _this.newlineDisabled = false;
    return _this;
  }

  LegendView.prototype.init = function () {
    this.group.add(this._contentGroup = new Group$1());
    this.group.add(this._selectorGroup = new Group$1());
    this._isFirstRender = true;
  };
  /**
   * @protected
   */


  LegendView.prototype.getContentGroup = function () {
    return this._contentGroup;
  };
  /**
   * @protected
   */


  LegendView.prototype.getSelectorGroup = function () {
    return this._selectorGroup;
  };
  /**
   * @override
   */


  LegendView.prototype.render = function (legendModel, ecModel, api) {
    var isFirstRender = this._isFirstRender;
    this._isFirstRender = false;
    this.resetInner();

    if (!legendModel.get('show', true)) {
      return;
    }

    var itemAlign = legendModel.get('align');
    var orient = legendModel.get('orient');

    if (!itemAlign || itemAlign === 'auto') {
      itemAlign = legendModel.get('left') === 'right' && orient === 'vertical' ? 'right' : 'left';
    } // selector has been normalized to an array in model


    var selector = legendModel.get('selector', true);
    var selectorPosition = legendModel.get('selectorPosition', true);

    if (selector && (!selectorPosition || selectorPosition === 'auto')) {
      selectorPosition = orient === 'horizontal' ? 'end' : 'start';
    }

    this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition); // Perform layout.

    var positionInfo = legendModel.getBoxLayoutParams();
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var padding = legendModel.get('padding');
    var maxSize = getLayoutRect(positionInfo, viewportSize, padding);
    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition); // Place mainGroup, based on the calculated `mainRect`.

    var layoutRect = getLayoutRect(defaults({
      width: mainRect.width,
      height: mainRect.height
    }, positionInfo), viewportSize, padding);
    this.group.x = layoutRect.x - mainRect.x;
    this.group.y = layoutRect.y - mainRect.y;
    this.group.markRedraw(); // Render background after group is layout.

    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
  };

  LegendView.prototype.resetInner = function () {
    this.getContentGroup().removeAll();
    this._backgroundEl && this.group.remove(this._backgroundEl);
    this.getSelectorGroup().removeAll();
  };

  LegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var legendDrawnMap = createHashMap();
    var selectMode = legendModel.get('selectedMode');
    var excludeSeriesId = [];
    ecModel.eachRawSeries(function (seriesModel) {
      !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);
    });
    each$3(legendModel.getData(), function (legendItemModel, dataIndex) {
      var name = legendItemModel.get('name'); // Use empty string or \n as a newline string

      if (!this.newlineDisabled && (name === '' || name === '\n')) {
        var g = new Group$1(); // @ts-ignore

        g.newline = true;
        contentGroup.add(g);
        return;
      } // Representitive series.


      var seriesModel = ecModel.getSeriesByName(name)[0];

      if (legendDrawnMap.get(name)) {
        // Have been drawed
        return;
      } // Legend to control series.


      if (seriesModel) {
        var data = seriesModel.getData();
        var lineVisualStyle = data.getVisual('legendLineStyle') || {};
        var legendIcon = data.getVisual('legendIcon');
        /**
         * `data.getVisual('style')` may be the color from the register
         * in series. For example, for line series,
         */

        var style = data.getVisual('style');

        var itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode, api);

        itemGroup.on('click', curry(dispatchSelectAction, name, null, api, excludeSeriesId)).on('mouseover', curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
        legendDrawnMap.set(name, true);
      } else {
        // Legend to control data. In pie and funnel.
        ecModel.eachRawSeries(function (seriesModel) {
          // In case multiple series has same data name
          if (legendDrawnMap.get(name)) {
            return;
          }

          if (seriesModel.legendVisualProvider) {
            var provider = seriesModel.legendVisualProvider;

            if (!provider.containName(name)) {
              return;
            }

            var idx = provider.indexOfName(name);
            var style = provider.getItemVisual(idx, 'style');
            var legendIcon = provider.getItemVisual(idx, 'legendIcon');
            var colorArr = parse(style.fill); // Color may be set to transparent in visualMap when data is out of range.
            // Do not show nothing.

            if (colorArr && colorArr[3] === 0) {
              colorArr[3] = 0.2; // TODO color is set to 0, 0, 0, 0. Should show correct RGBA

              style = extend$2(extend$2({}, style), {
                fill: stringify(colorArr, 'rgba')
              });
            }

            var itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, {}, style, legendIcon, selectMode, api); // FIXME: consider different series has items with the same name.


            itemGroup.on('click', curry(dispatchSelectAction, null, name, api, excludeSeriesId)) // Should not specify the series name, consider legend controls
            // more than one pie series.
            .on('mouseover', curry(dispatchHighlightAction, null, name, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, null, name, api, excludeSeriesId));
            legendDrawnMap.set(name, true);
          }
        }, this);
      }

      if (process.env.NODE_ENV !== 'production') {
        if (!legendDrawnMap.get(name)) {
          console.warn(name + ' series not exists. Legend data should be same with series name or data name.');
        }
      }
    }, this);

    if (selector) {
      this._createSelector(selector, legendModel, api, orient, selectorPosition);
    }
  };

  LegendView.prototype._createSelector = function (selector, legendModel, api, orient, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    each$3(selector, function createSelectorButton(selectorItem) {
      var type = selectorItem.type;
      var labelText = new ZRText$1({
        style: {
          x: 0,
          y: 0,
          align: 'center',
          verticalAlign: 'middle'
        },
        onclick: function () {
          api.dispatchAction({
            type: type === 'all' ? 'legendAllSelect' : 'legendInverseSelect'
          });
        }
      });
      selectorGroup.add(labelText);
      var labelModel = legendModel.getModel('selectorLabel');
      var emphasisLabelModel = legendModel.getModel(['emphasis', 'selectorLabel']);
      setLabelStyle(labelText, {
        normal: labelModel,
        emphasis: emphasisLabelModel
      }, {
        defaultText: selectorItem.title
      });
      enableHoverEmphasis(labelText);
    });
  };

  LegendView.prototype._createItem = function (seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode, api) {
    var drawType = seriesModel.visualDrawType;
    var itemWidth = legendModel.get('itemWidth');
    var itemHeight = legendModel.get('itemHeight');
    var isSelected = legendModel.isSelected(name);
    var iconRotate = legendItemModel.get('symbolRotate');
    var symbolKeepAspect = legendItemModel.get('symbolKeepAspect');
    var legendIconType = legendItemModel.get('icon');
    legendIcon = legendIconType || legendIcon || 'roundRect';
    var style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api);
    var itemGroup = new Group$1();
    var textStyleModel = legendItemModel.getModel('textStyle');

    if (isFunction(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === 'inherit')) {
      // Series has specific way to define legend icon
      itemGroup.add(seriesModel.getLegendIcon({
        itemWidth: itemWidth,
        itemHeight: itemHeight,
        icon: legendIcon,
        iconRotate: iconRotate,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect: symbolKeepAspect
      }));
    } else {
      // Use default legend icon policy for most series
      var rotate = legendIconType === 'inherit' && seriesModel.getData().getVisual('symbol') ? iconRotate === 'inherit' ? seriesModel.getData().getVisual('symbolRotate') : iconRotate : 0; // No rotation for no icon

      itemGroup.add(getDefaultLegendIcon({
        itemWidth: itemWidth,
        itemHeight: itemHeight,
        icon: legendIcon,
        iconRotate: rotate,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect: symbolKeepAspect
      }));
    }

    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;
    var textAlign = itemAlign;
    var formatter = legendModel.get('formatter');
    var content = name;

    if (isString(formatter) && formatter) {
      content = formatter.replace('{name}', name != null ? name : '');
    } else if (isFunction(formatter)) {
      content = formatter(name);
    }

    var inactiveColor = legendItemModel.get('inactiveColor');
    itemGroup.add(new ZRText$1({
      style: createTextStyle$1(textStyleModel, {
        text: content,
        x: textX,
        y: itemHeight / 2,
        fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
        align: textAlign,
        verticalAlign: 'middle'
      })
    })); // Add a invisible rect to increase the area of mouse hover

    var hitRect = new Rect$1({
      shape: itemGroup.getBoundingRect(),
      invisible: true
    });
    var tooltipModel = legendItemModel.getModel('tooltip');

    if (tooltipModel.get('show')) {
      setTooltipConfig({
        el: hitRect,
        componentModel: legendModel,
        itemName: name,
        itemTooltipOption: tooltipModel.option
      });
    }

    itemGroup.add(hitRect);
    itemGroup.eachChild(function (child) {
      child.silent = true;
    });
    hitRect.silent = !selectMode;
    this.getContentGroup().add(itemGroup);
    enableHoverEmphasis(itemGroup); // @ts-ignore

    itemGroup.__legendDataIndex = dataIndex;
    return itemGroup;
  };

  LegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var selectorGroup = this.getSelectorGroup(); // Place items in contentGroup.

    box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);
    var contentRect = contentGroup.getBoundingRect();
    var contentPos = [-contentRect.x, -contentRect.y];
    selectorGroup.markRedraw();
    contentGroup.markRedraw();

    if (selector) {
      // Place buttons in selectorGroup
      box( // Buttons in selectorGroup always layout horizontally
      'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));
      var selectorRect = selectorGroup.getBoundingRect();
      var selectorPos = [-selectorRect.x, -selectorRect.y];
      var selectorButtonGap = legendModel.get('selectorButtonGap', true);
      var orientIdx = legendModel.getOrient().index;
      var wh = orientIdx === 0 ? 'width' : 'height';
      var hw = orientIdx === 0 ? 'height' : 'width';
      var yx = orientIdx === 0 ? 'y' : 'x';

      if (selectorPosition === 'end') {
        selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
      } else {
        contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
      } //Always align selector to content as 'middle'


      selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      var mainRect = {
        x: 0,
        y: 0
      };
      mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
      mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
      return mainRect;
    } else {
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      return this.group.getBoundingRect();
    }
  };
  /**
   * @protected
   */


  LegendView.prototype.remove = function () {
    this.getContentGroup().removeAll();
    this._isFirstRender = true;
  };

  LegendView.type = 'legend.plain';
  return LegendView;
}(ComponentView$1);

function getLegendStyle(iconType, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api) {
  /**
   * Use series style if is inherit;
   * elsewise, use legend style
   */
  function handleCommonProps(style, visualStyle) {
    // If lineStyle.width is 'auto', it is set to be 2 if series has border
    if (style.lineWidth === 'auto') {
      style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;
    }

    each$3(style, function (propVal, propName) {
      style[propName] === 'inherit' && (style[propName] = visualStyle[propName]);
    });
  } // itemStyle


  var itemStyleModel = legendItemModel.getModel('itemStyle');
  var itemStyle = itemStyleModel.getItemStyle();
  var iconBrushType = iconType.lastIndexOf('empty', 0) === 0 ? 'fill' : 'stroke';
  var decalStyle = itemStyleModel.getShallow('decal');
  itemStyle.decal = !decalStyle || decalStyle === 'inherit' ? itemVisualStyle.decal : createOrUpdatePatternFromDecal(decalStyle, api);

  if (itemStyle.fill === 'inherit') {
    /**
     * Series with visualDrawType as 'stroke' should have
     * series stroke as legend fill
     */
    itemStyle.fill = itemVisualStyle[drawType];
  }

  if (itemStyle.stroke === 'inherit') {
    /**
     * icon type with "emptyXXX" should use fill color
     * in visual style
     */
    itemStyle.stroke = itemVisualStyle[iconBrushType];
  }

  if (itemStyle.opacity === 'inherit') {
    /**
     * Use lineStyle.opacity if drawType is stroke
     */
    itemStyle.opacity = (drawType === 'fill' ? itemVisualStyle : lineVisualStyle).opacity;
  }

  handleCommonProps(itemStyle, itemVisualStyle); // lineStyle

  var legendLineModel = legendItemModel.getModel('lineStyle');
  var lineStyle = legendLineModel.getLineStyle();
  handleCommonProps(lineStyle, lineVisualStyle); // Fix auto color to real color

  itemStyle.fill === 'auto' && (itemStyle.fill = itemVisualStyle.fill);
  itemStyle.stroke === 'auto' && (itemStyle.stroke = itemVisualStyle.fill);
  lineStyle.stroke === 'auto' && (lineStyle.stroke = itemVisualStyle.fill);

  if (!isSelected) {
    var borderWidth = legendItemModel.get('inactiveBorderWidth');
    /**
     * Since stroke is set to be inactiveBorderColor, it may occur that
     * there is no border in series but border in legend, so we need to
     * use border only when series has border if is set to be auto
     */

    var visualHasBorder = itemStyle[iconBrushType];
    itemStyle.lineWidth = borderWidth === 'auto' ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;
    itemStyle.fill = legendItemModel.get('inactiveColor');
    itemStyle.stroke = legendItemModel.get('inactiveBorderColor');
    lineStyle.stroke = legendLineModel.get('inactiveColor');
    lineStyle.lineWidth = legendLineModel.get('inactiveWidth');
  }

  return {
    itemStyle: itemStyle,
    lineStyle: lineStyle
  };
}

function getDefaultLegendIcon(opt) {
  var symboType = opt.icon || 'roundRect';
  var icon = createSymbol(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);
  icon.setStyle(opt.itemStyle);
  icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;
  icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);

  if (symboType.indexOf('empty') > -1) {
    icon.style.stroke = icon.style.fill;
    icon.style.fill = '#fff';
    icon.style.lineWidth = 2;
  }

  return icon;
}

function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
  // downplay before unselect
  dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
  api.dispatchAction({
    type: 'legendToggleSelect',
    name: seriesName != null ? seriesName : dataName
  }); // highlight after select
  // TODO higlight immediately may cause animation loss.

  dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
}

function isUseHoverLayer(api) {
  var list = api.getZr().storage.getDisplayList();
  var emphasisState;
  var i = 0;
  var len = list.length;

  while (i < len && !(emphasisState = list[i].states.emphasis)) {
    i++;
  }

  return emphasisState && emphasisState.hoverLayer;
}

function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
  // If element hover will move to a hoverLayer.
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: 'highlight',
      seriesName: seriesName,
      name: dataName,
      excludeSeriesId: excludeSeriesId
    });
  }
}

function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
  // If element hover will move to a hoverLayer.
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: 'downplay',
      seriesName: seriesName,
      name: dataName,
      excludeSeriesId: excludeSeriesId
    });
  }
}

var LegendView$1 = LegendView;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function legendFilter(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: 'legend'
  });

  if (legendModels && legendModels.length) {
    ecModel.filterSeries(function (series) {
      // If in any legend component the status is not selected.
      // Because in legend series is assumed selected when it is not in the legend data.
      for (var i = 0; i < legendModels.length; i++) {
        if (!legendModels[i].isSelected(series.name)) {
          return false;
        }
      }

      return true;
    });
  }
}

function legendSelectActionHandler(methodName, payload, ecModel) {
  var selectedMap = {};
  var isToggleSelect = methodName === 'toggleSelected';
  var isSelected; // Update all legend components

  ecModel.eachComponent('legend', function (legendModel) {
    if (isToggleSelect && isSelected != null) {
      // Force other legend has same selected status
      // Or the first is toggled to true and other are toggled to false
      // In the case one legend has some item unSelected in option. And if other legend
      // doesn't has the item, they will assume it is selected.
      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);
    } else if (methodName === 'allSelect' || methodName === 'inverseSelect') {
      legendModel[methodName]();
    } else {
      legendModel[methodName](payload.name);
      isSelected = legendModel.isSelected(payload.name);
    }

    var legendData = legendModel.getData();
    each$9(legendData, function (model) {
      var name = model.get('name'); // Wrap element

      if (name === '\n' || name === '') {
        return;
      }

      var isItemSelected = legendModel.isSelected(name);

      if (selectedMap.hasOwnProperty(name)) {
        // Unselected if any legend is unselected
        selectedMap[name] = selectedMap[name] && isItemSelected;
      } else {
        selectedMap[name] = isItemSelected;
      }
    });
  }); // Return the event explicitly

  return methodName === 'allSelect' || methodName === 'inverseSelect' ? {
    selected: selectedMap
  } : {
    name: payload.name,
    selected: selectedMap
  };
}

function installLegendAction(registers) {
  /**
   * @event legendToggleSelect
   * @type {Object}
   * @property {string} type 'legendToggleSelect'
   * @property {string} [from]
   * @property {string} name Series name or data item name
   */
  registers.registerAction('legendToggleSelect', 'legendselectchanged', curry$1(legendSelectActionHandler, 'toggleSelected'));
  registers.registerAction('legendAllSelect', 'legendselectall', curry$1(legendSelectActionHandler, 'allSelect'));
  registers.registerAction('legendInverseSelect', 'legendinverseselect', curry$1(legendSelectActionHandler, 'inverseSelect'));
  /**
   * @event legendSelect
   * @type {Object}
   * @property {string} type 'legendSelect'
   * @property {string} name Series name or data item name
   */

  registers.registerAction('legendSelect', 'legendselected', curry$1(legendSelectActionHandler, 'select'));
  /**
   * @event legendUnSelect
   * @type {Object}
   * @property {string} type 'legendUnSelect'
   * @property {string} name Series name or data item name
   */

  registers.registerAction('legendUnSelect', 'legendunselected', curry$1(legendSelectActionHandler, 'unSelect'));
}

function install$7(registers) {
  registers.registerComponentModel(LegendModel$1);
  registers.registerComponentView(LegendView$1);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
  registers.registerSubTypeDefaulter('legend', function () {
    return 'plain';
  });
  installLegendAction(registers);
}

var ScrollableLegendModel =
/** @class */
function (_super) {
  __extends$1(ScrollableLegendModel, _super);

  function ScrollableLegendModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ScrollableLegendModel.type;
    return _this;
  }
  /**
   * @param {number} scrollDataIndex
   */


  ScrollableLegendModel.prototype.setScrollDataIndex = function (scrollDataIndex) {
    this.option.scrollDataIndex = scrollDataIndex;
  };

  ScrollableLegendModel.prototype.init = function (option, parentModel, ecModel) {
    var inputPositionParams = getLayoutParams(option);

    _super.prototype.init.call(this, option, parentModel, ecModel);

    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
  };
  /**
   * @override
   */


  ScrollableLegendModel.prototype.mergeOption = function (option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);

    mergeAndNormalizeLayoutParams(this, this.option, option);
  };

  ScrollableLegendModel.type = 'legend.scroll';
  ScrollableLegendModel.defaultOption = inheritDefaultOption(LegendModel$1.defaultOption, {
    scrollDataIndex: 0,
    pageButtonItemGap: 5,
    pageButtonGap: null,
    pageButtonPosition: 'end',
    pageFormatter: '{current}/{total}',
    pageIcons: {
      horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],
      vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']
    },
    pageIconColor: '#2f4554',
    pageIconInactiveColor: '#aaa',
    pageIconSize: 15,
    pageTextStyle: {
      color: '#333'
    },
    animationDurationUpdate: 800
  });
  return ScrollableLegendModel;
}(LegendModel$1);

function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
  var orient = legendModel.getOrient();
  var ignoreSize = [1, 1];
  ignoreSize[orient.index] = 0;
  mergeLayoutParam(target, raw, {
    type: 'box',
    ignoreSize: !!ignoreSize
  });
}

var ScrollableLegendModel$1 = ScrollableLegendModel;

var Group = Group$3;
var WH = ['width', 'height'];
var XY = ['x', 'y'];

var ScrollableLegendView =
/** @class */
function (_super) {
  __extends$1(ScrollableLegendView, _super);

  function ScrollableLegendView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ScrollableLegendView.type;
    _this.newlineDisabled = true;
    _this._currentIndex = 0;
    return _this;
  }

  ScrollableLegendView.prototype.init = function () {
    _super.prototype.init.call(this);

    this.group.add(this._containerGroup = new Group());

    this._containerGroup.add(this.getContentGroup());

    this.group.add(this._controllerGroup = new Group());
  };
  /**
   * @override
   */


  ScrollableLegendView.prototype.resetInner = function () {
    _super.prototype.resetInner.call(this);

    this._controllerGroup.removeAll();

    this._containerGroup.removeClipPath();

    this._containerGroup.__rectSize = null;
  };
  /**
   * @override
   */


  ScrollableLegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
    var self = this; // Render content items.

    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);

    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,
    // e.g., '3/12345' should not overlap with the control arrow button.

    var pageIconSize = legendModel.get('pageIconSize', true);
    var pageIconSizeArr = isArray$1(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
    createPageButton('pagePrev', 0);
    var pageTextStyleModel = legendModel.getModel('pageTextStyle');
    controllerGroup.add(new ZRText$1({
      name: 'pageText',
      style: {
        // Placeholder to calculate a proper layout.
        text: 'xx/xx',
        fill: pageTextStyleModel.getTextColor(),
        font: pageTextStyleModel.getFont(),
        verticalAlign: 'middle',
        align: 'center'
      },
      silent: true
    }));
    createPageButton('pageNext', 1);

    function createPageButton(name, iconIdx) {
      var pageDataIndexName = name + 'DataIndex';
      var icon = createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {
        // Buttons will be created in each render, so we do not need
        // to worry about avoiding using legendModel kept in scope.
        onclick: bind$1(self._pageGo, self, pageDataIndexName, legendModel, api)
      }, {
        x: -pageIconSizeArr[0] / 2,
        y: -pageIconSizeArr[1] / 2,
        width: pageIconSizeArr[0],
        height: pageIconSizeArr[1]
      });
      icon.name = name;
      controllerGroup.add(icon);
    }
  };
  /**
   * @override
   */


  ScrollableLegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var xy = XY[orientIdx];
    var hw = WH[1 - orientIdx];
    var yx = XY[1 - orientIdx];
    selector && box( // Buttons in selectorGroup always layout horizontally
    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));
    var selectorButtonGap = legendModel.get('selectorButtonGap', true);
    var selectorRect = selectorGroup.getBoundingRect();
    var selectorPos = [-selectorRect.x, -selectorRect.y];
    var processMaxSize = clone$3(maxSize);
    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);

    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);

    if (selector) {
      if (selectorPosition === 'end') {
        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
      } else {
        var offset = selectorRect[wh] + selectorButtonGap;
        selectorPos[orientIdx] -= offset;
        mainRect[xy] -= offset;
      }

      mainRect[wh] += selectorRect[wh] + selectorButtonGap;
      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      selectorGroup.markRedraw();
    }

    return mainRect;
  };

  ScrollableLegendView.prototype._layoutContentAndController = function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
    var contentGroup = this.getContentGroup();
    var containerGroup = this._containerGroup;
    var controllerGroup = this._controllerGroup; // Place items in contentGroup.

    box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
    box( // Buttons in controller are layout always horizontally.
    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));
    var contentRect = contentGroup.getBoundingRect();
    var controllerRect = controllerGroup.getBoundingRect();
    var showController = this._showController = contentRect[wh] > maxSize[wh]; // In case that the inner elements of contentGroup layout do not based on [0, 0]

    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.
    // If first rendering, `contentGroup.position` is [0, 0], which
    // does not make sense and may cause unexepcted animation if adopted.

    if (!isFirstRender) {
      contentPos[orientIdx] = contentGroup[xy];
    } // Layout container group based on 0.


    var containerPos = [0, 0];
    var controllerPos = [-controllerRect.x, -controllerRect.y];
    var pageButtonGap = retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.

    if (showController) {
      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.

      if (pageButtonPosition === 'end') {
        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
      } // controller is on the left / top.
      else {
          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
        }
    } // Always align controller to content as 'middle'.


    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
    contentGroup.setPosition(contentPos);
    containerGroup.setPosition(containerPos);
    controllerGroup.setPosition(controllerPos); // Calculate `mainRect` and set `clipPath`.
    // mainRect should not be calculated by `this.group.getBoundingRect()`
    // for sake of the overflow.

    var mainRect = {
      x: 0,
      y: 0
    }; // Consider content may be overflow (should be clipped).

    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.

    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
    containerGroup.__rectSize = maxSize[wh];

    if (showController) {
      var clipShape = {
        x: 0,
        y: 0
      };
      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
      clipShape[hw] = mainRect[hw];
      containerGroup.setClipPath(new Rect$1({
        shape: clipShape
      })); // Consider content may be larger than container, container rect
      // can not be obtained from `containerGroup.getBoundingRect()`.

      containerGroup.__rectSize = clipShape[wh];
    } else {
      // Do not remove or ignore controller. Keep them set as placeholders.
      controllerGroup.eachChild(function (child) {
        child.attr({
          invisible: true,
          silent: true
        });
      });
    } // Content translate animation.


    var pageInfo = this._getPageInfo(legendModel);

    pageInfo.pageIndex != null && updateProps$1(contentGroup, {
      x: pageInfo.contentPosition[0],
      y: pageInfo.contentPosition[1]
    }, // When switch from "show controller" to "not show controller", view should be
    // updated immediately without animation, otherwise causes weird effect.
    showController ? legendModel : null);

    this._updatePageInfoView(legendModel, pageInfo);

    return mainRect;
  };

  ScrollableLegendView.prototype._pageGo = function (to, legendModel, api) {
    var scrollDataIndex = this._getPageInfo(legendModel)[to];

    scrollDataIndex != null && api.dispatchAction({
      type: 'legendScroll',
      scrollDataIndex: scrollDataIndex,
      legendId: legendModel.id
    });
  };

  ScrollableLegendView.prototype._updatePageInfoView = function (legendModel, pageInfo) {
    var controllerGroup = this._controllerGroup;
    each$9(['pagePrev', 'pageNext'], function (name) {
      var key = name + 'DataIndex';
      var canJump = pageInfo[key] != null;
      var icon = controllerGroup.childOfName(name);

      if (icon) {
        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));
        icon.cursor = canJump ? 'pointer' : 'default';
      }
    });
    var pageText = controllerGroup.childOfName('pageText');
    var pageFormatter = legendModel.get('pageFormatter');
    var pageIndex = pageInfo.pageIndex;
    var current = pageIndex != null ? pageIndex + 1 : 0;
    var total = pageInfo.pageCount;
    pageText && pageFormatter && pageText.setStyle('text', isString(pageFormatter) ? pageFormatter.replace('{current}', current == null ? '' : current + '').replace('{total}', total == null ? '' : total + '') : pageFormatter({
      current: current,
      total: total
    }));
  };
  /**
   *  contentPosition: Array.<number>, null when data item not found.
   *  pageIndex: number, null when data item not found.
   *  pageCount: number, always be a number, can be 0.
   *  pagePrevDataIndex: number, null when no previous page.
   *  pageNextDataIndex: number, null when no next page.
   * }
   */


  ScrollableLegendView.prototype._getPageInfo = function (legendModel) {
    var scrollDataIndex = legendModel.get('scrollDataIndex', true);
    var contentGroup = this.getContentGroup();
    var containerRectSize = this._containerGroup.__rectSize;
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var xy = XY[orientIdx];

    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);

    var children = contentGroup.children();
    var targetItem = children[targetItemIndex];
    var itemCount = children.length;
    var pCount = !itemCount ? 0 : 1;
    var result = {
      contentPosition: [contentGroup.x, contentGroup.y],
      pageCount: pCount,
      pageIndex: pCount - 1,
      pagePrevDataIndex: null,
      pageNextDataIndex: null
    };

    if (!targetItem) {
      return result;
    }

    var targetItemInfo = getItemInfo(targetItem);
    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:
    // (1) Always align based on the left/top most item.
    // (2) It is user-friendly that the last item shown in the
    // current window is shown at the begining of next window.
    // Otherwise if half of the last item is cut by the window,
    // it will have no chance to display entirely.
    // (3) Consider that item size probably be different, we
    // have calculate pageIndex by size rather than item index,
    // and we can not get page index directly by division.
    // (4) The window is to narrow to contain more than
    // one item, we should make sure that the page can be fliped.

    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
      currItemInfo = getItemInfo(children[i]);

      if ( // Half of the last item is out of the window.
      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page
      // can be started at the current item or the last item.
      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {
        if (winEndItemInfo.i > winStartItemInfo.i) {
          winStartItemInfo = winEndItemInfo;
        } else {
          // e.g., when page size is smaller than item size.
          winStartItemInfo = currItemInfo;
        }

        if (winStartItemInfo) {
          if (result.pageNextDataIndex == null) {
            result.pageNextDataIndex = winStartItemInfo.i;
          }

          ++result.pageCount;
        }
      }

      winEndItemInfo = currItemInfo;
    }

    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
      currItemInfo = getItemInfo(children[i]);

      if ( // If the the end item does not intersect with the window started
      // from the current item, a page can be settled.
      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.
      winStartItemInfo.i < winEndItemInfo.i) {
        winEndItemInfo = winStartItemInfo;

        if (result.pagePrevDataIndex == null) {
          result.pagePrevDataIndex = winStartItemInfo.i;
        }

        ++result.pageCount;
        ++result.pageIndex;
      }

      winStartItemInfo = currItemInfo;
    }

    return result;

    function getItemInfo(el) {
      if (el) {
        var itemRect = el.getBoundingRect();
        var start = itemRect[xy] + el[xy];
        return {
          s: start,
          e: start + itemRect[wh],
          i: el.__legendDataIndex
        };
      }
    }

    function intersect(itemInfo, winStart) {
      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
    }
  };

  ScrollableLegendView.prototype._findTargetItemIndex = function (targetDataIndex) {
    if (!this._showController) {
      return 0;
    }

    var index;
    var contentGroup = this.getContentGroup();
    var defaultIndex;
    contentGroup.eachChild(function (child, idx) {
      var legendDataIdx = child.__legendDataIndex; // FIXME
      // If the given targetDataIndex (from model) is illegal,
      // we use defaultIndex. But the index on the legend model and
      // action payload is still illegal. That case will not be
      // changed until some scenario requires.

      if (defaultIndex == null && legendDataIdx != null) {
        defaultIndex = idx;
      }

      if (legendDataIdx === targetDataIndex) {
        index = idx;
      }
    });
    return index != null ? index : defaultIndex;
  };

  ScrollableLegendView.type = 'legend.scroll';
  return ScrollableLegendView;
}(LegendView$1);

var ScrollableLegendView$1 = ScrollableLegendView;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function installScrollableLegendAction(registers) {
  /**
   * @event legendScroll
   * @type {Object}
   * @property {string} type 'legendScroll'
   * @property {string} scrollDataIndex
   */
  registers.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {
    var scrollDataIndex = payload.scrollDataIndex;
    scrollDataIndex != null && ecModel.eachComponent({
      mainType: 'legend',
      subType: 'scroll',
      query: payload
    }, function (legendModel) {
      legendModel.setScrollDataIndex(scrollDataIndex);
    });
  });
}

function install$6(registers) {
  use(install$7);
  registers.registerComponentModel(ScrollableLegendModel$1);
  registers.registerComponentView(ScrollableLegendView$1);
  installScrollableLegendAction(registers);
}

function install$5(registers) {
  use(install$7);
  use(install$6);
}

var visualDefault = {
  /**
   * @public
   */
  get: function (visualType, key, isCategory) {
    var value = clone$3((defaultOption[visualType] || {})[key]);
    return isCategory ? isArray$1(value) ? value[value.length - 1] : value : value;
  }
};
var defaultOption = {
  color: {
    active: ['#006edd', '#e0ffff'],
    inactive: ['rgba(0,0,0,0)']
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ['circle', 'roundRect', 'diamond'],
    inactive: ['none']
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
};
var visualDefault$1 = visualDefault;

var mapVisual = VisualMapping$1.mapVisual;
var eachVisual = VisualMapping$1.eachVisual;
var isArray = isArray$1;
var each$2 = each$9;
var asc = asc$1;
var linearMap$1 = linearMap$2;

var VisualMapModel =
/** @class */
function (_super) {
  __extends$1(VisualMapModel, _super);

  function VisualMapModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = VisualMapModel.type;
    _this.stateList = ['inRange', 'outOfRange'];
    _this.replacableOptionKeys = ['inRange', 'outOfRange', 'target', 'controller', 'color'];
    _this.layoutMode = {
      type: 'box',
      ignoreSize: true
    };
    /**
     * [lowerBound, upperBound]
     */

    _this.dataBound = [-Infinity, Infinity];
    _this.targetVisuals = {};
    _this.controllerVisuals = {};
    return _this;
  }

  VisualMapModel.prototype.init = function (option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  };
  /**
   * @protected
   */


  VisualMapModel.prototype.optionUpdated = function (newOption, isInit) {
    var thisOption = this.option;
    !isInit && replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
    this.textStyleModel = this.getModel('textStyle');
    this.resetItemSize();
    this.completeVisualOption();
  };
  /**
   * @protected
   */


  VisualMapModel.prototype.resetVisual = function (supplementVisualOption) {
    var stateList = this.stateList;
    supplementVisualOption = bind$1(supplementVisualOption, this);
    this.controllerVisuals = createVisualMappings(this.option.controller, stateList, supplementVisualOption);
    this.targetVisuals = createVisualMappings(this.option.target, stateList, supplementVisualOption);
  };
  /**
   * @public
   */


  VisualMapModel.prototype.getItemSymbol = function () {
    return null;
  };
  /**
   * @protected
   * @return {Array.<number>} An array of series indices.
   */


  VisualMapModel.prototype.getTargetSeriesIndices = function () {
    var optionSeriesIndex = this.option.seriesIndex;
    var seriesIndices = [];

    if (optionSeriesIndex == null || optionSeriesIndex === 'all') {
      this.ecModel.eachSeries(function (seriesModel, index) {
        seriesIndices.push(index);
      });
    } else {
      seriesIndices = normalizeToArray(optionSeriesIndex);
    }

    return seriesIndices;
  };
  /**
   * @public
   */


  VisualMapModel.prototype.eachTargetSeries = function (callback, context) {
    each$9(this.getTargetSeriesIndices(), function (seriesIndex) {
      var seriesModel = this.ecModel.getSeriesByIndex(seriesIndex);

      if (seriesModel) {
        callback.call(context, seriesModel);
      }
    }, this);
  };
  /**
   * @pubilc
   */


  VisualMapModel.prototype.isTargetSeries = function (seriesModel) {
    var is = false;
    this.eachTargetSeries(function (model) {
      model === seriesModel && (is = true);
    });
    return is;
  };
  /**
   * @example
   * this.formatValueText(someVal); // format single numeric value to text.
   * this.formatValueText(someVal, true); // format single category value to text.
   * this.formatValueText([min, max]); // format numeric min-max to text.
   * this.formatValueText([this.dataBound[0], max]); // using data lower bound.
   * this.formatValueText([min, this.dataBound[1]]); // using data upper bound.
   *
   * @param value Real value, or this.dataBound[0 or 1].
   * @param isCategory Only available when value is number.
   * @param edgeSymbols Open-close symbol when value is interval.
   * @protected
   */


  VisualMapModel.prototype.formatValueText = function (value, isCategory, edgeSymbols) {
    var option = this.option;
    var precision = option.precision;
    var dataBound = this.dataBound;
    var formatter = option.formatter;
    var isMinMax;
    edgeSymbols = edgeSymbols || ['<', '>'];

    if (isArray$1(value)) {
      value = value.slice();
      isMinMax = true;
    }

    var textValue = isCategory ? value // Value is string when isCategory
    : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);

    if (isString(formatter)) {
      return formatter.replace('{value}', isMinMax ? textValue[0] : textValue).replace('{value2}', isMinMax ? textValue[1] : textValue);
    } else if (isFunction(formatter)) {
      return isMinMax ? formatter(value[0], value[1]) : formatter(value);
    }

    if (isMinMax) {
      if (value[0] === dataBound[0]) {
        return edgeSymbols[0] + ' ' + textValue[1];
      } else if (value[1] === dataBound[1]) {
        return edgeSymbols[1] + ' ' + textValue[0];
      } else {
        return textValue[0] + ' - ' + textValue[1];
      }
    } else {
      // Format single value (includes category case).
      return textValue;
    }

    function toFixed(val) {
      return val === dataBound[0] ? 'min' : val === dataBound[1] ? 'max' : (+val).toFixed(Math.min(precision, 20));
    }
  };
  /**
   * @protected
   */


  VisualMapModel.prototype.resetExtent = function () {
    var thisOption = this.option; // Can not calculate data extent by data here.
    // Because series and data may be modified in processing stage.
    // So we do not support the feature "auto min/max".

    var extent = asc([thisOption.min, thisOption.max]);
    this._dataExtent = extent;
  };
  /**
   * PENDING:
   * delete this method if no outer usage.
   *
   * Return  Concrete dimention. If return null/undefined, no dimension used.
   */
  // getDataDimension(data: SeriesData) {
  //     const optDim = this.option.dimension;
  //     if (optDim != null) {
  //         return data.getDimension(optDim);
  //     }
  //     const dimNames = data.dimensions;
  //     for (let i = dimNames.length - 1; i >= 0; i--) {
  //         const dimName = dimNames[i];
  //         const dimInfo = data.getDimensionInfo(dimName);
  //         if (!dimInfo.isCalculationCoord) {
  //             return dimName;
  //         }
  //     }
  // }


  VisualMapModel.prototype.getDataDimensionIndex = function (data) {
    var optDim = this.option.dimension;

    if (optDim != null) {
      return data.getDimensionIndex(optDim);
    }

    var dimNames = data.dimensions;

    for (var i = dimNames.length - 1; i >= 0; i--) {
      var dimName = dimNames[i];
      var dimInfo = data.getDimensionInfo(dimName);

      if (!dimInfo.isCalculationCoord) {
        return dimInfo.storeDimIndex;
      }
    }
  };

  VisualMapModel.prototype.getExtent = function () {
    return this._dataExtent.slice();
  };

  VisualMapModel.prototype.completeVisualOption = function () {
    var ecModel = this.ecModel;
    var thisOption = this.option;
    var base = {
      inRange: thisOption.inRange,
      outOfRange: thisOption.outOfRange
    };
    var target = thisOption.target || (thisOption.target = {});
    var controller = thisOption.controller || (thisOption.controller = {});
    merge$1(target, base); // Do not override

    merge$1(controller, base); // Do not override

    var isCategory = this.isCategory();
    completeSingle.call(this, target);
    completeSingle.call(this, controller);
    completeInactive.call(this, target, 'inRange', 'outOfRange'); // completeInactive.call(this, target, 'outOfRange', 'inRange');

    completeController.call(this, controller);

    function completeSingle(base) {
      // Compatible with ec2 dataRange.color.
      // The mapping order of dataRange.color is: [high value, ..., low value]
      // whereas inRange.color and outOfRange.color is [low value, ..., high value]
      // Notice: ec2 has no inverse.
      if (isArray(thisOption.color) // If there has been inRange: {symbol: ...}, adding color is a mistake.
      // So adding color only when no inRange defined.
      && !base.inRange) {
        base.inRange = {
          color: thisOption.color.slice().reverse()
        };
      } // Compatible with previous logic, always give a defautl color, otherwise
      // simple config with no inRange and outOfRange will not work.
      // Originally we use visualMap.color as the default color, but setOption at
      // the second time the default color will be erased. So we change to use
      // constant DEFAULT_COLOR.
      // If user do not want the default color, set inRange: {color: null}.


      base.inRange = base.inRange || {
        color: ecModel.get('gradientColor')
      };
    }

    function completeInactive(base, stateExist, stateAbsent) {
      var optExist = base[stateExist];
      var optAbsent = base[stateAbsent];

      if (optExist && !optAbsent) {
        optAbsent = base[stateAbsent] = {};
        each$2(optExist, function (visualData, visualType) {
          if (!VisualMapping$1.isValidType(visualType)) {
            return;
          }

          var defa = visualDefault$1.get(visualType, 'inactive', isCategory);

          if (defa != null) {
            optAbsent[visualType] = defa; // Compatibable with ec2:
            // Only inactive color to rgba(0,0,0,0) can not
            // make label transparent, so use opacity also.

            if (visualType === 'color' && !optAbsent.hasOwnProperty('opacity') && !optAbsent.hasOwnProperty('colorAlpha')) {
              optAbsent.opacity = [0, 0];
            }
          }
        });
      }
    }

    function completeController(controller) {
      var symbolExists = (controller.inRange || {}).symbol || (controller.outOfRange || {}).symbol;
      var symbolSizeExists = (controller.inRange || {}).symbolSize || (controller.outOfRange || {}).symbolSize;
      var inactiveColor = this.get('inactiveColor');
      var itemSymbol = this.getItemSymbol();
      var defaultSymbol = itemSymbol || 'roundRect';
      each$2(this.stateList, function (state) {
        var itemSize = this.itemSize;
        var visuals = controller[state]; // Set inactive color for controller if no other color
        // attr (like colorAlpha) specified.

        if (!visuals) {
          visuals = controller[state] = {
            color: isCategory ? inactiveColor : [inactiveColor]
          };
        } // Consistent symbol and symbolSize if not specified.


        if (visuals.symbol == null) {
          visuals.symbol = symbolExists && clone$3(symbolExists) || (isCategory ? defaultSymbol : [defaultSymbol]);
        }

        if (visuals.symbolSize == null) {
          visuals.symbolSize = symbolSizeExists && clone$3(symbolSizeExists) || (isCategory ? itemSize[0] : [itemSize[0], itemSize[0]]);
        } // Filter none


        visuals.symbol = mapVisual(visuals.symbol, function (symbol) {
          return symbol === 'none' ? defaultSymbol : symbol;
        }); // Normalize symbolSize

        var symbolSize = visuals.symbolSize;

        if (symbolSize != null) {
          var max_1 = -Infinity; // symbolSize can be object when categories defined.

          eachVisual(symbolSize, function (value) {
            value > max_1 && (max_1 = value);
          });
          visuals.symbolSize = mapVisual(symbolSize, function (value) {
            return linearMap$1(value, [0, max_1], [0, itemSize[0]], true);
          });
        }
      }, this);
    }
  };

  VisualMapModel.prototype.resetItemSize = function () {
    this.itemSize = [parseFloat(this.get('itemWidth')), parseFloat(this.get('itemHeight'))];
  };

  VisualMapModel.prototype.isCategory = function () {
    return !!this.option.categories;
  };
  /**
   * @public
   * @abstract
   */


  VisualMapModel.prototype.setSelected = function (selected) {};

  VisualMapModel.prototype.getSelected = function () {
    return null;
  };
  /**
   * @public
   * @abstract
   */


  VisualMapModel.prototype.getValueState = function (value) {
    return null;
  };
  /**
   * FIXME
   * Do not publish to thirt-part-dev temporarily
   * util the interface is stable. (Should it return
   * a function but not visual meta?)
   *
   * @pubilc
   * @abstract
   * @param getColorVisual
   *        params: value, valueState
   *        return: color
   * @return {Object} visualMeta
   *        should includes {stops, outerColors}
   *        outerColor means [colorBeyondMinValue, colorBeyondMaxValue]
   */


  VisualMapModel.prototype.getVisualMeta = function (getColorVisual) {
    return null;
  };

  VisualMapModel.type = 'visualMap';
  VisualMapModel.dependencies = ['series'];
  VisualMapModel.defaultOption = {
    show: true,
    // zlevel: 0,
    z: 4,
    seriesIndex: 'all',
    min: 0,
    max: 200,
    left: 0,
    right: null,
    top: null,
    bottom: 0,
    itemWidth: null,
    itemHeight: null,
    inverse: false,
    orient: 'vertical',
    backgroundColor: 'rgba(0,0,0,0)',
    borderColor: '#ccc',
    contentColor: '#5793f3',
    inactiveColor: '#aaa',
    borderWidth: 0,
    padding: 5,
    // 接受数组分别设定上右下左边距，同css
    textGap: 10,
    precision: 0,
    textStyle: {
      color: '#333' // 值域文字颜色

    }
  };
  return VisualMapModel;
}(ComponentModel$1);

var VisualMapModel$1 = VisualMapModel;

var DEFAULT_BAR_BOUND = [20, 140];

var ContinuousModel =
/** @class */
function (_super) {
  __extends$1(ContinuousModel, _super);

  function ContinuousModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ContinuousModel.type;
    return _this;
  }
  /**
   * @override
   */


  ContinuousModel.prototype.optionUpdated = function (newOption, isInit) {
    _super.prototype.optionUpdated.apply(this, arguments);

    this.resetExtent();
    this.resetVisual(function (mappingOption) {
      mappingOption.mappingMethod = 'linear';
      mappingOption.dataExtent = this.getExtent();
    });

    this._resetRange();
  };
  /**
   * @protected
   * @override
   */


  ContinuousModel.prototype.resetItemSize = function () {
    _super.prototype.resetItemSize.apply(this, arguments);

    var itemSize = this.itemSize;
    (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
    (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
  };
  /**
   * @private
   */


  ContinuousModel.prototype._resetRange = function () {
    var dataExtent = this.getExtent();
    var range = this.option.range;

    if (!range || range.auto) {
      // `range` should always be array (so we dont use other
      // value like 'auto') for user-friend. (consider getOption).
      dataExtent.auto = 1;
      this.option.range = dataExtent;
    } else if (isArray$1(range)) {
      if (range[0] > range[1]) {
        range.reverse();
      }

      range[0] = Math.max(range[0], dataExtent[0]);
      range[1] = Math.min(range[1], dataExtent[1]);
    }
  };
  /**
   * @protected
   * @override
   */


  ContinuousModel.prototype.completeVisualOption = function () {
    _super.prototype.completeVisualOption.apply(this, arguments);

    each$9(this.stateList, function (state) {
      var symbolSize = this.option.controller[state].symbolSize;

      if (symbolSize && symbolSize[0] !== symbolSize[1]) {
        symbolSize[0] = symbolSize[1] / 3; // For good looking.
      }
    }, this);
  };
  /**
   * @override
   */


  ContinuousModel.prototype.setSelected = function (selected) {
    this.option.range = selected.slice();

    this._resetRange();
  };
  /**
   * @public
   */


  ContinuousModel.prototype.getSelected = function () {
    var dataExtent = this.getExtent();
    var dataInterval = asc$1((this.get('range') || []).slice()); // Clamp

    dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
    dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
    dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
    dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
    return dataInterval;
  };
  /**
   * @override
   */


  ContinuousModel.prototype.getValueState = function (value) {
    var range = this.option.range;
    var dataExtent = this.getExtent(); // When range[0] === dataExtent[0], any value larger than dataExtent[0] maps to 'inRange'.
    // range[1] is processed likewise.

    return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? 'inRange' : 'outOfRange';
  };

  ContinuousModel.prototype.findTargetDataIndices = function (range) {
    var result = [];
    this.eachTargetSeries(function (seriesModel) {
      var dataIndices = [];
      var data = seriesModel.getData();
      data.each(this.getDataDimensionIndex(data), function (value, dataIndex) {
        range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
      }, this);
      result.push({
        seriesId: seriesModel.id,
        dataIndex: dataIndices
      });
    }, this);
    return result;
  };
  /**
   * @implement
   */


  ContinuousModel.prototype.getVisualMeta = function (getColorVisual) {
    var oVals = getColorStopValues(this, 'outOfRange', this.getExtent());
    var iVals = getColorStopValues(this, 'inRange', this.option.range.slice());
    var stops = [];

    function setStop(value, valueState) {
      stops.push({
        value: value,
        color: getColorVisual(value, valueState)
      });
    } // Format to: outOfRange -- inRange -- outOfRange.


    var iIdx = 0;
    var oIdx = 0;
    var iLen = iVals.length;
    var oLen = oVals.length;

    for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
      // If oVal[oIdx] === iVals[iIdx], oVal[oIdx] should be ignored.
      if (oVals[oIdx] < iVals[iIdx]) {
        setStop(oVals[oIdx], 'outOfRange');
      }
    }

    for (var first = 1; iIdx < iLen; iIdx++, first = 0) {
      // If range is full, value beyond min, max will be clamped.
      // make a singularity
      first && stops.length && setStop(iVals[iIdx], 'outOfRange');
      setStop(iVals[iIdx], 'inRange');
    }

    for (var first = 1; oIdx < oLen; oIdx++) {
      if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
        // make a singularity
        if (first) {
          stops.length && setStop(stops[stops.length - 1].value, 'outOfRange');
          first = 0;
        }

        setStop(oVals[oIdx], 'outOfRange');
      }
    }

    var stopsLen = stops.length;
    return {
      stops: stops,
      outerColors: [stopsLen ? stops[0].color : 'transparent', stopsLen ? stops[stopsLen - 1].color : 'transparent']
    };
  };

  ContinuousModel.type = 'visualMap.continuous';
  ContinuousModel.defaultOption = inheritDefaultOption(VisualMapModel$1.defaultOption, {
    align: 'auto',
    calculable: false,
    hoverLink: true,
    realtime: true,
    handleIcon: 'path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z',
    handleSize: '120%',
    handleStyle: {
      borderColor: '#fff',
      borderWidth: 1
    },
    indicatorIcon: 'circle',
    indicatorSize: '50%',
    indicatorStyle: {
      borderColor: '#fff',
      borderWidth: 2,
      shadowBlur: 2,
      shadowOffsetX: 1,
      shadowOffsetY: 1,
      shadowColor: 'rgba(0,0,0,0.2)'
    } // emphasis: {
    //     handleStyle: {
    //         shadowBlur: 3,
    //         shadowOffsetX: 1,
    //         shadowOffsetY: 1,
    //         shadowColor: 'rgba(0,0,0,0.2)'
    //     }
    // }

  });
  return ContinuousModel;
}(VisualMapModel$1);

function getColorStopValues(visualMapModel, valueState, dataExtent) {
  if (dataExtent[0] === dataExtent[1]) {
    return dataExtent.slice();
  } // When using colorHue mapping, it is not linear color any more.
  // Moreover, canvas gradient seems not to be accurate linear.
  // FIXME
  // Should be arbitrary value 100? or based on pixel size?


  var count = 200;
  var step = (dataExtent[1] - dataExtent[0]) / count;
  var value = dataExtent[0];
  var stopValues = [];

  for (var i = 0; i <= count && value < dataExtent[1]; i++) {
    stopValues.push(value);
    value += step;
  }

  stopValues.push(dataExtent[1]);
  return stopValues;
}

var ContinuousModel$1 = ContinuousModel;

var VisualMapView =
/** @class */
function (_super) {
  __extends$1(VisualMapView, _super);

  function VisualMapView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = VisualMapView.type;
    _this.autoPositionValues = {
      left: 1,
      right: 1,
      top: 1,
      bottom: 1
    };
    return _this;
  }

  VisualMapView.prototype.init = function (ecModel, api) {
    this.ecModel = ecModel;
    this.api = api;
  };
  /**
   * @protected
   */


  VisualMapView.prototype.render = function (visualMapModel, ecModel, api, payload // TODO: TYPE
  ) {
    this.visualMapModel = visualMapModel;

    if (visualMapModel.get('show') === false) {
      this.group.removeAll();
      return;
    }

    this.doRender(visualMapModel, ecModel, api, payload);
  };
  /**
   * @protected
   */


  VisualMapView.prototype.renderBackground = function (group) {
    var visualMapModel = this.visualMapModel;
    var padding = normalizeCssArray(visualMapModel.get('padding') || 0);
    var rect = group.getBoundingRect();
    group.add(new Rect$1({
      z2: -1,
      silent: true,
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[3] + padding[1],
        height: rect.height + padding[0] + padding[2]
      },
      style: {
        fill: visualMapModel.get('backgroundColor'),
        stroke: visualMapModel.get('borderColor'),
        lineWidth: visualMapModel.get('borderWidth')
      }
    }));
  };
  /**
   * @protected
   * @param targetValue can be Infinity or -Infinity
   * @param visualCluster Only can be 'color' 'opacity' 'symbol' 'symbolSize'
   * @param opts
   * @param opts.forceState Specify state, instead of using getValueState method.
   * @param opts.convertOpacityToAlpha For color gradient in controller widget.
   * @return {*} Visual value.
   */


  VisualMapView.prototype.getControllerVisual = function (targetValue, visualCluster, opts) {
    opts = opts || {};
    var forceState = opts.forceState;
    var visualMapModel = this.visualMapModel;
    var visualObj = {}; // Default values.

    if (visualCluster === 'color') {
      var defaultColor = visualMapModel.get('contentColor');
      visualObj.color = defaultColor;
    }

    function getter(key) {
      return visualObj[key];
    }

    function setter(key, value) {
      visualObj[key] = value;
    }

    var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
    var visualTypes = VisualMapping$1.prepareVisualTypes(mappings);
    each$9(visualTypes, function (type) {
      var visualMapping = mappings[type];

      if (opts.convertOpacityToAlpha && type === 'opacity') {
        type = 'colorAlpha';
        visualMapping = mappings.__alphaForOpacity;
      }

      if (VisualMapping$1.dependsOn(type, visualCluster)) {
        visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
      }
    });
    return visualObj[visualCluster];
  };

  VisualMapView.prototype.positionGroup = function (group) {
    var model = this.visualMapModel;
    var api = this.api;
    positionElement(group, model.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  };

  VisualMapView.prototype.doRender = function (visualMapModel, ecModel, api, payload) {};

  VisualMapView.type = 'visualMap';
  return VisualMapView;
}(ComponentView$1);

var VisualMapView$1 = VisualMapView;

var paramsSet = [['left', 'right', 'width'], ['top', 'bottom', 'height']];
/**
 * @param visualMapModel
 * @param api
 * @param itemSize always [short, long]
 * @return {string} 'left' or 'right' or 'top' or 'bottom'
 */

function getItemAlign(visualMapModel, api, itemSize) {
  var modelOption = visualMapModel.option;
  var itemAlign = modelOption.align;

  if (itemAlign != null && itemAlign !== 'auto') {
    return itemAlign;
  } // Auto decision align.


  var ecSize = {
    width: api.getWidth(),
    height: api.getHeight()
  };
  var realIndex = modelOption.orient === 'horizontal' ? 1 : 0;
  var reals = paramsSet[realIndex];
  var fakeValue = [0, null, 10];
  var layoutInput = {};

  for (var i = 0; i < 3; i++) {
    layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
    layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
  }

  var rParam = [['x', 'width', 3], ['y', 'height', 0]][realIndex];
  var rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);
  return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
}
/**
 * Prepare dataIndex for outside usage, where dataIndex means rawIndex, and
 * dataIndexInside means filtered index.
 */
// TODO: TYPE more specified payload types.

function makeHighDownBatch(batch, visualMapModel) {
  each$9(batch || [], function (batchItem) {
    if (batchItem.dataIndex != null) {
      batchItem.dataIndexInside = batchItem.dataIndex;
      batchItem.dataIndex = null;
    }

    batchItem.highlightKey = 'visualMap' + (visualMapModel ? visualMapModel.componentIndex : '');
  });
  return batch;
}

var linearMap = linearMap$2;
var each$1 = each$9;
var mathMin = Math.min;
var mathMax = Math.max; // Arbitrary value

var HOVER_LINK_SIZE = 12;
var HOVER_LINK_OUT = 6; // Notice:
// Any "interval" should be by the order of [low, high].
// "handle0" (handleIndex === 0) maps to
// low data value: this._dataInterval[0] and has low coord.
// "handle1" (handleIndex === 1) maps to
// high data value: this._dataInterval[1] and has high coord.
// The logic of transform is implemented in this._createBarGroup.

var ContinuousView =
/** @class */
function (_super) {
  __extends$1(ContinuousView, _super);

  function ContinuousView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = ContinuousView.type;
    _this._shapes = {};
    _this._dataInterval = [];
    _this._handleEnds = [];
    _this._hoverLinkDataIndices = [];
    return _this;
  }

  ContinuousView.prototype.doRender = function (visualMapModel, ecModel, api, payload) {
    this._api = api;

    if (!payload || payload.type !== 'selectDataRange' || payload.from !== this.uid) {
      this._buildView();
    }
  };

  ContinuousView.prototype._buildView = function () {
    this.group.removeAll();
    var visualMapModel = this.visualMapModel;
    var thisGroup = this.group;
    this._orient = visualMapModel.get('orient');
    this._useHandle = visualMapModel.get('calculable');

    this._resetInterval();

    this._renderBar(thisGroup);

    var dataRangeText = visualMapModel.get('text');

    this._renderEndsText(thisGroup, dataRangeText, 0);

    this._renderEndsText(thisGroup, dataRangeText, 1); // Do this for background size calculation.


    this._updateView(true); // After updating view, inner shapes is built completely,
    // and then background can be rendered.


    this.renderBackground(thisGroup); // Real update view

    this._updateView();

    this._enableHoverLinkToSeries();

    this._enableHoverLinkFromSeries();

    this.positionGroup(thisGroup);
  };

  ContinuousView.prototype._renderEndsText = function (group, dataRangeText, endsIndex) {
    if (!dataRangeText) {
      return;
    } // Compatible with ec2, text[0] map to high value, text[1] map low value.


    var text = dataRangeText[1 - endsIndex];
    text = text != null ? text + '' : '';
    var visualMapModel = this.visualMapModel;
    var textGap = visualMapModel.get('textGap');
    var itemSize = visualMapModel.itemSize;
    var barGroup = this._shapes.mainGroup;

    var position = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);

    var align = this._applyTransform(endsIndex === 0 ? 'bottom' : 'top', barGroup);

    var orient = this._orient;
    var textStyleModel = this.visualMapModel.textStyleModel;
    this.group.add(new ZRText$1({
      style: createTextStyle$1(textStyleModel, {
        x: position[0],
        y: position[1],
        verticalAlign: orient === 'horizontal' ? 'middle' : align,
        align: orient === 'horizontal' ? align : 'center',
        text: text
      })
    }));
  };

  ContinuousView.prototype._renderBar = function (targetGroup) {
    var visualMapModel = this.visualMapModel;
    var shapes = this._shapes;
    var itemSize = visualMapModel.itemSize;
    var orient = this._orient;
    var useHandle = this._useHandle;
    var itemAlign = getItemAlign(visualMapModel, this.api, itemSize);

    var mainGroup = shapes.mainGroup = this._createBarGroup(itemAlign);

    var gradientBarGroup = new Group$3();
    mainGroup.add(gradientBarGroup); // Bar

    gradientBarGroup.add(shapes.outOfRange = createPolygon());
    gradientBarGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor(this._orient) : null, bind$1(this._dragHandle, this, 'all', false), bind$1(this._dragHandle, this, 'all', true))); // A border radius clip.

    gradientBarGroup.setClipPath(new Rect$1({
      shape: {
        x: 0,
        y: 0,
        width: itemSize[0],
        height: itemSize[1],
        r: 3
      }
    }));
    var textRect = visualMapModel.textStyleModel.getTextRect('国');
    var textSize = mathMax(textRect.width, textRect.height); // Handle

    if (useHandle) {
      shapes.handleThumbs = [];
      shapes.handleLabels = [];
      shapes.handleLabelPoints = [];

      this._createHandle(visualMapModel, mainGroup, 0, itemSize, textSize, orient);

      this._createHandle(visualMapModel, mainGroup, 1, itemSize, textSize, orient);
    }

    this._createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient);

    targetGroup.add(mainGroup);
  };

  ContinuousView.prototype._createHandle = function (visualMapModel, mainGroup, handleIndex, itemSize, textSize, orient) {
    var onDrift = bind$1(this._dragHandle, this, handleIndex, false);
    var onDragEnd = bind$1(this._dragHandle, this, handleIndex, true);
    var handleSize = parsePercent$1(visualMapModel.get('handleSize'), itemSize[0]);
    var handleThumb = createSymbol(visualMapModel.get('handleIcon'), -handleSize / 2, -handleSize / 2, handleSize, handleSize, null, true);
    var cursor = getCursor(this._orient);
    handleThumb.attr({
      cursor: cursor,
      draggable: true,
      drift: onDrift,
      ondragend: onDragEnd,
      onmousemove: function (e) {
        stop(e.event);
      }
    });
    handleThumb.x = itemSize[0] / 2;
    handleThumb.useStyle(visualMapModel.getModel('handleStyle').getItemStyle());
    handleThumb.setStyle({
      strokeNoScale: true,
      strokeFirst: true
    });
    handleThumb.style.lineWidth *= 2;
    handleThumb.ensureState('emphasis').style = visualMapModel.getModel(['emphasis', 'handleStyle']).getItemStyle();
    setAsHighDownDispatcher(handleThumb, true);
    mainGroup.add(handleThumb); // Text is always horizontal layout but should not be effected by
    // transform (orient/inverse). So label is built separately but not
    // use zrender/graphic/helper/RectText, and is located based on view
    // group (according to handleLabelPoint) but not barGroup.

    var textStyleModel = this.visualMapModel.textStyleModel;
    var handleLabel = new ZRText$1({
      cursor: cursor,
      draggable: true,
      drift: onDrift,
      onmousemove: function (e) {
        // Fot mobile devicem, prevent screen slider on the button.
        stop(e.event);
      },
      ondragend: onDragEnd,
      style: createTextStyle$1(textStyleModel, {
        x: 0,
        y: 0,
        text: ''
      })
    });
    handleLabel.ensureState('blur').style = {
      opacity: 0.1
    };
    handleLabel.stateTransition = {
      duration: 200
    };
    this.group.add(handleLabel);
    var handleLabelPoint = [handleSize, 0];
    var shapes = this._shapes;
    shapes.handleThumbs[handleIndex] = handleThumb;
    shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
    shapes.handleLabels[handleIndex] = handleLabel;
  };

  ContinuousView.prototype._createIndicator = function (visualMapModel, mainGroup, itemSize, textSize, orient) {
    var scale = parsePercent$1(visualMapModel.get('indicatorSize'), itemSize[0]);
    var indicator = createSymbol(visualMapModel.get('indicatorIcon'), -scale / 2, -scale / 2, scale, scale, null, true);
    indicator.attr({
      cursor: 'move',
      invisible: true,
      silent: true,
      x: itemSize[0] / 2
    });
    var indicatorStyle = visualMapModel.getModel('indicatorStyle').getItemStyle();

    if (indicator instanceof ZRImage$1) {
      var pathStyle = indicator.style;
      indicator.useStyle(extend$2({
        // TODO other properties like x, y ?
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, indicatorStyle));
    } else {
      indicator.useStyle(indicatorStyle);
    }

    mainGroup.add(indicator);
    var textStyleModel = this.visualMapModel.textStyleModel;
    var indicatorLabel = new ZRText$1({
      silent: true,
      invisible: true,
      style: createTextStyle$1(textStyleModel, {
        x: 0,
        y: 0,
        text: ''
      })
    });
    this.group.add(indicatorLabel);
    var indicatorLabelPoint = [(orient === 'horizontal' ? textSize / 2 : HOVER_LINK_OUT) + itemSize[0] / 2, 0];
    var shapes = this._shapes;
    shapes.indicator = indicator;
    shapes.indicatorLabel = indicatorLabel;
    shapes.indicatorLabelPoint = indicatorLabelPoint;
    this._firstShowIndicator = true;
  };

  ContinuousView.prototype._dragHandle = function (handleIndex, isEnd, // dx is event from ondragend if isEnd is true. It's not used
  dx, dy) {
    if (!this._useHandle) {
      return;
    }

    this._dragging = !isEnd;

    if (!isEnd) {
      // Transform dx, dy to bar coordination.
      var vertex = this._applyTransform([dx, dy], this._shapes.mainGroup, true);

      this._updateInterval(handleIndex, vertex[1]);

      this._hideIndicator(); // Considering realtime, update view should be executed
      // before dispatch action.


      this._updateView();
    } // dragEnd do not dispatch action when realtime.


    if (isEnd === !this.visualMapModel.get('realtime')) {
      // jshint ignore:line
      this.api.dispatchAction({
        type: 'selectDataRange',
        from: this.uid,
        visualMapId: this.visualMapModel.id,
        selected: this._dataInterval.slice()
      });
    }

    if (isEnd) {
      !this._hovering && this._clearHoverLinkToSeries();
    } else if (useHoverLinkOnHandle(this.visualMapModel)) {
      this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
    }
  };

  ContinuousView.prototype._resetInterval = function () {
    var visualMapModel = this.visualMapModel;
    var dataInterval = this._dataInterval = visualMapModel.getSelected();
    var dataExtent = visualMapModel.getExtent();
    var sizeExtent = [0, visualMapModel.itemSize[1]];
    this._handleEnds = [linearMap(dataInterval[0], dataExtent, sizeExtent, true), linearMap(dataInterval[1], dataExtent, sizeExtent, true)];
  };
  /**
   * @private
   * @param {(number|string)} handleIndex 0 or 1 or 'all'
   * @param {number} dx
   * @param {number} dy
   */


  ContinuousView.prototype._updateInterval = function (handleIndex, delta) {
    delta = delta || 0;
    var visualMapModel = this.visualMapModel;
    var handleEnds = this._handleEnds;
    var sizeExtent = [0, visualMapModel.itemSize[1]];
    sliderMove(delta, handleEnds, sizeExtent, handleIndex, // cross is forbiden
    0);
    var dataExtent = visualMapModel.getExtent(); // Update data interval.

    this._dataInterval = [linearMap(handleEnds[0], sizeExtent, dataExtent, true), linearMap(handleEnds[1], sizeExtent, dataExtent, true)];
  };

  ContinuousView.prototype._updateView = function (forSketch) {
    var visualMapModel = this.visualMapModel;
    var dataExtent = visualMapModel.getExtent();
    var shapes = this._shapes;
    var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
    var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;

    var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, 'inRange');

    var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, 'outOfRange');

    shapes.inRange.setStyle({
      fill: visualInRange.barColor // opacity: visualInRange.opacity

    }).setShape('points', visualInRange.barPoints);
    shapes.outOfRange.setStyle({
      fill: visualOutOfRange.barColor // opacity: visualOutOfRange.opacity

    }).setShape('points', visualOutOfRange.barPoints);

    this._updateHandle(inRangeHandleEnds, visualInRange);
  };

  ContinuousView.prototype._createBarVisual = function (dataInterval, dataExtent, handleEnds, forceState) {
    var opts = {
      forceState: forceState,
      convertOpacityToAlpha: true
    };

    var colorStops = this._makeColorGradient(dataInterval, opts);

    var symbolSizes = [this.getControllerVisual(dataInterval[0], 'symbolSize', opts), this.getControllerVisual(dataInterval[1], 'symbolSize', opts)];

    var barPoints = this._createBarPoints(handleEnds, symbolSizes);

    return {
      barColor: new LinearGradient$1(0, 0, 0, 1, colorStops),
      barPoints: barPoints,
      handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
    };
  };

  ContinuousView.prototype._makeColorGradient = function (dataInterval, opts) {
    // Considering colorHue, which is not linear, so we have to sample
    // to calculate gradient color stops, but not only caculate head
    // and tail.
    var sampleNumber = 100; // Arbitrary value.

    var colorStops = [];
    var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
    colorStops.push({
      color: this.getControllerVisual(dataInterval[0], 'color', opts),
      offset: 0
    });

    for (var i = 1; i < sampleNumber; i++) {
      var currValue = dataInterval[0] + step * i;

      if (currValue > dataInterval[1]) {
        break;
      }

      colorStops.push({
        color: this.getControllerVisual(currValue, 'color', opts),
        offset: i / sampleNumber
      });
    }

    colorStops.push({
      color: this.getControllerVisual(dataInterval[1], 'color', opts),
      offset: 1
    });
    return colorStops;
  };

  ContinuousView.prototype._createBarPoints = function (handleEnds, symbolSizes) {
    var itemSize = this.visualMapModel.itemSize;
    return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];
  };

  ContinuousView.prototype._createBarGroup = function (itemAlign) {
    var orient = this._orient;
    var inverse = this.visualMapModel.get('inverse');
    return new Group$3(orient === 'horizontal' && !inverse ? {
      scaleX: itemAlign === 'bottom' ? 1 : -1,
      rotation: Math.PI / 2
    } : orient === 'horizontal' && inverse ? {
      scaleX: itemAlign === 'bottom' ? -1 : 1,
      rotation: -Math.PI / 2
    } : orient === 'vertical' && !inverse ? {
      scaleX: itemAlign === 'left' ? 1 : -1,
      scaleY: -1
    } : {
      scaleX: itemAlign === 'left' ? 1 : -1
    });
  };

  ContinuousView.prototype._updateHandle = function (handleEnds, visualInRange) {
    if (!this._useHandle) {
      return;
    }

    var shapes = this._shapes;
    var visualMapModel = this.visualMapModel;
    var handleThumbs = shapes.handleThumbs;
    var handleLabels = shapes.handleLabels;
    var itemSize = visualMapModel.itemSize;
    var dataExtent = visualMapModel.getExtent();
    each$1([0, 1], function (handleIndex) {
      var handleThumb = handleThumbs[handleIndex];
      handleThumb.setStyle('fill', visualInRange.handlesColor[handleIndex]);
      handleThumb.y = handleEnds[handleIndex];
      var val = linearMap(handleEnds[handleIndex], [0, itemSize[1]], dataExtent, true);
      var symbolSize = this.getControllerVisual(val, 'symbolSize');
      handleThumb.scaleX = handleThumb.scaleY = symbolSize / itemSize[0];
      handleThumb.x = itemSize[0] - symbolSize / 2; // Update handle label position.

      var textPoint = applyTransform(shapes.handleLabelPoints[handleIndex], getTransform(handleThumb, this.group));
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
        verticalAlign: 'middle',
        align: this._orient === 'vertical' ? this._applyTransform('left', shapes.mainGroup) : 'center'
      });
    }, this);
  };

  ContinuousView.prototype._showIndicator = function (cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
    var visualMapModel = this.visualMapModel;
    var dataExtent = visualMapModel.getExtent();
    var itemSize = visualMapModel.itemSize;
    var sizeExtent = [0, itemSize[1]];
    var shapes = this._shapes;
    var indicator = shapes.indicator;

    if (!indicator) {
      return;
    }

    indicator.attr('invisible', false);
    var opts = {
      convertOpacityToAlpha: true
    };
    var color = this.getControllerVisual(cursorValue, 'color', opts);
    var symbolSize = this.getControllerVisual(cursorValue, 'symbolSize');
    var y = linearMap(cursorValue, dataExtent, sizeExtent, true);
    var x = itemSize[0] - symbolSize / 2;
    var oldIndicatorPos = {
      x: indicator.x,
      y: indicator.y
    }; // Update handle label position.

    indicator.y = y;
    indicator.x = x;
    var textPoint = applyTransform(shapes.indicatorLabelPoint, getTransform(indicator, this.group));
    var indicatorLabel = shapes.indicatorLabel;
    indicatorLabel.attr('invisible', false);

    var align = this._applyTransform('left', shapes.mainGroup);

    var orient = this._orient;
    var isHorizontal = orient === 'horizontal';
    indicatorLabel.setStyle({
      text: (rangeSymbol ? rangeSymbol : '') + visualMapModel.formatValueText(textValue),
      verticalAlign: isHorizontal ? align : 'middle',
      align: isHorizontal ? 'center' : align
    });
    var indicatorNewProps = {
      x: x,
      y: y,
      style: {
        fill: color
      }
    };
    var labelNewProps = {
      style: {
        x: textPoint[0],
        y: textPoint[1]
      }
    };

    if (visualMapModel.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
      var animationCfg = {
        duration: 100,
        easing: 'cubicInOut',
        additive: true
      };
      indicator.x = oldIndicatorPos.x;
      indicator.y = oldIndicatorPos.y;
      indicator.animateTo(indicatorNewProps, animationCfg);
      indicatorLabel.animateTo(labelNewProps, animationCfg);
    } else {
      indicator.attr(indicatorNewProps);
      indicatorLabel.attr(labelNewProps);
    }

    this._firstShowIndicator = false;
    var handleLabels = this._shapes.handleLabels;

    if (handleLabels) {
      for (var i = 0; i < handleLabels.length; i++) {
        // Fade out handle labels.
        // NOTE: Must use api enter/leave on emphasis/blur/select state. Or the global states manager will change it.
        this._api.enterBlur(handleLabels[i]);
      }
    }
  };

  ContinuousView.prototype._enableHoverLinkToSeries = function () {
    var self = this;

    this._shapes.mainGroup.on('mousemove', function (e) {
      self._hovering = true;

      if (!self._dragging) {
        var itemSize = self.visualMapModel.itemSize;

        var pos = self._applyTransform([e.offsetX, e.offsetY], self._shapes.mainGroup, true, true); // For hover link show when hover handle, which might be
        // below or upper than sizeExtent.


        pos[1] = mathMin(mathMax(0, pos[1]), itemSize[1]);

        self._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
      }
    }).on('mouseout', function () {
      // When mouse is out of handle, hoverLink still need
      // to be displayed when realtime is set as false.
      self._hovering = false;
      !self._dragging && self._clearHoverLinkToSeries();
    });
  };

  ContinuousView.prototype._enableHoverLinkFromSeries = function () {
    var zr = this.api.getZr();

    if (this.visualMapModel.option.hoverLink) {
      zr.on('mouseover', this._hoverLinkFromSeriesMouseOver, this);
      zr.on('mouseout', this._hideIndicator, this);
    } else {
      this._clearHoverLinkFromSeries();
    }
  };

  ContinuousView.prototype._doHoverLinkToSeries = function (cursorPos, hoverOnBar) {
    var visualMapModel = this.visualMapModel;
    var itemSize = visualMapModel.itemSize;

    if (!visualMapModel.option.hoverLink) {
      return;
    }

    var sizeExtent = [0, itemSize[1]];
    var dataExtent = visualMapModel.getExtent(); // For hover link show when hover handle, which might be below or upper than sizeExtent.

    cursorPos = mathMin(mathMax(sizeExtent[0], cursorPos), sizeExtent[1]);
    var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
    var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
    var cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, true);
    var valueRange = [linearMap(hoverRange[0], sizeExtent, dataExtent, true), linearMap(hoverRange[1], sizeExtent, dataExtent, true)]; // Consider data range is out of visualMap range, see test/visualMap-continuous.html,
    // where china and india has very large population.

    hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
    hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity); // Do not show indicator when mouse is over handle,
    // otherwise labels overlap, especially when dragging.

    if (hoverOnBar) {
      if (valueRange[0] === -Infinity) {
        this._showIndicator(cursorValue, valueRange[1], '< ', halfHoverLinkSize);
      } else if (valueRange[1] === Infinity) {
        this._showIndicator(cursorValue, valueRange[0], '> ', halfHoverLinkSize);
      } else {
        this._showIndicator(cursorValue, cursorValue, '≈ ', halfHoverLinkSize);
      }
    } // When realtime is set as false, handles, which are in barGroup,
    // also trigger hoverLink, which help user to realize where they
    // focus on when dragging. (see test/heatmap-large.html)
    // When realtime is set as true, highlight will not show when hover
    // handle, because the label on handle, which displays a exact value
    // but not range, might mislead users.


    var oldBatch = this._hoverLinkDataIndices;
    var newBatch = [];

    if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
      newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
    }

    var resultBatches = compressBatches(oldBatch, newBatch);

    this._dispatchHighDown('downplay', makeHighDownBatch(resultBatches[0], visualMapModel));

    this._dispatchHighDown('highlight', makeHighDownBatch(resultBatches[1], visualMapModel));
  };

  ContinuousView.prototype._hoverLinkFromSeriesMouseOver = function (e) {
    var ecData;
    findEventDispatcher(e.target, function (target) {
      var currECData = getECData(target);

      if (currECData.dataIndex != null) {
        ecData = currECData;
        return true;
      }
    }, true);

    if (!ecData) {
      return;
    }

    var dataModel = this.ecModel.getSeriesByIndex(ecData.seriesIndex);
    var visualMapModel = this.visualMapModel;

    if (!visualMapModel.isTargetSeries(dataModel)) {
      return;
    }

    var data = dataModel.getData(ecData.dataType);
    var value = data.getStore().get(visualMapModel.getDataDimensionIndex(data), ecData.dataIndex);

    if (!isNaN(value)) {
      this._showIndicator(value, value);
    }
  };

  ContinuousView.prototype._hideIndicator = function () {
    var shapes = this._shapes;
    shapes.indicator && shapes.indicator.attr('invisible', true);
    shapes.indicatorLabel && shapes.indicatorLabel.attr('invisible', true);
    var handleLabels = this._shapes.handleLabels;

    if (handleLabels) {
      for (var i = 0; i < handleLabels.length; i++) {
        // Fade out handle labels.
        // NOTE: Must use api enter/leave on emphasis/blur/select state. Or the global states manager will change it.
        this._api.leaveBlur(handleLabels[i]);
      }
    }
  };

  ContinuousView.prototype._clearHoverLinkToSeries = function () {
    this._hideIndicator();

    var indices = this._hoverLinkDataIndices;

    this._dispatchHighDown('downplay', makeHighDownBatch(indices, this.visualMapModel));

    indices.length = 0;
  };

  ContinuousView.prototype._clearHoverLinkFromSeries = function () {
    this._hideIndicator();

    var zr = this.api.getZr();
    zr.off('mouseover', this._hoverLinkFromSeriesMouseOver);
    zr.off('mouseout', this._hideIndicator);
  };

  ContinuousView.prototype._applyTransform = function (vertex, element, inverse, global) {
    var transform = getTransform(element, global ? null : this.group);
    return isArray$1(vertex) ? applyTransform(vertex, transform, inverse) : transformDirection(vertex, transform, inverse);
  }; // TODO: TYPE more specified payload types.


  ContinuousView.prototype._dispatchHighDown = function (type, batch) {
    batch && batch.length && this.api.dispatchAction({
      type: type,
      batch: batch
    });
  };
  /**
   * @override
   */


  ContinuousView.prototype.dispose = function () {
    this._clearHoverLinkFromSeries();

    this._clearHoverLinkToSeries();
  };
  /**
   * @override
   */


  ContinuousView.prototype.remove = function () {
    this._clearHoverLinkFromSeries();

    this._clearHoverLinkToSeries();
  };

  ContinuousView.type = 'visualMap.continuous';
  return ContinuousView;
}(VisualMapView$1);

function createPolygon(points, cursor, onDrift, onDragEnd) {
  return new Polygon$1({
    shape: {
      points: points
    },
    draggable: !!onDrift,
    cursor: cursor,
    drift: onDrift,
    onmousemove: function (e) {
      // Fot mobile devicem, prevent screen slider on the button.
      stop(e.event);
    },
    ondragend: onDragEnd
  });
}

function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
  var halfHoverLinkSize = HOVER_LINK_SIZE / 2;
  var hoverLinkDataSize = visualMapModel.get('hoverLinkDataSize');

  if (hoverLinkDataSize) {
    halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
  }

  return halfHoverLinkSize;
}

function useHoverLinkOnHandle(visualMapModel) {
  var hoverLinkOnHandle = visualMapModel.get('hoverLinkOnHandle');
  return !!(hoverLinkOnHandle == null ? visualMapModel.get('realtime') : hoverLinkOnHandle);
}

function getCursor(orient) {
  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';
}

var ContinuousView$1 = ContinuousView;

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
var visualMapActionInfo = {
  type: 'selectDataRange',
  event: 'dataRangeSelected',
  // FIXME use updateView appears wrong
  update: 'update'
};
var visualMapActionHander = function (payload, ecModel) {
  ecModel.eachComponent({
    mainType: 'visualMap',
    query: payload
  }, function (model) {
    model.setSelected(payload.selected);
  });
};

var visualMapEncodingHandlers = [{
  createOnAllSeries: true,
  reset: function (seriesModel, ecModel) {
    var resetDefines = [];
    ecModel.eachComponent('visualMap', function (visualMapModel) {
      var pipelineContext = seriesModel.pipelineContext;

      if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
        return;
      }

      resetDefines.push(incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, bind$1(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimensionIndex(seriesModel.getData())));
    });
    return resetDefines;
  }
}, // Only support color.
{
  createOnAllSeries: true,
  reset: function (seriesModel, ecModel) {
    var data = seriesModel.getData();
    var visualMetaList = [];
    ecModel.eachComponent('visualMap', function (visualMapModel) {
      if (visualMapModel.isTargetSeries(seriesModel)) {
        var visualMeta = visualMapModel.getVisualMeta(bind$1(getColorVisual, null, seriesModel, visualMapModel)) || {
          stops: [],
          outerColors: []
        };
        var dimIdx = visualMapModel.getDataDimensionIndex(data);

        if (dimIdx >= 0) {
          // visualMeta.dimension should be dimension index, but not concrete dimension.
          visualMeta.dimension = dimIdx;
          visualMetaList.push(visualMeta);
        }
      }
    }); // console.log(JSON.stringify(visualMetaList.map(a => a.stops)));

    seriesModel.getData().setVisual('visualMeta', visualMetaList);
  }
}]; // FIXME
// performance and export for heatmap?
// value can be Infinity or -Infinity

function getColorVisual(seriesModel, visualMapModel, value, valueState) {
  var mappings = visualMapModel.targetVisuals[valueState];
  var visualTypes = VisualMapping$1.prepareVisualTypes(mappings);
  var resultVisual = {
    color: getVisualFromData(seriesModel.getData(), 'color') // default color.

  };

  for (var i = 0, len = visualTypes.length; i < len; i++) {
    var type = visualTypes[i];
    var mapping = mappings[type === 'opacity' ? '__alphaForOpacity' : type];
    mapping && mapping.applyVisual(value, getVisual, setVisual);
  }

  return resultVisual.color;

  function getVisual(key) {
    return resultVisual[key];
  }

  function setVisual(key, value) {
    resultVisual[key] = value;
  }
}

var each = each$9;
function visualMapPreprocessor(option) {
  var visualMap = option && option.visualMap;

  if (!isArray$1(visualMap)) {
    visualMap = visualMap ? [visualMap] : [];
  }

  each(visualMap, function (opt) {
    if (!opt) {
      return;
    } // rename splitList to pieces


    if (has(opt, 'splitList') && !has(opt, 'pieces')) {
      opt.pieces = opt.splitList;
      delete opt.splitList;
    }

    var pieces = opt.pieces;

    if (pieces && isArray$1(pieces)) {
      each(pieces, function (piece) {
        if (isObject$3(piece)) {
          if (has(piece, 'start') && !has(piece, 'min')) {
            piece.min = piece.start;
          }

          if (has(piece, 'end') && !has(piece, 'max')) {
            piece.max = piece.end;
          }
        }
      });
    }
  });
}

function has(obj, name) {
  return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);
}

var installed = false;
function installCommon(registers) {
  if (installed) {
    return;
  }

  installed = true;
  registers.registerSubTypeDefaulter('visualMap', function (option) {
    // Compatible with ec2, when splitNumber === 0, continuous visualMap will be used.
    return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? 'continuous' : 'piecewise';
  });
  registers.registerAction(visualMapActionInfo, visualMapActionHander);
  each$9(visualMapEncodingHandlers, function (handler) {
    registers.registerVisual(registers.PRIORITY.VISUAL.COMPONENT, handler);
  });
  registers.registerPreprocessor(visualMapPreprocessor);
}

function install$4(registers) {
  registers.registerComponentModel(ContinuousModel$1);
  registers.registerComponentView(ContinuousView$1);
  installCommon(registers);
}

var PiecewiseModel =
/** @class */
function (_super) {
  __extends$1(PiecewiseModel, _super);

  function PiecewiseModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = PiecewiseModel.type;
    /**
     * The order is always [low, ..., high].
     * [{text: string, interval: Array.<number>}, ...]
     */

    _this._pieceList = [];
    return _this;
  }

  PiecewiseModel.prototype.optionUpdated = function (newOption, isInit) {
    _super.prototype.optionUpdated.apply(this, arguments);

    this.resetExtent();

    var mode = this._mode = this._determineMode();

    this._pieceList = [];

    resetMethods[this._mode].call(this, this._pieceList);

    this._resetSelected(newOption, isInit);

    var categories = this.option.categories;
    this.resetVisual(function (mappingOption, state) {
      if (mode === 'categories') {
        mappingOption.mappingMethod = 'category';
        mappingOption.categories = clone$3(categories);
      } else {
        mappingOption.dataExtent = this.getExtent();
        mappingOption.mappingMethod = 'piecewise';
        mappingOption.pieceList = map$1(this._pieceList, function (piece) {
          piece = clone$3(piece);

          if (state !== 'inRange') {
            // FIXME
            // outOfRange do not support special visual in pieces.
            piece.visual = null;
          }

          return piece;
        });
      }
    });
  };
  /**
   * @protected
   * @override
   */


  PiecewiseModel.prototype.completeVisualOption = function () {
    // Consider this case:
    // visualMap: {
    //      pieces: [{symbol: 'circle', lt: 0}, {symbol: 'rect', gte: 0}]
    // }
    // where no inRange/outOfRange set but only pieces. So we should make
    // default inRange/outOfRange for this case, otherwise visuals that only
    // appear in `pieces` will not be taken into account in visual encoding.
    var option = this.option;
    var visualTypesInPieces = {};
    var visualTypes = VisualMapping$1.listVisualTypes();
    var isCategory = this.isCategory();
    each$9(option.pieces, function (piece) {
      each$9(visualTypes, function (visualType) {
        if (piece.hasOwnProperty(visualType)) {
          visualTypesInPieces[visualType] = 1;
        }
      });
    });
    each$9(visualTypesInPieces, function (v, visualType) {
      var exists = false;
      each$9(this.stateList, function (state) {
        exists = exists || has(option, state, visualType) || has(option.target, state, visualType);
      }, this);
      !exists && each$9(this.stateList, function (state) {
        (option[state] || (option[state] = {}))[visualType] = visualDefault$1.get(visualType, state === 'inRange' ? 'active' : 'inactive', isCategory);
      });
    }, this);

    function has(obj, state, visualType) {
      return obj && obj[state] && obj[state].hasOwnProperty(visualType);
    }

    _super.prototype.completeVisualOption.apply(this, arguments);
  };

  PiecewiseModel.prototype._resetSelected = function (newOption, isInit) {
    var thisOption = this.option;
    var pieceList = this._pieceList; // Selected do not merge but all override.

    var selected = (isInit ? thisOption : newOption).selected || {};
    thisOption.selected = selected; // Consider 'not specified' means true.

    each$9(pieceList, function (piece, index) {
      var key = this.getSelectedMapKey(piece);

      if (!selected.hasOwnProperty(key)) {
        selected[key] = true;
      }
    }, this);

    if (thisOption.selectedMode === 'single') {
      // Ensure there is only one selected.
      var hasSel_1 = false;
      each$9(pieceList, function (piece, index) {
        var key = this.getSelectedMapKey(piece);

        if (selected[key]) {
          hasSel_1 ? selected[key] = false : hasSel_1 = true;
        }
      }, this);
    } // thisOption.selectedMode === 'multiple', default: all selected.

  };
  /**
   * @public
   */


  PiecewiseModel.prototype.getItemSymbol = function () {
    return this.get('itemSymbol');
  };
  /**
   * @public
   */


  PiecewiseModel.prototype.getSelectedMapKey = function (piece) {
    return this._mode === 'categories' ? piece.value + '' : piece.index + '';
  };
  /**
   * @public
   */


  PiecewiseModel.prototype.getPieceList = function () {
    return this._pieceList;
  };
  /**
   * @return {string}
   */


  PiecewiseModel.prototype._determineMode = function () {
    var option = this.option;
    return option.pieces && option.pieces.length > 0 ? 'pieces' : this.option.categories ? 'categories' : 'splitNumber';
  };
  /**
   * @override
   */


  PiecewiseModel.prototype.setSelected = function (selected) {
    this.option.selected = clone$3(selected);
  };
  /**
   * @override
   */


  PiecewiseModel.prototype.getValueState = function (value) {
    var index = VisualMapping$1.findPieceIndex(value, this._pieceList);
    return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? 'inRange' : 'outOfRange' : 'outOfRange';
  };
  /**
   * @public
   * @param pieceIndex piece index in visualMapModel.getPieceList()
   */


  PiecewiseModel.prototype.findTargetDataIndices = function (pieceIndex) {
    var result = [];
    var pieceList = this._pieceList;
    this.eachTargetSeries(function (seriesModel) {
      var dataIndices = [];
      var data = seriesModel.getData();
      data.each(this.getDataDimensionIndex(data), function (value, dataIndex) {
        // Should always base on model pieceList, because it is order sensitive.
        var pIdx = VisualMapping$1.findPieceIndex(value, pieceList);
        pIdx === pieceIndex && dataIndices.push(dataIndex);
      }, this);
      result.push({
        seriesId: seriesModel.id,
        dataIndex: dataIndices
      });
    }, this);
    return result;
  };
  /**
   * @private
   * @param piece piece.value or piece.interval is required.
   * @return  Can be Infinity or -Infinity
   */


  PiecewiseModel.prototype.getRepresentValue = function (piece) {
    var representValue;

    if (this.isCategory()) {
      representValue = piece.value;
    } else {
      if (piece.value != null) {
        representValue = piece.value;
      } else {
        var pieceInterval = piece.interval || [];
        representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
      }
    }

    return representValue;
  };

  PiecewiseModel.prototype.getVisualMeta = function (getColorVisual) {
    // Do not support category. (category axis is ordinal, numerical)
    if (this.isCategory()) {
      return;
    }

    var stops = [];
    var outerColors = ['', ''];
    var visualMapModel = this;

    function setStop(interval, valueState) {
      var representValue = visualMapModel.getRepresentValue({
        interval: interval
      }); // Not category

      if (!valueState) {
        valueState = visualMapModel.getValueState(representValue);
      }

      var color = getColorVisual(representValue, valueState);

      if (interval[0] === -Infinity) {
        outerColors[0] = color;
      } else if (interval[1] === Infinity) {
        outerColors[1] = color;
      } else {
        stops.push({
          value: interval[0],
          color: color
        }, {
          value: interval[1],
          color: color
        });
      }
    } // Suplement


    var pieceList = this._pieceList.slice();

    if (!pieceList.length) {
      pieceList.push({
        interval: [-Infinity, Infinity]
      });
    } else {
      var edge = pieceList[0].interval[0];
      edge !== -Infinity && pieceList.unshift({
        interval: [-Infinity, edge]
      });
      edge = pieceList[pieceList.length - 1].interval[1];
      edge !== Infinity && pieceList.push({
        interval: [edge, Infinity]
      });
    }

    var curr = -Infinity;
    each$9(pieceList, function (piece) {
      var interval = piece.interval;

      if (interval) {
        // Fulfill gap.
        interval[0] > curr && setStop([curr, interval[0]], 'outOfRange');
        setStop(interval.slice());
        curr = interval[1];
      }
    }, this);
    return {
      stops: stops,
      outerColors: outerColors
    };
  };

  PiecewiseModel.type = 'visualMap.piecewise';
  PiecewiseModel.defaultOption = inheritDefaultOption(VisualMapModel$1.defaultOption, {
    selected: null,
    minOpen: false,
    maxOpen: false,
    align: 'auto',
    itemWidth: 20,
    itemHeight: 14,
    itemSymbol: 'roundRect',
    pieces: null,
    categories: null,
    splitNumber: 5,
    selectedMode: 'multiple',
    itemGap: 10,
    hoverLink: true // Enable hover highlight.

  });
  return PiecewiseModel;
}(VisualMapModel$1);
/**
 * Key is this._mode
 * @type {Object}
 * @this {module:echarts/component/viusalMap/PiecewiseMode}
 */

var resetMethods = {
  splitNumber: function (outPieceList) {
    var thisOption = this.option;
    var precision = Math.min(thisOption.precision, 20);
    var dataExtent = this.getExtent();
    var splitNumber = thisOption.splitNumber;
    splitNumber = Math.max(parseInt(splitNumber, 10), 1);
    thisOption.splitNumber = splitNumber;
    var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber; // Precision auto-adaption

    while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
      precision++;
    }

    thisOption.precision = precision;
    splitStep = +splitStep.toFixed(precision);

    if (thisOption.minOpen) {
      outPieceList.push({
        interval: [-Infinity, dataExtent[0]],
        close: [0, 0]
      });
    }

    for (var index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {
      var max = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
      outPieceList.push({
        interval: [curr, max],
        close: [1, 1]
      });
    }

    if (thisOption.maxOpen) {
      outPieceList.push({
        interval: [dataExtent[1], Infinity],
        close: [0, 0]
      });
    }

    reformIntervals(outPieceList);
    each$9(outPieceList, function (piece, index) {
      piece.index = index;
      piece.text = this.formatValueText(piece.interval);
    }, this);
  },
  categories: function (outPieceList) {
    var thisOption = this.option;
    each$9(thisOption.categories, function (cate) {
      // FIXME category模式也使用pieceList，但在visualMapping中不是使用pieceList。
      // 是否改一致。
      outPieceList.push({
        text: this.formatValueText(cate, true),
        value: cate
      });
    }, this); // See "Order Rule".

    normalizeReverse(thisOption, outPieceList);
  },
  pieces: function (outPieceList) {
    var thisOption = this.option;
    each$9(thisOption.pieces, function (pieceListItem, index) {
      if (!isObject$3(pieceListItem)) {
        pieceListItem = {
          value: pieceListItem
        };
      }

      var item = {
        text: '',
        index: index
      };

      if (pieceListItem.label != null) {
        item.text = pieceListItem.label;
      }

      if (pieceListItem.hasOwnProperty('value')) {
        var value = item.value = pieceListItem.value;
        item.interval = [value, value];
        item.close = [1, 1];
      } else {
        // `min` `max` is legacy option.
        // `lt` `gt` `lte` `gte` is recommanded.
        var interval = item.interval = [];
        var close_1 = item.close = [0, 0];
        var closeList = [1, 0, 1];
        var infinityList = [-Infinity, Infinity];
        var useMinMax = [];

        for (var lg = 0; lg < 2; lg++) {
          var names = [['gte', 'gt', 'min'], ['lte', 'lt', 'max']][lg];

          for (var i = 0; i < 3 && interval[lg] == null; i++) {
            interval[lg] = pieceListItem[names[i]];
            close_1[lg] = closeList[i];
            useMinMax[lg] = i === 2;
          }

          interval[lg] == null && (interval[lg] = infinityList[lg]);
        }

        useMinMax[0] && interval[1] === Infinity && (close_1[0] = 0);
        useMinMax[1] && interval[0] === -Infinity && (close_1[1] = 0);

        if (process.env.NODE_ENV !== 'production') {
          if (interval[0] > interval[1]) {
            console.warn('Piece ' + index + 'is illegal: ' + interval + ' lower bound should not greater then uppper bound.');
          }
        }

        if (interval[0] === interval[1] && close_1[0] && close_1[1]) {
          // Consider: [{min: 5, max: 5, visual: {...}}, {min: 0, max: 5}],
          // we use value to lift the priority when min === max
          item.value = interval[0];
        }
      }

      item.visual = VisualMapping$1.retrieveVisuals(pieceListItem);
      outPieceList.push(item);
    }, this); // See "Order Rule".

    normalizeReverse(thisOption, outPieceList); // Only pieces

    reformIntervals(outPieceList);
    each$9(outPieceList, function (piece) {
      var close = piece.close;
      var edgeSymbols = [['<', '≤'][close[1]], ['>', '≥'][close[0]]];
      piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
    }, this);
  }
};

function normalizeReverse(thisOption, pieceList) {
  var inverse = thisOption.inverse;

  if (thisOption.orient === 'vertical' ? !inverse : inverse) {
    pieceList.reverse();
  }
}

var PiecewiseModel$1 = PiecewiseModel;

var PiecewiseVisualMapView =
/** @class */
function (_super) {
  __extends$1(PiecewiseVisualMapView, _super);

  function PiecewiseVisualMapView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = PiecewiseVisualMapView.type;
    return _this;
  }

  PiecewiseVisualMapView.prototype.doRender = function () {
    var thisGroup = this.group;
    thisGroup.removeAll();
    var visualMapModel = this.visualMapModel;
    var textGap = visualMapModel.get('textGap');
    var textStyleModel = visualMapModel.textStyleModel;
    var textFont = textStyleModel.getFont();
    var textFill = textStyleModel.getTextColor();

    var itemAlign = this._getItemAlign();

    var itemSize = visualMapModel.itemSize;

    var viewData = this._getViewData();

    var endsText = viewData.endsText;
    var showLabel = retrieve(visualMapModel.get('showLabel', true), !endsText);
    endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
    each$9(viewData.viewPieceList, function (item) {
      var piece = item.piece;
      var itemGroup = new Group$3();
      itemGroup.onclick = bind$1(this._onItemClick, this, piece);

      this._enableHoverLink(itemGroup, item.indexInModelPieceList); // TODO Category


      var representValue = visualMapModel.getRepresentValue(piece);

      this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);

      if (showLabel) {
        var visualState = this.visualMapModel.getValueState(representValue);
        itemGroup.add(new ZRText$1({
          style: {
            x: itemAlign === 'right' ? -textGap : itemSize[0] + textGap,
            y: itemSize[1] / 2,
            text: piece.text,
            verticalAlign: 'middle',
            align: itemAlign,
            font: textFont,
            fill: textFill,
            opacity: visualState === 'outOfRange' ? 0.5 : 1
          }
        }));
      }

      thisGroup.add(itemGroup);
    }, this);
    endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
    box(visualMapModel.get('orient'), thisGroup, visualMapModel.get('itemGap'));
    this.renderBackground(thisGroup);
    this.positionGroup(thisGroup);
  };

  PiecewiseVisualMapView.prototype._enableHoverLink = function (itemGroup, pieceIndex) {
    var _this = this;

    itemGroup.on('mouseover', function () {
      return onHoverLink('highlight');
    }).on('mouseout', function () {
      return onHoverLink('downplay');
    });

    var onHoverLink = function (method) {
      var visualMapModel = _this.visualMapModel; // TODO: TYPE More detailed action types

      visualMapModel.option.hoverLink && _this.api.dispatchAction({
        type: method,
        batch: makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
      });
    };
  };

  PiecewiseVisualMapView.prototype._getItemAlign = function () {
    var visualMapModel = this.visualMapModel;
    var modelOption = visualMapModel.option;

    if (modelOption.orient === 'vertical') {
      return getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
    } else {
      // horizontal, most case left unless specifying right.
      var align = modelOption.align;

      if (!align || align === 'auto') {
        align = 'left';
      }

      return align;
    }
  };

  PiecewiseVisualMapView.prototype._renderEndsText = function (group, text, itemSize, showLabel, itemAlign) {
    if (!text) {
      return;
    }

    var itemGroup = new Group$3();
    var textStyleModel = this.visualMapModel.textStyleModel;
    itemGroup.add(new ZRText$1({
      style: createTextStyle$1(textStyleModel, {
        x: showLabel ? itemAlign === 'right' ? itemSize[0] : 0 : itemSize[0] / 2,
        y: itemSize[1] / 2,
        verticalAlign: 'middle',
        align: showLabel ? itemAlign : 'center',
        text: text
      })
    }));
    group.add(itemGroup);
  };
  /**
   * @private
   * @return {Object} {peiceList, endsText} The order is the same as screen pixel order.
   */


  PiecewiseVisualMapView.prototype._getViewData = function () {
    var visualMapModel = this.visualMapModel;
    var viewPieceList = map$1(visualMapModel.getPieceList(), function (piece, index) {
      return {
        piece: piece,
        indexInModelPieceList: index
      };
    });
    var endsText = visualMapModel.get('text'); // Consider orient and inverse.

    var orient = visualMapModel.get('orient');
    var inverse = visualMapModel.get('inverse'); // Order of model pieceList is always [low, ..., high]

    if (orient === 'horizontal' ? inverse : !inverse) {
      viewPieceList.reverse();
    } // Origin order of endsText is [high, low]
    else if (endsText) {
        endsText = endsText.slice().reverse();
      }

    return {
      viewPieceList: viewPieceList,
      endsText: endsText
    };
  };

  PiecewiseVisualMapView.prototype._createItemSymbol = function (group, representValue, shapeParam) {
    group.add(createSymbol( // symbol will be string
    this.getControllerVisual(representValue, 'symbol'), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], // color will be string
    this.getControllerVisual(representValue, 'color')));
  };

  PiecewiseVisualMapView.prototype._onItemClick = function (piece) {
    var visualMapModel = this.visualMapModel;
    var option = visualMapModel.option;
    var selectedMode = option.selectedMode;

    if (!selectedMode) {
      return;
    }

    var selected = clone$3(option.selected);
    var newKey = visualMapModel.getSelectedMapKey(piece);

    if (selectedMode === 'single' || selectedMode === true) {
      selected[newKey] = true;
      each$9(selected, function (o, key) {
        selected[key] = key === newKey;
      });
    } else {
      selected[newKey] = !selected[newKey];
    }

    this.api.dispatchAction({
      type: 'selectDataRange',
      from: this.uid,
      visualMapId: this.visualMapModel.id,
      selected: selected
    });
  };

  PiecewiseVisualMapView.type = 'visualMap.piecewise';
  return PiecewiseVisualMapView;
}(VisualMapView$1);

var PiecewiseView = PiecewiseVisualMapView;

function install$3(registers) {
  registers.registerComponentModel(PiecewiseModel$1);
  registers.registerComponentView(PiecewiseView);
  installCommon(registers);
}

function install$2(registers) {
  use(install$4);
  use(install$3); // Do not install './dataZoomSelect',
  // since it only work for toolbox dataZoom.
}

var DatasetModel =
/** @class */
function (_super) {
  __extends$1(DatasetModel, _super);

  function DatasetModel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'dataset';
    return _this;
  }

  DatasetModel.prototype.init = function (option, parentModel, ecModel) {
    _super.prototype.init.call(this, option, parentModel, ecModel);

    this._sourceManager = new SourceManager(this);
    disableTransformOptionMerge(this);
  };

  DatasetModel.prototype.mergeOption = function (newOption, ecModel) {
    _super.prototype.mergeOption.call(this, newOption, ecModel);

    disableTransformOptionMerge(this);
  };

  DatasetModel.prototype.optionUpdated = function () {
    this._sourceManager.dirty();
  };

  DatasetModel.prototype.getSourceManager = function () {
    return this._sourceManager;
  };

  DatasetModel.type = 'dataset';
  DatasetModel.defaultOption = {
    seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN
  };
  return DatasetModel;
}(ComponentModel$1);

var DatasetView =
/** @class */
function (_super) {
  __extends$1(DatasetView, _super);

  function DatasetView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'dataset';
    return _this;
  }

  DatasetView.type = 'dataset';
  return DatasetView;
}(ComponentView$1);

function install$1(registers) {
  registers.registerComponentModel(DatasetModel);
  registers.registerComponentView(DatasetView);
}

function createDom(id, painter, dpr) {
    var newDom = platformApi.createCanvas();
    var width = painter.getWidth();
    var height = painter.getHeight();
    var newDomStyle = newDom.style;
    if (newDomStyle) {
        newDomStyle.position = 'absolute';
        newDomStyle.left = '0';
        newDomStyle.top = '0';
        newDomStyle.width = width + 'px';
        newDomStyle.height = height + 'px';
        newDom.setAttribute('data-zr-dom-id', id);
    }
    newDom.width = width * dpr;
    newDom.height = height * dpr;
    return newDom;
}
var Layer = (function (_super) {
    __extends(Layer, _super);
    function Layer(id, painter, dpr) {
        var _this = _super.call(this) || this;
        _this.motionBlur = false;
        _this.lastFrameAlpha = 0.7;
        _this.dpr = 1;
        _this.virtual = false;
        _this.config = {};
        _this.incremental = false;
        _this.zlevel = 0;
        _this.maxRepaintRectCount = 5;
        _this.__dirty = true;
        _this.__firstTimePaint = true;
        _this.__used = false;
        _this.__drawIndex = 0;
        _this.__startIndex = 0;
        _this.__endIndex = 0;
        _this.__prevStartIndex = null;
        _this.__prevEndIndex = null;
        var dom;
        dpr = dpr || devicePixelRatio;
        if (typeof id === 'string') {
            dom = createDom(id, painter, dpr);
        }
        else if (isObject$3(id)) {
            dom = id;
            id = dom.id;
        }
        _this.id = id;
        _this.dom = dom;
        var domStyle = dom.style;
        if (domStyle) {
            disableUserSelect(dom);
            dom.onselectstart = function () { return false; };
            domStyle.padding = '0';
            domStyle.margin = '0';
            domStyle.borderWidth = '0';
        }
        _this.painter = painter;
        _this.dpr = dpr;
        return _this;
    }
    Layer.prototype.getElementCount = function () {
        return this.__endIndex - this.__startIndex;
    };
    Layer.prototype.afterBrush = function () {
        this.__prevStartIndex = this.__startIndex;
        this.__prevEndIndex = this.__endIndex;
    };
    Layer.prototype.initContext = function () {
        this.ctx = this.dom.getContext('2d');
        this.ctx.dpr = this.dpr;
    };
    Layer.prototype.setUnpainted = function () {
        this.__firstTimePaint = true;
    };
    Layer.prototype.createBackBuffer = function () {
        var dpr = this.dpr;
        this.domBack = createDom('back-' + this.id, this.painter, dpr);
        this.ctxBack = this.domBack.getContext('2d');
        if (dpr !== 1) {
            this.ctxBack.scale(dpr, dpr);
        }
    };
    Layer.prototype.createRepaintRects = function (displayList, prevList, viewWidth, viewHeight) {
        if (this.__firstTimePaint) {
            this.__firstTimePaint = false;
            return null;
        }
        var mergedRepaintRects = [];
        var maxRepaintRectCount = this.maxRepaintRectCount;
        var full = false;
        var pendingRect = new BoundingRect$1(0, 0, 0, 0);
        function addRectToMergePool(rect) {
            if (!rect.isFinite() || rect.isZero()) {
                return;
            }
            if (mergedRepaintRects.length === 0) {
                var boundingRect = new BoundingRect$1(0, 0, 0, 0);
                boundingRect.copy(rect);
                mergedRepaintRects.push(boundingRect);
            }
            else {
                var isMerged = false;
                var minDeltaArea = Infinity;
                var bestRectToMergeIdx = 0;
                for (var i = 0; i < mergedRepaintRects.length; ++i) {
                    var mergedRect = mergedRepaintRects[i];
                    if (mergedRect.intersect(rect)) {
                        var pendingRect_1 = new BoundingRect$1(0, 0, 0, 0);
                        pendingRect_1.copy(mergedRect);
                        pendingRect_1.union(rect);
                        mergedRepaintRects[i] = pendingRect_1;
                        isMerged = true;
                        break;
                    }
                    else if (full) {
                        pendingRect.copy(rect);
                        pendingRect.union(mergedRect);
                        var aArea = rect.width * rect.height;
                        var bArea = mergedRect.width * mergedRect.height;
                        var pendingArea = pendingRect.width * pendingRect.height;
                        var deltaArea = pendingArea - aArea - bArea;
                        if (deltaArea < minDeltaArea) {
                            minDeltaArea = deltaArea;
                            bestRectToMergeIdx = i;
                        }
                    }
                }
                if (full) {
                    mergedRepaintRects[bestRectToMergeIdx].union(rect);
                    isMerged = true;
                }
                if (!isMerged) {
                    var boundingRect = new BoundingRect$1(0, 0, 0, 0);
                    boundingRect.copy(rect);
                    mergedRepaintRects.push(boundingRect);
                }
                if (!full) {
                    full = mergedRepaintRects.length >= maxRepaintRectCount;
                }
            }
        }
        for (var i = this.__startIndex; i < this.__endIndex; ++i) {
            var el = displayList[i];
            if (el) {
                var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
                var prevRect = el.__isRendered && ((el.__dirty & REDRAW_BIT) || !shouldPaint)
                    ? el.getPrevPaintRect()
                    : null;
                if (prevRect) {
                    addRectToMergePool(prevRect);
                }
                var curRect = shouldPaint && ((el.__dirty & REDRAW_BIT) || !el.__isRendered)
                    ? el.getPaintRect()
                    : null;
                if (curRect) {
                    addRectToMergePool(curRect);
                }
            }
        }
        for (var i = this.__prevStartIndex; i < this.__prevEndIndex; ++i) {
            var el = prevList[i];
            var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
            if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
                var prevRect = el.getPrevPaintRect();
                if (prevRect) {
                    addRectToMergePool(prevRect);
                }
            }
        }
        var hasIntersections;
        do {
            hasIntersections = false;
            for (var i = 0; i < mergedRepaintRects.length;) {
                if (mergedRepaintRects[i].isZero()) {
                    mergedRepaintRects.splice(i, 1);
                    continue;
                }
                for (var j = i + 1; j < mergedRepaintRects.length;) {
                    if (mergedRepaintRects[i].intersect(mergedRepaintRects[j])) {
                        hasIntersections = true;
                        mergedRepaintRects[i].union(mergedRepaintRects[j]);
                        mergedRepaintRects.splice(j, 1);
                    }
                    else {
                        j++;
                    }
                }
                i++;
            }
        } while (hasIntersections);
        this._paintRects = mergedRepaintRects;
        return mergedRepaintRects;
    };
    Layer.prototype.debugGetPaintRects = function () {
        return (this._paintRects || []).slice();
    };
    Layer.prototype.resize = function (width, height) {
        var dpr = this.dpr;
        var dom = this.dom;
        var domStyle = dom.style;
        var domBack = this.domBack;
        if (domStyle) {
            domStyle.width = width + 'px';
            domStyle.height = height + 'px';
        }
        dom.width = width * dpr;
        dom.height = height * dpr;
        if (domBack) {
            domBack.width = width * dpr;
            domBack.height = height * dpr;
            if (dpr !== 1) {
                this.ctxBack.scale(dpr, dpr);
            }
        }
    };
    Layer.prototype.clear = function (clearAll, clearColor, repaintRects) {
        var dom = this.dom;
        var ctx = this.ctx;
        var width = dom.width;
        var height = dom.height;
        clearColor = clearColor || this.clearColor;
        var haveMotionBLur = this.motionBlur && !clearAll;
        var lastFrameAlpha = this.lastFrameAlpha;
        var dpr = this.dpr;
        var self = this;
        if (haveMotionBLur) {
            if (!this.domBack) {
                this.createBackBuffer();
            }
            this.ctxBack.globalCompositeOperation = 'copy';
            this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
        }
        var domBack = this.domBack;
        function doClear(x, y, width, height) {
            ctx.clearRect(x, y, width, height);
            if (clearColor && clearColor !== 'transparent') {
                var clearColorGradientOrPattern = void 0;
                if (isGradientObject(clearColor)) {
                    clearColorGradientOrPattern = clearColor.__canvasGradient
                        || getCanvasGradient(ctx, clearColor, {
                            x: 0,
                            y: 0,
                            width: width,
                            height: height
                        });
                    clearColor.__canvasGradient = clearColorGradientOrPattern;
                }
                else if (isImagePatternObject(clearColor)) {
                    clearColor.scaleX = clearColor.scaleX || dpr;
                    clearColor.scaleY = clearColor.scaleY || dpr;
                    clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {
                        dirty: function () {
                            self.setUnpainted();
                            self.__painter.refresh();
                        }
                    });
                }
                ctx.save();
                ctx.fillStyle = clearColorGradientOrPattern || clearColor;
                ctx.fillRect(x, y, width, height);
                ctx.restore();
            }
            if (haveMotionBLur) {
                ctx.save();
                ctx.globalAlpha = lastFrameAlpha;
                ctx.drawImage(domBack, x, y, width, height);
                ctx.restore();
            }
        }
        if (!repaintRects || haveMotionBLur) {
            doClear(0, 0, width, height);
        }
        else if (repaintRects.length) {
            each$9(repaintRects, function (rect) {
                doClear(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr);
            });
        }
    };
    return Layer;
}(Eventful$1));
var Layer$1 = Layer;

var HOVER_LAYER_ZLEVEL = 1e5;
var CANVAS_ZLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = 0.01;
var INCREMENTAL_INC = 0.001;
function isLayerValid(layer) {
    if (!layer) {
        return false;
    }
    if (layer.__builtin__) {
        return true;
    }
    if (typeof (layer.resize) !== 'function'
        || typeof (layer.refresh) !== 'function') {
        return false;
    }
    return true;
}
function createRoot(width, height) {
    var domRoot = document.createElement('div');
    domRoot.style.cssText = [
        'position:relative',
        'width:' + width + 'px',
        'height:' + height + 'px',
        'padding:0',
        'margin:0',
        'border-width:0'
    ].join(';') + ';';
    return domRoot;
}
var CanvasPainter = (function () {
    function CanvasPainter(root, storage, opts, id) {
        this.type = 'canvas';
        this._zlevelList = [];
        this._prevDisplayList = [];
        this._layers = {};
        this._layerConfig = {};
        this._needsManuallyCompositing = false;
        this.type = 'canvas';
        var singleCanvas = !root.nodeName
            || root.nodeName.toUpperCase() === 'CANVAS';
        this._opts = opts = extend$2({}, opts || {});
        this.dpr = opts.devicePixelRatio || devicePixelRatio;
        this._singleCanvas = singleCanvas;
        this.root = root;
        var rootStyle = root.style;
        if (rootStyle) {
            disableUserSelect(root);
            root.innerHTML = '';
        }
        this.storage = storage;
        var zlevelList = this._zlevelList;
        this._prevDisplayList = [];
        var layers = this._layers;
        if (!singleCanvas) {
            this._width = getSize(root, 0, opts);
            this._height = getSize(root, 1, opts);
            var domRoot = this._domRoot = createRoot(this._width, this._height);
            root.appendChild(domRoot);
        }
        else {
            var rootCanvas = root;
            var width = rootCanvas.width;
            var height = rootCanvas.height;
            if (opts.width != null) {
                width = opts.width;
            }
            if (opts.height != null) {
                height = opts.height;
            }
            this.dpr = opts.devicePixelRatio || 1;
            rootCanvas.width = width * this.dpr;
            rootCanvas.height = height * this.dpr;
            this._width = width;
            this._height = height;
            var mainLayer = new Layer$1(rootCanvas, this, this.dpr);
            mainLayer.__builtin__ = true;
            mainLayer.initContext();
            layers[CANVAS_ZLEVEL] = mainLayer;
            mainLayer.zlevel = CANVAS_ZLEVEL;
            zlevelList.push(CANVAS_ZLEVEL);
            this._domRoot = root;
        }
    }
    CanvasPainter.prototype.getType = function () {
        return 'canvas';
    };
    CanvasPainter.prototype.isSingleCanvas = function () {
        return this._singleCanvas;
    };
    CanvasPainter.prototype.getViewportRoot = function () {
        return this._domRoot;
    };
    CanvasPainter.prototype.getViewportRootOffset = function () {
        var viewportRoot = this.getViewportRoot();
        if (viewportRoot) {
            return {
                offsetLeft: viewportRoot.offsetLeft || 0,
                offsetTop: viewportRoot.offsetTop || 0
            };
        }
    };
    CanvasPainter.prototype.refresh = function (paintAll) {
        var list = this.storage.getDisplayList(true);
        var prevList = this._prevDisplayList;
        var zlevelList = this._zlevelList;
        this._redrawId = Math.random();
        this._paintList(list, prevList, paintAll, this._redrawId);
        for (var i = 0; i < zlevelList.length; i++) {
            var z = zlevelList[i];
            var layer = this._layers[z];
            if (!layer.__builtin__ && layer.refresh) {
                var clearColor = i === 0 ? this._backgroundColor : null;
                layer.refresh(clearColor);
            }
        }
        if (this._opts.useDirtyRect) {
            this._prevDisplayList = list.slice();
        }
        return this;
    };
    CanvasPainter.prototype.refreshHover = function () {
        this._paintHoverList(this.storage.getDisplayList(false));
    };
    CanvasPainter.prototype._paintHoverList = function (list) {
        var len = list.length;
        var hoverLayer = this._hoverlayer;
        hoverLayer && hoverLayer.clear();
        if (!len) {
            return;
        }
        var scope = {
            inHover: true,
            viewWidth: this._width,
            viewHeight: this._height
        };
        var ctx;
        for (var i = 0; i < len; i++) {
            var el = list[i];
            if (el.__inHover) {
                if (!hoverLayer) {
                    hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
                }
                if (!ctx) {
                    ctx = hoverLayer.ctx;
                    ctx.save();
                }
                brush(ctx, el, scope, i === len - 1);
            }
        }
        if (ctx) {
            ctx.restore();
        }
    };
    CanvasPainter.prototype.getHoverLayer = function () {
        return this.getLayer(HOVER_LAYER_ZLEVEL);
    };
    CanvasPainter.prototype.paintOne = function (ctx, el) {
        brushSingle(ctx, el);
    };
    CanvasPainter.prototype._paintList = function (list, prevList, paintAll, redrawId) {
        if (this._redrawId !== redrawId) {
            return;
        }
        paintAll = paintAll || false;
        this._updateLayerStatus(list);
        var _a = this._doPaintList(list, prevList, paintAll), finished = _a.finished, needsRefreshHover = _a.needsRefreshHover;
        if (this._needsManuallyCompositing) {
            this._compositeManually();
        }
        if (needsRefreshHover) {
            this._paintHoverList(list);
        }
        if (!finished) {
            var self_1 = this;
            requestAnimationFrame$2(function () {
                self_1._paintList(list, prevList, paintAll, redrawId);
            });
        }
        else {
            this.eachLayer(function (layer) {
                layer.afterBrush && layer.afterBrush();
            });
        }
    };
    CanvasPainter.prototype._compositeManually = function () {
        var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
        var width = this._domRoot.width;
        var height = this._domRoot.height;
        ctx.clearRect(0, 0, width, height);
        this.eachBuiltinLayer(function (layer) {
            if (layer.virtual) {
                ctx.drawImage(layer.dom, 0, 0, width, height);
            }
        });
    };
    CanvasPainter.prototype._doPaintList = function (list, prevList, paintAll) {
        var _this = this;
        var layerList = [];
        var useDirtyRect = this._opts.useDirtyRect;
        for (var zi = 0; zi < this._zlevelList.length; zi++) {
            var zlevel = this._zlevelList[zi];
            var layer = this._layers[zlevel];
            if (layer.__builtin__
                && layer !== this._hoverlayer
                && (layer.__dirty || paintAll)) {
                layerList.push(layer);
            }
        }
        var finished = true;
        var needsRefreshHover = false;
        var _loop_1 = function (k) {
            var layer = layerList[k];
            var ctx = layer.ctx;
            var repaintRects = useDirtyRect
                && layer.createRepaintRects(list, prevList, this_1._width, this_1._height);
            var start = paintAll ? layer.__startIndex : layer.__drawIndex;
            var useTimer = !paintAll && layer.incremental && Date.now;
            var startTime = useTimer && Date.now();
            var clearColor = layer.zlevel === this_1._zlevelList[0]
                ? this_1._backgroundColor : null;
            if (layer.__startIndex === layer.__endIndex) {
                layer.clear(false, clearColor, repaintRects);
            }
            else if (start === layer.__startIndex) {
                var firstEl = list[start];
                if (!firstEl.incremental || !firstEl.notClear || paintAll) {
                    layer.clear(false, clearColor, repaintRects);
                }
            }
            if (start === -1) {
                console.error('For some unknown reason. drawIndex is -1');
                start = layer.__startIndex;
            }
            var i;
            var repaint = function (repaintRect) {
                var scope = {
                    inHover: false,
                    allClipped: false,
                    prevEl: null,
                    viewWidth: _this._width,
                    viewHeight: _this._height
                };
                for (i = start; i < layer.__endIndex; i++) {
                    var el = list[i];
                    if (el.__inHover) {
                        needsRefreshHover = true;
                    }
                    _this._doPaintEl(el, layer, useDirtyRect, repaintRect, scope, i === layer.__endIndex - 1);
                    if (useTimer) {
                        var dTime = Date.now() - startTime;
                        if (dTime > 15) {
                            break;
                        }
                    }
                }
                if (scope.prevElClipPaths) {
                    ctx.restore();
                }
            };
            if (repaintRects) {
                if (repaintRects.length === 0) {
                    i = layer.__endIndex;
                }
                else {
                    var dpr = this_1.dpr;
                    for (var r = 0; r < repaintRects.length; ++r) {
                        var rect = repaintRects[r];
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr);
                        ctx.clip();
                        repaint(rect);
                        ctx.restore();
                    }
                }
            }
            else {
                ctx.save();
                repaint();
                ctx.restore();
            }
            layer.__drawIndex = i;
            if (layer.__drawIndex < layer.__endIndex) {
                finished = false;
            }
        };
        var this_1 = this;
        for (var k = 0; k < layerList.length; k++) {
            _loop_1(k);
        }
        if (env$1.wxa) {
            each$9(this._layers, function (layer) {
                if (layer && layer.ctx && layer.ctx.draw) {
                    layer.ctx.draw();
                }
            });
        }
        return {
            finished: finished,
            needsRefreshHover: needsRefreshHover
        };
    };
    CanvasPainter.prototype._doPaintEl = function (el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
        var ctx = currentLayer.ctx;
        if (useDirtyRect) {
            var paintRect = el.getPaintRect();
            if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
                brush(ctx, el, scope, isLast);
                el.setPrevPaintRect(paintRect);
            }
        }
        else {
            brush(ctx, el, scope, isLast);
        }
    };
    CanvasPainter.prototype.getLayer = function (zlevel, virtual) {
        if (this._singleCanvas && !this._needsManuallyCompositing) {
            zlevel = CANVAS_ZLEVEL;
        }
        var layer = this._layers[zlevel];
        if (!layer) {
            layer = new Layer$1('zr_' + zlevel, this, this.dpr);
            layer.zlevel = zlevel;
            layer.__builtin__ = true;
            if (this._layerConfig[zlevel]) {
                merge$1(layer, this._layerConfig[zlevel], true);
            }
            else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
                merge$1(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
            }
            if (virtual) {
                layer.virtual = virtual;
            }
            this.insertLayer(zlevel, layer);
            layer.initContext();
        }
        return layer;
    };
    CanvasPainter.prototype.insertLayer = function (zlevel, layer) {
        var layersMap = this._layers;
        var zlevelList = this._zlevelList;
        var len = zlevelList.length;
        var domRoot = this._domRoot;
        var prevLayer = null;
        var i = -1;
        if (layersMap[zlevel]) {
            if (process.env.NODE_ENV !== 'production') {
                logError('ZLevel ' + zlevel + ' has been used already');
            }
            return;
        }
        if (!isLayerValid(layer)) {
            if (process.env.NODE_ENV !== 'production') {
                logError('Layer of zlevel ' + zlevel + ' is not valid');
            }
            return;
        }
        if (len > 0 && zlevel > zlevelList[0]) {
            for (i = 0; i < len - 1; i++) {
                if (zlevelList[i] < zlevel
                    && zlevelList[i + 1] > zlevel) {
                    break;
                }
            }
            prevLayer = layersMap[zlevelList[i]];
        }
        zlevelList.splice(i + 1, 0, zlevel);
        layersMap[zlevel] = layer;
        if (!layer.virtual) {
            if (prevLayer) {
                var prevDom = prevLayer.dom;
                if (prevDom.nextSibling) {
                    domRoot.insertBefore(layer.dom, prevDom.nextSibling);
                }
                else {
                    domRoot.appendChild(layer.dom);
                }
            }
            else {
                if (domRoot.firstChild) {
                    domRoot.insertBefore(layer.dom, domRoot.firstChild);
                }
                else {
                    domRoot.appendChild(layer.dom);
                }
            }
        }
        layer.__painter = this;
    };
    CanvasPainter.prototype.eachLayer = function (cb, context) {
        var zlevelList = this._zlevelList;
        for (var i = 0; i < zlevelList.length; i++) {
            var z = zlevelList[i];
            cb.call(context, this._layers[z], z);
        }
    };
    CanvasPainter.prototype.eachBuiltinLayer = function (cb, context) {
        var zlevelList = this._zlevelList;
        for (var i = 0; i < zlevelList.length; i++) {
            var z = zlevelList[i];
            var layer = this._layers[z];
            if (layer.__builtin__) {
                cb.call(context, layer, z);
            }
        }
    };
    CanvasPainter.prototype.eachOtherLayer = function (cb, context) {
        var zlevelList = this._zlevelList;
        for (var i = 0; i < zlevelList.length; i++) {
            var z = zlevelList[i];
            var layer = this._layers[z];
            if (!layer.__builtin__) {
                cb.call(context, layer, z);
            }
        }
    };
    CanvasPainter.prototype.getLayers = function () {
        return this._layers;
    };
    CanvasPainter.prototype._updateLayerStatus = function (list) {
        this.eachBuiltinLayer(function (layer, z) {
            layer.__dirty = layer.__used = false;
        });
        function updatePrevLayer(idx) {
            if (prevLayer) {
                if (prevLayer.__endIndex !== idx) {
                    prevLayer.__dirty = true;
                }
                prevLayer.__endIndex = idx;
            }
        }
        if (this._singleCanvas) {
            for (var i_1 = 1; i_1 < list.length; i_1++) {
                var el = list[i_1];
                if (el.zlevel !== list[i_1 - 1].zlevel || el.incremental) {
                    this._needsManuallyCompositing = true;
                    break;
                }
            }
        }
        var prevLayer = null;
        var incrementalLayerCount = 0;
        var prevZlevel;
        var i;
        for (i = 0; i < list.length; i++) {
            var el = list[i];
            var zlevel = el.zlevel;
            var layer = void 0;
            if (prevZlevel !== zlevel) {
                prevZlevel = zlevel;
                incrementalLayerCount = 0;
            }
            if (el.incremental) {
                layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
                layer.incremental = true;
                incrementalLayerCount = 1;
            }
            else {
                layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
            }
            if (!layer.__builtin__) {
                logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);
            }
            if (layer !== prevLayer) {
                layer.__used = true;
                if (layer.__startIndex !== i) {
                    layer.__dirty = true;
                }
                layer.__startIndex = i;
                if (!layer.incremental) {
                    layer.__drawIndex = i;
                }
                else {
                    layer.__drawIndex = -1;
                }
                updatePrevLayer(i);
                prevLayer = layer;
            }
            if ((el.__dirty & REDRAW_BIT) && !el.__inHover) {
                layer.__dirty = true;
                if (layer.incremental && layer.__drawIndex < 0) {
                    layer.__drawIndex = i;
                }
            }
        }
        updatePrevLayer(i);
        this.eachBuiltinLayer(function (layer, z) {
            if (!layer.__used && layer.getElementCount() > 0) {
                layer.__dirty = true;
                layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;
            }
            if (layer.__dirty && layer.__drawIndex < 0) {
                layer.__drawIndex = layer.__startIndex;
            }
        });
    };
    CanvasPainter.prototype.clear = function () {
        this.eachBuiltinLayer(this._clearLayer);
        return this;
    };
    CanvasPainter.prototype._clearLayer = function (layer) {
        layer.clear();
    };
    CanvasPainter.prototype.setBackgroundColor = function (backgroundColor) {
        this._backgroundColor = backgroundColor;
        each$9(this._layers, function (layer) {
            layer.setUnpainted();
        });
    };
    CanvasPainter.prototype.configLayer = function (zlevel, config) {
        if (config) {
            var layerConfig = this._layerConfig;
            if (!layerConfig[zlevel]) {
                layerConfig[zlevel] = config;
            }
            else {
                merge$1(layerConfig[zlevel], config, true);
            }
            for (var i = 0; i < this._zlevelList.length; i++) {
                var _zlevel = this._zlevelList[i];
                if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
                    var layer = this._layers[_zlevel];
                    merge$1(layer, layerConfig[zlevel], true);
                }
            }
        }
    };
    CanvasPainter.prototype.delLayer = function (zlevel) {
        var layers = this._layers;
        var zlevelList = this._zlevelList;
        var layer = layers[zlevel];
        if (!layer) {
            return;
        }
        layer.dom.parentNode.removeChild(layer.dom);
        delete layers[zlevel];
        zlevelList.splice(indexOf(zlevelList, zlevel), 1);
    };
    CanvasPainter.prototype.resize = function (width, height) {
        if (!this._domRoot.style) {
            if (width == null || height == null) {
                return;
            }
            this._width = width;
            this._height = height;
            this.getLayer(CANVAS_ZLEVEL).resize(width, height);
        }
        else {
            var domRoot = this._domRoot;
            domRoot.style.display = 'none';
            var opts = this._opts;
            var root = this.root;
            width != null && (opts.width = width);
            height != null && (opts.height = height);
            width = getSize(root, 0, opts);
            height = getSize(root, 1, opts);
            domRoot.style.display = '';
            if (this._width !== width || height !== this._height) {
                domRoot.style.width = width + 'px';
                domRoot.style.height = height + 'px';
                for (var id in this._layers) {
                    if (this._layers.hasOwnProperty(id)) {
                        this._layers[id].resize(width, height);
                    }
                }
                this.refresh(true);
            }
            this._width = width;
            this._height = height;
        }
        return this;
    };
    CanvasPainter.prototype.clearLayer = function (zlevel) {
        var layer = this._layers[zlevel];
        if (layer) {
            layer.clear();
        }
    };
    CanvasPainter.prototype.dispose = function () {
        this.root.innerHTML = '';
        this.root =
            this.storage =
                this._domRoot =
                    this._layers = null;
    };
    CanvasPainter.prototype.getRenderedCanvas = function (opts) {
        opts = opts || {};
        if (this._singleCanvas && !this._compositeManually) {
            return this._layers[CANVAS_ZLEVEL].dom;
        }
        var imageLayer = new Layer$1('image', this, opts.pixelRatio || this.dpr);
        imageLayer.initContext();
        imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
        var ctx = imageLayer.ctx;
        if (opts.pixelRatio <= this.dpr) {
            this.refresh();
            var width_1 = imageLayer.dom.width;
            var height_1 = imageLayer.dom.height;
            this.eachLayer(function (layer) {
                if (layer.__builtin__) {
                    ctx.drawImage(layer.dom, 0, 0, width_1, height_1);
                }
                else if (layer.renderToCanvas) {
                    ctx.save();
                    layer.renderToCanvas(ctx);
                    ctx.restore();
                }
            });
        }
        else {
            var scope = {
                inHover: false,
                viewWidth: this._width,
                viewHeight: this._height
            };
            var displayList = this.storage.getDisplayList(true);
            for (var i = 0, len = displayList.length; i < len; i++) {
                var el = displayList[i];
                brush(ctx, el, scope, i === len - 1);
            }
        }
        return imageLayer.dom;
    };
    CanvasPainter.prototype.getWidth = function () {
        return this._width;
    };
    CanvasPainter.prototype.getHeight = function () {
        return this._height;
    };
    return CanvasPainter;
}());
var CanvasPainter$1 = CanvasPainter;

function install(registers) {
  registers.registerPainter('canvas', CanvasPainter$1);
}

var css$g = ".BaseVerticalBarChart_module_root__db36f9d1 {\n  width: \"100%\";\n}";
var modules_8757388c = {"root":"BaseVerticalBarChart_module_root__db36f9d1"};
n(css$g,{});

var css$f = ".Skeleton_module_root__cca72340 {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: flex-end;\n  gap: 1rem;\n  height: 100%;\n  width: 100%;\n  padding: 2rem;\n}";
var modules_37a5ff73$4 = {"root":"Skeleton_module_root__cca72340"};
n(css$f,{});

var BARS$1 = _toConsumableArray$1(Array(10).keys()).map(function () {
  return Math.random() * 80 + 20;
});
var ChartSkeleton$4 = function ChartSkeleton(_ref) {
  var theme = _ref.theme,
    fallback = _ref.fallback;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: modules_37a5ff73$4.root,
    children: BARS$1.map(function (bar) {
      return /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
        theme: theme,
        width: "3rem",
        height: "".concat(bar, "%"),
        variant: "rounded",
        style: {
          animationDuration: '4s'
        },
        noAnimation: fallback
      }, bar);
    })
  });
};

use([install$8, install$9, install$a, install$1, install$5, install$h, install]);
var AXIS_COLORS = {
  label: {
    dark: '#a2a4a5',
    light: COLORS.grey
  },
  line: {
    dark: '#757679',
    light: COLORS.grey3
  },
  split: {
    dark: COLORS['dark-grey'],
    light: COLORS.grey5
  },
  tick: {
    dark: '#757679',
    light: COLORS.grey3
  }
};
var determineAxesColors = function determineAxesColors(type) {
  var defaultColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var theme = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'dark';
  if (defaultColor !== '') {
    return defaultColor;
  }
  return AXIS_COLORS[type]["".concat(theme)];
};
var determineGradient = function determineGradient(seriesData, objectData, index, subIndex, key) {
  var _seriesData$chartData, _seriesData$chartData2;
  if (seriesData !== null && seriesData !== void 0 && (_seriesData$chartData = seriesData.chartData) !== null && _seriesData$chartData !== void 0 && (_seriesData$chartData2 = _seriesData$chartData[key]) !== null && _seriesData$chartData2 !== void 0 && _seriesData$chartData2["x".concat(index + 1)]) {
    var _ref, _objectData$color, _objectData$barColor$2, _objectData$barColor2, _objectData$color3;
    if (typeof ((_ref = (_objectData$color = objectData === null || objectData === void 0 ? void 0 : objectData.color) !== null && _objectData$color !== void 0 ? _objectData$color : '') !== null && _ref !== void 0 ? _ref : {}) !== 'string') {
      var _objectData$barColor$, _objectData$barColor, _objectData$color2;
      return _construct(LinearGradient$1, _toConsumableArray$1(((_objectData$barColor$ = objectData === null || objectData === void 0 ? void 0 : (_objectData$barColor = objectData.barColor) === null || _objectData$barColor === void 0 ? void 0 : _objectData$barColor[subIndex]) !== null && _objectData$barColor$ !== void 0 ? _objectData$barColor$ : '') || ((_objectData$color2 = objectData === null || objectData === void 0 ? void 0 : objectData.color) !== null && _objectData$color2 !== void 0 ? _objectData$color2 : '')));
    }
    return ((_objectData$barColor$2 = objectData === null || objectData === void 0 ? void 0 : (_objectData$barColor2 = objectData.barColor) === null || _objectData$barColor2 === void 0 ? void 0 : _objectData$barColor2[subIndex]) !== null && _objectData$barColor$2 !== void 0 ? _objectData$barColor$2 : '') || ((_objectData$color3 = objectData === null || objectData === void 0 ? void 0 : objectData.color) !== null && _objectData$color3 !== void 0 ? _objectData$color3 : '');
  }
  return '';
};
var BaseVerticalBarChart = function BaseVerticalBarChart(props) {
  var _Object$keys, _seriesData$chartData3, _seriesData$metaData$, _seriesData$metaData, _seriesData$metaData$2, _seriesData$chartData6, _seriesData$chartData21;
  var loading = props.loading,
    title = props.title,
    gridContainLabel = props.gridContainLabel,
    gridOptions = props.gridOptions,
    xAxisShow = props.xAxisShow,
    xAxisLabel = props.xAxisLabel,
    seriesData = props.seriesData,
    onEvents = props.onEvents,
    yAxisLabelShow = props.yAxisLabelShow,
    ySplitLineShow = props.ySplitLineShow,
    yAxisLineShow = props.yAxisLineShow,
    yAxisTickShow = props.yAxisTickShow,
    axisColor = props.axisColor,
    splitType = props.splitType,
    barWidth = props.barWidth,
    cursor = props.cursor,
    legend = props.legend,
    tooltip = props.tooltip,
    seriesName = props.seriesName,
    stackCount = props.stackCount,
    seriesOption = props.seriesOption,
    style = props.style,
    className = props.className,
    theme = props.theme,
    fallback = props.fallback;
  if (loading || fallback) {
    return /*#__PURE__*/jsxRuntime.jsx(ChartSkeleton$4, {
      theme: theme,
      fallback: !loading && fallback
    });
  }
  var minHeightCheck = !((_Object$keys = Object.keys((_seriesData$chartData3 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData3 !== void 0 ? _seriesData$chartData3 : 0)) !== null && _Object$keys !== void 0 && _Object$keys.some(function (obj1) {
    return seriesOption.some(function (obj, index) {
      var _seriesData$chartData4, _seriesData$chartData5;
      return seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData4 = seriesData.chartData) === null || _seriesData$chartData4 === void 0 ? void 0 : (_seriesData$chartData5 = _seriesData$chartData4[obj1]) === null || _seriesData$chartData5 === void 0 ? void 0 : _seriesData$chartData5["x".concat(index + 1)];
    });
  })) ? 1 : 0;
  var seriesOptionObject = {
    type: 'bar',
    barWidth: stackCount ? barWidth : barWidth / stackCount,
    cursor: cursor,
    stack: stackCount,
    groupPadding: 3,
    barMinHeight: minHeightCheck,
    showBackground: true,
    backgroundStyle: {
      color: 'whitesmoke'
    },
    label: {
      color: 'black',
      position: 'outside',
      formatter: function formatter(param) {
        return param.value;
      },
      show: true
    },
    itemStyle: {
      borderRadius: [0, 2, 2, 0]
    },
    name: (_seriesData$metaData$ = seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$metaData = seriesData.metaData) === null || _seriesData$metaData === void 0 ? void 0 : (_seriesData$metaData$2 = _seriesData$metaData.keyData) === null || _seriesData$metaData$2 === void 0 ? void 0 : _seriesData$metaData$2.x1) !== null && _seriesData$metaData$ !== void 0 ? _seriesData$metaData$ : '',
    data: Object.keys((_seriesData$chartData6 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData6 !== void 0 ? _seriesData$chartData6 : {}).map(function (key) {
      var _seriesData$chartData7, _seriesData$chartData8, _seriesData$chartData9;
      return {
        value: (_seriesData$chartData7 = seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData8 = seriesData.chartData) === null || _seriesData$chartData8 === void 0 ? void 0 : (_seriesData$chartData9 = _seriesData$chartData8[key]) === null || _seriesData$chartData9 === void 0 ? void 0 : _seriesData$chartData9.x1) !== null && _seriesData$chartData7 !== void 0 ? _seriesData$chartData7 : ''
      };
    })
  };
  var generateSeries = function generateSeries() {
    var _Object$keys2, _seriesData$chartData10;
    var minHeight = (_Object$keys2 = Object.keys((_seriesData$chartData10 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData10 !== void 0 ? _seriesData$chartData10 : 0)) !== null && _Object$keys2 !== void 0 && _Object$keys2.some(function (obj1) {
      return seriesOption.some(function (obj, index) {
        var _seriesData$chartData11, _seriesData$chartData12;
        return seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData11 = seriesData.chartData) === null || _seriesData$chartData11 === void 0 ? void 0 : (_seriesData$chartData12 = _seriesData$chartData11[obj1]) === null || _seriesData$chartData12 === void 0 ? void 0 : _seriesData$chartData12["x".concat(index + 1)];
      });
    }) ? 0.004 : 0;
    return seriesOption.map(function (objectData, index) {
      var _seriesOptionObject$l, _objectData$label, _seriesData$chartData13;
      return _objectSpread2(_objectSpread2(_objectSpread2({}, seriesOptionObject), objectData), {}, {
        label: _objectSpread2(_objectSpread2({}, (_seriesOptionObject$l = seriesOptionObject === null || seriesOptionObject === void 0 ? void 0 : seriesOptionObject.label) !== null && _seriesOptionObject$l !== void 0 ? _seriesOptionObject$l : {}), (_objectData$label = objectData === null || objectData === void 0 ? void 0 : objectData.label) !== null && _objectData$label !== void 0 ? _objectData$label : {}),
        name: seriesName(index),
        data: Object.keys((_seriesData$chartData13 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData13 !== void 0 ? _seriesData$chartData13 : {}).map(function (key, subIndex) {
          var _seriesData$chartData18, _seriesData$chartData19, _seriesData$chartData20, _objectData$color4, _seriesOption$subInde, _seriesOption$subInde2;
          var check = true;
          if (stackCount <= 1) {
            check = seriesOption.some(function (obj, checkIndex) {
              var _seriesData$chartData14, _seriesData$chartData15;
              return seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData14 = seriesData.chartData) === null || _seriesData$chartData14 === void 0 ? void 0 : (_seriesData$chartData15 = _seriesData$chartData14[key]) === null || _seriesData$chartData15 === void 0 ? void 0 : _seriesData$chartData15["x".concat(checkIndex + 1)];
            });
          } else {
            var stackCal = seriesOption[index].stack;
            check = seriesOption.some(function (series, checkNewIndex) {
              if (series.stack === stackCal) {
                var _seriesData$chartData16, _seriesData$chartData17;
                return seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData16 = seriesData.chartData) === null || _seriesData$chartData16 === void 0 ? void 0 : (_seriesData$chartData17 = _seriesData$chartData16[key]) === null || _seriesData$chartData17 === void 0 ? void 0 : _seriesData$chartData17["x".concat(checkNewIndex + 1)];
              }
              return false;
            });
          }
          return _objectSpread2(_objectSpread2({
            value: check ? (_seriesData$chartData18 = seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData19 = seriesData.chartData) === null || _seriesData$chartData19 === void 0 ? void 0 : (_seriesData$chartData20 = _seriesData$chartData19[key]) === null || _seriesData$chartData20 === void 0 ? void 0 : _seriesData$chartData20["x".concat(index + 1)]) !== null && _seriesData$chartData18 !== void 0 ? _seriesData$chartData18 : '' : minHeight
          }, ((_objectData$color4 = objectData === null || objectData === void 0 ? void 0 : objectData.color) !== null && _objectData$color4 !== void 0 ? _objectData$color4 : '') && {
            itemStyle: {
              color: determineGradient(seriesData, objectData, index, subIndex, key)
            }
          }), {}, {
            tooltip: _objectSpread2({}, (_seriesOption$subInde = (_seriesOption$subInde2 = seriesOption[subIndex]) === null || _seriesOption$subInde2 === void 0 ? void 0 : _seriesOption$subInde2.tooltip) !== null && _seriesOption$subInde !== void 0 ? _seriesOption$subInde : {})
          });
        })
      });
    });
  };
  return /*#__PURE__*/jsxRuntime.jsx(_default, {
    option: {
      title: {
        text: title
      },
      grid: _objectSpread2({
        containLabel: gridContainLabel
      }, gridOptions),
      xAxis: {
        data: Object.keys((_seriesData$chartData21 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData21 !== void 0 ? _seriesData$chartData21 : {}),
        show: xAxisShow,
        type: 'category',
        axisTick: {
          show: false,
          lineStyle: {
            color: determineAxesColors('tick', axisColor, theme)
          }
        },
        axisLabel: _objectSpread2(_objectSpread2({}, xAxisLabel), {}, {
          color: determineAxesColors('label', axisColor, theme)
        }),
        axisLine: {
          show: xAxisShow,
          lineStyle: {
            color: determineAxesColors('line', axisColor, theme)
          }
        }
      },
      legend: _objectSpread2({}, legend),
      tooltip: _objectSpread2({}, tooltip),
      yAxis: {
        type: 'value',
        axisLabel: {
          show: yAxisLabelShow,
          color: determineAxesColors('label', axisColor, theme)
        },
        splitLine: {
          show: ySplitLineShow,
          lineStyle: {
            color: determineAxesColors('split', axisColor, theme),
            type: splitType
          }
        },
        axisLine: {
          show: yAxisLineShow,
          lineStyle: {
            color: determineAxesColors('line', axisColor, theme)
          }
        },
        axisTick: {
          show: yAxisTickShow,
          lineStyle: {
            color: determineAxesColors('tick', axisColor, theme)
          }
        }
      },
      series: generateSeries()
    },
    onEvents: onEvents,
    echarts: echarts,
    notMerge: true,
    lazyUpdate: true,
    className: classes(className, modules_8757388c.root),
    style: style
  });
};
BaseVerticalBarChart.propTypes = {
  loading: propTypes$1.exports.bool,
  title: propTypes$1.exports.string,
  gridContainLabel: propTypes$1.exports.bool,
  gridOptions: propTypes$1.exports.object,
  xAxisShow: propTypes$1.exports.bool,
  xAxisLabel: propTypes$1.exports.object,
  tooltip: propTypes$1.exports.object,
  seriesData: propTypes$1.exports.shape({
    chartData: propTypes$1.exports.object,
    metaData: propTypes$1.exports.object
  }),
  onEvents: propTypes$1.exports.func,
  yAxisLabelShow: propTypes$1.exports.bool,
  ySplitLineShow: propTypes$1.exports.bool,
  yAxisLineShow: propTypes$1.exports.bool,
  yAxisTickShow: propTypes$1.exports.bool,
  axisColor: propTypes$1.exports.string,
  splitType: propTypes$1.exports.string,
  barWidth: propTypes$1.exports.string,
  legend: propTypes$1.exports.object,
  seriesName: propTypes$1.exports.func,
  cursor: propTypes$1.exports.string,
  stackCount: propTypes$1.exports.number,
  seriesOption: propTypes$1.exports.arrayOf(propTypes$1.exports.shape),
  style: propTypes$1.exports.objectOf(propTypes$1.exports.shape),
  className: propTypes$1.exports.string,
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
BaseVerticalBarChart.defaultProps = {
  loading: false,
  title: '',
  gridContainLabel: false,
  gridOptions: {
    left: 0,
    right: 0,
    bottom: 0,
    top: 5
  },
  xAxisShow: true,
  xAxisLabel: {
    show: true,
    rotate: 90,
    inside: true,
    verticalAlign: 'bottom',
    padding: [0, 0, 90, 0]
  },
  tooltip: {
    trigger: 'item'
  },
  seriesData: {},
  onEvents: function onEvents() {},
  yAxisLabelShow: false,
  ySplitLineShow: false,
  yAxisLineShow: false,
  yAxisTickShow: false,
  axisColor: '',
  splitType: 'solid',
  barWidth: '50%',
  seriesName: function seriesName() {},
  legend: {
    show: true
  },
  cursor: 'default',
  stackCount: 1,
  seriesOption: [{
    stackIndex: 1
  }],
  style: {
    width: '100%',
    height: '100%'
  },
  className: '',
  theme: 'dark'
};

var css$e = ".BaseHorizontalBarChart_module_root__75f8867a {\n  width: \"100%\";\n}";
var modules_8904c6a0 = {"root":"BaseHorizontalBarChart_module_root__75f8867a"};
n(css$e,{});

var css$d = ".Skeleton_module_root__daf92a10 {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  align-items: flex-start;\n  height: 100%;\n  width: 100%;\n  gap: 1rem;\n  padding: 2rem;\n}";
var modules_37a5ff73$3 = {"root":"Skeleton_module_root__daf92a10"};
n(css$d,{});

var BARS = _toConsumableArray$1(Array(8).keys()).map(function () {
  return Math.random() * 80 + 20;
});
var ChartSkeleton$3 = function ChartSkeleton(_ref) {
  var theme = _ref.theme,
    fallback = _ref.fallback;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: modules_37a5ff73$3.root,
    children: BARS.map(function (bar) {
      return /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
        theme: theme,
        variant: "rounded",
        width: "".concat(bar, "%"),
        height: "3rem",
        noAnimation: fallback
      }, bar);
    })
  });
};

use([install$8, install$9, install$a, install$1, install$h, install]);
var BaseHorizontalBarChart = function BaseHorizontalBarChart(props) {
  var _seriesOption$length, _seriesData$metaData$, _seriesData$metaData, _seriesData$metaData$2, _seriesData$chartData, _seriesData$chartData13;
  var loading = props.loading,
    title = props.title,
    gridContainLabel = props.gridContainLabel,
    gridOptions = props.gridOptions,
    inverse = props.inverse,
    xAxisShow = props.xAxisShow,
    seriesData = props.seriesData,
    onEvents = props.onEvents,
    yAxisLabelShow = props.yAxisLabelShow,
    ySplitLineShow = props.ySplitLineShow,
    yAxisLineShow = props.yAxisLineShow,
    yAxisTickShow = props.yAxisTickShow,
    barWidth = props.barWidth,
    cursor = props.cursor,
    legend = props.legend,
    tooltip = props.tooltip,
    seriesName = props.seriesName,
    stacked = props.stacked,
    seriesOption = props.seriesOption,
    style = props.style,
    className = props.className,
    theme = props.theme,
    fallback = props.fallback;
  if (loading || fallback) {
    return /*#__PURE__*/jsxRuntime.jsx(ChartSkeleton$3, {
      theme: theme,
      fallback: !loading && fallback
    });
  }
  var seriesOptionObject = {
    type: 'bar',
    barWidth: stacked ? barWidth : barWidth / ((_seriesOption$length = seriesOption === null || seriesOption === void 0 ? void 0 : seriesOption.length) !== null && _seriesOption$length !== void 0 ? _seriesOption$length : 1),
    cursor: cursor,
    stack: stacked,
    groupPadding: 3,
    showBackground: true,
    backgroundStyle: {
      color: 'whitesmoke'
    },
    label: {
      color: 'black',
      position: [0, -16],
      formatter: function formatter(param) {
        return param.value;
      },
      show: true
    },
    itemStyle: {
      borderRadius: [0, 2, 2, 0]
    },
    name: (_seriesData$metaData$ = seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$metaData = seriesData.metaData) === null || _seriesData$metaData === void 0 ? void 0 : (_seriesData$metaData$2 = _seriesData$metaData.keyData) === null || _seriesData$metaData$2 === void 0 ? void 0 : _seriesData$metaData$2.x1) !== null && _seriesData$metaData$ !== void 0 ? _seriesData$metaData$ : '',
    data: Object.keys((_seriesData$chartData = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData !== void 0 ? _seriesData$chartData : {}).map(function (key) {
      var _seriesData$chartData2, _seriesData$chartData3, _seriesData$chartData4;
      return (_seriesData$chartData2 = seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData3 = seriesData.chartData) === null || _seriesData$chartData3 === void 0 ? void 0 : (_seriesData$chartData4 = _seriesData$chartData3[key]) === null || _seriesData$chartData4 === void 0 ? void 0 : _seriesData$chartData4.x1) !== null && _seriesData$chartData2 !== void 0 ? _seriesData$chartData2 : '';
    })
  };
  var generateSeries = function generateSeries() {
    return seriesOption.map(function (objectData, index) {
      var _seriesOptionObject$l, _objectData$label, _seriesOption$index, _seriesOption$index$m, _seriesOption$index2, _seriesData$chartData5, _seriesData$chartData9;
      return _objectSpread2(_objectSpread2(_objectSpread2({}, seriesOptionObject), objectData), {}, {
        label: _objectSpread2(_objectSpread2({}, (_seriesOptionObject$l = seriesOptionObject === null || seriesOptionObject === void 0 ? void 0 : seriesOptionObject.label) !== null && _seriesOptionObject$l !== void 0 ? _seriesOptionObject$l : {}), (_objectData$label = objectData === null || objectData === void 0 ? void 0 : objectData.label) !== null && _objectData$label !== void 0 ? _objectData$label : {}),
        name: seriesName(index),
        data: seriesOption !== null && seriesOption !== void 0 && (_seriesOption$index = seriesOption[index]) !== null && _seriesOption$index !== void 0 && (_seriesOption$index$m = _seriesOption$index.maxvalueStyle) !== null && _seriesOption$index$m !== void 0 && _seriesOption$index$m.value ? [_objectSpread2(_objectSpread2({}, seriesOption === null || seriesOption === void 0 ? void 0 : (_seriesOption$index2 = seriesOption[index]) === null || _seriesOption$index2 === void 0 ? void 0 : _seriesOption$index2.maxvalueStyle), {}, {
          emphasis: {
            disabled: true
          },
          tooltip: {
            show: false
          }
        })].concat(_toConsumableArray$1(Object.keys((_seriesData$chartData5 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData5 !== void 0 ? _seriesData$chartData5 : {}).map(function (key, subIndex) {
          var _seriesData$chartData6, _seriesData$chartData7, _seriesData$chartData8, _ref, _objectData$color, _objectData$barColor$, _objectData$barColor, _objectData$color2, _objectData$barColor$2, _objectData$barColor2, _objectData$color3, _seriesOption$subInde, _seriesOption$subInde2;
          return {
            value: (_seriesData$chartData6 = seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData7 = seriesData.chartData) === null || _seriesData$chartData7 === void 0 ? void 0 : (_seriesData$chartData8 = _seriesData$chartData7[key]) === null || _seriesData$chartData8 === void 0 ? void 0 : _seriesData$chartData8["x".concat(index + 1)]) !== null && _seriesData$chartData6 !== void 0 ? _seriesData$chartData6 : '',
            itemStyle: {
              color: typeof ((_ref = (_objectData$color = objectData === null || objectData === void 0 ? void 0 : objectData.color) !== null && _objectData$color !== void 0 ? _objectData$color : '') !== null && _ref !== void 0 ? _ref : {}) !== 'string' ? _construct(LinearGradient$1, _toConsumableArray$1(((_objectData$barColor$ = objectData === null || objectData === void 0 ? void 0 : (_objectData$barColor = objectData.barColor) === null || _objectData$barColor === void 0 ? void 0 : _objectData$barColor[subIndex]) !== null && _objectData$barColor$ !== void 0 ? _objectData$barColor$ : '') || ((_objectData$color2 = objectData === null || objectData === void 0 ? void 0 : objectData.color) !== null && _objectData$color2 !== void 0 ? _objectData$color2 : ''))) : ((_objectData$barColor$2 = objectData === null || objectData === void 0 ? void 0 : (_objectData$barColor2 = objectData.barColor) === null || _objectData$barColor2 === void 0 ? void 0 : _objectData$barColor2[subIndex]) !== null && _objectData$barColor$2 !== void 0 ? _objectData$barColor$2 : '') || ((_objectData$color3 = objectData === null || objectData === void 0 ? void 0 : objectData.color) !== null && _objectData$color3 !== void 0 ? _objectData$color3 : '')
            },
            tooltip: _objectSpread2({}, (_seriesOption$subInde = (_seriesOption$subInde2 = seriesOption[subIndex]) === null || _seriesOption$subInde2 === void 0 ? void 0 : _seriesOption$subInde2.tooltip) !== null && _seriesOption$subInde !== void 0 ? _seriesOption$subInde : {})
          };
        }))) : Object.keys((_seriesData$chartData9 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData9 !== void 0 ? _seriesData$chartData9 : {}).map(function (key, subIndex) {
          var _seriesData$chartData10, _seriesData$chartData11, _seriesData$chartData12, _ref2, _objectData$color4, _objectData$barColor$3, _objectData$barColor3, _objectData$color5, _objectData$barColor$4, _objectData$barColor4, _objectData$color6, _seriesOption$subInde3, _seriesOption$subInde4;
          return {
            value: (_seriesData$chartData10 = seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData11 = seriesData.chartData) === null || _seriesData$chartData11 === void 0 ? void 0 : (_seriesData$chartData12 = _seriesData$chartData11[key]) === null || _seriesData$chartData12 === void 0 ? void 0 : _seriesData$chartData12["x".concat(index + 1)]) !== null && _seriesData$chartData10 !== void 0 ? _seriesData$chartData10 : '',
            itemStyle: {
              color: typeof ((_ref2 = (_objectData$color4 = objectData === null || objectData === void 0 ? void 0 : objectData.color) !== null && _objectData$color4 !== void 0 ? _objectData$color4 : '') !== null && _ref2 !== void 0 ? _ref2 : {}) !== 'string' ? _construct(LinearGradient$1, _toConsumableArray$1(((_objectData$barColor$3 = objectData === null || objectData === void 0 ? void 0 : (_objectData$barColor3 = objectData.barColor) === null || _objectData$barColor3 === void 0 ? void 0 : _objectData$barColor3[subIndex]) !== null && _objectData$barColor$3 !== void 0 ? _objectData$barColor$3 : '') || ((_objectData$color5 = objectData === null || objectData === void 0 ? void 0 : objectData.color) !== null && _objectData$color5 !== void 0 ? _objectData$color5 : ''))) : ((_objectData$barColor$4 = objectData === null || objectData === void 0 ? void 0 : (_objectData$barColor4 = objectData.barColor) === null || _objectData$barColor4 === void 0 ? void 0 : _objectData$barColor4[subIndex]) !== null && _objectData$barColor$4 !== void 0 ? _objectData$barColor$4 : '') || ((_objectData$color6 = objectData === null || objectData === void 0 ? void 0 : objectData.color) !== null && _objectData$color6 !== void 0 ? _objectData$color6 : '')
            },
            tooltip: _objectSpread2({}, (_seriesOption$subInde3 = (_seriesOption$subInde4 = seriesOption[subIndex]) === null || _seriesOption$subInde4 === void 0 ? void 0 : _seriesOption$subInde4.tooltip) !== null && _seriesOption$subInde3 !== void 0 ? _seriesOption$subInde3 : {})
          };
        })
      });
    });
  };
  return /*#__PURE__*/jsxRuntime.jsx(_default, {
    option: {
      title: {
        text: title
      },
      grid: _objectSpread2({
        containLabel: gridContainLabel
      }, gridOptions),
      xAxis: {
        inverse: inverse,
        show: xAxisShow,
        type: 'value'
      },
      legend: _objectSpread2({}, legend),
      tooltip: _objectSpread2({}, tooltip),
      yAxis: {
        data: Object.keys((_seriesData$chartData13 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData13 !== void 0 ? _seriesData$chartData13 : {}),
        type: 'category',
        axisLabel: {
          show: yAxisLabelShow
        },
        splitLine: {
          show: ySplitLineShow
        },
        axisLine: {
          show: yAxisLineShow
        },
        axisTick: {
          show: yAxisTickShow
        },
        inverse: true
      },
      series: generateSeries()
    },
    onEvents: onEvents,
    echarts: echarts,
    notMerge: true,
    lazyUpdate: true,
    className: classes(className, modules_8904c6a0.root),
    style: style
  });
};
BaseHorizontalBarChart.propTypes = {
  loading: propTypes$1.exports.bool,
  fallback: propTypes$1.exports.bool,
  title: propTypes$1.exports.string,
  gridContainLabel: propTypes$1.exports.bool,
  gridOptions: propTypes$1.exports.object,
  tooltip: propTypes$1.exports.object,
  xAxisShow: propTypes$1.exports.bool,
  inverse: propTypes$1.exports.bool,
  seriesData: propTypes$1.exports.shape({
    chartData: propTypes$1.exports.object,
    metaData: propTypes$1.exports.object
  }),
  onEvents: propTypes$1.exports.func,
  yAxisLabelShow: propTypes$1.exports.bool,
  ySplitLineShow: propTypes$1.exports.bool,
  yAxisLineShow: propTypes$1.exports.bool,
  yAxisTickShow: propTypes$1.exports.bool,
  barWidth: propTypes$1.exports.string,
  legend: propTypes$1.exports.object,
  seriesName: propTypes$1.exports.func,
  cursor: propTypes$1.exports.string,
  stacked: propTypes$1.exports.bool,
  seriesOption: propTypes$1.exports.objectOf(propTypes$1.exports.shape),
  style: propTypes$1.exports.object,
  className: propTypes$1.exports.string,
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
BaseHorizontalBarChart.defaultProps = {
  loading: false,
  fallback: false,
  title: '',
  gridContainLabel: false,
  gridOptions: {
    left: 0,
    right: 0,
    bottom: 0,
    top: 5
  },
  xAxisShow: false,
  inverse: false,
  tooltip: {
    trigger: 'item'
  },
  seriesData: {},
  onEvents: function onEvents() {},
  yAxisLabelShow: false,
  ySplitLineShow: false,
  yAxisLineShow: false,
  yAxisTickShow: false,
  barWidth: '50%',
  seriesName: function seriesName() {},
  legend: {
    show: false
  },
  cursor: 'default',
  stacked: true,
  seriesOption: [{
    stackIndex: 1
  }],
  style: {
    width: '100%',
    height: '100%'
  },
  className: '',
  theme: 'dark'
};

var css$c = ".BasePieChart_module_root__45f70e28 {\n  width: \"100%\";\n}";
var modules_c20882aa = {"root":"BasePieChart_module_root__45f70e28"};
n(css$c,{});

var css$b = ".Skeleton_module_root__ecbd3e3d {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n}\n.Skeleton_module_root__ecbd3e3d > .Skeleton_module_outer__ecbd3e3d,\n.Skeleton_module_root__ecbd3e3d > .Skeleton_module_inner__ecbd3e3d {\n  max-width: 100%;\n  max-height: 100%;\n}\n.Skeleton_module_root__ecbd3e3d > .Skeleton_module_inner__ecbd3e3d {\n  position: absolute;\n  opacity: 1;\n}\n.Skeleton_module_root__ecbd3e3d span.Skeleton_module_line__ecbd3e3d {\n  opacity: 1;\n  height: 0.5rem;\n  position: absolute;\n  transform-origin: left;\n}\n.Skeleton_module_root__ecbd3e3d span.Skeleton_module_line__ecbd3e3d:nth-last-of-type(1) {\n  transform: translateX(3.25rem) rotate(45deg);\n}\n.Skeleton_module_root__ecbd3e3d span.Skeleton_module_line__ecbd3e3d:nth-last-of-type(2) {\n  transform: translateX(3.25rem) rotate(-75deg);\n}\n.Skeleton_module_root__ecbd3e3d span.Skeleton_module_line__ecbd3e3d:nth-last-of-type(3) {\n  transform: translateX(3.25rem) rotate(-10deg);\n}\n.Skeleton_module_root__ecbd3e3d.Skeleton_module_lightTheme__ecbd3e3d > .Skeleton_module_inner__ecbd3e3d {\n  background: var(--white);\n}\n.Skeleton_module_root__ecbd3e3d.Skeleton_module_lightTheme__ecbd3e3d span.Skeleton_module_line__ecbd3e3d {\n  background: var(--white);\n}\n.Skeleton_module_root__ecbd3e3d.Skeleton_module_darkTheme__ecbd3e3d > .Skeleton_module_inner__ecbd3e3d {\n  background: var(--menu-black);\n}\n.Skeleton_module_root__ecbd3e3d.Skeleton_module_darkTheme__ecbd3e3d span.Skeleton_module_line__ecbd3e3d {\n  background: var(--menu-black);\n}";
var modules_37a5ff73$2 = {"root":"Skeleton_module_root__ecbd3e3d","outer":"Skeleton_module_outer__ecbd3e3d","inner":"Skeleton_module_inner__ecbd3e3d","line":"Skeleton_module_line__ecbd3e3d","light-theme":"Skeleton_module_lightTheme__ecbd3e3d","dark-theme":"Skeleton_module_darkTheme__ecbd3e3d"};
n(css$b,{});

var ChartSkeleton$2 = function ChartSkeleton(_ref) {
  var theme = _ref.theme,
    fallback = _ref.fallback;
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(modules_37a5ff73$2.root, modules_37a5ff73$2["".concat(theme, "-theme")]),
    children: [/*#__PURE__*/jsxRuntime.jsx(Skeleton, {
      theme: theme,
      className: modules_37a5ff73$2.outer,
      width: "12.5rem",
      height: "12.5rem",
      variant: "circle",
      noAnimation: fallback
    }), /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
      noAnimation: true,
      className: modules_37a5ff73$2.inner,
      width: "7.5rem",
      height: "7.5rem",
      variant: "circle"
    }), /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
      noAnimation: true,
      className: modules_37a5ff73$2.line,
      width: "6.25rem"
    }), /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
      noAnimation: true,
      className: modules_37a5ff73$2.line,
      width: "6.25rem"
    }), /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
      noAnimation: true,
      className: modules_37a5ff73$2.line,
      width: "6.25rem"
    })]
  });
};

use([install$8, install$9, install$a, install$1, install$g, install, install$5]);
var BasePieChart = function BasePieChart(props) {
  var _seriesData$chartData;
  var loading = props.loading,
    title = props.title,
    gridOptions = props.gridOptions,
    tooltip = props.tooltip,
    seriesData = props.seriesData,
    startAngle = props.startAngle,
    semiDoughnut = props.semiDoughnut,
    radius = props.radius,
    center = props.center,
    cursor = props.cursor,
    showLabelLine = props.showLabelLine,
    itemStyle = props.itemStyle,
    legend = props.legend,
    seriesOption = props.seriesOption,
    style = props.style,
    className = props.className,
    theme = props.theme,
    fallback = props.fallback;
  if (loading || fallback) {
    return /*#__PURE__*/jsxRuntime.jsx(ChartSkeleton$2, {
      theme: theme,
      fallback: !loading && fallback
    });
  }
  var seriesOptionObject = {
    type: 'pie',
    radius: radius,
    center: center,
    legendHoverLink: false,
    avoidLabelOverlap: false,
    cursor: cursor,
    labelLine: {
      show: showLabelLine
    },
    itemStyle: _objectSpread2({}, itemStyle),
    label: {
      show: false
    },
    data: Object.keys((_seriesData$chartData = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData !== void 0 ? _seriesData$chartData : {}).map(function (key) {
      var _seriesData$chartData2;
      var temp = [];
      temp.push({
        value: seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData2 = seriesData.chartData) === null || _seriesData$chartData2 === void 0 ? void 0 : _seriesData$chartData2[key]
      });
      return temp;
    })
  };
  var generateSeries = function generateSeries() {
    var _seriesData$chartData3, _seriesData$chartData7;
    var semiDoughnutValue = 0;
    return _objectSpread2(_objectSpread2(_objectSpread2({}, seriesOptionObject), seriesOption), {}, {
      startAngle: semiDoughnut ? 180 : startAngle,
      data: semiDoughnut ? [].concat(_toConsumableArray$1(Object.keys((_seriesData$chartData3 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData3 !== void 0 ? _seriesData$chartData3 : {}).map(function (key, subIndex) {
        var _seriesData$chartData4, _seriesData$chartData5, _seriesData$chartData6, _seriesData$metaData, _seriesOption$subInde, _seriesOption$subInde2, _seriesOption$subInde3, _seriesOption$subInde4, _seriesOption$subInde5;
        semiDoughnutValue += (_seriesData$chartData4 = seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData5 = seriesData.chartData) === null || _seriesData$chartData5 === void 0 ? void 0 : _seriesData$chartData5[key]) !== null && _seriesData$chartData4 !== void 0 ? _seriesData$chartData4 : 0;
        return {
          value: seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData6 = seriesData.chartData) === null || _seriesData$chartData6 === void 0 ? void 0 : _seriesData$chartData6[key],
          name: seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$metaData = seriesData.metaData) === null || _seriesData$metaData === void 0 ? void 0 : _seriesData$metaData.keyData[key],
          itemStyle: _objectSpread2({}, (_seriesOption$subInde = seriesOption === null || seriesOption === void 0 ? void 0 : (_seriesOption$subInde2 = seriesOption[subIndex]) === null || _seriesOption$subInde2 === void 0 ? void 0 : _seriesOption$subInde2.itemStyle) !== null && _seriesOption$subInde !== void 0 ? _seriesOption$subInde : {}),
          label: _objectSpread2({}, seriesOption === null || seriesOption === void 0 ? void 0 : (_seriesOption$subInde3 = seriesOption[subIndex]) === null || _seriesOption$subInde3 === void 0 ? void 0 : _seriesOption$subInde3.label),
          tooltip: _objectSpread2({}, seriesOption === null || seriesOption === void 0 ? void 0 : (_seriesOption$subInde4 = seriesOption[subIndex]) === null || _seriesOption$subInde4 === void 0 ? void 0 : _seriesOption$subInde4.tooltip),
          emphasis: _objectSpread2({}, seriesOption === null || seriesOption === void 0 ? void 0 : (_seriesOption$subInde5 = seriesOption[subIndex]) === null || _seriesOption$subInde5 === void 0 ? void 0 : _seriesOption$subInde5.emphasis)
        };
      })), [{
        value: semiDoughnutValue,
        name: '',
        itemStyle: {
          opacity: 0
        },
        tooltip: {
          show: false
        }
      }]) : Object.keys((_seriesData$chartData7 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData7 !== void 0 ? _seriesData$chartData7 : {}).map(function (key, subIndex) {
        var _seriesData$chartData8, _seriesData$metaData2, _seriesData$metaData3, _seriesOption$subInde6, _seriesOption$subInde7, _seriesOption$subInde8, _seriesOption$subInde9;
        return {
          value: seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData8 = seriesData.chartData) === null || _seriesData$chartData8 === void 0 ? void 0 : _seriesData$chartData8[key],
          name: seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$metaData2 = seriesData.metaData) === null || _seriesData$metaData2 === void 0 ? void 0 : (_seriesData$metaData3 = _seriesData$metaData2.keyData) === null || _seriesData$metaData3 === void 0 ? void 0 : _seriesData$metaData3[key],
          itemStyle: _objectSpread2({}, seriesOption === null || seriesOption === void 0 ? void 0 : (_seriesOption$subInde6 = seriesOption[subIndex]) === null || _seriesOption$subInde6 === void 0 ? void 0 : _seriesOption$subInde6.itemStyle),
          label: _objectSpread2({}, seriesOption === null || seriesOption === void 0 ? void 0 : (_seriesOption$subInde7 = seriesOption[subIndex]) === null || _seriesOption$subInde7 === void 0 ? void 0 : _seriesOption$subInde7.label),
          tooltip: _objectSpread2({}, seriesOption === null || seriesOption === void 0 ? void 0 : (_seriesOption$subInde8 = seriesOption[subIndex]) === null || _seriesOption$subInde8 === void 0 ? void 0 : _seriesOption$subInde8.tooltip),
          emphasis: _objectSpread2({}, seriesOption === null || seriesOption === void 0 ? void 0 : (_seriesOption$subInde9 = seriesOption[subIndex]) === null || _seriesOption$subInde9 === void 0 ? void 0 : _seriesOption$subInde9.emphasis)
        };
      })
    });
  };
  return /*#__PURE__*/jsxRuntime.jsx(_default, {
    option: _objectSpread2(_objectSpread2({
      title: {
        text: title
      }
    }, gridOptions), {}, {
      tooltip: _objectSpread2({}, tooltip),
      legend: _objectSpread2({}, legend),
      series: generateSeries()
    }),
    echarts: echarts,
    notMerge: true,
    lazyUpdate: true,
    className: classes(className, modules_c20882aa.root),
    style: style
  });
};
BasePieChart.propTypes = {
  loading: propTypes$1.exports.bool,
  fallback: propTypes$1.exports.bool,
  title: propTypes$1.exports.string,
  gridOptions: propTypes$1.exports.object,
  tooltip: propTypes$1.exports.object,
  seriesData: propTypes$1.exports.shape({
    chartData: propTypes$1.exports.object,
    metaData: propTypes$1.exports.object
  }),
  startAngle: propTypes$1.exports.number,
  semiDoughnut: propTypes$1.exports.bool,
  cursor: propTypes$1.exports.string,
  radius: propTypes$1.exports.arrayOf(propTypes$1.exports.string),
  center: propTypes$1.exports.arrayOf(propTypes$1.exports.string),
  showLabelLine: propTypes$1.exports.bool,
  itemStyle: propTypes$1.exports.object,
  legend: propTypes$1.exports.object,
  seriesOption: propTypes$1.exports.arrayOf(propTypes$1.exports.shape),
  style: propTypes$1.exports.objectOf(propTypes$1.exports.shape),
  className: propTypes$1.exports.string,
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
BasePieChart.defaultProps = {
  loading: false,
  fallback: false,
  title: '',
  gridOptions: {
    left: 0,
    right: 0,
    bottom: 20,
    top: 10
  },
  tooltip: {
    trigger: 'item'
  },
  seriesData: {},
  startAngle: 90,
  semiDoughnut: true,
  cursor: 'default',
  radius: ['30%', '60%'],
  center: ['50%', '50%'],
  showLabelLine: false,
  itemStyle: {
    borderWidth: 5,
    borderColor: 'white',
    borderType: 'solid'
  },
  legend: {
    top: '80%',
    left: '30%',
    orient: 'vertical'
  },
  seriesOption: [{
    stackIndex: 1
  }],
  style: {
    width: '100%',
    height: '100%'
  },
  className: '',
  theme: 'dark'
};

var css$a = ".BaseRegionChart_module_root__617af265 {\n  width: \"100%\";\n}";
var modules_459dfe63 = {"root":"BaseRegionChart_module_root__617af265"};
n(css$a,{});

use([install$8, install$9, install$a, install$1, install$d, install$2, install$e, install$5, install]);
var BaseRegionChart = function BaseRegionChart(props) {
  var geoJson = props.geoJson,
    specialAreas = props.specialAreas,
    regionData = props.regionData,
    tooltip = props.tooltip,
    visualMap = props.visualMap,
    seriesOption = props.seriesOption,
    onEvents = props.onEvents,
    style = props.style,
    className = props.className;
  registerMap$1('states', geoJson, specialAreas);
  return /*#__PURE__*/jsxRuntime.jsx(_default, {
    option: {
      tooltip: _objectSpread2({}, tooltip),
      visualMap: _objectSpread2({}, visualMap),
      series: [_objectSpread2(_objectSpread2({}, seriesOption), {}, {
        data: regionData
      })]
    },
    onEvents: onEvents,
    echarts: echarts,
    notMerge: true,
    lazyUpdate: true,
    className: classes(className, modules_459dfe63.root),
    style: style
  });
};
BaseRegionChart.propTypes = {
  geoJson: propTypes$1.exports.shape(),
  specialAreas: propTypes$1.exports.shape(),
  regionData: propTypes$1.exports.shape({
    chartData: propTypes$1.exports.object,
    metaData: propTypes$1.exports.object
  }),
  tooltip: propTypes$1.exports.shape(),
  visualMap: propTypes$1.exports.shape(),
  seriesOption: propTypes$1.exports.shape(),
  onEvents: propTypes$1.exports.func,
  style: propTypes$1.exports.objectOf(propTypes$1.exports.shape),
  className: propTypes$1.exports.string
};
BaseRegionChart.defaultProps = {
  geoJson: {},
  specialAreas: {},
  regionData: [],
  tooltip: {
    backgroundColor: 'rgba(255,255,255)',
    textStyle: {
      fontStyle: 'normal',
      fontWeight: 'normal',
      fontFamily: 'Fira Sans',
      color: 'rgb(109,110,113)',
      fontSize: 16
    },
    trigger: 'item',
    transitionDuration: 0.2,
    extraCssText: 'box-shadow: rgb(174,174,174) 0px 0px 5px;border-radius:3px;',
    formatter: '{b0}: {c}'
  },
  visualMap: {
    show: false,
    min: 1,
    max: 10,
    inRange: {
      color: ['#313695', '#74add1', '#abd9e9', '#e0f3f8', '#ffffbf', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026']
    }
  },
  seriesOption: {
    name: 'USa',
    type: 'map',
    roam: false,
    map: 'states',
    scaleLimit: {
      min: 1,
      max: 10
    },
    aspectScale: '1:1'
  },
  onEvents: function onEvents() {},
  style: {
    width: '100%',
    height: '100%'
  },
  className: ''
};

var css$9 = ".HeatMapChart_module_root__41cf6ace {\n  width: \"100%\";\n}";
var modules_0ba85659 = {"root":"HeatMapChart_module_root__41cf6ace"};
n(css$9,{});

var css$8 = ".Skeleton_module_root__79bb2358 {\n  display: grid;\n  grid-template-rows: auto;\n  grid-template-columns: repeat(6, 1fr);\n  row-gap: 0.25rem;\n  -moz-column-gap: 0.25rem;\n       column-gap: 0.25rem;\n  height: 100%;\n}";
var modules_37a5ff73$1 = {"root":"Skeleton_module_root__79bb2358"};
n(css$8,{});

var BOXES = _toConsumableArray$1(Array(36).keys()).map(function () {
  return Math.random() * 80 + 20;
});
var ChartSkeleton$1 = function ChartSkeleton(_ref) {
  var theme = _ref.theme,
    fallback = _ref.fallback;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: modules_37a5ff73$1.root,
    children: BOXES.map(function (box) {
      return /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
        theme: theme,
        className: modules_37a5ff73$1.box,
        height: "100%",
        noAnimation: fallback
      }, box);
    })
  });
};

use([install$8, install$9, install$a, install$1, install$5, install$c, install]);
var HeatMapChart = function HeatMapChart(props) {
  var _seriesData$metaData$, _seriesData$metaData, _seriesData$metaData$2;
  var loading = props.loading,
    title = props.title,
    gridContainLabel = props.gridContainLabel,
    gridOptions = props.gridOptions,
    xAxisLabel = props.xAxisLabel,
    seriesData = props.seriesData,
    onEvents = props.onEvents,
    xSplitLineShow = props.xSplitLineShow,
    xAxisLineShow = props.xAxisLineShow,
    xAxisTickShow = props.xAxisTickShow,
    yAxisLabelShow = props.yAxisLabelShow,
    ySplitLineShow = props.ySplitLineShow,
    yAxisLineShow = props.yAxisLineShow,
    yAxisTickShow = props.yAxisTickShow,
    axisColor = props.axisColor,
    tooltip = props.tooltip,
    seriesName = props.seriesName,
    seriesOption = props.seriesOption,
    visualMap = props.visualMap,
    defaultColor = props.defaultColor,
    style = props.style,
    className = props.className,
    theme = props.theme,
    fallback = props.fallback;
  if (loading || fallback) {
    return /*#__PURE__*/jsxRuntime.jsx(ChartSkeleton$1, {
      theme: theme,
      fallback: !loading && fallback
    });
  }
  var seriesOptionObject = {
    type: 'heatmap',
    label: {
      show: true
    },
    itemStyle: {
      borderWidth: 0,
      borderColor: theme === 'dark' ? '#757679' : COLORS.grey3
    },
    emphasis: {
      itemStyle: {
        shadowBlur: 10,
        shadowColor: 'rgba(0, 0, 0, 0.5)'
      }
    },
    name: (_seriesData$metaData$ = seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$metaData = seriesData.metaData) === null || _seriesData$metaData === void 0 ? void 0 : (_seriesData$metaData$2 = _seriesData$metaData.seriesDetails) === null || _seriesData$metaData$2 === void 0 ? void 0 : _seriesData$metaData$2.id) !== null && _seriesData$metaData$ !== void 0 ? _seriesData$metaData$ : '',
    data: []
  };
  var generateXAxis = function generateXAxis() {
    var row = Math.floor(Math.sqrt(seriesData.length));
    var xAxis = [];
    for (var i = 0; i < row; i++) {
      xAxis.push(i);
    }
    return xAxis;
  };
  var generateYAxis = function generateYAxis() {
    var col = Math.ceil(Math.sqrt(seriesData.length));
    var yAxis = [];
    for (var i = 0; i < col; i++) {
      yAxis.push(i);
    }
    return yAxis;
  };
  var generateSeries = function generateSeries() {
    var _seriesData$chartData, _seriesOptionObject$l, _seriesOption$label, _seriesOptionObject$i, _seriesOption$itemSty;
    var newSeriesData = Object.keys((_seriesData$chartData = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData !== void 0 ? _seriesData$chartData : {}).map(function (ob) {
      return {
        name: ob,
        value: seriesData.chartData[ob].x1
      };
    });
    var row = Math.floor(Math.sqrt(newSeriesData.length)) > 7 ? Math.floor(Math.sqrt(newSeriesData.length)) : 7;
    var col = Math.ceil(Math.sqrt(newSeriesData.length)) > 7 ? Math.ceil(Math.sqrt(newSeriesData.length)) : 7;
    var dataNew = [];
    for (var i = row, k = 0; i > 0; i--) {
      for (var j = 0; j < col; j++, k++) {
        var _newSeriesData$k$name, _newSeriesData$k, _newSeriesData$k$valu, _newSeriesData$k2, _newSeriesData$k$valu2, _newSeriesData$k3;
        dataNew.push(_objectSpread2({
          name: (_newSeriesData$k$name = newSeriesData === null || newSeriesData === void 0 ? void 0 : (_newSeriesData$k = newSeriesData[k]) === null || _newSeriesData$k === void 0 ? void 0 : _newSeriesData$k.name) !== null && _newSeriesData$k$name !== void 0 ? _newSeriesData$k$name : '',
          value: [j, i, (_newSeriesData$k$valu = newSeriesData === null || newSeriesData === void 0 ? void 0 : (_newSeriesData$k2 = newSeriesData[k]) === null || _newSeriesData$k2 === void 0 ? void 0 : _newSeriesData$k2.value) !== null && _newSeriesData$k$valu !== void 0 ? _newSeriesData$k$valu : -1]
        }, ((_newSeriesData$k$valu2 = newSeriesData === null || newSeriesData === void 0 ? void 0 : (_newSeriesData$k3 = newSeriesData[k]) === null || _newSeriesData$k3 === void 0 ? void 0 : _newSeriesData$k3.value) !== null && _newSeriesData$k$valu2 !== void 0 ? _newSeriesData$k$valu2 : -1) === -1 ? {
          itemStyle: {
            color: defaultColor !== '' ? defaultColor : theme === 'dark' ? COLORS['dark-grey'] : COLORS.grey5
          },
          emphasis: {
            disabled: true
          }
        } : {}));
      }
    }
    return [_objectSpread2(_objectSpread2(_objectSpread2({}, seriesOptionObject), seriesOption), {}, {
      label: _objectSpread2(_objectSpread2({}, (_seriesOptionObject$l = seriesOptionObject === null || seriesOptionObject === void 0 ? void 0 : seriesOptionObject.label) !== null && _seriesOptionObject$l !== void 0 ? _seriesOptionObject$l : {}), (_seriesOption$label = seriesOption === null || seriesOption === void 0 ? void 0 : seriesOption.label) !== null && _seriesOption$label !== void 0 ? _seriesOption$label : {}),
      itemStyle: _objectSpread2(_objectSpread2({}, (_seriesOptionObject$i = seriesOptionObject === null || seriesOptionObject === void 0 ? void 0 : seriesOptionObject.itemStyle) !== null && _seriesOptionObject$i !== void 0 ? _seriesOptionObject$i : {}), (_seriesOption$itemSty = seriesOption === null || seriesOption === void 0 ? void 0 : seriesOption.itemStyle) !== null && _seriesOption$itemSty !== void 0 ? _seriesOption$itemSty : {}),
      name: seriesName,
      data: dataNew
    })];
  };
  return /*#__PURE__*/jsxRuntime.jsx(_default, {
    option: {
      title: {
        text: title
      },
      grid: _objectSpread2({
        containLabel: gridContainLabel
      }, gridOptions),
      xAxis: {
        data: generateXAxis(),
        type: 'category',
        axisLabel: _objectSpread2({}, xAxisLabel),
        splitLine: {
          show: xSplitLineShow
        },
        axisLine: {
          show: xAxisLineShow
        },
        axisTick: {
          show: xAxisTickShow
        },
        splitArea: {
          show: true
        }
      },
      tooltip: _objectSpread2({}, tooltip),
      yAxis: {
        data: generateYAxis(),
        type: 'category',
        splitArea: {
          show: true
        },
        axisLabel: {
          show: yAxisLabelShow,
          color: axisColor
        },
        splitLine: {
          show: ySplitLineShow
        },
        axisLine: {
          show: yAxisLineShow
        },
        axisTick: {
          show: yAxisTickShow
        }
      },
      visualMap: _objectSpread2({}, visualMap),
      series: generateSeries()
    },
    onEvents: onEvents,
    echarts: echarts,
    notMerge: true,
    lazyUpdate: true,
    className: classes(className, modules_0ba85659.root),
    style: style
  });
};
HeatMapChart.propTypes = {
  loading: propTypes$1.exports.bool,
  fallback: propTypes$1.exports.bool,
  title: propTypes$1.exports.string,
  gridContainLabel: propTypes$1.exports.bool,
  gridOptions: propTypes$1.exports.object,
  xAxisLabel: propTypes$1.exports.object,
  tooltip: propTypes$1.exports.object,
  seriesData: propTypes$1.exports.object,
  onEvents: propTypes$1.exports.func,
  xSplitLineShow: propTypes$1.exports.bool,
  xAxisLineShow: propTypes$1.exports.bool,
  xAxisTickShow: propTypes$1.exports.bool,
  yAxisLabelShow: propTypes$1.exports.bool,
  ySplitLineShow: propTypes$1.exports.bool,
  yAxisLineShow: propTypes$1.exports.bool,
  yAxisTickShow: propTypes$1.exports.bool,
  axisColor: propTypes$1.exports.string,
  seriesName: propTypes$1.exports.string,
  visualMap: propTypes$1.exports.shape({}),
  seriesOption: propTypes$1.exports.shape({}),
  style: propTypes$1.exports.objectOf(propTypes$1.exports.shape),
  defaultColor: propTypes$1.exports.string,
  className: propTypes$1.exports.string,
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
HeatMapChart.defaultProps = {
  loading: false,
  fallback: false,
  title: '',
  gridContainLabel: false,
  gridOptions: {
    left: 0,
    right: 0,
    bottom: 0,
    top: 0
  },
  xAxisLabel: {},
  tooltip: {
    position: 'top'
  },
  seriesData: {},
  onEvents: function onEvents() {},
  yAxisLabelShow: false,
  xSplitLineShow: false,
  xAxisLineShow: false,
  xAxisTickShow: false,
  ySplitLineShow: false,
  yAxisLineShow: false,
  yAxisTickShow: false,
  axisColor: '',
  visualMap: {},
  seriesName: '',
  seriesOption: {
    label: {
      show: true
    }
  },
  defaultColor: '',
  style: {
    width: '100%',
    height: '100%'
  },
  className: '',
  theme: 'dark'
};

var css$7 = ".BaseAreaChart_module_root__aee251f3 {\n  width: \"100%\";\n}";
var modules_6d3781f0 = {"root":"BaseAreaChart_module_root__aee251f3"};
n(css$7,{});

var css$6 = ".Skeleton_module_root__13b12cf6 {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  overflow: hidden;\n  height: 100%;\n  width: 100%;\n  padding: 2rem;\n}\n.Skeleton_module_root__13b12cf6 .Skeleton_module_line__13b12cf6 {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n}\n.Skeleton_module_root__13b12cf6 .Skeleton_module_line__13b12cf6 .Skeleton_module_bump__13b12cf6 {\n  transform: rotate(30deg);\n}\n.Skeleton_module_root__13b12cf6 .Skeleton_module_line__13b12cf6 .Skeleton_module_bump__13b12cf6:not(:nth-child(1)) {\n  margin-left: -1.75rem;\n}\n.Skeleton_module_root__13b12cf6 .Skeleton_module_line__13b12cf6 .Skeleton_module_bump__13b12cf6:nth-child(2n) {\n  transform: rotate(-30deg);\n}\n.Skeleton_module_root__13b12cf6.Skeleton_module_filled__13b12cf6 {\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.Skeleton_module_root__13b12cf6.Skeleton_module_filled__13b12cf6 .Skeleton_module_bumps__13b12cf6 {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: flex-end;\n  flex: 1 1 50%;\n}\n.Skeleton_module_root__13b12cf6.Skeleton_module_filled__13b12cf6 .Skeleton_module_bumps__13b12cf6 .Skeleton_module_triangle__13b12cf6 {\n  height: 10rem;\n}\n.Skeleton_module_root__13b12cf6.Skeleton_module_filled__13b12cf6 .Skeleton_module_bumps__13b12cf6 .Skeleton_module_triangle__13b12cf6:nth-child(2n) {\n  transform: rotate3d(0, 1, 0, 180deg);\n}\n.Skeleton_module_root__13b12cf6.Skeleton_module_filled__13b12cf6.Skeleton_module_lightTheme__13b12cf6 .Skeleton_module_bumps__13b12cf6 .Skeleton_module_triangle__13b12cf6 {\n  background: linear-gradient(to bottom right, var(--white) 0%, var(--white) 50%, var(--grey6) 50%, var(--grey6) 100%);\n}\n.Skeleton_module_root__13b12cf6.Skeleton_module_filled__13b12cf6.Skeleton_module_darkTheme__13b12cf6 .Skeleton_module_bumps__13b12cf6 .Skeleton_module_triangle__13b12cf6 {\n  background: linear-gradient(to bottom right, var(--dark-grey) 0%, var(--dark-grey) 50%, var(--grey2) 50%, var(--grey2) 100%);\n}\n.Skeleton_module_root__13b12cf6.Skeleton_module_filled__13b12cf6 .Skeleton_module_base__13b12cf6 {\n  flex: 1 1 50%;\n}";
var modules_37a5ff73 = {"root":"Skeleton_module_root__13b12cf6","line":"Skeleton_module_line__13b12cf6","bump":"Skeleton_module_bump__13b12cf6","filled":"Skeleton_module_filled__13b12cf6","bumps":"Skeleton_module_bumps__13b12cf6","triangle":"Skeleton_module_triangle__13b12cf6","light-theme":"Skeleton_module_lightTheme__13b12cf6","dark-theme":"Skeleton_module_darkTheme__13b12cf6","base":"Skeleton_module_base__13b12cf6"};
n(css$6,{});

var BUMPS = _toConsumableArray$1(Array(10).keys()).map(function () {
  return Math.random() * 80 + 20;
});
var TRIANGLES = _toConsumableArray$1(Array(7).keys()).map(function () {
  return Math.random() * 80 + 20;
});
var ChartSkeleton = function ChartSkeleton(_ref) {
  var filled = _ref.filled,
    theme = _ref.theme,
    fallback = _ref.fallback;
  if (filled) {
    return /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: classes(modules_37a5ff73.root, modules_37a5ff73.filled, modules_37a5ff73["".concat(theme, "-theme")]),
      children: [/*#__PURE__*/jsxRuntime.jsx("div", {
        className: modules_37a5ff73.bumps,
        children: TRIANGLES.map(function (bump) {
          return /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
            theme: theme,
            className: modules_37a5ff73.triangle,
            noAnimation: true
          }, bump);
        })
      }), /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
        className: modules_37a5ff73.base,
        theme: theme
      })]
    });
  }
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: modules_37a5ff73.root,
    children: /*#__PURE__*/jsxRuntime.jsx("div", {
      className: modules_37a5ff73.line,
      children: BUMPS.map(function (bump) {
        return /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
          theme: theme,
          className: modules_37a5ff73.bump,
          height: "0.5rem",
          noAnimation: fallback
        }, bump);
      })
    })
  });
};

use([install$8, install$5, install$9, install$a, install$1, install$i, install]);
var BaseAreaChart = function BaseAreaChart(props) {
  var _seriesData$chartData, _seriesData$chartData6, _seriesData$metaData$, _seriesData$metaData;
  var loading = props.loading,
    title = props.title,
    gridOptions = props.gridOptions,
    gridContainLabel = props.gridContainLabel,
    seriesData = props.seriesData,
    tooltip = props.tooltip,
    legend = props.legend,
    xAxisLabelShow = props.xAxisLabelShow,
    xSplitLineShow = props.xSplitLineShow,
    xAxisLineShow = props.xAxisLineShow,
    xAxisTickShow = props.xAxisTickShow,
    xAxisLabel = props.xAxisLabel,
    yAxisLabelShow = props.yAxisLabelShow,
    ySplitLineShow = props.ySplitLineShow,
    yAxisLineShow = props.yAxisLineShow,
    yAxisTickShow = props.yAxisTickShow,
    yAxisLabel = props.yAxisLabel,
    axisLabelColor = props.axisLabelColor,
    axisSplitColor = props.axisSplitColor,
    splitType = props.splitType,
    seriesOption = props.seriesOption,
    lineStyleWidth = props.lineStyleWidth,
    lineStyleType = props.lineStyleType,
    lineStyleCap = props.lineStyleCap,
    lineStyleJoin = props.lineStyleJoin,
    stacked = props.stacked,
    cursor = props.cursor,
    smooth = props.smooth,
    opacity = props.opacity,
    style = props.style,
    className = props.className,
    theme = props.theme,
    fallback = props.fallback;
  if (loading || fallback) {
    // const filled = seriesOption.some((series) => {
    // return series?.areaStyle.opacity > 0;
    // });
    return /*#__PURE__*/jsxRuntime.jsx(ChartSkeleton
    //  filled={filled}
    , {
      theme: theme,
      fallback: !loading && fallback
    });
  }
  var seriesOptionObject = {
    type: 'line',
    symbol: 'emptyCircle',
    stack: stacked,
    symbolSize: 4,
    smooth: smooth,
    name: 'SeriesName',
    connectNulls: true,
    clip: true,
    cursor: cursor,
    groupPadding: 3,
    showBackground: true,
    backgroundStyle: {
      color: 'whitesmoke'
    },
    label: {
      color: 'black',
      offset: [0, 0],
      show: false,
      position: 'top',
      formatter: function formatter(param) {
        return param.value;
      }
    },
    lineStyle: {
      width: lineStyleWidth,
      type: lineStyleType,
      cap: lineStyleCap,
      join: lineStyleJoin
    },
    areaStyle: {
      origin: 'auto',
      shadowBlur: 0,
      shadowColor: 'white',
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      opacity: opacity
    },
    emphasis: {
      focus: 'series'
    },
    data: Object.keys((_seriesData$chartData = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData !== void 0 ? _seriesData$chartData : {}).map(function (key) {
      var _seriesData$chartData2, _seriesData$chartData3;
      return (_seriesData$chartData2 = seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData3 = seriesData.chartData) === null || _seriesData$chartData3 === void 0 ? void 0 : _seriesData$chartData3[key]) !== null && _seriesData$chartData2 !== void 0 ? _seriesData$chartData2 : '';
    })
  };
  var generateSeries = function generateSeries() {
    return Object.keys(seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData).map(function (objectData, index) {
      var _Object$keys$index, _Object$keys, _seriesData$chartData4, _seriesOption$index, _seriesOption$index$c, _seriesOption$index2, _seriesOption$index$c2, _seriesOption$index3, _seriesOption$index$c3, _seriesOption$index4, _seriesOptionObject$l, _seriesOption$index$l, _seriesOption$index5, _seriesOptionObject$l2, _seriesOption$index$l2, _seriesOption$index6, _seriesOption$index7, _seriesOption$index7$, _seriesOption$index$l3, _seriesOption$index8, _seriesOption$index8$, _seriesOption$index$l4, _seriesOption$index9, _seriesOption$index9$, _seriesOption$index$l5, _seriesOption$index10, _seriesOption$index11, _seriesOptionObject$a, _seriesOption$index$a, _seriesOption$index12, _seriesOption$index13, _seriesOption$index14, _seriesOption$index$a2, _seriesOption$index15, _seriesOption$index16, _seriesOption$index$a3, _seriesOption$index17, _seriesOption$index18, _seriesOption$index$a4, _seriesOption$index19, _seriesOption$index20, _seriesOptionObject$e, _seriesOption$index$e, _seriesOption$index21, _Object$values$index, _Object$values, _seriesData$chartData5;
      return _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, seriesOptionObject), seriesOption[index]), {}, {
        name: (_Object$keys$index = (_Object$keys = Object.keys((_seriesData$chartData4 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData4 !== void 0 ? _seriesData$chartData4 : {})) === null || _Object$keys === void 0 ? void 0 : _Object$keys[index]) !== null && _Object$keys$index !== void 0 ? _Object$keys$index : ''
      }, ((_seriesOption$index = seriesOption[index]) === null || _seriesOption$index === void 0 ? void 0 : _seriesOption$index.color) && {
        color: typeof ((_seriesOption$index$c = (_seriesOption$index2 = seriesOption[index]) === null || _seriesOption$index2 === void 0 ? void 0 : _seriesOption$index2.color) !== null && _seriesOption$index$c !== void 0 ? _seriesOption$index$c : {}) !== 'string' ? _construct(LinearGradient$1, _toConsumableArray$1((_seriesOption$index$c2 = (_seriesOption$index3 = seriesOption[index]) === null || _seriesOption$index3 === void 0 ? void 0 : _seriesOption$index3.color) !== null && _seriesOption$index$c2 !== void 0 ? _seriesOption$index$c2 : [])) : (_seriesOption$index$c3 = (_seriesOption$index4 = seriesOption[index]) === null || _seriesOption$index4 === void 0 ? void 0 : _seriesOption$index4.color) !== null && _seriesOption$index$c3 !== void 0 ? _seriesOption$index$c3 : {}
      }), {}, {
        label: _objectSpread2(_objectSpread2({}, (_seriesOptionObject$l = seriesOptionObject === null || seriesOptionObject === void 0 ? void 0 : seriesOptionObject.label) !== null && _seriesOptionObject$l !== void 0 ? _seriesOptionObject$l : {}), (_seriesOption$index$l = (_seriesOption$index5 = seriesOption[index]) === null || _seriesOption$index5 === void 0 ? void 0 : _seriesOption$index5.label) !== null && _seriesOption$index$l !== void 0 ? _seriesOption$index$l : {}),
        lineStyle: _objectSpread2(_objectSpread2(_objectSpread2({}, (_seriesOptionObject$l2 = seriesOptionObject === null || seriesOptionObject === void 0 ? void 0 : seriesOptionObject.lineStyle) !== null && _seriesOptionObject$l2 !== void 0 ? _seriesOptionObject$l2 : {}), (_seriesOption$index$l2 = (_seriesOption$index6 = seriesOption[index]) === null || _seriesOption$index6 === void 0 ? void 0 : _seriesOption$index6.lineStyle) !== null && _seriesOption$index$l2 !== void 0 ? _seriesOption$index$l2 : {}), ((_seriesOption$index7 = seriesOption[index]) === null || _seriesOption$index7 === void 0 ? void 0 : (_seriesOption$index7$ = _seriesOption$index7.lineStyle) === null || _seriesOption$index7$ === void 0 ? void 0 : _seriesOption$index7$.color) && {
          color: typeof ((_seriesOption$index$l3 = (_seriesOption$index8 = seriesOption[index]) === null || _seriesOption$index8 === void 0 ? void 0 : (_seriesOption$index8$ = _seriesOption$index8.lineStyle) === null || _seriesOption$index8$ === void 0 ? void 0 : _seriesOption$index8$.color) !== null && _seriesOption$index$l3 !== void 0 ? _seriesOption$index$l3 : {}) !== 'string' ? _construct(LinearGradient$1, _toConsumableArray$1((_seriesOption$index$l4 = (_seriesOption$index9 = seriesOption[index]) === null || _seriesOption$index9 === void 0 ? void 0 : (_seriesOption$index9$ = _seriesOption$index9.lineStyle) === null || _seriesOption$index9$ === void 0 ? void 0 : _seriesOption$index9$.color) !== null && _seriesOption$index$l4 !== void 0 ? _seriesOption$index$l4 : {})) : (_seriesOption$index$l5 = (_seriesOption$index10 = seriesOption[index]) === null || _seriesOption$index10 === void 0 ? void 0 : (_seriesOption$index11 = _seriesOption$index10.lineStyle) === null || _seriesOption$index11 === void 0 ? void 0 : _seriesOption$index11.color) !== null && _seriesOption$index$l5 !== void 0 ? _seriesOption$index$l5 : {}
        }),
        areaStyle: _objectSpread2(_objectSpread2(_objectSpread2({}, (_seriesOptionObject$a = seriesOptionObject === null || seriesOptionObject === void 0 ? void 0 : seriesOptionObject.areaStyle) !== null && _seriesOptionObject$a !== void 0 ? _seriesOptionObject$a : {}), (_seriesOption$index$a = (_seriesOption$index12 = seriesOption[index]) === null || _seriesOption$index12 === void 0 ? void 0 : _seriesOption$index12.areaStyle) !== null && _seriesOption$index$a !== void 0 ? _seriesOption$index$a : {}), ((_seriesOption$index13 = seriesOption[index]) === null || _seriesOption$index13 === void 0 ? void 0 : (_seriesOption$index14 = _seriesOption$index13.areaStyle) === null || _seriesOption$index14 === void 0 ? void 0 : _seriesOption$index14.color) && {
          color: typeof ((_seriesOption$index$a2 = (_seriesOption$index15 = seriesOption[index]) === null || _seriesOption$index15 === void 0 ? void 0 : (_seriesOption$index16 = _seriesOption$index15.areaStyle) === null || _seriesOption$index16 === void 0 ? void 0 : _seriesOption$index16.color) !== null && _seriesOption$index$a2 !== void 0 ? _seriesOption$index$a2 : {}) !== 'string' ? new LinearGradient$1((_seriesOption$index$a3 = (_seriesOption$index17 = seriesOption[index]) === null || _seriesOption$index17 === void 0 ? void 0 : (_seriesOption$index18 = _seriesOption$index17.areaStyle) === null || _seriesOption$index18 === void 0 ? void 0 : _seriesOption$index18.color) !== null && _seriesOption$index$a3 !== void 0 ? _seriesOption$index$a3 : {}) : (_seriesOption$index$a4 = (_seriesOption$index19 = seriesOption[index]) === null || _seriesOption$index19 === void 0 ? void 0 : (_seriesOption$index20 = _seriesOption$index19.areaStyle) === null || _seriesOption$index20 === void 0 ? void 0 : _seriesOption$index20.color) !== null && _seriesOption$index$a4 !== void 0 ? _seriesOption$index$a4 : {}
        }),
        emphasis: _objectSpread2(_objectSpread2({}, (_seriesOptionObject$e = seriesOptionObject === null || seriesOptionObject === void 0 ? void 0 : seriesOptionObject.emphasis) !== null && _seriesOptionObject$e !== void 0 ? _seriesOptionObject$e : {}), (_seriesOption$index$e = (_seriesOption$index21 = seriesOption[index]) === null || _seriesOption$index21 === void 0 ? void 0 : _seriesOption$index21.emphasis) !== null && _seriesOption$index$e !== void 0 ? _seriesOption$index$e : {}),
        data: (_Object$values$index = (_Object$values = Object.values((_seriesData$chartData5 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData5 !== void 0 ? _seriesData$chartData5 : {})) === null || _Object$values === void 0 ? void 0 : _Object$values[index]) !== null && _Object$values$index !== void 0 ? _Object$values$index : ''
      });
    });
  };
  return /*#__PURE__*/jsxRuntime.jsx(_default, {
    option: {
      title: {
        text: title
      },
      grid: _objectSpread2({
        containLabel: gridContainLabel
      }, gridOptions),
      tooltip: _objectSpread2({}, tooltip),
      legend: _objectSpread2(_objectSpread2({}, legend), {}, {
        data: Object.keys((_seriesData$chartData6 = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData6 !== void 0 ? _seriesData$chartData6 : [])
      }),
      xAxis: [{
        type: 'category',
        axisLabel: _objectSpread2({
          show: xAxisLabelShow,
          color: axisLabelColor !== '' ? axisLabelColor : theme === 'dark' ? '#a2a4a5' : COLORS.grey
        }, xAxisLabel),
        splitLine: {
          show: xSplitLineShow,
          lineStyle: {
            color: axisSplitColor !== '' ? axisSplitColor : theme === 'dark' ? COLORS['dark-grey'] : COLORS.grey5,
            type: splitType
          }
        },
        axisLine: {
          show: xAxisLineShow,
          lineStyle: {
            color: theme === 'dark' ? '#757679' : COLORS.grey3
          }
        },
        axisTick: {
          show: xAxisTickShow,
          lineStyle: {
            color: theme === 'dark' ? '#a2a4a5' : COLORS.grey
          }
        },
        boundaryGap: false,
        data: (_seriesData$metaData$ = seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$metaData = seriesData.metaData) === null || _seriesData$metaData === void 0 ? void 0 : _seriesData$metaData.xAxisData) !== null && _seriesData$metaData$ !== void 0 ? _seriesData$metaData$ : []
      }],
      yAxis: [{
        type: 'value',
        axisLabel: _objectSpread2({
          show: yAxisLabelShow,
          color: axisLabelColor !== '' ? axisLabelColor : theme === 'dark' ? '#a2a4a5' : COLORS.grey
        }, yAxisLabel),
        splitLine: {
          show: ySplitLineShow,
          lineStyle: {
            color: axisSplitColor !== '' ? axisSplitColor : theme === 'dark' ? COLORS['dark-grey'] : COLORS.grey5,
            type: splitType
          }
        },
        axisLine: {
          show: yAxisLineShow,
          lineStyle: {
            color: theme === 'dark' ? '#757679' : COLORS.grey3
          }
        },
        axisTick: {
          show: yAxisTickShow,
          lineStyle: {
            color: theme === 'dark' ? '#a2a4a5' : COLORS.grey
          }
        }
      }],
      series: generateSeries()
    },
    echarts: echarts,
    notMerge: true,
    lazyUpdate: true,
    className: classes(className, modules_6d3781f0.root),
    style: style
  });
};
BaseAreaChart.propTypes = {
  loading: propTypes$1.exports.bool,
  fallback: propTypes$1.exports.bool,
  title: propTypes$1.exports.string,
  gridOptions: propTypes$1.exports.object,
  gridContainLabel: propTypes$1.exports.bool,
  tooltip: propTypes$1.exports.object,
  legend: propTypes$1.exports.object,
  xAxisLabelShow: propTypes$1.exports.bool,
  xSplitLineShow: propTypes$1.exports.bool,
  xAxisLineShow: propTypes$1.exports.bool,
  xAxisTickShow: propTypes$1.exports.bool,
  xAxisLabel: propTypes$1.exports.object,
  axisLabelColor: propTypes$1.exports.string,
  axisSplitColor: propTypes$1.exports.string,
  splitType: propTypes$1.exports.string,
  seriesData: propTypes$1.exports.objectOf(propTypes$1.exports.shape),
  stacked: propTypes$1.exports.bool,
  yAxisLabelShow: propTypes$1.exports.bool,
  ySplitLineShow: propTypes$1.exports.bool,
  yAxisLineShow: propTypes$1.exports.bool,
  yAxisTickShow: propTypes$1.exports.bool,
  yAxisLabel: propTypes$1.exports.object,
  cursor: propTypes$1.exports.string,
  seriesOption: propTypes$1.exports.arrayOf(propTypes$1.exports.object),
  lineStyleWidth: propTypes$1.exports.number,
  lineStyleType: propTypes$1.exports.oneOf(['dashed', 'solid', 'dotted']),
  lineStyleCap: propTypes$1.exports.oneOf(['butt', 'round', 'square']),
  lineStyleJoin: propTypes$1.exports.oneOf(['round', 'bevel', 'miter']),
  smooth: propTypes$1.exports.bool,
  opacity: propTypes$1.exports.number,
  style: propTypes$1.exports.objectOf(propTypes$1.exports.shape),
  className: propTypes$1.exports.string,
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
BaseAreaChart.defaultProps = {
  loading: false,
  fallback: false,
  title: '',
  gridOptions: {
    left: 0,
    right: 0,
    bottom: 0,
    top: 0
  },
  gridContainLabel: false,
  tooltip: {},
  stacked: false,
  legend: {},
  xAxisLabelShow: false,
  xSplitLineShow: false,
  xAxisLineShow: false,
  xAxisTickShow: false,
  xAxisLabel: {},
  axisLabelColor: '',
  axisSplitColor: '',
  splitType: 'solid',
  seriesData: {},
  yAxisLabelShow: false,
  ySplitLineShow: false,
  yAxisLineShow: false,
  yAxisTickShow: false,
  yAxisLabel: {},
  cursor: 'default',
  seriesOption: [],
  lineStyleWidth: 4,
  lineStyleType: 'solid',
  lineStyleCap: 'butt',
  lineStyleJoin: 'round',
  smooth: false,
  opacity: 1,
  style: {
    width: '100%',
    height: '100%'
  },
  className: '',
  theme: 'dark'
};

var css$5 = ".NestedPieChart_module_root__c8f30b3e {\n  width: 100%;\n}";
var modules_23ba650c = {"root":"NestedPieChart_module_root__c8f30b3e"};
n(css$5,{});

use([install$8, install$9, install$a, install$1, install$g, install, install$5]);
var NestedPieChart = function NestedPieChart(props) {
  var _seriesData$chartData;
  var loading = props.loading,
    title = props.title,
    gridOptions = props.gridOptions,
    tooltip = props.tooltip,
    seriesData = props.seriesData,
    radius = props.radius,
    center = props.center,
    cursor = props.cursor,
    showLabelLine = props.showLabelLine,
    itemStyle = props.itemStyle,
    legend = props.legend,
    pieSeries = props.pieSeries,
    style = props.style,
    className = props.className,
    theme = props.theme,
    fallback = props.fallback;
  if (loading || fallback) {
    return /*#__PURE__*/jsxRuntime.jsx(ChartSkeleton$2, {
      theme: theme,
      fallback: !loading && fallback
    });
  }
  var seriesOptionObject = {
    type: 'pie',
    radius: radius,
    center: center,
    legendHoverLink: false,
    avoidLabelOverlap: false,
    cursor: cursor,
    labelLine: {
      show: showLabelLine
    },
    itemStyle: _objectSpread2({
      borderColor: theme === 'dark' ? COLORS['menu-black'] : COLORS.white
    }, itemStyle),
    label: {
      show: false
    },
    data: Object.keys((_seriesData$chartData = seriesData === null || seriesData === void 0 ? void 0 : seriesData.chartData) !== null && _seriesData$chartData !== void 0 ? _seriesData$chartData : {}).map(function (key) {
      var _seriesData$chartData2;
      var temp = [];
      temp.push({
        value: seriesData === null || seriesData === void 0 ? void 0 : (_seriesData$chartData2 = seriesData.chartData) === null || _seriesData$chartData2 === void 0 ? void 0 : _seriesData$chartData2[key]
      });
      return temp;
    })
  };
  var generateSeries = function generateSeries() {
    return pieSeries.map(function (objectData) {
      var _objectData$complete, _objectData$seriesDat, _objectData$seriesDat2, _objectData$seriesDat14, _objectData$seriesDat15;
      var completionValue = objectData === null || objectData === void 0 ? void 0 : objectData.complete;
      var semiDoughnutValue = 0;
      return _objectSpread2(_objectSpread2(_objectSpread2({}, seriesOptionObject), objectData), {}, {
        startAngle: objectData !== null && objectData !== void 0 && objectData.semiDoughnut ? 180 : objectData === null || objectData === void 0 ? void 0 : objectData.startAngle,
        data: ((_objectData$complete = objectData === null || objectData === void 0 ? void 0 : objectData.complete) !== null && _objectData$complete !== void 0 ? _objectData$complete : 0) ? [].concat(_toConsumableArray$1(Object.keys((_objectData$seriesDat = objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesDat2 = objectData.seriesData) === null || _objectData$seriesDat2 === void 0 ? void 0 : _objectData$seriesDat2.chartData) !== null && _objectData$seriesDat !== void 0 ? _objectData$seriesDat : {}).map(function (key, subIndex) {
          var _objectData$seriesDat3, _objectData$seriesDat4, _objectData$seriesDat5, _objectData$seriesDat6, _objectData$seriesDat7, _objectData$seriesDat8, _objectData$seriesDat9, _objectData$seriesDat10, _objectData$seriesDat11, _objectData$seriesDat12, _objectData$seriesDat13, _objectData$seriesOpt, _objectData$seriesOpt2, _objectData$seriesOpt3, _objectData$seriesOpt4, _objectData$seriesOpt5, _objectData$seriesOpt6, _objectData$seriesOpt7, _objectData$seriesOpt8;
          completionValue -= (_objectData$seriesDat3 = objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesDat4 = objectData.seriesData) === null || _objectData$seriesDat4 === void 0 ? void 0 : (_objectData$seriesDat5 = _objectData$seriesDat4.chartData) === null || _objectData$seriesDat5 === void 0 ? void 0 : _objectData$seriesDat5[key]) !== null && _objectData$seriesDat3 !== void 0 ? _objectData$seriesDat3 : 0;
          semiDoughnutValue += (_objectData$seriesDat6 = objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesDat7 = objectData.seriesData) === null || _objectData$seriesDat7 === void 0 ? void 0 : (_objectData$seriesDat8 = _objectData$seriesDat7.chartData) === null || _objectData$seriesDat8 === void 0 ? void 0 : _objectData$seriesDat8[key]) !== null && _objectData$seriesDat6 !== void 0 ? _objectData$seriesDat6 : 0;
          return {
            value: objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesDat9 = objectData.seriesData) === null || _objectData$seriesDat9 === void 0 ? void 0 : (_objectData$seriesDat10 = _objectData$seriesDat9.chartData) === null || _objectData$seriesDat10 === void 0 ? void 0 : _objectData$seriesDat10[key],
            name: objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesDat11 = objectData.seriesData) === null || _objectData$seriesDat11 === void 0 ? void 0 : (_objectData$seriesDat12 = _objectData$seriesDat11.metaData) === null || _objectData$seriesDat12 === void 0 ? void 0 : (_objectData$seriesDat13 = _objectData$seriesDat12.keyData) === null || _objectData$seriesDat13 === void 0 ? void 0 : _objectData$seriesDat13[key],
            itemStyle: _objectSpread2({}, objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesOpt = objectData.seriesOption) === null || _objectData$seriesOpt === void 0 ? void 0 : (_objectData$seriesOpt2 = _objectData$seriesOpt[subIndex]) === null || _objectData$seriesOpt2 === void 0 ? void 0 : _objectData$seriesOpt2.itemStyle),
            label: _objectSpread2({}, objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesOpt3 = objectData.seriesOption) === null || _objectData$seriesOpt3 === void 0 ? void 0 : (_objectData$seriesOpt4 = _objectData$seriesOpt3[subIndex]) === null || _objectData$seriesOpt4 === void 0 ? void 0 : _objectData$seriesOpt4.label),
            tooltip: _objectSpread2({}, objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesOpt5 = objectData.seriesOption) === null || _objectData$seriesOpt5 === void 0 ? void 0 : (_objectData$seriesOpt6 = _objectData$seriesOpt5[subIndex]) === null || _objectData$seriesOpt6 === void 0 ? void 0 : _objectData$seriesOpt6.tooltip),
            emphasis: _objectSpread2({}, objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesOpt7 = objectData.seriesOption) === null || _objectData$seriesOpt7 === void 0 ? void 0 : (_objectData$seriesOpt8 = _objectData$seriesOpt7[subIndex]) === null || _objectData$seriesOpt8 === void 0 ? void 0 : _objectData$seriesOpt8.emphasis)
          };
        })), [{
          value: completionValue,
          name: '',
          itemStyle: {
            opacity: 0
          },
          tooltip: {
            show: false
          }
        }, objectData !== null && objectData !== void 0 && objectData.semiDoughnut ? {
          value: semiDoughnutValue,
          name: '',
          itemStyle: {
            opacity: 0
          },
          tooltip: {
            show: false
          }
        } : {}]) : [].concat(_toConsumableArray$1(Object.keys((_objectData$seriesDat14 = objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesDat15 = objectData.seriesData) === null || _objectData$seriesDat15 === void 0 ? void 0 : _objectData$seriesDat15.chartData) !== null && _objectData$seriesDat14 !== void 0 ? _objectData$seriesDat14 : {}).map(function (key, subIndex) {
          var _objectData$seriesDat16, _objectData$seriesDat17, _objectData$seriesDat18, _objectData$seriesDat19, _objectData$seriesDat20, _objectData$seriesDat21, _objectData$seriesDat22, _objectData$seriesDat23, _objectData$seriesOpt9, _objectData$seriesOpt10, _objectData$seriesOpt11, _objectData$seriesOpt12, _objectData$seriesOpt13, _objectData$seriesOpt14, _objectData$seriesOpt15, _objectData$seriesOpt16;
          semiDoughnutValue += (_objectData$seriesDat16 = objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesDat17 = objectData.seriesData) === null || _objectData$seriesDat17 === void 0 ? void 0 : (_objectData$seriesDat18 = _objectData$seriesDat17.chartData) === null || _objectData$seriesDat18 === void 0 ? void 0 : _objectData$seriesDat18[key]) !== null && _objectData$seriesDat16 !== void 0 ? _objectData$seriesDat16 : 0;
          return {
            value: objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesDat19 = objectData.seriesData) === null || _objectData$seriesDat19 === void 0 ? void 0 : (_objectData$seriesDat20 = _objectData$seriesDat19.chartData) === null || _objectData$seriesDat20 === void 0 ? void 0 : _objectData$seriesDat20[key],
            name: objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesDat21 = objectData.seriesData) === null || _objectData$seriesDat21 === void 0 ? void 0 : (_objectData$seriesDat22 = _objectData$seriesDat21.metaData) === null || _objectData$seriesDat22 === void 0 ? void 0 : (_objectData$seriesDat23 = _objectData$seriesDat22.keyData) === null || _objectData$seriesDat23 === void 0 ? void 0 : _objectData$seriesDat23[key],
            itemStyle: _objectSpread2({}, objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesOpt9 = objectData.seriesOption) === null || _objectData$seriesOpt9 === void 0 ? void 0 : (_objectData$seriesOpt10 = _objectData$seriesOpt9[subIndex]) === null || _objectData$seriesOpt10 === void 0 ? void 0 : _objectData$seriesOpt10.itemStyle),
            label: _objectSpread2({}, objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesOpt11 = objectData.seriesOption) === null || _objectData$seriesOpt11 === void 0 ? void 0 : (_objectData$seriesOpt12 = _objectData$seriesOpt11[subIndex]) === null || _objectData$seriesOpt12 === void 0 ? void 0 : _objectData$seriesOpt12.label),
            tooltip: _objectSpread2({}, objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesOpt13 = objectData.seriesOption) === null || _objectData$seriesOpt13 === void 0 ? void 0 : (_objectData$seriesOpt14 = _objectData$seriesOpt13[subIndex]) === null || _objectData$seriesOpt14 === void 0 ? void 0 : _objectData$seriesOpt14.tooltip),
            emphasis: _objectSpread2({}, objectData === null || objectData === void 0 ? void 0 : (_objectData$seriesOpt15 = objectData.seriesOption) === null || _objectData$seriesOpt15 === void 0 ? void 0 : (_objectData$seriesOpt16 = _objectData$seriesOpt15[subIndex]) === null || _objectData$seriesOpt16 === void 0 ? void 0 : _objectData$seriesOpt16.emphasis)
          };
        })), [objectData !== null && objectData !== void 0 && objectData.semiDoughnut ? {
          value: semiDoughnutValue,
          name: '',
          itemStyle: {
            opacity: 0
          },
          tooltip: {
            show: false
          }
        } : {}])
      });
    });
  };
  return /*#__PURE__*/jsxRuntime.jsx(_default, {
    option: _objectSpread2(_objectSpread2({
      title: {
        text: title
      }
    }, gridOptions), {}, {
      tooltip: _objectSpread2({}, tooltip),
      legend: _objectSpread2({}, legend),
      series: generateSeries()
    }),
    echarts: echarts,
    notMerge: true,
    lazyUpdate: true,
    className: classes(className, modules_23ba650c.root),
    style: style
  });
};
NestedPieChart.propTypes = {
  loading: propTypes$1.exports.bool,
  fallback: propTypes$1.exports.bool,
  title: propTypes$1.exports.string,
  gridOptions: propTypes$1.exports.object,
  tooltip: propTypes$1.exports.object,
  seriesData: propTypes$1.exports.shape({
    chartData: propTypes$1.exports.object,
    metaData: propTypes$1.exports.object
  }),
  cursor: propTypes$1.exports.string,
  radius: propTypes$1.exports.arrayOf(propTypes$1.exports.string),
  center: propTypes$1.exports.arrayOf(propTypes$1.exports.string),
  showLabelLine: propTypes$1.exports.bool,
  itemStyle: propTypes$1.exports.object,
  legend: propTypes$1.exports.object,
  pieSeries: propTypes$1.exports.arrayOf(propTypes$1.exports.shape),
  style: propTypes$1.exports.objectOf(propTypes$1.exports.shape),
  className: propTypes$1.exports.string,
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
NestedPieChart.defaultProps = {
  loading: false,
  fallback: false,
  title: '',
  gridOptions: {
    left: 0,
    right: 0,
    bottom: 20,
    top: 10
  },
  tooltip: {
    trigger: 'item'
  },
  seriesData: {},
  cursor: 'default',
  radius: ['30%', '60%'],
  center: ['50%', '50%'],
  showLabelLine: false,
  itemStyle: {
    borderWidth: 0
  },
  legend: {
    top: '80%',
    left: '30%',
    orient: 'vertical'
  },
  pieSeries: [{
    seriesOption: {
      stackIndex: 1
    }
  }],
  style: {
    width: '100%',
    height: '100%'
  },
  className: '',
  theme: 'dark'
};

var css$4 = ".BaseWidget_module_root__5287a5f8 {\n  border: 1px solid var(--grey);\n  border-radius: 0.25rem;\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-start;\n  align-items: stretch;\n  height: 100%;\n  width: 100%;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  padding: 1rem;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerTitle__5287a5f8 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  gap: 0.5rem;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerTitle__5287a5f8 .BaseWidget_module_back__5287a5f8 {\n  height: 1.5rem;\n  width: 1.5rem;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerTitle__5287a5f8 .BaseWidget_module_back__5287a5f8 [data-elem=component1] .BaseWidget_module_icon__5287a5f8 {\n  width: 1.5rem;\n  height: 1.5rem;\n  fill: var(--white);\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerTitle__5287a5f8.BaseWidget_module_noOptions__5287a5f8 {\n  flex: 1;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerTitle__5287a5f8 .BaseWidget_module_title__5287a5f8 {\n  white-space: nowrap;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerTitle__5287a5f8 .BaseWidget_module_value__5287a5f8 {\n  white-space: nowrap;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-end;\n  align-items: center;\n  gap: 0.5rem;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_toggleBody__5287a5f8 {\n  padding: 0.125rem 0.25rem;\n  height: 1.75rem;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_dropdownHeader__5287a5f8 {\n  height: 1.75rem;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_dropdownHeader__5287a5f8 [data-elem=select] {\n  background-color: transparent;\n  width: 100%;\n  padding: 0.07rem 0.5rem;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_dropdownHeader__5287a5f8 [data-elem=select] [data-elem=placeholder] {\n  font-size: 0.875rem;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_dropdownHeader__5287a5f8 [data-elem=select] > svg {\n  width: 0.875rem;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_expandButton__5287a5f8 {\n  height: 1.75rem;\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_expandButton__5287a5f8 .BaseWidget_module_expandIcon__5287a5f8 {\n  height: 1.25rem;\n  width: 1.25rem;\n}\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_darkTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerTitle__5287a5f8 [data-elem=title],\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_darkTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerTitle__5287a5f8 [data-elem=subtitle] {\n  color: var(--white);\n}\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_darkTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_dropdownHeader__5287a5f8 [data-elem=select] {\n  border-color: var(--grey);\n}\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_darkTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_dropdownHeader__5287a5f8 [data-elem=select] [data-elem=placeholder] {\n  color: var(--white);\n}\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_darkTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_dropdownHeader__5287a5f8 [data-elem=select] > svg {\n  fill: var(--white);\n}\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_darkTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_expandButton__5287a5f8 {\n  color: var(--white);\n  border-color: var(--grey);\n}\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_darkTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_expandButton__5287a5f8 .BaseWidget_module_expandIcon__5287a5f8 {\n  fill: var(--white);\n}\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_lightTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerTitle__5287a5f8 [data-elem=title],\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_lightTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerTitle__5287a5f8 [data-elem=subtitle] {\n  color: var(--dark-grey);\n}\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_lightTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_dropdownHeader__5287a5f8 [data-elem=select] {\n  border-color: var(--grey6);\n}\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_lightTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_dropdownHeader__5287a5f8 [data-elem=select] [data-elem=placeholder] {\n  color: var(--dark-grey);\n}\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_lightTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_dropdownHeader__5287a5f8 [data-elem=select] > svg {\n  fill: var(--dark-grey);\n}\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_lightTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_expandButton__5287a5f8 {\n  color: var(--dark-grey);\n  border-color: var(--grey6);\n}\n.BaseWidget_module_root__5287a5f8.BaseWidget_module_lightTheme__5287a5f8 .BaseWidget_module_header__5287a5f8 .BaseWidget_module_headerOptions__5287a5f8 .BaseWidget_module_expandButton__5287a5f8 .BaseWidget_module_expandIcon__5287a5f8 {\n  fill: var(--dark-grey);\n}\n.BaseWidget_module_root__5287a5f8 .BaseWidget_module_children__5287a5f8 {\n  flex: 1 1;\n  position: relative;\n  padding: 0.5rem;\n}\n\n.BaseWidget_module_dropdownPopper__5287a5f8 {\n  padding: 0rem;\n  background: var(--grey1);\n}\n.BaseWidget_module_dropdownPopper__5287a5f8 .BaseWidget_module_dropdownItem__5287a5f8 {\n  height: 2.25rem;\n  color: var(--white);\n  background: var(--grey);\n}\n.BaseWidget_module_dropdownPopper__5287a5f8 .BaseWidget_module_dropdownItem__5287a5f8:hover, .BaseWidget_module_dropdownPopper__5287a5f8 .BaseWidget_module_dropdownItem__5287a5f8:focus {\n  color: var(--dark-grey);\n  background: var(--grey2);\n}\n.BaseWidget_module_dropdownPopper__5287a5f8 .BaseWidget_module_dropdownItem__5287a5f8:hover label > svg, .BaseWidget_module_dropdownPopper__5287a5f8 .BaseWidget_module_dropdownItem__5287a5f8:focus label > svg {\n  border: 1px solid var(--dark-grey);\n  border-radius: 0.25rem;\n}";
var modules_6a0e74b6 = {"root":"BaseWidget_module_root__5287a5f8","header":"BaseWidget_module_header__5287a5f8","header-title":"BaseWidget_module_headerTitle__5287a5f8","back":"BaseWidget_module_back__5287a5f8","icon":"BaseWidget_module_icon__5287a5f8","no-options":"BaseWidget_module_noOptions__5287a5f8","title":"BaseWidget_module_title__5287a5f8","value":"BaseWidget_module_value__5287a5f8","header-options":"BaseWidget_module_headerOptions__5287a5f8","toggle-body":"BaseWidget_module_toggleBody__5287a5f8","dropdown-header":"BaseWidget_module_dropdownHeader__5287a5f8","expand-button":"BaseWidget_module_expandButton__5287a5f8","expand-icon":"BaseWidget_module_expandIcon__5287a5f8","dark-theme":"BaseWidget_module_darkTheme__5287a5f8","light-theme":"BaseWidget_module_lightTheme__5287a5f8","children":"BaseWidget_module_children__5287a5f8","dropdown-popper":"BaseWidget_module_dropdownPopper__5287a5f8","dropdown-item":"BaseWidget_module_dropdownItem__5287a5f8"};
n(css$4,{});

var css$3 = "div.Toggle_module_root__7f4ba8d3 {\n  display: flex;\n  flex-direction: row;\n  justify-content: flex-start;\n  align-items: center;\n  overflow: auto;\n  gap: 0.25rem;\n  padding: 0.25rem;\n  background: var(--grey8);\n  width: -webkit-fit-content;\n  width: -moz-fit-content;\n  width: fit-content;\n  border-radius: 0.4rem 0.4rem;\n  border-width: 1px;\n  border-style: solid;\n  background: transparent;\n}\ndiv.Toggle_module_root__7f4ba8d3 [data-elem=base-cell].Toggle_module_toggleButton__7f4ba8d3 {\n  background: transparent;\n}\ndiv.Toggle_module_root__7f4ba8d3.Toggle_module_themeDark__7f4ba8d3 {\n  border-color: var(--dark-grey);\n}\ndiv.Toggle_module_root__7f4ba8d3.Toggle_module_themeDark__7f4ba8d3 [data-elem=base-cell].Toggle_module_toggleButton__7f4ba8d3 {\n  color: var(--grey4);\n}\ndiv.Toggle_module_root__7f4ba8d3.Toggle_module_themeDark__7f4ba8d3 [data-elem=base-cell].Toggle_module_toggleButton__7f4ba8d3.Toggle_module_active__7f4ba8d3 {\n  background: var(--dark-grey);\n  color: var(--white);\n  border: 1px solid var(--grey);\n}\ndiv.Toggle_module_root__7f4ba8d3.Toggle_module_themeLight__7f4ba8d3 {\n  border-color: var(--grey6);\n}\ndiv.Toggle_module_root__7f4ba8d3.Toggle_module_themeLight__7f4ba8d3 [data-elem=base-cell].Toggle_module_toggleButton__7f4ba8d3 {\n  background: transparent;\n  color: var(--grey);\n}\ndiv.Toggle_module_root__7f4ba8d3.Toggle_module_themeLight__7f4ba8d3 [data-elem=base-cell].Toggle_module_toggleButton__7f4ba8d3.Toggle_module_active__7f4ba8d3 {\n  background: var(--grey6);\n  color: var(--dark-grey);\n  border: 1px solid var(--grey4);\n}\ndiv.Toggle_module_root__7f4ba8d3 [data-elem=base-cell].Toggle_module_toggleButton__7f4ba8d3 {\n  padding: 0.344rem 0.75rem;\n  height: 2rem;\n}\ndiv.Toggle_module_root__7f4ba8d3 [data-elem=base-cell].Toggle_module_toggleButton__7f4ba8d3.Toggle_module_active__7f4ba8d3 {\n  border-radius: 0.25rem;\n}\ndiv.Toggle_module_root__7f4ba8d3 .Toggle_module_input__7f4ba8d3 {\n  display: none;\n}";
var modules_a2cdc77c = {"root":"Toggle_module_root__7f4ba8d3","toggle-button":"Toggle_module_toggleButton__7f4ba8d3","theme-dark":"Toggle_module_themeDark__7f4ba8d3","active":"Toggle_module_active__7f4ba8d3","theme-light":"Toggle_module_themeLight__7f4ba8d3","input":"Toggle_module_input__7f4ba8d3"};
n(css$3,{});

var Toggle = /*#__PURE__*/React.forwardRef(function Toggle(props, ref) {
  // eslint-disable-next-line object-curly-newline
  var className = props.className,
    theme = props.theme,
    options = props.options,
    defaultValue = props.defaultValue,
    value = props.value,
    onChange = props.onChange,
    multi = props.multi,
    color = props.color;

  // for uncontrolled input
  var _useState = React.useState(function () {
      var _options$2;
      if (multi) {
        var _ref, _options$;
        return (_ref = defaultValue !== null && defaultValue !== void 0 ? defaultValue : options === null || options === void 0 ? void 0 : (_options$ = options[0]) === null || _options$ === void 0 ? void 0 : _options$.value) !== null && _ref !== void 0 ? _ref : [];
      }
      return defaultValue !== null && defaultValue !== void 0 ? defaultValue : options === null || options === void 0 ? void 0 : (_options$2 = options[0]) === null || _options$2 === void 0 ? void 0 : _options$2.value;
    }),
    _useState2 = _slicedToArray(_useState, 2),
    uncontrolledValue = _useState2[0],
    setUncontrolledValue = _useState2[1];
  var _useRef = React.useRef(value !== undefined),
    isControlled = _useRef.current;

  // eslint-disable-next-line no-nested-ternary
  var inputValue = isControlled ? value !== null && value !== void 0 ? value : '' : uncontrolledValue;
  var allSelected = multi ? options.length === inputValue.length : false;
  var onSelectAll = function onSelectAll() {
    var allValues = options.map(function (option) {
      return option.value;
    });
    if (isControlled) {
      onChange(allValues);
    } else {
      setUncontrolledValue(allValues);
    }
  };
  var onButtonClick = function onButtonClick(newValue, selected) {
    // if multi select
    if (multi) {
      // if it was already selected, remove it
      if (selected) {
        var newInputValue = inputValue.filter(function (val) {
          return val !== newValue;
        });

        // if total selected after removal is greater than 0, set that
        // else select all
        if (newInputValue.length > 0) {
          if (isControlled) {
            onChange(newInputValue);
          } else {
            setUncontrolledValue(newInputValue);
          }
        } else {
          onSelectAll();
        }
      } else {
        // if all are selected, select only the one being clicked
        if (allSelected) {
          var _newInputValue = [newValue];
          if (isControlled) {
            onChange(_newInputValue);
          } else {
            setUncontrolledValue(_newInputValue);
          }
        } else {
          var _newInputValue2 = [].concat(_toConsumableArray$1(inputValue), [newValue]);
          if (isControlled) {
            onChange(_newInputValue2);
          } else {
            setUncontrolledValue(_newInputValue2);
          }
        }
      }
    } else {
      // if single select, just select that item
      if (isControlled) {
        onChange(newValue);
      } else {
        setUncontrolledValue(newValue);
      }
    }
  };
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(className, modules_a2cdc77c.root, modules_a2cdc77c["theme-".concat(theme)]),
    children: [multi && /*#__PURE__*/jsxRuntime.jsx(Button, {
      size: "auto",
      "data-elem": "toggle",
      className: classes(modules_a2cdc77c['toggle-button'], allSelected ? modules_a2cdc77c.active : ''),
      onClick: onSelectAll,
      title: "All",
      color: allSelected ? color : 'default',
      children: value
    }), options.map(function (item) {
      var title = item.title,
        itemValue = item.value,
        leftComponent = item.leftComponent,
        rightComponent = item.rightComponent,
        itemClassName = item.className;
      var isActive = inputValue.indexOf(itemValue) !== -1 && !allSelected;
      return /*#__PURE__*/jsxRuntime.jsx(Button, {
        size: "auto",
        "data-elem": "toggle",
        className: classes(modules_a2cdc77c['toggle-button'], isActive ? modules_a2cdc77c.active : '', itemClassName),
        onClick: function onClick() {
          onButtonClick(itemValue, isActive);
        },
        title: title,
        color: isActive ? color : 'default',
        leftComponent: leftComponent,
        rightComponent: rightComponent,
        children: value
      }, itemValue);
    }), /*#__PURE__*/jsxRuntime.jsx("input", {
      type: "text",
      ref: ref,
      className: modules_a2cdc77c.input,
      value: inputValue
    })]
  });
});
Toggle.propTypes = {
  className: propTypes$1.exports.string,
  theme: propTypes$1.exports.oneOf(['dark', 'light']),
  options: propTypes$1.exports.arrayOf(propTypes$1.exports.string),
  defaultValue: propTypes$1.exports.string,
  value: propTypes$1.exports.string,
  multi: propTypes$1.exports.bool
};
Toggle.defaultProps = {
  className: '',
  theme: 'light',
  options: [],
  defaultValue: null,
  value: undefined,
  multi: false
};

var css$2 = ".WidgetFallback_module_root__02f3e804 {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  position: absolute;\n  z-index: 1;\n  inset: 0;\n  padding: 2rem;\n  gap: 0.5rem;\n  margin: auto;\n  -webkit-backdrop-filter: blur(0.25rem);\n          backdrop-filter: blur(0.25rem);\n}\n.WidgetFallback_module_root__02f3e804 .WidgetFallback_module_wrapper__02f3e804 {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n  gap: 0.5rem;\n}\n.WidgetFallback_module_root__02f3e804 .WidgetFallback_module_text__02f3e804 {\n  text-align: center;\n  width: 80%;\n}\n.WidgetFallback_module_root__02f3e804.WidgetFallback_module_lightTheme__02f3e804 span.WidgetFallback_module_text__02f3e804:nth-of-type(1) {\n  color: var(--dark-grey);\n}\n.WidgetFallback_module_root__02f3e804.WidgetFallback_module_lightTheme__02f3e804 span.WidgetFallback_module_text__02f3e804:nth-of-type(2) {\n  color: var(--grey2);\n}\n.WidgetFallback_module_root__02f3e804.WidgetFallback_module_darkTheme__02f3e804 span.WidgetFallback_module_text__02f3e804:nth-of-type(1) {\n  color: var(--white);\n}\n.WidgetFallback_module_root__02f3e804.WidgetFallback_module_darkTheme__02f3e804 span.WidgetFallback_module_text__02f3e804:nth-of-type(2) {\n  color: var(--grey1);\n}\n.WidgetFallback_module_root__02f3e804 button {\n  margin-top: 1rem;\n}";
var modules_543e23b5 = {"root":"WidgetFallback_module_root__02f3e804","wrapper":"WidgetFallback_module_wrapper__02f3e804","text":"WidgetFallback_module_text__02f3e804","light-theme":"WidgetFallback_module_lightTheme__02f3e804","dark-theme":"WidgetFallback_module_darkTheme__02f3e804"};
n(css$2,{});

var WidgetFallback = function WidgetFallback(props) {
  var onReload = props.onReload,
    title = props.title,
    subtitle = props.subtitle,
    className = props.className,
    theme = props.theme;
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    className: classes(modules_543e23b5.root, className, modules_543e23b5["".concat(theme, "-theme")]),
    children: /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: modules_543e23b5.wrapper,
      children: [/*#__PURE__*/jsxRuntime.jsx(Text, {
        variant: "h2",
        stroke: "medium",
        className: modules_543e23b5.text,
        children: title
      }), /*#__PURE__*/jsxRuntime.jsx(Text, {
        variant: "b1",
        className: modules_543e23b5.text,
        children: subtitle
      }), /*#__PURE__*/jsxRuntime.jsx(Button, {
        variant: "outlined",
        size: "auto",
        rightComponent: function rightComponent() {
          return 'Reload';
        },
        className: modules_543e23b5.button,
        onClick: onReload
      })]
    })
  });
};
WidgetFallback.propTypes = {
  className: propTypes$1.exports.string,
  title: propTypes$1.exports.string,
  subtitle: propTypes$1.exports.string,
  onReload: propTypes$1.exports.func,
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
WidgetFallback.defaultProps = {
  className: '',
  title: '',
  subtitle: '',
  onReload: function onReload() {},
  theme: 'dark'
};

var generateOptions = function generateOptions(optionData, theme) {
  var _optionData$id, _optionData$placehold, _optionData$value, _optionData$onChange, _optionData$selectOpt, _optionData$title, _optionData$onClick;
  switch ((_optionData$id = optionData === null || optionData === void 0 ? void 0 : optionData.id) !== null && _optionData$id !== void 0 ? _optionData$id : '') {
    case 'toggle':
      return /*#__PURE__*/jsxRuntime.jsx(Toggle, _objectSpread2({
        className: modules_6a0e74b6['toggle-body'],
        theme: theme
      }, optionData));
    case 'dropdown':
      return /*#__PURE__*/jsxRuntime.jsx(Dropdown, {
        placeholder: (_optionData$placehold = optionData === null || optionData === void 0 ? void 0 : optionData.placeholder) !== null && _optionData$placehold !== void 0 ? _optionData$placehold : '',
        value: (_optionData$value = optionData === null || optionData === void 0 ? void 0 : optionData.value) !== null && _optionData$value !== void 0 ? _optionData$value : '',
        onChange: (_optionData$onChange = optionData === null || optionData === void 0 ? void 0 : optionData.onChange) !== null && _optionData$onChange !== void 0 ? _optionData$onChange : '',
        className: classes(modules_6a0e74b6['dropdown-header']),
        popperClassName: modules_6a0e74b6['dropdown-popper'],
        children: ((_optionData$selectOpt = optionData === null || optionData === void 0 ? void 0 : optionData.selectOption) !== null && _optionData$selectOpt !== void 0 ? _optionData$selectOpt : []).map(function (objectData) {
          var _objectData$title, _objectData$value, _objectData$value2;
          return /*#__PURE__*/jsxRuntime.jsx(DropdownItem, {
            title: (_objectData$title = objectData === null || objectData === void 0 ? void 0 : objectData.title) !== null && _objectData$title !== void 0 ? _objectData$title : '',
            value: (_objectData$value2 = objectData === null || objectData === void 0 ? void 0 : objectData.value) !== null && _objectData$value2 !== void 0 ? _objectData$value2 : '',
            variant: "checkbox",
            className: modules_6a0e74b6['dropdown-item']
          }, (_objectData$value = objectData === null || objectData === void 0 ? void 0 : objectData.value) !== null && _objectData$value !== void 0 ? _objectData$value : '');
        })
      });
    case 'expand':
      return /*#__PURE__*/jsxRuntime.jsx(Button, {
        title: (_optionData$title = optionData === null || optionData === void 0 ? void 0 : optionData.title) !== null && _optionData$title !== void 0 ? _optionData$title : '',
        variant: "outlined",
        size: "auto",
        className: modules_6a0e74b6['expand-button'],
        onClick: (_optionData$onClick = optionData === null || optionData === void 0 ? void 0 : optionData.onClick) !== null && _optionData$onClick !== void 0 ? _optionData$onClick : '',
        rightComponent: function rightComponent() {
          return /*#__PURE__*/jsxRuntime.jsx(ExpandArrowAlt, {
            className: modules_6a0e74b6['expand-icon']
          });
        }
      });
    case 'custom':
      return optionData.render({
        theme: theme
      });
    default:
      return null;
  }
};

// eslint-disable-next-line prefer-arrow-callback
var BaseWidget = /*#__PURE__*/React.forwardRef(function BaseWidget(props, ref) {
  var _options$length, _options$length2;
  // eslint-disable-next-line object-curly-newline
  var loading = props.loading,
    title = props.title,
    subtitle = props.subtitle,
    showBack = props.showBack,
    onBack = props.onBack,
    onReload = props.onReload,
    options = props.options,
    className = props.className,
    children = props.children,
    fallbackProps = props.fallbackProps,
    theme = props.theme,
    setFallback = props.setFallback,
    showFallback = props.showFallback,
    style = props.style,
    onMouseDown = props.onMouseDown,
    onMouseUp = props.onMouseUp,
    onTouchEnd = props.onTouchEnd;
  var emptyChartData = React.useMemo(function () {
    return React.Children.toArray(children).every(function (child) {
      var _child$props$seriesDa, _child$props, _child$props$seriesDa2;
      var chartData = (_child$props$seriesDa = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : (_child$props$seriesDa2 = _child$props.seriesData) === null || _child$props$seriesDa2 === void 0 ? void 0 : _child$props$seriesDa2.chartData) !== null && _child$props$seriesDa !== void 0 ? _child$props$seriesDa : {};
      return chartData && Object.keys(chartData).length === 0;
    });
  }, [children]);
  React.useEffect(function () {
    setFallback(emptyChartData);
  }, [emptyChartData]);
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    ref: ref,
    className: classes(modules_6a0e74b6.root, className, modules_6a0e74b6["".concat(theme, "-theme")]),
    style: style,
    onMouseDown: onMouseDown,
    onMouseUp: onMouseUp,
    onTouchEnd: onTouchEnd,
    children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
      className: modules_6a0e74b6.header,
      "data-elem": "header",
      children: [/*#__PURE__*/jsxRuntime.jsxs("div", {
        className: classes(modules_6a0e74b6['header-title'], ((_options$length = options === null || options === void 0 ? void 0 : options.length) !== null && _options$length !== void 0 ? _options$length : 0) === 0 ? modules_6a0e74b6['no-options'] : ''),
        "data-elem": "header-title",
        children: [showBack && /*#__PURE__*/jsxRuntime.jsx(Button, {
          size: "auto",
          radius: "round",
          className: modules_6a0e74b6.back,
          leftComponent: function leftComponent() {
            return /*#__PURE__*/jsxRuntime.jsx(Arrow$1, {
              className: modules_6a0e74b6.icon,
              position: "left"
            });
          },
          onClick: onBack
        }), /*#__PURE__*/jsxRuntime.jsxs(Text, {
          variant: "b1",
          stroke: "semibold",
          attrs: {
            'data-elem': 'title'
          },
          children: [title, " -"]
        }), subtitle && /*#__PURE__*/jsxRuntime.jsx(Text, {
          variant: "b2",
          stroke: "medium",
          attrs: {
            'data-elem': 'subtitle'
          },
          children: subtitle
        })]
      }), /*#__PURE__*/jsxRuntime.jsx("div", {
        className: classes(modules_6a0e74b6['header-options']),
        "data-elem": "header-options",
        children: ((_options$length2 = options === null || options === void 0 ? void 0 : options.length) !== null && _options$length2 !== void 0 ? _options$length2 : 0) > 0 && (options === null || options === void 0 ? void 0 : options.map(function (objectData) {
          return generateOptions(objectData, theme);
        }))
      })]
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      className: modules_6a0e74b6.children,
      "data-elem": "children",
      children: [showFallback && !loading && emptyChartData && /*#__PURE__*/jsxRuntime.jsx(WidgetFallback, _objectSpread2(_objectSpread2({}, fallbackProps), {}, {
        onReload: onReload,
        theme: theme
      })), React.Children.map(children, function (child) {
        if ( /*#__PURE__*/React.isValidElement(child)) {
          return /*#__PURE__*/React.cloneElement(child, {
            fallback: !loading && emptyChartData
          });
        }
        return null;
      })]
    })]
  });
});
BaseWidget.propTypes = {
  loading: propTypes$1.exports.bool,
  title: propTypes$1.exports.string,
  showBack: propTypes$1.exports.bool,
  onBack: propTypes$1.exports.func,
  onReload: propTypes$1.exports.func,
  options: propTypes$1.exports.arrayOf(propTypes$1.exports.shape),
  className: propTypes$1.exports.string,
  fallbackProps: propTypes$1.exports.shape({
    className: propTypes$1.exports.string,
    title: propTypes$1.exports.string,
    subtitle: propTypes$1.exports.string
  }),
  theme: propTypes$1.exports.oneOf(['light', 'dark']),
  setFallback: propTypes$1.exports.func,
  showFallback: propTypes$1.exports.bool
};
BaseWidget.defaultProps = {
  loading: false,
  title: '',
  showBack: false,
  onBack: function onBack() {},
  onReload: function onReload() {},
  options: [],
  className: '',
  fallbackProps: {
    className: '',
    title: "We're having trouble loading this data",
    subtitle: 'There could be something happening on our end. Reload this widget to try again.'
  },
  theme: 'dark',
  setFallback: function setFallback() {},
  showFallback: false
};

var css$1 = ".DisplayPicture_module_root__a7ba07d1.DisplayPicture_module_sm__a7ba07d1 img {\n  height: 1.5rem;\n  width: 1.5rem;\n  border-radius: 100%;\n}\n.DisplayPicture_module_root__a7ba07d1.DisplayPicture_module_sm__a7ba07d1 div {\n  height: 1.5rem;\n  width: 1.5rem;\n  border-radius: 100%;\n  background-color: var(--highlight);\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n}\n.DisplayPicture_module_root__a7ba07d1.DisplayPicture_module_sm__a7ba07d1 div span {\n  font-size: 1rem;\n  font-weight: 600;\n  color: var(--white);\n}\n.DisplayPicture_module_root__a7ba07d1.DisplayPicture_module_md__a7ba07d1 img {\n  height: 5.3125rem;\n  width: 5.3125rem;\n  border-radius: 100%;\n}\n.DisplayPicture_module_root__a7ba07d1.DisplayPicture_module_md__a7ba07d1 div {\n  height: 5.3125rem;\n  width: 5.3125rem;\n  border-radius: 100%;\n  background-color: var(--highlight);\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n}\n.DisplayPicture_module_root__a7ba07d1.DisplayPicture_module_md__a7ba07d1 div span {\n  font-size: 2rem;\n  font-weight: 600;\n  color: var(--white);\n}";
var modules_49a16e28 = {"root":"DisplayPicture_module_root__a7ba07d1","sm":"DisplayPicture_module_sm__a7ba07d1","md":"DisplayPicture_module_md__a7ba07d1"};
n(css$1,{});

var DisplayPicture = function DisplayPicture(props) {
  var name = props.name,
    className = props.className,
    url = props.url,
    size = props.size;
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(modules_49a16e28.root, className, modules_49a16e28[size]),
    children: [!url && /*#__PURE__*/jsxRuntime.jsx("div", {
      children: /*#__PURE__*/jsxRuntime.jsx("span", {
        "data-elem": "dp-name",
        children: getInitialsOfName(name)
      })
    }), url && /*#__PURE__*/jsxRuntime.jsx("img", {
      "data-elem": "dp-img",
      src: url,
      alt: name
    })]
  });
};
DisplayPicture.propTypes = {
  name: propTypes$1.exports.string,
  url: propTypes$1.exports.string,
  className: propTypes$1.exports.string,
  size: propTypes$1.exports.string
};
DisplayPicture.defaultProps = {
  name: '',
  url: '',
  className: '',
  size: 'sm'
};

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

/**
 * Copyright 2019 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at.
 *
 *      Http://www.apache.org/licenses/LICENSE-2.0.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ID = "__googleMapsScriptId";
/**
 * The status of the [[Loader]].
 */
var LoaderStatus;
(function (LoaderStatus) {
    LoaderStatus[LoaderStatus["INITIALIZED"] = 0] = "INITIALIZED";
    LoaderStatus[LoaderStatus["LOADING"] = 1] = "LOADING";
    LoaderStatus[LoaderStatus["SUCCESS"] = 2] = "SUCCESS";
    LoaderStatus[LoaderStatus["FAILURE"] = 3] = "FAILURE";
})(LoaderStatus || (LoaderStatus = {}));
/**
 * [[Loader]] makes it easier to add Google Maps JavaScript API to your application
 * dynamically using
 * [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
 * It works by dynamically creating and appending a script node to the the
 * document head and wrapping the callback function so as to return a promise.
 *
 * ```
 * const loader = new Loader({
 *   apiKey: "",
 *   version: "weekly",
 *   libraries: ["places"]
 * });
 *
 * loader.load().then((google) => {
 *   const map = new google.maps.Map(...)
 * })
 * ```
 */
class Loader {
    /**
     * Creates an instance of Loader using [[LoaderOptions]]. No defaults are set
     * using this library, instead the defaults are set by the Google Maps
     * JavaScript API server.
     *
     * ```
     * const loader = Loader({apiKey, version: 'weekly', libraries: ['places']});
     * ```
     */
    constructor({ apiKey, authReferrerPolicy, channel, client, id = DEFAULT_ID, language, libraries = [], mapIds, nonce, region, retries = 3, url = "https://maps.googleapis.com/maps/api/js", version, }) {
        this.CALLBACK = "__googleMapsCallback";
        this.callbacks = [];
        this.done = false;
        this.loading = false;
        this.errors = [];
        this.apiKey = apiKey;
        this.authReferrerPolicy = authReferrerPolicy;
        this.channel = channel;
        this.client = client;
        this.id = id || DEFAULT_ID; // Do not allow empty string
        this.language = language;
        this.libraries = libraries;
        this.mapIds = mapIds;
        this.nonce = nonce;
        this.region = region;
        this.retries = retries;
        this.url = url;
        this.version = version;
        if (Loader.instance) {
            if (!fastDeepEqual(this.options, Loader.instance.options)) {
                throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(Loader.instance.options)}`);
            }
            return Loader.instance;
        }
        Loader.instance = this;
    }
    get options() {
        return {
            version: this.version,
            apiKey: this.apiKey,
            channel: this.channel,
            client: this.client,
            id: this.id,
            libraries: this.libraries,
            language: this.language,
            region: this.region,
            mapIds: this.mapIds,
            nonce: this.nonce,
            url: this.url,
            authReferrerPolicy: this.authReferrerPolicy,
        };
    }
    get status() {
        if (this.errors.length) {
            return LoaderStatus.FAILURE;
        }
        if (this.done) {
            return LoaderStatus.SUCCESS;
        }
        if (this.loading) {
            return LoaderStatus.LOADING;
        }
        return LoaderStatus.INITIALIZED;
    }
    get failed() {
        return this.done && !this.loading && this.errors.length >= this.retries + 1;
    }
    /**
     * CreateUrl returns the Google Maps JavaScript API script url given the [[LoaderOptions]].
     *
     * @ignore
     */
    createUrl() {
        let url = this.url;
        url += `?callback=${this.CALLBACK}`;
        if (this.apiKey) {
            url += `&key=${this.apiKey}`;
        }
        if (this.channel) {
            url += `&channel=${this.channel}`;
        }
        if (this.client) {
            url += `&client=${this.client}`;
        }
        if (this.libraries.length > 0) {
            url += `&libraries=${this.libraries.join(",")}`;
        }
        if (this.language) {
            url += `&language=${this.language}`;
        }
        if (this.region) {
            url += `&region=${this.region}`;
        }
        if (this.version) {
            url += `&v=${this.version}`;
        }
        if (this.mapIds) {
            url += `&map_ids=${this.mapIds.join(",")}`;
        }
        if (this.authReferrerPolicy) {
            url += `&auth_referrer_policy=${this.authReferrerPolicy}`;
        }
        return url;
    }
    deleteScript() {
        const script = document.getElementById(this.id);
        if (script) {
            script.remove();
        }
    }
    /**
     * Load the Google Maps JavaScript API script and return a Promise.
     */
    load() {
        return this.loadPromise();
    }
    /**
     * Load the Google Maps JavaScript API script and return a Promise.
     *
     * @ignore
     */
    loadPromise() {
        return new Promise((resolve, reject) => {
            this.loadCallback((err) => {
                if (!err) {
                    resolve(window.google);
                }
                else {
                    reject(err.error);
                }
            });
        });
    }
    /**
     * Load the Google Maps JavaScript API script with a callback.
     */
    loadCallback(fn) {
        this.callbacks.push(fn);
        this.execute();
    }
    /**
     * Set the script on document.
     */
    setScript() {
        if (document.getElementById(this.id)) {
            // TODO wrap onerror callback for cases where the script was loaded elsewhere
            this.callback();
            return;
        }
        const url = this.createUrl();
        const script = document.createElement("script");
        script.id = this.id;
        script.type = "text/javascript";
        script.src = url;
        script.onerror = this.loadErrorCallback.bind(this);
        script.defer = true;
        script.async = true;
        if (this.nonce) {
            script.nonce = this.nonce;
        }
        document.head.appendChild(script);
    }
    /**
     * Reset the loader state.
     */
    reset() {
        this.deleteScript();
        this.done = false;
        this.loading = false;
        this.errors = [];
        this.onerrorEvent = null;
    }
    resetIfRetryingFailed() {
        if (this.failed) {
            this.reset();
        }
    }
    loadErrorCallback(e) {
        this.errors.push(e);
        if (this.errors.length <= this.retries) {
            const delay = this.errors.length * Math.pow(2, this.errors.length);
            console.log(`Failed to load Google Maps script, retrying in ${delay} ms.`);
            setTimeout(() => {
                this.deleteScript();
                this.setScript();
            }, delay);
        }
        else {
            this.onerrorEvent = e;
            this.callback();
        }
    }
    setCallback() {
        window.__googleMapsCallback = this.callback.bind(this);
    }
    callback() {
        this.done = true;
        this.loading = false;
        this.callbacks.forEach((cb) => {
            cb(this.onerrorEvent);
        });
        this.callbacks = [];
    }
    execute() {
        this.resetIfRetryingFailed();
        if (this.done) {
            this.callback();
        }
        else {
            // short circuit and warn if google.maps is already loaded
            if (window.google && window.google.maps && window.google.maps.version) {
                console.warn("Google Maps already loaded outside @googlemaps/js-api-loader." +
                    "This may result in undesirable behavior as options and script parameters may not match.");
                this.callback();
                return;
            }
            if (this.loading) ;
            else {
                this.loading = true;
                this.setCallback();
                this.setScript();
            }
        }
    }
}

/**
 * Copyright 2021 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at.
 *
 *      Http://www.apache.org/licenses/LICENSE-2.0.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Status;
(function (Status) {
    Status["LOADING"] = "LOADING";
    Status["FAILURE"] = "FAILURE";
    Status["SUCCESS"] = "SUCCESS";
})(Status || (Status = {}));
/**
 * A component to wrap the loading of the Google Maps JavaScript API.
 *
 * ```
 * import { Wrapper } from '@googlemaps/react-wrapper';
 *
 * const MyApp = () => (
 * 	<Wrapper apiKey={'YOUR_API_KEY'}>
 * 		<MyMapComponent />
 * 	</Wrapper>
 * );
 * ```
 *
 * @param props
 */
const Wrapper = ({ children, render, callback, ...options }) => {
    const [status, setStatus] = React.useState(Status.LOADING);
    React.useEffect(() => {
        const loader = new Loader(options);
        const setStatusAndExecuteCallback = (status) => {
            if (callback)
                callback(status, loader);
            setStatus(status);
        };
        setStatusAndExecuteCallback(Status.LOADING);
        loader.load().then(() => setStatusAndExecuteCallback(Status.SUCCESS), () => setStatusAndExecuteCallback(Status.FAILURE));
    }, []);
    if (status === Status.SUCCESS && children)
        return React.createElement(React.Fragment, null, children);
    if (render)
        return render(status);
    return React.createElement(React.Fragment, null);
};

function sortKD(ids, coords, nodeSize, left, right, depth) {
    if (right - left <= nodeSize) return;

    const m = (left + right) >> 1;

    select(ids, coords, m, left, right, depth % 2);

    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
}

function select(ids, coords, k, left, right, inc) {

    while (right > left) {
        if (right - left > 600) {
            const n = right - left + 1;
            const m = k - left + 1;
            const z = Math.log(n);
            const s = 0.5 * Math.exp(2 * z / 3);
            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            select(ids, coords, k, newLeft, newRight, inc);
        }

        const t = coords[2 * k + inc];
        let i = left;
        let j = right;

        swapItem(ids, coords, left, k);
        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);

        while (i < j) {
            swapItem(ids, coords, i, j);
            i++;
            j--;
            while (coords[2 * i + inc] < t) i++;
            while (coords[2 * j + inc] > t) j--;
        }

        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);
        else {
            j++;
            swapItem(ids, coords, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swapItem(ids, coords, i, j) {
    swap(ids, i, j);
    swap(coords, 2 * i, 2 * j);
    swap(coords, 2 * i + 1, 2 * j + 1);
}

function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {
    const stack = [0, ids.length - 1, 0];
    const result = [];
    let x, y;

    while (stack.length) {
        const axis = stack.pop();
        const right = stack.pop();
        const left = stack.pop();

        if (right - left <= nodeSize) {
            for (let i = left; i <= right; i++) {
                x = coords[2 * i];
                y = coords[2 * i + 1];
                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);
            }
            continue;
        }

        const m = Math.floor((left + right) / 2);

        x = coords[2 * m];
        y = coords[2 * m + 1];

        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);

        const nextAxis = (axis + 1) % 2;

        if (axis === 0 ? minX <= x : minY <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
        }
        if (axis === 0 ? maxX >= x : maxY >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
        }
    }

    return result;
}

function within(ids, coords, qx, qy, r, nodeSize) {
    const stack = [0, ids.length - 1, 0];
    const result = [];
    const r2 = r * r;

    while (stack.length) {
        const axis = stack.pop();
        const right = stack.pop();
        const left = stack.pop();

        if (right - left <= nodeSize) {
            for (let i = left; i <= right; i++) {
                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
            }
            continue;
        }

        const m = Math.floor((left + right) / 2);

        const x = coords[2 * m];
        const y = coords[2 * m + 1];

        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);

        const nextAxis = (axis + 1) % 2;

        if (axis === 0 ? qx - r <= x : qy - r <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
        }
        if (axis === 0 ? qx + r >= x : qy + r >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
        }
    }

    return result;
}

function sqDist(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
}

const defaultGetX = p => p[0];
const defaultGetY = p => p[1];

class KDBush {
    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {
        this.nodeSize = nodeSize;
        this.points = points;

        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;

        const ids = this.ids = new IndexArrayType(points.length);
        const coords = this.coords = new ArrayType(points.length * 2);

        for (let i = 0; i < points.length; i++) {
            ids[i] = i;
            coords[2 * i] = getX(points[i]);
            coords[2 * i + 1] = getY(points[i]);
        }

        sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);
    }

    range(minX, minY, maxX, maxY) {
        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
    }

    within(x, y, r) {
        return within(this.ids, this.coords, x, y, r, this.nodeSize);
    }
}

const defaultOptions = {
    minZoom: 0,   // min zoom to generate clusters on
    maxZoom: 16,  // max zoom level to cluster the points on
    minPoints: 2, // minimum points to form a cluster
    radius: 40,   // cluster radius in pixels
    extent: 512,  // tile extent (radius is calculated relative to it)
    nodeSize: 64, // size of the KD-tree leaf node, affects performance
    log: false,   // whether to log timing info

    // whether to generate numeric ids for input features (in vector tiles)
    generateId: false,

    // a reduce function for calculating custom cluster properties
    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }

    // properties to use for individual points when running the reducer
    map: props => props // props => ({sum: props.my_value})
};

const fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));

class Supercluster {
    constructor(options) {
        this.options = extend$1(Object.create(defaultOptions), options);
        this.trees = new Array(this.options.maxZoom + 1);
    }

    load(points) {
        const {log, minZoom, maxZoom, nodeSize} = this.options;

        if (log) console.time('total time');

        const timerId = `prepare ${  points.length  } points`;
        if (log) console.time(timerId);

        this.points = points;

        // generate a cluster object for each point and index input points into a KD-tree
        let clusters = [];
        for (let i = 0; i < points.length; i++) {
            if (!points[i].geometry) continue;
            clusters.push(createPointCluster(points[i], i));
        }
        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);

        if (log) console.timeEnd(timerId);

        // cluster points on max zoom, then cluster the results on previous zoom, etc.;
        // results in a cluster hierarchy across zoom levels
        for (let z = maxZoom; z >= minZoom; z--) {
            const now = +Date.now();

            // create a new set of clusters for the zoom and index them with a KD-tree
            clusters = this._cluster(clusters, z);
            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);

            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);
        }

        if (log) console.timeEnd('total time');

        return this;
    }

    getClusters(bbox, zoom) {
        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;
        const minLat = Math.max(-90, Math.min(90, bbox[1]));
        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;
        const maxLat = Math.max(-90, Math.min(90, bbox[3]));

        if (bbox[2] - bbox[0] >= 360) {
            minLng = -180;
            maxLng = 180;
        } else if (minLng > maxLng) {
            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);
            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);
            return easternHem.concat(westernHem);
        }

        const tree = this.trees[this._limitZoom(zoom)];
        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));
        const clusters = [];
        for (const id of ids) {
            const c = tree.points[id];
            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
        }
        return clusters;
    }

    getChildren(clusterId) {
        const originId = this._getOriginId(clusterId);
        const originZoom = this._getOriginZoom(clusterId);
        const errorMsg = 'No cluster with the specified id.';

        const index = this.trees[originZoom];
        if (!index) throw new Error(errorMsg);

        const origin = index.points[originId];
        if (!origin) throw new Error(errorMsg);

        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));
        const ids = index.within(origin.x, origin.y, r);
        const children = [];
        for (const id of ids) {
            const c = index.points[id];
            if (c.parentId === clusterId) {
                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
            }
        }

        if (children.length === 0) throw new Error(errorMsg);

        return children;
    }

    getLeaves(clusterId, limit, offset) {
        limit = limit || 10;
        offset = offset || 0;

        const leaves = [];
        this._appendLeaves(leaves, clusterId, limit, offset, 0);

        return leaves;
    }

    getTile(z, x, y) {
        const tree = this.trees[this._limitZoom(z)];
        const z2 = Math.pow(2, z);
        const {extent, radius} = this.options;
        const p = radius / extent;
        const top = (y - p) / z2;
        const bottom = (y + 1 + p) / z2;

        const tile = {
            features: []
        };

        this._addTileFeatures(
            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),
            tree.points, x, y, z2, tile);

        if (x === 0) {
            this._addTileFeatures(
                tree.range(1 - p / z2, top, 1, bottom),
                tree.points, z2, y, z2, tile);
        }
        if (x === z2 - 1) {
            this._addTileFeatures(
                tree.range(0, top, p / z2, bottom),
                tree.points, -1, y, z2, tile);
        }

        return tile.features.length ? tile : null;
    }

    getClusterExpansionZoom(clusterId) {
        let expansionZoom = this._getOriginZoom(clusterId) - 1;
        while (expansionZoom <= this.options.maxZoom) {
            const children = this.getChildren(clusterId);
            expansionZoom++;
            if (children.length !== 1) break;
            clusterId = children[0].properties.cluster_id;
        }
        return expansionZoom;
    }

    _appendLeaves(result, clusterId, limit, offset, skipped) {
        const children = this.getChildren(clusterId);

        for (const child of children) {
            const props = child.properties;

            if (props && props.cluster) {
                if (skipped + props.point_count <= offset) {
                    // skip the whole cluster
                    skipped += props.point_count;
                } else {
                    // enter the cluster
                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);
                    // exit the cluster
                }
            } else if (skipped < offset) {
                // skip a single point
                skipped++;
            } else {
                // add a single point
                result.push(child);
            }
            if (result.length === limit) break;
        }

        return skipped;
    }

    _addTileFeatures(ids, points, x, y, z2, tile) {
        for (const i of ids) {
            const c = points[i];
            const isCluster = c.numPoints;

            let tags, px, py;
            if (isCluster) {
                tags = getClusterProperties(c);
                px = c.x;
                py = c.y;
            } else {
                const p = this.points[c.index];
                tags = p.properties;
                px = lngX(p.geometry.coordinates[0]);
                py = latY(p.geometry.coordinates[1]);
            }

            const f = {
                type: 1,
                geometry: [[
                    Math.round(this.options.extent * (px * z2 - x)),
                    Math.round(this.options.extent * (py * z2 - y))
                ]],
                tags
            };

            // assign id
            let id;
            if (isCluster) {
                id = c.id;
            } else if (this.options.generateId) {
                // optionally generate id
                id = c.index;
            } else if (this.points[c.index].id) {
                // keep id if already assigned
                id = this.points[c.index].id;
            }

            if (id !== undefined) f.id = id;

            tile.features.push(f);
        }
    }

    _limitZoom(z) {
        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));
    }

    _cluster(points, zoom) {
        const clusters = [];
        const {radius, extent, reduce, minPoints} = this.options;
        const r = radius / (extent * Math.pow(2, zoom));

        // loop through each point
        for (let i = 0; i < points.length; i++) {
            const p = points[i];
            // if we've already visited the point at this zoom level, skip it
            if (p.zoom <= zoom) continue;
            p.zoom = zoom;

            // find all nearby points
            const tree = this.trees[zoom + 1];
            const neighborIds = tree.within(p.x, p.y, r);

            const numPointsOrigin = p.numPoints || 1;
            let numPoints = numPointsOrigin;

            // count the number of points in a potential cluster
            for (const neighborId of neighborIds) {
                const b = tree.points[neighborId];
                // filter out neighbors that are already processed
                if (b.zoom > zoom) numPoints += b.numPoints || 1;
            }

            // if there were neighbors to merge, and there are enough points to form a cluster
            if (numPoints > numPointsOrigin && numPoints >= minPoints) {
                let wx = p.x * numPointsOrigin;
                let wy = p.y * numPointsOrigin;

                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;

                // encode both zoom and point index on which the cluster originated -- offset by total length of features
                const id = (i << 5) + (zoom + 1) + this.points.length;

                for (const neighborId of neighborIds) {
                    const b = tree.points[neighborId];

                    if (b.zoom <= zoom) continue;
                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)

                    const numPoints2 = b.numPoints || 1;
                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center
                    wy += b.y * numPoints2;

                    b.parentId = id;

                    if (reduce) {
                        if (!clusterProperties) clusterProperties = this._map(p, true);
                        reduce(clusterProperties, this._map(b));
                    }
                }

                p.parentId = id;
                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));

            } else { // left points as unclustered
                clusters.push(p);

                if (numPoints > 1) {
                    for (const neighborId of neighborIds) {
                        const b = tree.points[neighborId];
                        if (b.zoom <= zoom) continue;
                        b.zoom = zoom;
                        clusters.push(b);
                    }
                }
            }
        }

        return clusters;
    }

    // get index of the point from which the cluster originated
    _getOriginId(clusterId) {
        return (clusterId - this.points.length) >> 5;
    }

    // get zoom of the point from which the cluster originated
    _getOriginZoom(clusterId) {
        return (clusterId - this.points.length) % 32;
    }

    _map(point, clone) {
        if (point.numPoints) {
            return clone ? extend$1({}, point.properties) : point.properties;
        }
        const original = this.points[point.index].properties;
        const result = this.options.map(original);
        return clone && result === original ? extend$1({}, result) : result;
    }
}

function createCluster(x, y, id, numPoints, properties) {
    return {
        x: fround(x), // weighted cluster center; round for consistency with Float32Array index
        y: fround(y),
        zoom: Infinity, // the last zoom the cluster was processed at
        id, // encodes index of the first child of the cluster and its zoom level
        parentId: -1, // parent cluster id
        numPoints,
        properties
    };
}

function createPointCluster(p, id) {
    const [x, y] = p.geometry.coordinates;
    return {
        x: fround(lngX(x)), // projected point coordinates
        y: fround(latY(y)),
        zoom: Infinity, // the last zoom the point was processed at
        index: id, // index of the source feature in the original input array,
        parentId: -1 // parent cluster id
    };
}

function getClusterJSON(cluster) {
    return {
        type: 'Feature',
        id: cluster.id,
        properties: getClusterProperties(cluster),
        geometry: {
            type: 'Point',
            coordinates: [xLng(cluster.x), yLat(cluster.y)]
        }
    };
}

function getClusterProperties(cluster) {
    const count = cluster.numPoints;
    const abbrev =
        count >= 10000 ? `${Math.round(count / 1000)  }k` :
        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;
    return extend$1(extend$1({}, cluster.properties), {
        cluster: true,
        cluster_id: cluster.id,
        point_count: count,
        point_count_abbreviated: abbrev
    });
}

// longitude/latitude to spherical mercator in [0..1] range
function lngX(lng) {
    return lng / 360 + 0.5;
}
function latY(lat) {
    const sin = Math.sin(lat * Math.PI / 180);
    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
    return y < 0 ? 0 : y > 1 ? 1 : y;
}

// spherical mercator to longitude/latitude
function xLng(x) {
    return (x - 0.5) * 360;
}
function yLat(y) {
    const y2 = (180 - y * 360) * Math.PI / 180;
    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;
}

function extend$1(dest, src) {
    for (const id in src) dest[id] = src[id];
    return dest;
}

function getX(p) {
    return p.x;
}
function getY(p) {
    return p.y;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Cluster {
    constructor({ markers, position }) {
        this.markers = markers;
        if (position) {
            if (position instanceof google.maps.LatLng) {
                this._position = position;
            }
            else {
                this._position = new google.maps.LatLng(position);
            }
        }
    }
    get bounds() {
        if (this.markers.length === 0 && !this._position) {
            return undefined;
        }
        return this.markers.reduce((bounds, marker) => {
            return bounds.extend(marker.getPosition());
        }, new google.maps.LatLngBounds(this._position, this._position));
    }
    get position() {
        return this._position || this.bounds.getCenter();
    }
    /**
     * Get the count of **visible** markers.
     */
    get count() {
        return this.markers.filter((m) => m.getVisible())
            .length;
    }
    /**
     * Add a marker to the cluster.
     */
    push(marker) {
        this.markers.push(marker);
    }
    /**
     * Cleanup references and remove marker from map.
     */
    delete() {
        if (this.marker) {
            this.marker.setMap(null);
            delete this.marker;
        }
        this.markers.length = 0;
    }
}

/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @hidden
 */
class AbstractAlgorithm {
    constructor({ maxZoom = 16 }) {
        this.maxZoom = maxZoom;
    }
    /**
     * Helper function to bypass clustering based upon some map state such as
     * zoom, number of markers, etc.
     *
     * ```typescript
     *  cluster({markers, map}: AlgorithmInput): Cluster[] {
     *    if (shouldBypassClustering(map)) {
     *      return this.noop({markers, map})
     *    }
     * }
     * ```
     */
    noop({ markers }) {
        return noop(markers);
    }
}
/**
 * @hidden
 */
const noop = (markers) => {
    const clusters = markers.map((marker) => new Cluster({
        position: marker.getPosition(),
        markers: [marker],
    }));
    return clusters;
};

/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A very fast JavaScript algorithm for geospatial point clustering using KD trees.
 *
 * @see https://www.npmjs.com/package/supercluster for more information on options.
 */
class SuperClusterAlgorithm extends AbstractAlgorithm {
    constructor(_a) {
        var { maxZoom, radius = 60 } = _a, options = __rest(_a, ["maxZoom", "radius"]);
        super({ maxZoom });
        this.superCluster = new Supercluster(Object.assign({ maxZoom: this.maxZoom, radius }, options));
        this.state = { zoom: null };
    }
    calculate(input) {
        let changed = false;
        if (!fastDeepEqual$1(input.markers, this.markers)) {
            changed = true;
            // TODO use proxy to avoid copy?
            this.markers = [...input.markers];
            const points = this.markers.map((marker) => {
                return {
                    type: "Feature",
                    geometry: {
                        type: "Point",
                        coordinates: [
                            marker.getPosition().lng(),
                            marker.getPosition().lat(),
                        ],
                    },
                    properties: { marker },
                };
            });
            this.superCluster.load(points);
        }
        const state = { zoom: input.map.getZoom() };
        if (!changed) {
            if (this.state.zoom > this.maxZoom && state.zoom > this.maxZoom) ;
            else {
                changed = changed || !fastDeepEqual$1(this.state, state);
            }
        }
        this.state = state;
        if (changed) {
            this.clusters = this.cluster(input);
        }
        return { clusters: this.clusters, changed };
    }
    cluster({ map }) {
        return this.superCluster
            .getClusters([-180, -90, 180, 90], Math.round(map.getZoom()))
            .map(this.transformCluster.bind(this));
    }
    transformCluster({ geometry: { coordinates: [lng, lat], }, properties, }) {
        if (properties.cluster) {
            return new Cluster({
                markers: this.superCluster
                    .getLeaves(properties.cluster_id, Infinity)
                    .map((leaf) => leaf.properties.marker),
                position: new google.maps.LatLng({ lat, lng }),
            });
        }
        else {
            const marker = properties.marker;
            return new Cluster({
                markers: [marker],
                position: marker.getPosition(),
            });
        }
    }
}

/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provides statistics on all clusters in the current render cycle for use in {@link Renderer.render}.
 */
class ClusterStats {
    constructor(markers, clusters) {
        this.markers = { sum: markers.length };
        const clusterMarkerCounts = clusters.map((a) => a.count);
        const clusterMarkerSum = clusterMarkerCounts.reduce((a, b) => a + b, 0);
        this.clusters = {
            count: clusters.length,
            markers: {
                mean: clusterMarkerSum / clusters.length,
                sum: clusterMarkerSum,
                min: Math.min(...clusterMarkerCounts),
                max: Math.max(...clusterMarkerCounts),
            },
        };
    }
}
class DefaultRenderer {
    /**
     * The default render function for the library used by {@link MarkerClusterer}.
     *
     * Currently set to use the following:
     *
     * ```typescript
     * // change color if this cluster has more markers than the mean cluster
     * const color =
     *   count > Math.max(10, stats.clusters.markers.mean)
     *     ? "#ff0000"
     *     : "#0000ff";
     *
     * // create svg url with fill color
     * const svg = window.btoa(`
     * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
     *   <circle cx="120" cy="120" opacity=".6" r="70" />
     *   <circle cx="120" cy="120" opacity=".3" r="90" />
     *   <circle cx="120" cy="120" opacity=".2" r="110" />
     *   <circle cx="120" cy="120" opacity=".1" r="130" />
     * </svg>`);
     *
     * // create marker using svg icon
     * return new google.maps.Marker({
     *   position,
     *   icon: {
     *     url: `data:image/svg+xml;base64,${svg}`,
     *     scaledSize: new google.maps.Size(45, 45),
     *   },
     *   label: {
     *     text: String(count),
     *     color: "rgba(255,255,255,0.9)",
     *     fontSize: "12px",
     *   },
     *   // adjust zIndex to be above other markers
     *   zIndex: 1000 + count,
     * });
     * ```
     */
    render({ count, position }, stats) {
        // change color if this cluster has more markers than the mean cluster
        const color = count > Math.max(10, stats.clusters.markers.mean) ? "#ff0000" : "#0000ff";
        // create svg url with fill color
        const svg = window.btoa(`
  <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
    <circle cx="120" cy="120" opacity=".6" r="70" />
    <circle cx="120" cy="120" opacity=".3" r="90" />
    <circle cx="120" cy="120" opacity=".2" r="110" />
  </svg>`);
        // create marker using svg icon
        return new google.maps.Marker({
            position,
            icon: {
                url: `data:image/svg+xml;base64,${svg}`,
                scaledSize: new google.maps.Size(45, 45),
            },
            label: {
                text: String(count),
                color: "rgba(255,255,255,0.9)",
                fontSize: "12px",
            },
            title: `Cluster of ${count} markers`,
            // adjust zIndex to be above other markers
            zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count,
        });
    }
}

/**
 * Copyright 2019 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Extends an object's prototype by another's.
 *
 * @param type1 The Type to be extended.
 * @param type2 The Type to extend with.
 * @ignore
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function extend(type1, type2) {
    /* istanbul ignore next */
    // eslint-disable-next-line prefer-const
    for (let property in type2.prototype) {
        type1.prototype[property] = type2.prototype[property];
    }
}
/**
 * @ignore
 */
class OverlayViewSafe {
    constructor() {
        // MarkerClusterer implements google.maps.OverlayView interface. We use the
        // extend function to extend MarkerClusterer with google.maps.OverlayView
        // because it might not always be available when the code is defined so we
        // look for it at the last possible moment. If it doesn't exist now then
        // there is no point going ahead :)
        extend(OverlayViewSafe, google.maps.OverlayView);
    }
}

/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MarkerClustererEvents;
(function (MarkerClustererEvents) {
    MarkerClustererEvents["CLUSTERING_BEGIN"] = "clusteringbegin";
    MarkerClustererEvents["CLUSTERING_END"] = "clusteringend";
    MarkerClustererEvents["CLUSTER_CLICK"] = "click";
})(MarkerClustererEvents || (MarkerClustererEvents = {}));
const defaultOnClusterClickHandler = (_, cluster, map) => {
    map.fitBounds(cluster.bounds);
};
/**
 * MarkerClusterer creates and manages per-zoom-level clusters for large amounts
 * of markers. See {@link MarkerClustererOptions} for more details.
 *
 */
class MarkerClusterer extends OverlayViewSafe {
    constructor({ map, markers = [], algorithm = new SuperClusterAlgorithm({}), renderer = new DefaultRenderer(), onClusterClick = defaultOnClusterClickHandler, }) {
        super();
        this.markers = [...markers];
        this.clusters = [];
        this.algorithm = algorithm;
        this.renderer = renderer;
        this.onClusterClick = onClusterClick;
        if (map) {
            this.setMap(map);
        }
    }
    addMarker(marker, noDraw) {
        if (this.markers.includes(marker)) {
            return;
        }
        this.markers.push(marker);
        if (!noDraw) {
            this.render();
        }
    }
    addMarkers(markers, noDraw) {
        markers.forEach((marker) => {
            this.addMarker(marker, true);
        });
        if (!noDraw) {
            this.render();
        }
    }
    removeMarker(marker, noDraw) {
        const index = this.markers.indexOf(marker);
        if (index === -1) {
            // Marker is not in our list of markers, so do nothing:
            return false;
        }
        marker.setMap(null);
        this.markers.splice(index, 1); // Remove the marker from the list of managed markers
        if (!noDraw) {
            this.render();
        }
        return true;
    }
    removeMarkers(markers, noDraw) {
        let removed = false;
        markers.forEach((marker) => {
            removed = this.removeMarker(marker, true) || removed;
        });
        if (removed && !noDraw) {
            this.render();
        }
        return removed;
    }
    clearMarkers(noDraw) {
        this.markers.length = 0;
        if (!noDraw) {
            this.render();
        }
    }
    /**
     * Recalculates and draws all the marker clusters.
     */
    render() {
        const map = this.getMap();
        if (map instanceof google.maps.Map && this.getProjection()) {
            google.maps.event.trigger(this, MarkerClustererEvents.CLUSTERING_BEGIN, this);
            const { clusters, changed } = this.algorithm.calculate({
                markers: this.markers,
                map,
                mapCanvasProjection: this.getProjection(),
            });
            // allow algorithms to return flag on whether the clusters/markers have changed
            if (changed || changed == undefined) {
                // reset visibility of markers and clusters
                this.reset();
                // store new clusters
                this.clusters = clusters;
                this.renderClusters();
            }
            google.maps.event.trigger(this, MarkerClustererEvents.CLUSTERING_END, this);
        }
    }
    onAdd() {
        this.idleListener = this.getMap().addListener("idle", this.render.bind(this));
        this.render();
    }
    onRemove() {
        google.maps.event.removeListener(this.idleListener);
        this.reset();
    }
    reset() {
        this.markers.forEach((marker) => marker.setMap(null));
        this.clusters.forEach((cluster) => cluster.delete());
        this.clusters = [];
    }
    renderClusters() {
        // generate stats to pass to renderers
        const stats = new ClusterStats(this.markers, this.clusters);
        const map = this.getMap();
        this.clusters.forEach((cluster) => {
            if (cluster.markers.length === 1) {
                cluster.marker = cluster.markers[0];
            }
            else {
                cluster.marker = this.renderer.render(cluster, stats);
                if (this.onClusterClick) {
                    cluster.marker.addListener("click", 
                    /* istanbul ignore next */
                    (event) => {
                        google.maps.event.trigger(this, MarkerClustererEvents.CLUSTER_CLICK, cluster);
                        this.onClusterClick(event, cluster, map);
                    });
                }
            }
            cluster.marker.setMap(map);
        });
    }
}

/**
 * Default equality comparator pass-through, used as the standard `isEqual` creator for
 * use inside the built comparator.
 */
function createDefaultIsNestedEqual(comparator) {
    return function isEqual(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, meta) {
        return comparator(a, b, meta);
    };
}
/**
 * Wrap the provided `areItemsEqual` method to manage the circular cache, allowing
 * for circular references to be safely included in the comparison without creating
 * stack overflows.
 */
function createIsCircular(areItemsEqual) {
    return function isCircular(a, b, isEqual, cache) {
        if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {
            return areItemsEqual(a, b, isEqual, cache);
        }
        var cachedA = cache.get(a);
        var cachedB = cache.get(b);
        if (cachedA && cachedB) {
            return cachedA === b && cachedB === a;
        }
        cache.set(a, b);
        cache.set(b, a);
        var result = areItemsEqual(a, b, isEqual, cache);
        cache.delete(a);
        cache.delete(b);
        return result;
    };
}
/**
 * Targeted shallow merge of two objects.
 *
 * @NOTE
 * This exists as a tinier compiled version of the `__assign` helper that
 * `tsc` injects in case of `Object.assign` not being present.
 */
function merge(a, b) {
    var merged = {};
    for (var key in a) {
        merged[key] = a[key];
    }
    for (var key in b) {
        merged[key] = b[key];
    }
    return merged;
}
/**
 * Whether the value is a plain object.
 *
 * @NOTE
 * This is a same-realm compariosn only.
 */
function isPlainObject(value) {
    return value.constructor === Object || value.constructor == null;
}
/**
 * When the value is `Promise`-like, aka "then-able".
 */
function isPromiseLike(value) {
    return typeof value.then === 'function';
}
/**
 * Whether the values passed are strictly equal or both NaN.
 */
function sameValueZeroEqual(a, b) {
    return a === b || (a !== a && b !== b);
}

var ARGUMENTS_TAG = '[object Arguments]';
var BOOLEAN_TAG = '[object Boolean]';
var DATE_TAG = '[object Date]';
var REG_EXP_TAG = '[object RegExp]';
var MAP_TAG = '[object Map]';
var NUMBER_TAG = '[object Number]';
var OBJECT_TAG = '[object Object]';
var SET_TAG = '[object Set]';
var STRING_TAG = '[object String]';
var toString = Object.prototype.toString;
function createComparator(_a) {
    var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areMapsEqual = _a.areMapsEqual, areObjectsEqual = _a.areObjectsEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, createIsNestedEqual = _a.createIsNestedEqual;
    var isEqual = createIsNestedEqual(comparator);
    /**
     * compare the value of the two objects and return true if they are equivalent in values
     */
    function comparator(a, b, meta) {
        // If the items are strictly equal, no need to do a value comparison.
        if (a === b) {
            return true;
        }
        // If the items are not non-nullish objects, then the only possibility
        // of them being equal but not strictly is if they are both `NaN`. Since
        // `NaN` is uniquely not equal to itself, we can use self-comparison of
        // both objects, which is faster than `isNaN()`.
        if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {
            return a !== a && b !== b;
        }
        // Checks are listed in order of commonality of use-case:
        //   1. Common complex object types (plain object, array)
        //   2. Common data values (date, regexp)
        //   3. Less-common complex object types (map, set)
        //   4. Less-common data values (promise, primitive wrappers)
        // Inherently this is both subjective and assumptive, however
        // when reviewing comparable libraries in the wild this order
        // appears to be generally consistent.
        // `isPlainObject` only checks against the object's own realm. Cross-realm
        // comparisons are rare, and will be handled in the ultimate fallback, so
        // we can avoid the `toString.call()` cost unless necessary.
        if (isPlainObject(a) && isPlainObject(b)) {
            return areObjectsEqual(a, b, isEqual, meta);
        }
        // `isArray()` works on subclasses and is cross-realm, so we can again avoid
        // the `toString.call()` cost unless necessary by just checking if either
        // and then both are arrays.
        var aArray = Array.isArray(a);
        var bArray = Array.isArray(b);
        if (aArray || bArray) {
            return aArray === bArray && areArraysEqual(a, b, isEqual, meta);
        }
        // Since this is a custom object, use the classic `toString.call()` to get its
        // type. This is reasonably performant in modern environments like v8 and
        // SpiderMonkey, and allows for cross-realm comparison when other checks like
        // `instanceof` do not.
        var aTag = toString.call(a);
        if (aTag !== toString.call(b)) {
            return false;
        }
        if (aTag === DATE_TAG) {
            // `getTime()` showed better results compared to alternatives like `valueOf()`
            // or the unary `+` operator.
            return areDatesEqual(a, b, isEqual, meta);
        }
        if (aTag === REG_EXP_TAG) {
            return areRegExpsEqual(a, b, isEqual, meta);
        }
        if (aTag === MAP_TAG) {
            return areMapsEqual(a, b, isEqual, meta);
        }
        if (aTag === SET_TAG) {
            return areSetsEqual(a, b, isEqual, meta);
        }
        // If a simple object tag, then we can prioritize a simple object comparison because
        // it is likely a custom class. If an arguments tag, it should be treated as a standard
        // object.
        if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {
            // The exception for value comparison is `Promise`-like contracts. These should be
            // treated the same as standard `Promise` objects, which means strict equality.
            return isPromiseLike(a) || isPromiseLike(b)
                ? false
                : areObjectsEqual(a, b, isEqual, meta);
        }
        // As the penultimate fallback, check if the values passed are primitive wrappers. This
        // is very rare in modern JS, which is why it is deprioritized compared to all other object
        // types.
        if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {
            return sameValueZeroEqual(a.valueOf(), b.valueOf());
        }
        // If not matching any tags that require a specific type of comparison, then we hard-code false because
        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:
        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only
        //     comparison that can be made.
        //   - For types that can be introspected, but rarely have requirements to be compared
        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common
        //     use-cases (may be included in a future release, if requested enough).
        //   - For types that can be introspected but do not have an objective definition of what
        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.
        // In all cases, these decisions should be reevaluated based on changes to the language and
        // common development practices.
        return false;
    }
    return comparator;
}

/**
 * Whether the arrays are equal in value.
 */
function areArraysEqual(a, b, isEqual, meta) {
    var index = a.length;
    if (b.length !== index) {
        return false;
    }
    // Decrementing `while` showed faster results than either incrementing or
    // decrementing `for` loop and than an incrementing `while` loop. Declarative
    // methods like `some` / `every` were not used to avoid incurring the garbage
    // cost of anonymous callbacks.
    while (index-- > 0) {
        if (!isEqual(a[index], b[index], index, index, a, b, meta)) {
            return false;
        }
    }
    return true;
}
/**
 * Whether the arrays are equal in value, including circular references.
 */
var areArraysEqualCircular = createIsCircular(areArraysEqual);

/**
 * Whether the dates passed are equal in value.
 *
 * @NOTE
 * This is a standalone function instead of done inline in the comparator
 * to allow for overrides.
 */
function areDatesEqual(a, b) {
    return sameValueZeroEqual(a.valueOf(), b.valueOf());
}

/**
 * Whether the `Map`s are equal in value.
 */
function areMapsEqual(a, b, isEqual, meta) {
    var isValueEqual = a.size === b.size;
    if (!isValueEqual) {
        return false;
    }
    if (!a.size) {
        return true;
    }
    // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and
    // the inability to control the performance of the resulting code. It also avoids excessive
    // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,
    // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the
    // equality checks themselves.
    var matchedIndices = {};
    var indexA = 0;
    a.forEach(function (aValue, aKey) {
        if (!isValueEqual) {
            return;
        }
        var hasMatch = false;
        var matchIndexB = 0;
        b.forEach(function (bValue, bKey) {
            if (!hasMatch &&
                !matchedIndices[matchIndexB] &&
                (hasMatch =
                    isEqual(aKey, bKey, indexA, matchIndexB, a, b, meta) &&
                        isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {
                matchedIndices[matchIndexB] = true;
            }
            matchIndexB++;
        });
        indexA++;
        isValueEqual = hasMatch;
    });
    return isValueEqual;
}
/**
 * Whether the `Map`s are equal in value, including circular references.
 */
var areMapsEqualCircular = createIsCircular(areMapsEqual);

var OWNER = '_owner';
var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * Whether the objects are equal in value.
 */
function areObjectsEqual(a, b, isEqual, meta) {
    var keysA = Object.keys(a);
    var index = keysA.length;
    if (Object.keys(b).length !== index) {
        return false;
    }
    var key;
    // Decrementing `while` showed faster results than either incrementing or
    // decrementing `for` loop and than an incrementing `while` loop. Declarative
    // methods like `some` / `every` were not used to avoid incurring the garbage
    // cost of anonymous callbacks.
    while (index-- > 0) {
        key = keysA[index];
        if (key === OWNER) {
            var reactElementA = !!a.$$typeof;
            var reactElementB = !!b.$$typeof;
            if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {
                return false;
            }
        }
        if (!hasOwnProperty.call(b, key) ||
            !isEqual(a[key], b[key], key, key, a, b, meta)) {
            return false;
        }
    }
    return true;
}
/**
 * Whether the objects are equal in value, including circular references.
 */
var areObjectsEqualCircular = createIsCircular(areObjectsEqual);

/**
 * Whether the regexps passed are equal in value.
 *
 * @NOTE
 * This is a standalone function instead of done inline in the comparator
 * to allow for overrides. An example of this would be supporting a
 * pre-ES2015 environment where the `flags` property is not available.
 */
function areRegExpsEqual(a, b) {
    return a.source === b.source && a.flags === b.flags;
}

/**
 * Whether the `Set`s are equal in value.
 */
function areSetsEqual(a, b, isEqual, meta) {
    var isValueEqual = a.size === b.size;
    if (!isValueEqual) {
        return false;
    }
    if (!a.size) {
        return true;
    }
    // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and
    // the inability to control the performance of the resulting code. It also avoids excessive
    // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,
    // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the
    // equality checks themselves.
    var matchedIndices = {};
    a.forEach(function (aValue, aKey) {
        if (!isValueEqual) {
            return;
        }
        var hasMatch = false;
        var matchIndex = 0;
        b.forEach(function (bValue, bKey) {
            if (!hasMatch &&
                !matchedIndices[matchIndex] &&
                (hasMatch = isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {
                matchedIndices[matchIndex] = true;
            }
            matchIndex++;
        });
        isValueEqual = hasMatch;
    });
    return isValueEqual;
}
/**
 * Whether the `Set`s are equal in value, including circular references.
 */
var areSetsEqualCircular = createIsCircular(areSetsEqual);

var DEFAULT_CONFIG = Object.freeze({
    areArraysEqual: areArraysEqual,
    areDatesEqual: areDatesEqual,
    areMapsEqual: areMapsEqual,
    areObjectsEqual: areObjectsEqual,
    areRegExpsEqual: areRegExpsEqual,
    areSetsEqual: areSetsEqual,
    createIsNestedEqual: createDefaultIsNestedEqual,
});
var DEFAULT_CIRCULAR_CONFIG = Object.freeze({
    areArraysEqual: areArraysEqualCircular,
    areDatesEqual: areDatesEqual,
    areMapsEqual: areMapsEqualCircular,
    areObjectsEqual: areObjectsEqualCircular,
    areRegExpsEqual: areRegExpsEqual,
    areSetsEqual: areSetsEqualCircular,
    createIsNestedEqual: createDefaultIsNestedEqual,
});
createComparator(DEFAULT_CONFIG);
createComparator(merge(DEFAULT_CONFIG, { createIsNestedEqual: function () { return sameValueZeroEqual; } }));
createComparator(DEFAULT_CIRCULAR_CONFIG);
createComparator(merge(DEFAULT_CIRCULAR_CONFIG, {
    createIsNestedEqual: function () { return sameValueZeroEqual; },
}));
/**
 * Create a custom equality comparison method.
 *
 * This can be done to create very targeted comparisons in extreme hot-path scenarios
 * where the standard methods are not performant enough, but can also be used to provide
 * support for legacy environments that do not support expected features like
 * `RegExp.prototype.flags` out of the box.
 */
function createCustomEqual(getComparatorOptions) {
    return createComparator(merge(DEFAULT_CONFIG, getComparatorOptions(DEFAULT_CONFIG)));
}

var deepCompareEqualsForMaps = createCustomEqual(function (deepEqual) {
  return function (a, b) {
    if (a instanceof google.maps.LatLng || b instanceof google.maps.LatLng) {
      return new google.maps.LatLng(a).equals(new google.maps.LatLng(b));
    }

    // TODO extend to other types

    // use fast-equals for other objects
    return deepEqual(a, b);
  };
});
function useDeepCompareEffectForMaps(callback, dependencies) {
  React.useEffect(callback, dependencies.map(useDeepCompareMemoize));
}
function useDeepCompareMemoize(value) {
  var ref = React.useRef();
  if (!deepCompareEqualsForMaps(value, ref.current)) {
    ref.current = value;
  }
  return ref.current;
}

var css = ".BaseMap_module_root__1c20d6e7 {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n  width: 100%;\n  height: 100%;\n}";
var modules_a07e405a = {"root":"BaseMap_module_root__1c20d6e7"};
n(css,{});

var _excluded$1 = ["loading", "onClick", "onIdle", "children", "style", "mapId", "clustered", "fitBounds", "theme", "fallback"];
var BaseMap = function BaseMap(props) {
  // eslint-disable-next-line object-curly-newline
  var loading = props.loading,
    onClick = props.onClick,
    onIdle = props.onIdle,
    children = props.children,
    style = props.style,
    mapId = props.mapId,
    clustered = props.clustered,
    fitBounds = props.fitBounds,
    theme = props.theme,
    fallback = props.fallback,
    options = _objectWithoutProperties$1(props, _excluded$1);
  var ref = React.useRef(null);
  var markersRef = React.useRef([]);
  var _useState = React.useState(),
    _useState2 = _slicedToArray(_useState, 2),
    map = _useState2[0],
    setMap = _useState2[1];
  var _useState3 = React.useState(null),
    _useState4 = _slicedToArray(_useState3, 2),
    markerClusterer = _useState4[0],
    setMarkerClusterer = _useState4[1];
  var _useState5 = React.useState(null),
    _useState6 = _slicedToArray(_useState5, 2),
    activeInfoWindow = _useState6[0],
    setActiveInfoWindow = _useState6[1];
  React.useEffect(function () {
    if (ref.current && !map) {
      setMap(new window.google.maps.Map(ref.current, {
        mapId: mapId,
        mapTypeControl: false,
        streetViewControl: false
      }));
    }
  }, [map]);
  React.useEffect(function () {
    var _markersRef$current;
    if (clustered && map && React.Children.count(children) > 0 && (markersRef === null || markersRef === void 0 ? void 0 : (_markersRef$current = markersRef.current) === null || _markersRef$current === void 0 ? void 0 : _markersRef$current.length) > 0) {
      var _markersRef$current2;
      if (markerClusterer) {
        markerClusterer.clearMarkers();
        setMarkerClusterer(null);
      }
      var markers = markersRef === null || markersRef === void 0 ? void 0 : (_markersRef$current2 = markersRef.current) === null || _markersRef$current2 === void 0 ? void 0 : _markersRef$current2.map(function (marker) {
        return marker.current;
      });

      // eslint-disable-next-line no-new
      setMarkerClusterer(new MarkerClusterer({
        map: map,
        markers: markers
      }));
    }
  }, [clustered, children, map]);
  React.useEffect(function () {
    if (fitBounds && map && React.Children.count(children) > 0) {
      var bounds = new google.maps.LatLngBounds();
      React.Children.forEach(children, function (child) {
        bounds.extend(new google.maps.LatLng(child.props.position.lat, child.props.position.lng));
      });
      map.fitBounds(bounds);
    }
  }, [fitBounds, map]);
  useDeepCompareEffectForMaps(function () {
    if (map) {
      map.setOptions(options);
    }
  }, [map, options]);
  React.useEffect(function () {
    if (map) {
      ['click', 'idle'].forEach(function (eventName) {
        return google.maps.event.clearListeners(map, eventName);
      });
      if (onClick) {
        map.addListener('click', onClick);
      }
      if (onIdle) {
        map.addListener('idle', function () {
          return onIdle(map);
        });
      }
    }
  }, [map, onClick, onIdle]);
  React.useEffect(function () {
    if (map) {
      ['click', 'idle'].forEach(function (eventName) {
        return google.maps.event.clearListeners(map, eventName);
      });
      if (onClick) {
        map.addListener('click', onClick);
      }
      if (onIdle) {
        map.addListener('idle', function () {
          return onIdle(map);
        });
      }
    }
  }, [map, onClick, onIdle]);
  return /*#__PURE__*/jsxRuntime.jsxs("div", {
    className: classes(modules_a07e405a.root),
    children: [/*#__PURE__*/jsxRuntime.jsx("div", {
      ref: ref,
      style: loading ? {
        flexGrow: 0
      } : style
    }), loading && /*#__PURE__*/jsxRuntime.jsx(Skeleton, {
      theme: theme,
      height: "100%",
      variant: "rounded",
      noAnimation: !loading && fallback
    }), React.Children.toArray(children).filter(function (child) {
      return /*#__PURE__*/React.isValidElement(child);
    }).map(function (child, index) {
      if (index === 0) {
        markersRef.current = [];
      }
      if ( /*#__PURE__*/React.isValidElement(child)) {
        var _markersRef$current3;
        var childRef = /*#__PURE__*/React.createRef();
        markersRef === null || markersRef === void 0 ? void 0 : (_markersRef$current3 = markersRef.current) === null || _markersRef$current3 === void 0 ? void 0 : _markersRef$current3.push(childRef);
        // set the map prop on the child component
        return /*#__PURE__*/React.cloneElement(child, {
          map: map,
          ref: childRef,
          index: index,
          activeInfoWindow: activeInfoWindow,
          setActiveInfoWindow: setActiveInfoWindow
        });
      }
      return null;
    })]
  });
};
BaseMap.defaultProps = {
  loading: false,
  clustered: false,
  fitBounds: false,
  zoom: 1,
  center: {
    lat: 0,
    lng: 0
  },
  theme: 'dark'
};

var Map$1 = function Map(props) {
  var loading = props.loading,
    options = props.options,
    apiKey = props.apiKey,
    libraries = props.libraries,
    children = props.children,
    theme = props.theme,
    fallback = props.fallback;
  return /*#__PURE__*/jsxRuntime.jsx(Wrapper, {
    apiKey: apiKey,
    libraries: libraries,
    children: /*#__PURE__*/jsxRuntime.jsx(BaseMap, _objectSpread2(_objectSpread2({}, options), {}, {
      loading: loading,
      theme: theme,
      fallback: fallback,
      children: children
    }))
  });
};
Map$1.propTypes = {
  loading: propTypes$1.exports.bool,
  apiKey: propTypes$1.exports.string.isRequired,
  libraries: propTypes$1.exports.arrayOf(propTypes$1.exports.string),
  theme: propTypes$1.exports.oneOf(['light', 'dark'])
};
Map$1.defaultProps = {
  loading: false,
  libraries: undefined,
  theme: 'dark'
};

var _excluded = ["children", "activeInfoWindow", "setActiveInfoWindow", "index"];

// eslint-disable-next-line prefer-arrow-callback
var Marker = /*#__PURE__*/React.forwardRef(function Marker(_ref, ref) {
  var children = _ref.children,
    activeInfoWindow = _ref.activeInfoWindow,
    setActiveInfoWindow = _ref.setActiveInfoWindow,
    index = _ref.index,
    options = _objectWithoutProperties$1(_ref, _excluded);
  var _useState = React.useState(),
    _useState2 = _slicedToArray(_useState, 2),
    marker = _useState2[0],
    setMarker = _useState2[1];
  var infoWindowRef = React.useRef(null);
  React.useEffect(function () {
    if (marker) {
      ref.current = marker;
    }
    if (!marker) {
      var newMap = new google.maps.Marker();
      setMarker(newMap);
      ref.current = newMap;
    }

    // remove marker from map on unmount
    return function () {
      if (marker) {
        marker.setMap(null);
        ref.current = null;
      }
    };
  }, [marker]);
  React.useEffect(function () {
    if (marker && React.Children.count(children) === 1 && infoWindowRef !== null && infoWindowRef !== void 0 && infoWindowRef.current) {
      var infoWindow = infoWindowRef === null || infoWindowRef === void 0 ? void 0 : infoWindowRef.current;
      marker.addListener('click', function () {
        setActiveInfoWindow(index);
        infoWindow.open({
          anchor: marker,
          map: options.map
        });
      });
    }
  }, [marker, children]);
  React.useEffect(function () {
    if (marker) {
      marker.setOptions(options);
    }
  }, [marker, options]);
  React.useEffect(function () {
    if (activeInfoWindow == null || activeInfoWindow !== index) {
      var infoWindow = infoWindowRef === null || infoWindowRef === void 0 ? void 0 : infoWindowRef.current;
      infoWindow === null || infoWindow === void 0 ? void 0 : infoWindow.close();
    }
  }, [activeInfoWindow]);
  if (React.Children.count(children) === 1) {
    var _Children$toArray;
    var child = (_Children$toArray = React.Children.toArray(children)) === null || _Children$toArray === void 0 ? void 0 : _Children$toArray[0];
    if ( /*#__PURE__*/React.isValidElement(child)) {
      // set the map prop on the child component
      return /*#__PURE__*/React.cloneElement(child, {
        ref: infoWindowRef
      });
    }
  }
  return null;
});

// eslint-disable-next-line prefer-arrow-callback
var InfoWindow = /*#__PURE__*/React.forwardRef(function InfoWindow(options, ref) {
  var _useState = React.useState(),
    _useState2 = _slicedToArray(_useState, 2),
    infoWindow = _useState2[0],
    setInfoWindow = _useState2[1];
  React.useEffect(function () {
    if (!infoWindow) {
      var newInfoWindow = new google.maps.InfoWindow();
      setInfoWindow(newInfoWindow);
      ref.current = newInfoWindow;
    }
  }, [infoWindow]);
  React.useEffect(function () {
    if (infoWindow) {
      infoWindow.setOptions(options);
    }
  }, [infoWindow, options]);
  return null;
});
InfoWindow.defaultProps = {
  disableAutoPan: true
};

exports.Accordion = Accordion;
exports.Alert = Alert;
exports.AlertIcon = AlertIcon;
exports.AngleDoubleIcon = AngleDouble;
exports.ArrowIcon = Arrow$1;
exports.BASE_URLS = BASE_URLS;
exports.BaseAreaChart = BaseAreaChart;
exports.BaseButton = BaseButton;
exports.BaseCell = BaseCell;
exports.BaseHorizontalBarChart = BaseHorizontalBarChart;
exports.BaseMap = BaseMap;
exports.BaseModal = BaseModal;
exports.BasePieChart = BasePieChart;
exports.BaseRegionChart = BaseRegionChart;
exports.BaseSidePanel = BaseSidePanel;
exports.BaseTable = BaseTable;
exports.BaseVerticalBarChart = BaseVerticalBarChart;
exports.BaseWidget = BaseWidget;
exports.BreadCrumbs = BreadCrumbs;
exports.BreadcrumbSeperatorIcon = BreadcrumbSeperator;
exports.Button = Button;
exports.COLORS = COLORS;
exports.CalenderIcon = Calender$1;
exports.CaretIcon = Caret;
exports.Checkbox = Checkbox;
exports.CheckboxIcon = CheckboxIcon;
exports.ChevronIcon = Chevron;
exports.Chip = Chip;
exports.CloseIcon = Close;
exports.CloudIcons = Clouds;
exports.CodeSnippet = CodeSnippet;
exports.ColumnsIcon = Columns$1;
exports.CopyIcon = Copy;
exports.CrossIcon = Cross$1;
exports.DAYS = DAYS;
exports.DatabaseIcons = Databases;
exports.DatePicker = DatePicker;
exports.DeleteIcon = Delete;
exports.DialogBox = DialogBox;
exports.DisplayPicture = DisplayPicture;
exports.DownloadIcon = Download;
exports.Dropdown = Dropdown;
exports.DropdownItem = DropdownItem;
exports.EditIcon = Edit;
exports.ExpandArrowAltIcon = ExpandArrowAlt;
exports.FULL_MONTHS = FULL_MONTHS;
exports.FilterIcon = Filter;
exports.HalfShadeIcon = HalfShade;
exports.HeatMapChart = HeatMapChart;
exports.HierarchyBrowser = HierarchyBrowser;
exports.HierarchyItem = HierarchyItem;
exports.InfoWindow = InfoWindow;
exports.Link = Link;
exports.MONTHS = MONTHS;
exports.MagnifyingGlassIcon = MagnifyingGlass;
exports.Map = Map$1;
exports.Marker = Marker;
exports.NestedPieChart = NestedPieChart;
exports.NutIcon = Nut;
exports.PageHeader = PageHeader;
exports.Pagination = Pagination;
exports.PaginationList = PaginationList;
exports.PlusIcon = Plus;
exports.Popover = Popover;
exports.Popper = Popper;
exports.Radio = Radio;
exports.RadioIcon = RadioIcon;
exports.RefreshIcon = Refresh;
exports.ResetIcon = Reset;
exports.SearchIcon = SearchIcon;
exports.ServerIcon = Server;
exports.SettingsIcon = Settings;
exports.Skeleton = Skeleton;
exports.SortIcon = Sort;
exports.Step = Step;
exports.Stepper = Stepper;
exports.Switch = Switch;
exports.Table = Table;
exports.TableCell = TableCell;
exports.TableChip = TableChip;
exports.TableChips = TableChips;
exports.TableColumn = TableColumn;
exports.TableFilters = TableFilters;
exports.Tabs = Tabs;
exports.Text = Text;
exports.TextField = TextField;
exports.TickIcon = Tick;
exports.TimePicker = TimePicker;
exports.Toggle = Toggle;
exports.Tooltip = Tooltip;
exports.TrashIcon = Trash;
exports.ViewIcon = View$2;
exports.classes = classes;
exports.cloneDeep = cloneDeep;
exports.defaultProps = defaultProps;
exports.doubleDigitted = doubleDigitted;
exports.epochToFormattedDate = epochToFormattedDate;
exports.get = get$1;
exports.getCSSVariableValue = getCSSVariableValue;
exports.getCurrentSearchParams = getCurrentSearchParams;
exports.getDateFromEpoch = getDateFromEpoch;
exports.getDatesInAMonth = getDatesInAMonth;
exports.getDatesInStringFormat = getDatesInStringFormat;
exports.getDayInfo = getDayInfo;
exports.getInitialsOfName = getInitialsOfName;
exports.getJSDateFromEpoch = getJSDateFromEpoch;
exports.getPagination = getPagination;
exports.getSpacedDisplayName = getSpacedDisplayName;
exports.getTimeFromEpoch = getTimeFromEpoch;
exports.inputHelper = inputHelper;
exports.propTypes = propTypes;
exports.safeJSONParse = safeJSONParse;
exports.stringToPath = stringToPath;
exports.sumArrayOfObjects = sumArrayOfObjects;
exports.uniqueArray = uniqueArray;
exports.uniqueArrayOfObjects = uniqueArrayOfObjects;
exports.useOutsideClickListener = useOutsideClickListener;
exports.usePagination = usePagination;
exports.useResize = useResize;
exports.useRowFilter = useRowFilter;
//# sourceMappingURL=index.js.map
